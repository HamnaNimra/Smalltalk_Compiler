

  

nil subclass: #DelegationObject
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Delegation' )
  comment: ''!

  

DelegationObject subclass: #ContainerObject
  instanceVariableNames: 
    ' contents '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Delegation' )
  comment: ''!

!ContainerObject methods !
yourself
    ^self!    ! 
#('March 13, 2003' '10:26:28 AM' nil)!

(CodeFiler organizerFor: ContainerObject) reorganizeFrom: #(
('debugging' yourself )) !


  

nil subclass: #Object
  instanceVariableNames: ''
  classVariableNames: 
    ' Dependents EventHandlers RecursionInError RecursiveSet '
  poolDictionaries: ''
  categories: #( 'Kernel-Objects' )
  comment: ''!

!Object methods !
isPointer
    ^false!  ! 
#('November 13, 2001' '12:14:32 PM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' isPointer )) !


!Object methods ! 
triggerEvent: eventName with: firstArgument with: secondArgument with: thirdArgument
        "Trigger the event <eventName> using the <firstArgument>
        and <secondArgument> as the arguments.  Answer the
        value returned by the most recently defined event
        handler action."
    ^self
        triggerEvent: eventName
        withArguments: (Array
            with: firstArgument
            with: secondArgument
            with: thirdArgument)!    ! 
#('April 7, 2005' '09:31:17 AM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('no category methods' triggerEvent:with:with:with: )) !


!Object methods ! 
tersePrintOn: aStream
    ^self printOn: aStream!  ! 
#('July 19, 2006' '09:17:25 AM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' tersePrintOn: )) !


!Object methods ! 
haltIfShift: title

    Notifier isShiftKeyDownNow ifTrue: [self halt: title].!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' haltIfShift: )) !


!Object methods !
promptingHalt: title
    Object promptingHaltEnabled ifTrue: [self halt: title].!  ! 
#('January 20, 2010' '10:37:51 AM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' promptingHalt: )) !


!Object methods ! 
addBehavior: methodDictionary
    "Add <methodDictionary> as instance specific behavior for the receiver."
    "If the method dictionary is not instance specific, do not add it (instance specific method dictionaries have a nil classField)"
    "ASSUMPTIONS:
        The methods in methodDictionary do not directly reference instance variables"

    methodDictionary classField == nil
        ifFalse: [^nil].
    self methodDictionaryArray: (self methodDictionaryArray asOrderedCollection add: methodDictionary; yourself) asArray.! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('no category methods' addBehavior: )) !


!Object methods !   
isFace
    ^false! ! 
#('May 14, 2002' '10:15:43 AM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' isFace )) !


!Object methods ! 
promptingHalt
    Object promptingHaltEnabled ifTrue: [self halt].!    ! 
#('January 20, 2010' '10:38:09 AM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' promptingHalt )) !


!Object methods !  
haltIfShift

    self haltIfShift: ''!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' haltIfShift )) !


!Object methods ! 
allSourcesContainingString: string
    "Example: 
        self allSourcesContainingString: 'terrains:'
    "
    ^self allSourcesSuchThat: [:source | (source indexOfString: string) > 0].! ! 
#('February 12, 2003' '10:23:02 AM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' allSourcesContainingString: )) !


!Object methods !   
halt: title
    "Initiate a walkback with 'title' message for debugging."
    Process
        queueWalkback: title
        makeUserIF: CurrentProcess isUserIF
        resumable: 2!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' halt: )) !


!Object methods !   
classNamed: name
    "Returns the class whose name, ignoring case, matches."
    Smalltalk keys do: [:key | key asString equalsIgnoreCase: name ifTrue: [^key]].
    ^nil!   ! 
#('April 14, 2003' '01:49:06 PM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' classNamed: )) !


!Object methods !  
classNamed: name
    "Returns the class whose name, ignoring case, matches."
    Smalltalk keys do: [:key | (key asString equalsIgnoreCase: name) ifTrue: [^key]].
    ^nil! ! 
#('April 14, 2003' '01:55:06 PM' 4364)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' classNamed: )) !


!Object methods ! 
classNamed: name
    "Returns the class whose name, ignoring case, matches."
    Smalltalk keys do: [:key | (key asString equalsIgnoreCase: name asString) ifTrue: [^key]].
    ^nil!    ! 
#('April 14, 2003' '01:55:34 PM' 4696)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' classNamed: )) !


!Object methods ! 
wilfAndAdriaanWillFix
    ^false!  ! 
#('July 17, 2002' '02:03:59 PM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' wilfAndAdriaanWillFix )) !


!Object methods ! 
isTrianglePatch
    ^false!    ! 
#('May 13, 2002' '11:00:24 AM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' isTrianglePatch )) !


!Object methods !
notNilOrEmptyString
    self isNil ifTrue: [^false].
    ^self ~= ''! ! 
#('July 13, 2006' '01:58:21 PM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' notNilOrEmptyString )) !


!Object methods !   
allSourcesSuchThat: aBlock
    | everything source result |
    
    result := OrderedCollection new.
    everything := Object class allSubclasses, Object allSubclasses, Behavior allSubclasses.
    everything do: [:class | 
        class methodDictionaries first do: [: method |
            source := method source.
            source notNil ifTrue: [(aBlock value: source) ifTrue: [result add: source]]]].
    ^result!    ! 
#('February 12, 2003' '10:19:13 AM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' allSourcesSuchThat: )) !


!Object methods !   
isNilOrEmptyString
    self isNil ifTrue: [^true].
    ^self = ''!    ! 
#('July 13, 2006' '01:57:38 PM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' isNilOrEmptyString )) !


!Object methods !
isEffectEditorLook

    ^false!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' isEffectEditorLook )) !


!Object methods !  
haltIfAlt: title

    Notifier isAltKeyDownNow ifTrue: [self halt: title].!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' haltIfAlt: )) !


!Object methods !  
isClassPointer
    ^false! ! 
#('November 13, 2001' '12:33:18 PM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' isClassPointer )) !


!Object methods !
isPoint3D
    ^false!  ! 
#('September 26, 2005' '12:19:51 PM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' isPoint3D )) !


!Object methods !
isProceduralTexture
    ^false!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' isProceduralTexture )) !


!Object methods ! 
isVideoTexture
    ^false! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' isVideoTexture )) !


!Object methods !  
isPoint4D
    ^false!  ! 
#('October 20, 2006' '11:30:37 AM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' isPoint4D )) !


!Object methods !  
isAbstractTexture
    ^false!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' isAbstractTexture )) !


!Object methods !   
isNormalTexture
    ^false!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' isNormalTexture )) !


!Object methods ! 
terseString
    ^self printString! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' terseString )) !


!Object methods ! 
terseString
    "^self printString"
        "Answer a String that is an ASCII representation
         of the receiver."
    | aStream aString |
    RecursiveSet := Set new.
    aString := String new: 20.
    self tersePrintOn: (aStream := WriteStream on: aString).
    ^aStream contents! ! 
#('July 18, 2006' '05:22:36 PM' 8588)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' terseString )) !


!Object methods !  
haltIfAlt

    self haltIfAlt: ''!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' haltIfAlt )) !


!Object methods !   
obsolete
    self halt: 'Obsolete method encountered...'!  ! 
#('August 21, 2001' '09:53:12 AM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' obsolete )) !


!Object methods !
isFrame
    ^false!    ! 
#('December 4, 2001' '01:49:27 PM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' isFrame )) !


!Object methods !
haltIfCtrl: title

    Notifier isControlKeyDownNow ifTrue: [self halt: title].!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' haltIfCtrl: )) !


!Object methods ! 
perform: aSymbol with: object1 with: object2 with: object3 with: object4
    ^self perform: aSymbol withArguments: (Array with: object1 with: object2 with: object3 with: object4)!    ! 
#('June 12, 2007' '11:44:25 AM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('no category methods' perform:with:with:with:with: )) !


!Object methods ! 
isTexture
    ^false!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' isTexture )) !


!Object methods !   
haltHard: title
    "Initiate a walkback with 'title' message for debugging."
    Process
        queueWalkback: title
        makeUserIF: CurrentProcess isUserIF
        resumable: 2
! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('no category methods' haltHard: )) !


!Object methods !  
haltIfCtrl

    self haltIfCtrl: ''!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Object) reorganizeFrom: #(
('extensions' haltIfCtrl )) !


!Object class methods !
promptingHaltEnabled
    ^Smalltalk at: #PromptingHaltEnabled! ! 
#('January 20, 2010' '10:36:13 AM' nil)!

(CodeFiler organizerFor: Object class) reorganizeFrom: #(
('prompting halt' promptingHaltEnabled )) !


!Object class methods !   
promptingHaltEnabled: aBoolean
    Smalltalk at: #PromptingHaltEnabled put: aBoolean!  ! 
#('January 20, 2010' '10:36:01 AM' nil)!

(CodeFiler organizerFor: Object class) reorganizeFrom: #(
('prompting halt' promptingHaltEnabled: )) !


!Object class methods !  
promptingHaltEnabled: aBoolean
    "Object promptingHaltEnabled: true"
    "Object promptingHaltEnabled: false"
    Smalltalk at: #PromptingHaltEnabled put: aBoolean!   ! 
#('January 20, 2010' '10:36:43 AM' 11404)!

(CodeFiler organizerFor: Object class) reorganizeFrom: #(
('prompting halt' promptingHaltEnabled: )) !


   

Object subclass: #ApplicationCoordinator
  instanceVariableNames: 
    ' handlers '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Windows-Views' )
  comment: ''!

 

Object subclass: #Behavior
  instanceVariableNames: 
    ' superClass dictionaryArray structure name comment subclasses instances '
  classVariableNames: 
    ' InstIndexedBit InstNumberMask InstPointerBit InstZeroTerminatedBit '
  poolDictionaries: ''
  categories: #( 'Kernel-Behaviors' )
  comment: ''!

!Behavior methods ! 
methods
        "Answer an instance of ClassReader
         initialized for the receiver."

    (Smalltalk includesKey: #CodeFiler) ifTrue: [
        ((Smalltalk at: #CodeFiler) organizerFor: self) makeDirty.
        ^(Smalltalk at: #CodeFiler) forClass: self].

    ^ClassReader forClass: self! ! 
#('August 28, 2001' '03:00:20 PM' nil)!

(CodeFiler organizerFor: Behavior) reorganizeFrom: #(
('extensions' methods )) !


!Behavior methods ! 
methodsFor: protocol stamp: squeakGarbage

    ^self methodsFor: protocol!    ! 
#('November 21, 2001' '11:04:40 AM' nil)!

(CodeFiler organizerFor: Behavior) reorganizeFrom: #(
('extensions' methodsFor:stamp: )) !




Object variableSubclass: #BlockClosure
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Objects' )
  comment: ''!

!BlockClosure methods !   
correctedValueWithArguments: anArray
    "Answer the result of evaluating the block described by the receiver."

    anArray isEmpty ifTrue: [^self value] ifFalse: [^self valueWithArguments: anArray]! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BlockClosure) reorganizeFrom: #(
('extensions' correctedValueWithArguments: )) !


!BlockClosure methods !
repeatUntil: aBlock
     self value.
     ^aBlock whileFalse: self.!  ! 
#('February 10, 2003' '03:02:35 PM' nil)!

(CodeFiler organizerFor: BlockClosure) reorganizeFrom: #(
('extensions' repeatUntil: )) !


!BlockClosure methods !  
value: arg1 value: arg2 value: arg3 value: arg4
    "Evaluate the block represented by the receiver.  Fail if the block
    expects other than three arguments."

    ^self valueWithArguments:
        (Array
            with: arg1
            with: arg2
            with: arg3
            with: arg4)!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BlockClosure) reorganizeFrom: #(
('no category methods' value:value:value:value: )) !


  

Object subclass: #BlockDescription
  instanceVariableNames: 
    ' block '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Compiler Support' )
  comment: ''!



Object subclass: #Boolean
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Objects' )
  comment: ''!

   

Object subclass: #BoundingBox
  instanceVariableNames: 
    ' maximum minimum center radius '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( '3D-Basic' )
  comment: ''!

!BoundingBox methods !  
intersects: box
    box maximum x < self minimum x ifTrue: [^false].
    box minimum x > self maximum x ifTrue: [^false].
    box maximum y < self minimum y ifTrue: [^false].
    box minimum y > self maximum y ifTrue: [^false].
    box maximum z < self minimum z ifTrue: [^false].
    box minimum z > self maximum z ifTrue: [^false].
    ^true! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' intersects: )) !


!BoundingBox methods ! 
scaledBy: aPoint3D

    ^self class minimum: self minimum * aPoint3D maximum: self maximum * aPoint3D.!   ! 
#('March 24, 2003' '04:35:57 PM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('transforming' scaledBy: )) !


!BoundingBox methods !
shrunkBy: aPoint3D

    | half minimum maximum |
    half := aPoint3D * 0.5.
    minimum := self minimum + half.
    maximum := self maximum - half.
    ^BoundingBox minimum: (minimum min: maximum) maximum: (minimum max: maximum)!    ! 
#('June 24, 2005' '11:47:42 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('growing' shrunkBy: )) !


!BoundingBox methods !  
depth
    ^self extent z!  ! 
#('April 7, 2003' '03:55:17 PM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' depth )) !


!BoundingBox methods ! 
printOn: aStream
    aStream
        nextPutAll: 'Box ('; print: self minimum;
        nextPutAll: ' -> '; print: self maximum;
        nextPutAll: ')'!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('printing' printOn: )) !


!BoundingBox methods !
expandedByDistance: distance
    ^BoundingBox minimum: self minimum - distance maximum: self maximum + distance.!  ! 
#('November 9, 2011' '08:50:32 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('growing' expandedByDistance: )) !


!BoundingBox methods ! 
horizontalTopRight
    ^(maximum x@0.0@minimum z)! ! 
#('September 16, 2009' '12:03:44 PM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' horizontalTopRight )) !


!BoundingBox methods !   
points
    | points |
    points := OrderedCollection new: 8.
    1 to: 8 do: [:i | points add: (self pointForIndex: i)].
    ^points!  ! 
#('February 6, 2003' '04:18:09 PM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' points )) !


!BoundingBox methods ! 
expandBy: aPoint3D

    | half |
    half := aPoint3D * 0.5.
    self minimum: self minimum - half. self maximum: self maximum + half.! ! 
#('December 10, 2002' '10:34:42 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('growing' expandBy: )) !


!BoundingBox methods !  
addPoint: aPoint

    self maximum: (self maximum isNil ifTrue: [aPoint] ifFalse: [self maximum max: aPoint]).
    self minimum: (self minimum isNil ifTrue: [aPoint] ifFalse: [self minimum min: aPoint]).
    self update!    ! 
#('March 20, 2002' '11:25:55 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('growing' addPoint: )) !


!BoundingBox methods ! 
union: box
    self isUnknown ifTrue: [^box]. box isUnknown ifTrue: [^self].
    ^self class new add: self minimum; add: box minimum; add: self maximum; add: box maximum!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('growing' union: )) !


!BoundingBox methods !   
isUnknown
    ^self maximum isNil! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('growing' isUnknown )) !


!BoundingBox methods !
maximum: aPoint3D
    maximum := aPoint3D! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('get/set' maximum: )) !


!BoundingBox methods ! 
shortestExtent
    | extent |
    extent := self extent.
    ^(extent x min: extent y) min: extent z!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' shortestExtent )) !


!BoundingBox methods !  
includesXZofPoint: aPoint
    self minimum x > aPoint x ifTrue: [^false].
    self maximum x < aPoint x ifTrue: [^false].
    self minimum z > aPoint z ifTrue: [^false].
    self maximum z < aPoint z ifTrue: [^false].
    ^true!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' includesXZofPoint: )) !


!BoundingBox methods !  
width
    ^self extent x!  ! 
#('April 7, 2003' '03:55:01 PM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' width )) !


!BoundingBox methods ! 
topCenter
    ^self center shallowCopy y: self maximum y!  ! 
#('November 13, 2009' '05:48:52 PM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' topCenter )) !


!BoundingBox methods ! 
includesYZofPoint: aPoint
    self minimum y > aPoint y ifTrue: [^false].
    self maximum y < aPoint y ifTrue: [^false].
    self minimum z > aPoint z ifTrue: [^false].
    self maximum z < aPoint z ifTrue: [^false].
    ^true!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' includesYZofPoint: )) !


!BoundingBox methods !  
update
    self center: (self minimum + self maximum) * 0.5.
    self radius: (self minimum distanceTo: self maximum) * 0.5!  ! 
#('April 7, 2003' '09:37:17 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('updating' update )) !


!BoundingBox methods !
horizontalTopLeft
    ^(minimum x@0.0@minimum z)!  ! 
#('September 16, 2009' '12:05:05 PM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' horizontalTopLeft )) !


!BoundingBox methods !
lines
    | result |
    result := OrderedCollection new.
    self linesDo: [:p1 :p2 | result add: (p1 to: p2)].
    ^result asArray!   ! 
#('July 29, 2002' '02:23:55 PM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' lines )) !


!BoundingBox methods ! 
intersectsXZ: box
    box maximum x < self minimum x ifTrue: [^false].
    box minimum x > self maximum x ifTrue: [^false].
    box maximum z < self minimum z ifTrue: [^false].
    box minimum z > self maximum z ifTrue: [^false].
    ^true!   ! 
#('September 16, 2003' '09:55:30 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' intersectsXZ: )) !


!BoundingBox methods !
pointForIndex: index
    "index = 1..8"
    | a b |
    a := self minimum. b := self maximum.
    index = 1 ifTrue: [^Point3D x: a x y: a y z: a z "left back bottom"].
    index = 2 ifTrue: [^Point3D x: a x y: a y z: b z "left front bottom"].
    index = 3 ifTrue: [^Point3D x: b x y: a y z: b z "right front bottom"].
    index = 4 ifTrue: [^Point3D x: b x y: a y z: a z "right back bottom"].
    index = 5 ifTrue: [^Point3D x: a x y: b y z: a z "left back top"].
    index = 6 ifTrue: [^Point3D x: a x y: b y z: b z "left front top"].
    index = 7 ifTrue: [^Point3D x: b x y: b y z: b z "right front top"].
    index = 8 ifTrue: [^Point3D x: b x y: b y z: a z "right back top"].
    self error: 'can''t happen'!  ! 
#('April 29, 2003' '10:11:02 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('leading/trailing' pointForIndex: )) !


!BoundingBox methods !   
intersection: box
    ^BoundingBox minimum: (self minimum max: box minimum) maximum: (self maximum min: box maximum)!  ! 
#('December 5, 2011' '03:45:13 PM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' intersection: )) !


!BoundingBox methods !  
addToBoundingBox: aBox

    aBox addBox: self!    ! 
#('March 14, 2001' '11:06:20 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('growing' addToBoundingBox: )) !


!BoundingBox methods ! 
maximalExtent
    | extent |
    extent := self extent.
    ^extent x max: (extent y max: extent z)! ! 
#('August 10, 2010' '12:14:51 PM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' maximalExtent )) !


!BoundingBox methods !   
includesPoint: aPoint

    (self minimum x - WorldGlobal epsilon) > aPoint x ifTrue: [^false].
    aPoint x > (self maximum x + WorldGlobal epsilon) ifTrue: [^false].
    (self minimum y - WorldGlobal epsilon) > aPoint y ifTrue: [^false].
    aPoint y > (self maximum y + WorldGlobal epsilon) ifTrue: [^false].
    (self minimum z - WorldGlobal epsilon) > aPoint z ifTrue: [^false].
    aPoint z > (self maximum z + WorldGlobal epsilon) ifTrue: [^false].
    ^true!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' includesPoint: )) !


!BoundingBox methods !  
leftFrontBottom
    ^self pointForIndex: 2!    ! 
#('April 29, 2003' '10:11:02 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('leading/trailing' leftFrontBottom )) !


!BoundingBox methods !  
includesBoundingBoxXZ: box
    | boxMinimum boxMaximum epsilon |
    epsilon := WorldGlobal epsilon.
    boxMinimum := box minimum.
    minimum x - epsilon <= boxMinimum x ifFalse: [^false].
    minimum z - epsilon  <= boxMinimum z ifFalse: [^false].
    boxMaximum := box maximum.
    maximum x + epsilon >= boxMaximum x ifFalse: [^false].
    maximum z + epsilon >= boxMaximum z ifFalse: [^false].
    ^true! ! 
#('September 15, 2003' '12:15:16 PM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' includesBoundingBoxXZ: )) !


!BoundingBox methods !   
includesBoundingBoxXZ: box
    | boxMinimum boxMaximum epsilon |
    epsilon := 1.0e-5.
    boxMinimum := box minimum.
    minimum x - epsilon <= boxMinimum x ifFalse: [^false].
    minimum z - epsilon  <= boxMinimum z ifFalse: [^false].
    boxMaximum := box maximum.
    maximum x + epsilon >= boxMaximum x ifFalse: [^false].
    maximum z + epsilon >= boxMaximum z ifFalse: [^false].
    ^true!  ! 
#('December 27, 2016' '03:06:28 PM' 24348)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' includesBoundingBoxXZ: )) !


!BoundingBox methods !  
allPoints
    "Returns all points in a dictionary with names of the form 'left OR right' / 'front OR back' / 'top OR bottom'."

    | a b |
    a := self minimum. b := self maximum.
    ^IdentityDictionary new
        at: #leftBackBottom put: (Point3D x: a x y: a y z: a z); "left back bot"
        at: #leftFrontBottom put: (Point3D x: a x y: a y z: b z); "left front bot"
        at: #rightFrontBottom put: (Point3D x: b x y: a y z: b z); "right front bot"
        at: #rightBackBottom put: (Point3D x: b x y: a y z: a z); "right back bot"
        at: #leftBackTop put: (Point3D x: a x y: b y z: a z); "left back top"
        at: #leftFrontTop put: (Point3D x: a x y: b y z: b z); "left front top"
        at: #rightFrontTop put: (Point3D x: b x y: b y z: b z); "right front top"
        at: #rightBackTop put: (Point3D x: b x y: b y z: a z); "right back top"
        yourself!   ! 
#('April 29, 2003' '10:10:36 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' allPoints )) !


!BoundingBox methods !
expandedBy: aPoint3D

    | half |
    half := aPoint3D * 0.5.
    ^BoundingBox minimum: self minimum - half maximum: self maximum + half.! ! 
#('June 5, 2003' '03:26:44 PM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('growing' expandedBy: )) !


!BoundingBox methods ! 
maximum
    ^maximum!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('get/set' maximum )) !


!BoundingBox methods !  
intersectsUsingEquals: box
    box maximum x <= self minimum x ifTrue: [^false].
    box minimum x >= self maximum x ifTrue: [^false].
    box maximum y <= self minimum y ifTrue: [^false].
    box minimum y >= self maximum y ifTrue: [^false].
    box maximum z <= self minimum z ifTrue: [^false].
    box minimum z >= self maximum z ifTrue: [^false].
    ^true!    ! 
#('July 29, 2002' '02:30:27 PM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' intersectsUsingEquals: )) !


!BoundingBox methods !
height
    ^self extent y! ! 
#('April 7, 2003' '03:55:10 PM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' height )) !


!BoundingBox methods !
scaleBy: aPoint3D

    self minimum: self minimum * aPoint3D.
    self maximum: self maximum * aPoint3D.!    ! 
#('December 17, 2002' '04:15:13 PM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('transforming' scaleBy: )) !


!BoundingBox methods !  
touching: box
    ^self withinSquaredDistance: WorldGlobal epsilon ofBoundingBox: box! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' touching: )) !


!BoundingBox methods !   
pointsDo: aBlock
    | a b |
    a := self minimum. b := self maximum.
    aBlock value: (Point3D x: a x y: a y z: a z). "left back bot"
    aBlock value: (Point3D x: a x y: a y z: b z). "left front bot"
    aBlock value: (Point3D x: b x y: a y z: b z). "right front bot"
    aBlock value: (Point3D x: b x y: a y z: a z). "right back bot"
    aBlock value: (Point3D x: a x y: b y z: a z). "left back top"
    aBlock value: (Point3D x: a x y: b y z: b z). "left front top"
    aBlock value: (Point3D x: b x y: b y z: b z). "right front top"
    aBlock value: (Point3D x: b x y: b y z: a z). "right back top"!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('sequencing' pointsDo: )) !


!BoundingBox methods ! 
leftFrontTop
    ^self pointForIndex: 6!   ! 
#('April 29, 2003' '10:11:02 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('leading/trailing' leftFrontTop )) !


!BoundingBox methods ! 
longestExtent

    | extent |
    extent := self extent.
    ^(extent x max: extent y) max: extent z!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' longestExtent )) !


!BoundingBox methods !   
extent
    self isUnknown ifTrue: [^Point3D zero].
    ^(self maximum - self minimum) abs.!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' extent )) !


!BoundingBox methods !  
horizontalBottomLeft
    ^(minimum x@0.0@maximum z)!   ! 
#('September 16, 2009' '12:04:10 PM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' horizontalBottomLeft )) !


!BoundingBox methods ! 
linesDo: aBlock
    | all |
    all := OrderedCollection new.
    self pointsDo: [:point | all add: point].
    "Assuming order is unchanged in pointsDo: ..."
    aBlock value: (all at: 1) value: (all at: 2).
    aBlock value: (all at: 2) value: (all at: 3).
    aBlock value: (all at: 3) value: (all at: 4).
    aBlock value: (all at: 4) value: (all at: 1).

    aBlock value: (all at: 5) value: (all at: 6).
    aBlock value: (all at: 6) value: (all at: 7).
    aBlock value: (all at: 7) value: (all at: 8).
    aBlock value: (all at: 8) value: (all at: 5).

    aBlock value: (all at: 1) value: (all at: 5).
    aBlock value: (all at: 2) value: (all at: 6).
    aBlock value: (all at: 3) value: (all at: 7).
    aBlock value: (all at: 4) value: (all at: 8).! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('sequencing' linesDo: )) !


!BoundingBox methods !  
yRotatingExtent
    | extent yRotatingRadius |
    extent := self extent.
    yRotatingRadius := (extent x max: extent z) * 2 sqrt. "Since sqrt (a^2 + a^2) = sqrt (2a^2) = sqrt (2) a."
    ^yRotatingRadius @ extent y @ yRotatingRadius! ! 
#('August 3, 2011' '09:00:12 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' yRotatingExtent )) !


!BoundingBox methods !  
center
    self isUnknown ifTrue: [^Point3D zero].
    center isNil ifTrue: [self update].
    ^center!  ! 
#('March 24, 2003' '04:27:22 PM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('get/set' center )) !


!BoundingBox methods !
center: aPoint3D
    center := aPoint3D!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('get/set' center: )) !


!BoundingBox methods !  
horizontalBottomRight
    ^(maximum x@0.0@maximum z)!  ! 
#('September 16, 2009' '12:04:48 PM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' horizontalBottomRight )) !


!BoundingBox methods !
addBox: aBox

    aBox isUnknown ifTrue: [^self].
    self add: aBox minimum; add: aBox maximum.!    ! 
#('March 20, 2002' '11:31:20 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('growing' addBox: )) !


!BoundingBox methods !   
frontCenter
    ^self center shallowCopy z: self maximum z!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' frontCenter )) !


!BoundingBox methods ! 
includeY: y

    (self maximum isNil | self minimum isNil) ifTrue: [self halt: 'Need initial bounding box value to use "includeY:"...'].
    self maximum: (self maximum max: (self maximum x @ y @ self maximum z)).
    self minimum: (self minimum min: (self minimum x @ y @ self minimum z)).
    self update!    ! 
#('April 4, 2009' '02:07:05 PM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('growing' includeY: )) !


!BoundingBox methods !  
radius: aPoint3D
    radius := aPoint3D!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('get/set' radius: )) !


!BoundingBox methods !  
addAll: objects
    objects do: [:object | self add: object]!  ! 
#('March 20, 2002' '11:26:17 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('growing' addAll: )) !


!BoundingBox methods !   
squaredDistanceToPoint: aPoint
    | distance1 distance2 |
    distance1 := aPoint distanceSquaredTo: self minimum.
    distance2 := aPoint distanceSquaredTo: self maximum.
    ^distance1 > distance2 ifTrue: [distance1] ifFalse: [distance2]!   ! 
#('June 23, 2005' '09:34:12 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' squaredDistanceToPoint: )) !


!BoundingBox methods !   
squaredDistanceToPoint: aPoint
    | distance1 distance2 |
    distance1 := aPoint distanceSquaredTo: self minimum.
    distance2 := aPoint distanceSquaredTo: self maximum.
    ^distance1 < distance2 ifTrue: [distance1] ifFalse: [distance2]!   ! 
#('June 23, 2005' '12:41:37 PM' 33552)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' squaredDistanceToPoint: )) !


!BoundingBox methods ! 
radius
    radius isNil ifTrue: [self update].
    ^radius!   ! 
#('March 24, 2003' '04:27:36 PM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('get/set' radius )) !


!BoundingBox methods !
diameter
    ^self radius * 2.0!   ! 
#('March 31, 2003' '10:21:09 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' diameter )) !


!BoundingBox methods ! 
minimum: aPoint3D
    minimum := aPoint3D! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('get/set' minimum: )) !


!BoundingBox methods ! 
uniformExtent
    self isUnknown ifTrue: [^Point3D zero].
    ^Point ones * self diameter!    ! 
#('March 31, 2003' '10:23:32 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' uniformExtent )) !


!BoundingBox methods !
volume

    | extent |
    extent := self extent.
    ^extent x * extent y * extent z!  ! 
#('March 21, 2002' '02:14:06 PM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' volume )) !


!BoundingBox methods !   
bottomCenter
    ^self center shallowCopy y: self minimum y!   ! 
#('April 27, 2004' '09:17:19 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' bottomCenter )) !


!BoundingBox methods ! 
absoluteExtremalCoordinate
    ^(minimum x abs max:
    (minimum y abs max:
    (minimum z abs max:
    (maximum x abs max:
    (maximum y abs max:
    (maximum z abs))))))! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' absoluteExtremalCoordinate )) !


!BoundingBox methods !  
includesXYofPoint: aPoint
    self minimum x > aPoint x ifTrue: [^false].
    self maximum x < aPoint x ifTrue: [^false].
    self minimum y > aPoint y ifTrue: [^false].
    self maximum y < aPoint y ifTrue: [^false].
    ^true!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' includesXYofPoint: )) !


!BoundingBox methods !  
includesBoundingBox: box
    | boxMinimum boxMaximum epsilon |
    epsilon := WorldGlobal epsilon.
    boxMinimum := box minimum.
    minimum x - epsilon <= boxMinimum x ifFalse: [^false].
    minimum y - epsilon  <= boxMinimum y ifFalse: [^false].
    minimum z - epsilon  <= boxMinimum z ifFalse: [^false].
    boxMaximum := box maximum.
    maximum x + epsilon >= boxMaximum x ifFalse: [^false].
    maximum y + epsilon >= boxMaximum y ifFalse: [^false].
    maximum z + epsilon >= boxMaximum z ifFalse: [^false].
    ^true!  ! 
#('April 1, 2002' '11:15:23 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' includesBoundingBox: )) !


!BoundingBox methods !  
includesBoundingBox: box
    | boxMinimum boxMaximum epsilon |
    box isUnknown ifTrue: [^true].
    epsilon := WorldGlobal epsilon.
    boxMinimum := box minimum.
    minimum x - epsilon <= boxMinimum x ifFalse: [^false].
    minimum y - epsilon  <= boxMinimum y ifFalse: [^false].
    minimum z - epsilon  <= boxMinimum z ifFalse: [^false].
    boxMaximum := box maximum.
    maximum x + epsilon >= boxMaximum x ifFalse: [^false].
    maximum y + epsilon >= boxMaximum y ifFalse: [^false].
    maximum z + epsilon >= boxMaximum z ifFalse: [^false].
    ^true!  ! 
#('January 27, 2010' '02:37:51 PM' 36528)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' includesBoundingBox: )) !


!BoundingBox methods ! 
includesBoundingBox: box
    | boxMinimum boxMaximum epsilon |
    box isUnknown ifTrue: [^true].
    epsilon := 1.0e-5.
    boxMinimum := box minimum.
    minimum x - epsilon <= boxMinimum x ifFalse: [^false].
    minimum y - epsilon  <= boxMinimum y ifFalse: [^false].
    minimum z - epsilon  <= boxMinimum z ifFalse: [^false].
    boxMaximum := box maximum.
    maximum x + epsilon >= boxMaximum x ifFalse: [^false].
    maximum y + epsilon >= boxMaximum y ifFalse: [^false].
    maximum z + epsilon >= boxMaximum z ifFalse: [^false].
    ^true!   ! 
#('December 27, 2016' '03:06:09 PM' 37240)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' includesBoundingBox: )) !


!BoundingBox methods !
minimum
    ^minimum!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('get/set' minimum )) !


!BoundingBox methods !  
withinExactHorizontalDistance: distance ofBox: aBoundingBox
    maximum x < aBoundingBox minimum x ifTrue: [
        self maximum z < aBoundingBox minimum z ifTrue: [^(self bottomRight distanceTo: aBoundingBox topLeft) <= distance].
        self minimum z > aBoundingBox maximum z ifTrue: [^(self topRight distanceTo: aBoundingBox bottomLeft) <= distance].
        ^(aBoundingBox left - self right) <= distance].
    self minimum x > aBoundingBox maximum x ifTrue: [
        self maximum z < aBoundingBox minimum z ifTrue: [^(self bottomLeft distanceTo: aBoundingBox topRight) <= distance].
        self minimum z > aBoundingBox maximum z ifTrue: [^(self topLeft distanceTo: aBoundingBox bottomRight) <= distance].
        ^(self minimum x - aBoundingBox maximum x) <= distance].
        
    self maximum z < aBoundingBox minimum z ifTrue: [^(aBoundingBox top - self bottom) <= distance].
    self minimum z > aBoundingBox maximum z ifTrue: [^(self top - aBoundingBox bottom) <= distance].
    ^true "overlapping"! ! 
#('September 16, 2009' '11:51:52 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' withinExactHorizontalDistance:ofBox: )) !


!BoundingBox methods ! 
withinExactHorizontalDistance: distance ofBox: aBoundingBox
    maximum x < aBoundingBox minimum x ifTrue: [
        self maximum z < aBoundingBox minimum z ifTrue: [^self horizontalBottomRight distanceTo: aBoundingBox horizontalTopLeft <= distance].
        self minimum z > aBoundingBox maximum z ifTrue: [^(self horizontalTopRight distanceTo: aBoundingBox horizontalBottomLeft) <= distance].
        ^(aBoundingBox minimum x - self maximum x) <= distance].
    self minimum x > aBoundingBox maximum x ifTrue: [
        self maximum z < aBoundingBox minimum z ifTrue: [^(self horizontalBottomLeft distanceTo: aBoundingBox horizontalTopRight) <= distance].
        self minimum z > aBoundingBox maximum z ifTrue: [^(self horizontalTopLeft distanceTo: aBoundingBox horizontalBottomRight) <= distance].
        ^(self minimum x - aBoundingBox maximum x) <= distance].
        
    self maximum z < aBoundingBox minimum z ifTrue: [^(aBoundingBox minimum z - self maximum z) <= distance].
    self minimum z > aBoundingBox maximum z ifTrue: [^(self minimum z - aBoundingBox maximum z) <= distance].
    ^true "overlapping"!    ! 
#('September 16, 2009' '12:09:59 PM' 38916)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' withinExactHorizontalDistance:ofBox: )) !


!BoundingBox methods !   
withinExactHorizontalDistance: distance ofBox: aBoundingBox
    maximum x < aBoundingBox minimum x ifTrue: [
        self maximum z < aBoundingBox minimum z ifTrue: [^(self horizontalBottomRight distanceTo: aBoundingBox horizontalTopLeft) <= distance].
        self minimum z > aBoundingBox maximum z ifTrue: [^(self horizontalTopRight distanceTo: aBoundingBox horizontalBottomLeft) <= distance].
        ^(aBoundingBox minimum x - self maximum x) <= distance].
    self minimum x > aBoundingBox maximum x ifTrue: [
        self maximum z < aBoundingBox minimum z ifTrue: [^(self horizontalBottomLeft distanceTo: aBoundingBox horizontalTopRight) <= distance].
        self minimum z > aBoundingBox maximum z ifTrue: [^(self horizontalTopLeft distanceTo: aBoundingBox horizontalBottomRight) <= distance].
        ^(self minimum x - aBoundingBox maximum x) <= distance].

    self maximum z < aBoundingBox minimum z ifTrue: [^(aBoundingBox minimum z - self maximum z) <= distance].
    self minimum z > aBoundingBox maximum z ifTrue: [^(self minimum z - aBoundingBox maximum z) <= distance].
    ^true "overlapping"!  ! 
#('September 16, 2009' '12:49:55 PM' 40136)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' withinExactHorizontalDistance:ofBox: )) !


!BoundingBox methods !   
withinDistance: distance ofBoundingBox: aBoundingBox
    | distanceBetweenCenters |
    distanceBetweenCenters := self center distanceSquaredTo: aBoundingBox center.
    ^distanceBetweenCenters < ((distance + self radius + aBoundingBox radius) square)! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' withinDistance:ofBoundingBox: )) !


!BoundingBox methods !   
leftBottomNear
    ^self minimum shallowCopy z: self maximum z!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' leftBottomNear )) !


!BoundingBox methods !  
withinSquaredDistance: squaredDistance ofBoundingBox: aBoundingBox
    | distanceBetweenCenters tooFarApart |
    distanceBetweenCenters := self center distanceSquaredTo: aBoundingBox center.
    "Match with below: If a > b+c, then a2 > b2+c2+2ab > b2+c2."
    tooFarApart := distanceBetweenCenters > (squaredDistance + (self radius + aBoundingBox radius) squared).
    ^tooFarApart not
!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' withinSquaredDistance:ofBoundingBox: )) !


!BoundingBox methods !
insideHorizontalDistance: distance ofBox: aBoundingBox
    maximum x < aBoundingBox minimum x ifTrue: [
        self maximum z < aBoundingBox minimum z ifTrue: [^(self horizontalBottomRight distanceTo: aBoundingBox horizontalTopLeft) < distance].
        self minimum z > aBoundingBox maximum z ifTrue: [^(self horizontalTopRight distanceTo: aBoundingBox horizontalBottomLeft) < distance].
        ^(aBoundingBox minimum x - self maximum x) < distance].
    self minimum x > aBoundingBox maximum x ifTrue: [
        self maximum z < aBoundingBox minimum z ifTrue: [^(self horizontalBottomLeft distanceTo: aBoundingBox horizontalTopRight) < distance].
        self minimum z > aBoundingBox maximum z ifTrue: [^(self horizontalTopLeft distanceTo: aBoundingBox horizontalBottomRight) < distance].
        ^(self minimum x - aBoundingBox maximum x) < distance].

    self maximum z < aBoundingBox minimum z ifTrue: [^(aBoundingBox minimum z - self maximum z) < distance].
    self minimum z > aBoundingBox maximum z ifTrue: [^(self minimum z - aBoundingBox maximum z) < distance].
    ^true "inside"!    ! 
#('September 17, 2009' '04:47:50 PM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('querying' insideHorizontalDistance:ofBox: )) !


!BoundingBox methods !  
add: anObject

    anObject addToBoundingBox: self!   ! 
#('March 20, 2002' '11:26:38 AM' nil)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('growing' add: )) !


!BoundingBox class methods !
minimum: minimum maximum: maximum
    "Performs an automatic update in addition to creating the instance."
    ^self new minimum: minimum; maximum: maximum; update!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BoundingBox class) reorganizeFrom: #(
('instance creation' minimum:maximum: )) !


!BoundingBox class methods !   
minimum: minimum extent: extent
    "Performs an automatic update in addition to creating the instance."
    ^self new minimum: minimum; maximum: (minimum + extent); update! ! 
#('September 16, 2009' '11:44:28 AM' nil)!

(CodeFiler organizerFor: BoundingBox class) reorganizeFrom: #(
('instance creation' minimum:extent: )) !


!BoundingBox class methods ! 
bottomCenter: aPoint extent: aVector
    | halfXZExtent heightAsVector |
    halfXZExtent := Point3D x: aVector x * 0.5 y: 0.0 z: aVector z * 0.5.
    heightAsVector := Point3D x: 0.0 y: aVector y z: 0.0.
    ^self minimum: (aPoint - halfXZExtent) maximum: (aPoint + halfXZExtent + heightAsVector)!  ! 
#('April 29, 2003' '10:10:41 AM' nil)!

(CodeFiler organizerFor: BoundingBox class) reorganizeFrom: #(
('instance creation' bottomCenter:extent: )) !


!BoundingBox class methods !
for: points
    | minimum maximum |
    minimum := maximum := points first.
    points do: [:point |
        minimum := minimum min: point.
        maximum := maximum max: point].
    ^BoundingBox minimum: minimum maximum: maximum!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BoundingBox class) reorganizeFrom: #(
('instance creation' for: )) !


!BoundingBox class methods !   
center: aPoint extent: aVector
    | halfExtent |
    halfExtent := (aVector * 0.5) abs.
    ^self minimum: (aPoint - halfExtent) maximum: (aPoint + halfExtent)!    ! 
#('July 29, 2002' '02:30:27 PM' nil)!

(CodeFiler organizerFor: BoundingBox class) reorganizeFrom: #(
('instance creation' center:extent: )) !


!BoundingBox class methods !   
unitBox
    ^self minimum: (Point3D x: -0.5 y: -0.5 z: -0.5) maximum: (Point3D x: 0.5 y: 0.5 z: 0.5)!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BoundingBox class) reorganizeFrom: #(
('instance creation' unitBox )) !




Object subclass: #CallBack
  instanceVariableNames: 
    ' slotNumber lpfnInstanceProc stMessage typeArray returnType ccType '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Kernel-Host Interfaces' )
  comment: ''!

 

CallBack subclass: #CallBack16
  instanceVariableNames: ''
  classVariableNames: 
    ' LpCodeCallBackEntry LpDataCallBackEntry LpfnSTCallBack '
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!

 

Object subclass: #ChangeLogCompressor
  instanceVariableNames: 
    ' classes methods oldestMethodDate oldestMethodCount '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'Tools-Development Support' )
  comment: ''!

!ChangeLogCompressor methods !  
scan: aClass

    | changedMethods sourceIndex recordDefinition |
    recordDefinition := false.
    changedMethods := aClass selectors select: [:selector |
        sourceIndex := (aClass compiledMethodAt: selector) sourceIndex.
        recordDefinition := recordDefinition or:  [sourceIndex ~= 3].
        sourceIndex = 2 "change log"].

    recordDefinition ifTrue: [classes add: aClass].
    changedMethods notEmpty ifTrue: [methods at: aClass put: changedMethods].! ! 
#('February 15, 2002' '11:39:51 AM' nil)!

(CodeFiler organizerFor: ChangeLogCompressor) reorganizeFrom: #(
('private' scan: )) !


!ChangeLogCompressor methods !  
promptForOptionsIfCancel: cancelBlock
    "We always keep at least the most recent method... After that we satisfy 2 criteria: one by date and one by count.
    For example,
        By date: might specify all methods that are 2 months old or less.
        By count: might specifity at least 3 methods.
    So we will keep at least 3 methods (more if there are 10 less than 2 months old)...."
    
    | retainmentCriterion countString dateString |
    
    retainmentCriterion := ChooseOneDialog new
        openOn: #('By date' 'By count' 'By both') label: 'Method history retainment criteria?'.
    retainmentCriterion isNil ifTrue: [^cancelBlock value].
    
    retainmentCriterion ~= 'By date' "i.e., either 'By count' or 'By both'..."
        ifTrue: [
            countString := Prompter prompt: 'Minimum number of methods to keep?' default: '2'.
            countString isNil ifTrue: [^cancelBlock value].
            oldestMethodCount := countString asInteger]
        ifFalse: [
            oldestMethodCount := 1].
            
    retainmentCriterion ~= 'By count' "i.e., either 'By date' or 'By both'..."
        ifTrue: [
            dateString := Prompter prompt: 'Oldest method to keep (in months)?' default: 'Keep all methods'.
            dateString isNil ifTrue: [^cancelBlock value].
            oldestMethodDate := dateString = 'Keep all methods'ifTrue: [Date fromDays: 0] ifFalse: [Date today subtractDays: 30 * dateString asInteger]]
        ifFalse: [
            oldestMethodDate := Date today].! ! 
#('July 21, 2006' '09:30:59 AM' nil)!

(CodeFiler organizerFor: ChangeLogCompressor) reorganizeFrom: #(
('prompting' promptForOptionsIfCancel: )) !


!ChangeLogCompressor methods !
writeChangeSetsOn: aStream

    ((Smalltalk includesKey: #CodeFiler) and: [Smalltalk includesKey: #ChangeSetManager]) ifTrue: [
        CodeFiler changeSetManager changeSets do: [:changeSet | changeSet exportOn: aStream]].!  ! 
#('August 29, 2001' '02:49:32 PM' nil)!

(CodeFiler organizerFor: ChangeLogCompressor) reorganizeFrom: #(
('private' writeChangeSetsOn: )) !


!ChangeLogCompressor methods !   
scanClasses

    | roots class |
    roots := Smalltalk rootClasses copy.
    [roots notEmpty] whileTrue: [
        class := roots removeFirst.
        self scan: class; scan: class class.
        roots addAll: class subclasses]!    ! 
#('February 15, 2002' '11:39:51 AM' nil)!

(CodeFiler organizerFor: ChangeLogCompressor) reorganizeFrom: #(
('building' scanClasses )) !


!ChangeLogCompressor methods !   
writeDefinitionFor: aClass on: aStream

    (aClass isMetaClass and: [classes includesIdentical: aClass instanceClass]) ifTrue: [^self]. "definition will be written by instanceClass."
    aStream cr; cr; nextChunkPut: (CodeFiler forClass: aClass) definitionString! ! 
#('February 15, 2002' '11:39:51 AM' nil)!

(CodeFiler organizerFor: ChangeLogCompressor) reorganizeFrom: #(
('private' writeDefinitionFor:on: )) !


!ChangeLogCompressor methods ! 
initialize

    classes := OrderedCollection new.
    methods := IdentityDictionary new.
    oldestMethodDate := Date fromDays: 0.! ! 
#('February 15, 2002' '11:40:46 AM' nil)!

(CodeFiler organizerFor: ChangeLogCompressor) reorganizeFrom: #(
('initializing' initialize )) !


!ChangeLogCompressor methods !
writeSystemOrganizationOn: aStream
    "Place a doit chunk capable of reorganizing the system organization to look identical to the current organization"

    aStream
        << 'CodeFiler systemOrganizer: (ClassBasedOrganizer fromArray: #(';
        cr; << CodeFiler systemOrganizer editString;
        cr; << ')) !!'!   ! 
#('February 15, 2002' '11:39:51 AM' nil)!

(CodeFiler organizerFor: ChangeLogCompressor) reorganizeFrom: #(
('private' writeSystemOrganizationOn: )) !


!ChangeLogCompressor methods ! 
writeChangesOn: aStream

    | progressBar |
    progressBar := ProgressIndicatorDialogThatWorks new noCancel; open: 'Compressing changes ...' message: ''.
    [classes indexedDo: [:index :class |
        progressBar percent: (index / classes size * 100.0) truncated.
        self writeDefinitionFor: class on: aStream.
        self writeMethodsFor: class on: aStream].
    self writeSystemOrganizationOn: aStream.
    self writeChangeSetsOn: aStream] ensure: [progressBar close].!  ! 
#('August 29, 2001' '02:49:44 PM' nil)!

(CodeFiler organizerFor: ChangeLogCompressor) reorganizeFrom: #(
('building' writeChangesOn: )) !


!ChangeLogCompressor methods ! 
promptForOptions

    | dateString |
    dateString := Prompter prompt: 'Oldest method to keep (in months)?' default: 'Keep all methods'.
    (dateString isNil or: [dateString = 'Keep all methods']) ifTrue: [^self].
    oldestMethodDate := Date today subtractDays: 30 * dateString asInteger.!   ! 
#('February 5, 2003' '10:31:51 AM' nil)!

(CodeFiler organizerFor: ChangeLogCompressor) reorganizeFrom: #(
('prompting' promptForOptions )) !


!ChangeLogCompressor methods !  
promptForOptions
    "We always keep at least the most recent method... After that we satisfy 2 criteria: one by date and one by count.
    For example,
        By date: might specify all methods that are 2 months old or less.
        By count: might specifity at least 3 methods.
    So we will keep at least 3 methods (more if there are 10 less than 2 months old)...."
    
    | retainmentCriterion countString dateString |
    
    retainmentCriterion := ChooseOneDialog new
        openOn: #('By date' 'By count' 'By both') label: 'Method history retainment criteria?'.
    retainmentCriterion isNil ifTrue: [retainmentCriterion := 'By date'].
    
    retainmentCriterion ~= 'By date' "i.e., either 'By count' or 'By both'..."
        ifTrue: [
            countString := Prompter prompt: 'Minimum number of methods to keep?' default: '2'.
            oldestMethodCount := countString isNil ifTrue: [1] ifFalse: [countString asInteger]]
        ifFalse: [
            oldestMethodCount := 1].
            
    retainmentCriterion ~= 'By count' "i.e., either 'By date' or 'By both'..."
        ifTrue: [
            dateString := Prompter prompt: 'Oldest method to keep (in months)?' default: 'Keep all methods'.
            oldestMethodDate := (dateString isNil or: [dateString = 'Keep all methods']) ifTrue: [Date fromDays: 0] ifFalse: [Date today subtractDays: 30 * dateString asInteger]]
        ifFalse: [
            oldestMethodDate := Date today].!  ! 
#('July 21, 2006' '09:23:34 AM' 53860)!

(CodeFiler organizerFor: ChangeLogCompressor) reorganizeFrom: #(
('prompting' promptForOptions )) !


!ChangeLogCompressor methods !   
writeMethodsFor: aClass on: aStream

    | codeFiler methodVersions previousSourcePosition currrentVersion allOtherVersions |
    codeFiler := CodeFiler forClass: aClass.
    (methods at: aClass ifAbsent: [^self]) do: [:selector |
        methodVersions := (codeFiler loadedVersionOf: selector) withAllPreviousVersions reversed.
        currrentVersion := methodVersions copyFrom: methodVersions size to: methodVersions size.
        allOtherVersions := methodVersions allButLast reject: [:version | version timeStamp date < oldestMethodDate].
        previousSourcePosition := nil.
        (allOtherVersions, currrentVersion) do: [:methodVersion |
            codeFiler
                logSource: methodVersion source
                forSelector: selector
                withTimestamp: methodVersion timeStamp
                withPreviousSourcePosition: previousSourcePosition
                on: aStream.
            previousSourcePosition := (aClass compiledMethodAt: selector) sourcePosition]].!    ! 
#('February 5, 2003' '10:31:51 AM' nil)!

(CodeFiler organizerFor: ChangeLogCompressor) reorganizeFrom: #(
('private' writeMethodsFor:on: )) !


!ChangeLogCompressor methods ! 
writeMethodsFor: aClass on: aStream

    | codeFiler methodVersions previousSourcePosition inclusionBoundary versionsByCount versionsByDate |
    codeFiler := CodeFiler forClass: aClass.
    (methods at: aClass ifAbsent: [^self]) do: [:selector |
        methodVersions := (codeFiler loadedVersionOf: selector) withAllPreviousVersions reversed.
        
        inclusionBoundary := methodVersions size - (oldestMethodCount - 1) max: 1.
        versionsByCount := methodVersions copyFrom: inclusionBoundary to: methodVersions size.
        versionsByDate := (methodVersions copyFrom: 1 to: inclusionBoundary - 1) reject: [:version | version timeStamp date < oldestMethodDate].

        previousSourcePosition := nil.
        (versionsByCount, versionsByDate) do: [:methodVersion |
            codeFiler
                logSource: methodVersion source
                forSelector: selector
                withTimestamp: methodVersion timeStamp
                withPreviousSourcePosition: previousSourcePosition
                on: aStream.
            previousSourcePosition := (aClass compiledMethodAt: selector) sourcePosition]].! ! 
#('July 21, 2006' '09:20:38 AM' 56024)!

(CodeFiler organizerFor: ChangeLogCompressor) reorganizeFrom: #(
('private' writeMethodsFor:on: )) !


!ChangeLogCompressor methods !  
writeMethodsFor: aClass on: aStream

    | codeFiler methodVersions previousSourcePosition inclusionBoundary versionsByCount versionsByDate |
    codeFiler := CodeFiler forClass: aClass.
    (methods at: aClass ifAbsent: [^self]) do: [:selector |
        methodVersions := (codeFiler loadedVersionOf: selector) withAllPreviousVersions reversed.
        
        inclusionBoundary := methodVersions size - (oldestMethodCount - 1) max: 1.
        versionsByCount := methodVersions copyFrom: inclusionBoundary to: methodVersions size.
        versionsByDate := (methodVersions copyFrom: 1 to: inclusionBoundary - 1) reject: [:version | version timeStamp date < oldestMethodDate].

        previousSourcePosition := nil.
        (versionsByDate, versionsByCount) do: [:methodVersion |
            codeFiler
                logSource: methodVersion source
                forSelector: selector
                withTimestamp: methodVersion timeStamp
                withPreviousSourcePosition: previousSourcePosition
                on: aStream.
            previousSourcePosition := (aClass compiledMethodAt: selector) sourcePosition]].! ! 
#('July 22, 2006' '11:29:04 AM' 57232)!

(CodeFiler organizerFor: ChangeLogCompressor) reorganizeFrom: #(
('private' writeMethodsFor:on: )) !


!ChangeLogCompressor class methods !
new
    ^super new initialize! ! 
#('August 29, 2001' '11:54:12 AM' nil)!

(CodeFiler organizerFor: ChangeLogCompressor class) reorganizeFrom: #(
('instance scheduling' new )) !


  

Object subclass: #ChangeSetItem
  instanceVariableNames: 
    ' date time owner '
  classVariableNames: 
    ' TypeSortOrder '
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'Tools-Change Sets' )
  comment: ''!



ChangeSetItem subclass: #ChangeSetEvaluateItem
  instanceVariableNames: 
    ' source '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Change Sets' )
  comment: ''!

 

Object subclass: #ChangeSetManager
  instanceVariableNames: 
    ' changeSets buildDate buildTime '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants '
  categories: #( 'Tools-Change Sets' )
  comment: ''!

   

Behavior subclass: #Class
  instanceVariableNames: 
    ' classPool sharedPools '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Behaviors' )
  comment: ''!

!Class methods !
variableSubclass: classSymbol
    instanceVariableNames: instanceVariables
    classVariableNames: classVariables
    poolDictionaries: poolDictNames
    categories: categories
    comment: comment
    
    | result |
    result := self 
        variableSubclass: classSymbol
        instanceVariableNames: instanceVariables
        classVariableNames: classVariables
        poolDictionaries: poolDictNames
        categories: categories.
        
    CodeFiler setCommentFor: classSymbol to: comment.
    ^result! ! 
#('May 24, 2002' '04:18:26 PM' nil)!

(CodeFiler organizerFor: Class) reorganizeFrom: #(
('no category methods' variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:categories:comment: )) !


!Class methods !  
subclass: classSymbol
    instanceVariableNames: instanceVariables
    classVariableNames: classVariables
    poolDictionaries: poolDictNames
    categories: categories
    comment: comment

    | result |
    result := self 
        subclass: classSymbol
        instanceVariableNames: instanceVariables
        classVariableNames: classVariables
        poolDictionaries: poolDictNames
        categories: categories.
        
    CodeFiler setCommentFor: classSymbol to: comment.
    ^result! ! 
#('May 24, 2002' '04:17:56 PM' nil)!

(CodeFiler organizerFor: Class) reorganizeFrom: #(
('no category methods' subclass:instanceVariableNames:classVariableNames:poolDictionaries:categories:comment: )) !


!Class methods !  
variableByteSubclass: classSymbol
    classVariableNames: classVariables
    poolDictionaries: poolDictNames
    categories: categories
    comment: comment 
    
    | result |
    result := self 
        variableByteSubclass: classSymbol
        classVariableNames: classVariables
        poolDictionaries: poolDictNames
        categories: categories.

    CodeFiler setCommentFor: classSymbol to: comment.
    ^result!    ! 
#('May 24, 2002' '04:18:10 PM' nil)!

(CodeFiler organizerFor: Class) reorganizeFrom: #(
('no category methods' variableByteSubclass:classVariableNames:poolDictionaries:categories:comment: )) !


!Class methods !
removeAllInstances

    (MessageBox confirm: 'Remove all ', self name, 's?') ifFalse: [^self].
    self allInstances do: [:each | each become: nil]! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Class) reorganizeFrom: #(
('extensions' removeAllInstances )) !


!Class methods !
removeFromSystem
        "Remove the receiver from Smalltalk.  Report
         an error if there are any subclasses or
         instances of the receiver."

    | className |
    className := self name asSymbol.
    self removeFromSystem: true.
    (Smalltalk includesKey: className) ifTrue: [
        CodeFiler
            removeOrganizerFor: className;
            removeOrganizerFor: (className, ' class') asSymbol.
        CodeFiler systemOrganizer update].!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Class) reorganizeFrom: #(
('extensions' removeFromSystem )) !


!Class methods !  
removeFromSystem
        "Remove the receiver from Smalltalk.  Report
         an error if there are any subclasses or
         instances of the receiver."

    | className |
    className := self name asSymbol.
    self removeFromSystem: true.
    (Smalltalk includesKey: className) ifTrue: [
        CodeFiler
            removeOrganizerFor: className;
            removeOrganizerFor: (className, ' class') asSymbol.
            
        CodeFiler systemOrganizer categoryToElement keysAndValuesDo: [:category :classNamesInCategory |
            (classNamesInCategory includes: className) ifTrue: [classNamesInCategory remove: className]].

        CodeFiler systemOrganizer update].!  ! 
#('July 22, 2006' '01:40:57 PM' 63508)!

(CodeFiler organizerFor: Class) reorganizeFrom: #(
('extensions' removeFromSystem )) !


!Class methods !  
removeFromSystem
        "Remove the receiver from Smalltalk.  Report
         an error if there are any subclasses or
         instances of the receiver."

    | includedKey className |
    className := self name asSymbol.
    includedKey := Smalltalk includesKey: className.
    self removeFromSystem: true.
    (includedKey and: [(Smalltalk includesKey: className) not]) ifTrue: [
        "It was a class we were allowed to delete (Not UndefinedObject, for example)..."
        CodeFiler
            removeOrganizerFor: className;
            removeOrganizerFor: (className, ' class') asSymbol.

        CodeFiler systemOrganizer categoryToElement keysAndValuesDo: [:category :classNamesInCategory |
            (classNamesInCategory includes: className) ifTrue: [classNamesInCategory remove: className]].

        CodeFiler systemOrganizer update].! ! 
#('July 22, 2006' '01:53:12 PM' 64144)!

(CodeFiler organizerFor: Class) reorganizeFrom: #(
('extensions' removeFromSystem )) !


!Class methods !  
classVarNames
        "Answer a Set of class variable
         names defined in the receiver."
    ^self classPool keys collect: [:symbol | symbol asString]!    ! 
#('January 20, 2003' '10:53:23 AM' nil)!

(CodeFiler organizerFor: Class) reorganizeFrom: #(
('no category methods' classVarNames )) !


!Class methods !   
rename: candidateName in: aSystemDictionary
    "Private - Rename the receiver 'candidateName' in the environment aSystemDictionary."

    | oldName newName categoryToClassNames |

    oldName := self name. newName := candidateName asSymbol.

    self halt: 'Considering ', oldName.
    categoryToClassNames := CodeFiler systemOrganizer categoryToElement.
    categoryToClassNames keysAndValuesDo: [:category :classNamesInCategory |
    (category = '3D-Levels') ifTrue: [
    self halt: 'Reached category 3D-Levels'].
        (classNamesInCategory includes: oldName) ifTrue: [
        self halt: 'Before renaming ', oldName, ': Category ', category, ' has ', oldName]].


    (aSystemDictionary includesKey: newName) ifTrue: [^self error: 'can''t rename to existing name'].
    DefinitionInstaller current
        renameClass: self
        to: newName
        inGlobalDictionary: aSystemDictionary.

    categoryToClassNames keysAndValuesDo: [:category :classNamesInCategory |
        (classNamesInCategory includes: oldName) ifTrue: [
        self halt: 'After installer ran for ', oldName, ': Category ', category, ' has ', oldName]].

    CodeFiler rekeyOrganizerFor: oldName under: newName.
    CodeFiler rekeyOrganizerFor: oldName, ' class' under: newName, ' class'.
    categoryToClassNames := CodeFiler systemOrganizer categoryToElement.
    categoryToClassNames keysAndValuesDo: [:category :classNamesInCategory |
        (classNamesInCategory includes: oldName) ifTrue: [
        self halt:  'After rekeying for ', oldName, ': Category ', category, ' has ', oldName.
            classNamesInCategory remove: oldName; add: newName]].
    CodeFiler logRenameClass: oldName to: newName.

    self halt: 'All done for ', oldName!   ! 
#('July 22, 2006' '01:21:26 PM' nil)!

(CodeFiler organizerFor: Class) reorganizeFrom: #(
('no category methods' rename:in: )) !


!Class methods ! 
rename: candidateName in: aSystemDictionary
    "Private - Rename the receiver 'candidateName' in the environment aSystemDictionary."

    | oldName newName categoryToClassNames |

    oldName := self name asSymbol. newName := candidateName asSymbol.

    self halt: 'Considering ', oldName.
    categoryToClassNames := CodeFiler systemOrganizer categoryToElement.
    categoryToClassNames keysAndValuesDo: [:category :classNamesInCategory |
    (category = '3D-Levels') ifTrue: [
    self halt: 'Reached category 3D-Levels'].
        (classNamesInCategory includes: oldName) ifTrue: [
        self halt: 'Before renaming ', oldName, ': Category ', category, ' has ', oldName]].


    (aSystemDictionary includesKey: newName) ifTrue: [^self error: 'can''t rename to existing name'].
    DefinitionInstaller current
        renameClass: self
        to: newName
        inGlobalDictionary: aSystemDictionary.

    categoryToClassNames keysAndValuesDo: [:category :classNamesInCategory |
        (classNamesInCategory includes: oldName) ifTrue: [
        self halt: 'After installer ran for ', oldName, ': Category ', category, ' has ', oldName]].

    CodeFiler rekeyOrganizerFor: oldName under: newName.
    CodeFiler rekeyOrganizerFor: oldName, ' class' under: newName, ' class'.
    categoryToClassNames := CodeFiler systemOrganizer categoryToElement.
    categoryToClassNames keysAndValuesDo: [:category :classNamesInCategory |
        (classNamesInCategory includes: oldName) ifTrue: [
        self halt:  'After rekeying for ', oldName, ': Category ', category, ' has ', oldName.
            classNamesInCategory remove: oldName; add: newName]].
    CodeFiler logRenameClass: oldName to: newName.

    self halt: 'All done for ', oldName!  ! 
#('July 22, 2006' '01:24:40 PM' 66372)!

(CodeFiler organizerFor: Class) reorganizeFrom: #(
('no category methods' rename:in: )) !


!Class methods !   
rename: candidateName in: aSystemDictionary
    "Private - Rename the receiver 'candidateName' in the environment aSystemDictionary."

    | oldName newName |

    oldName := self name asSymbol. newName := candidateName asSymbol.

    (aSystemDictionary includesKey: newName) ifTrue: [^self error: 'can''t rename to existing name'].
    DefinitionInstaller current
        renameClass: self
        to: newName
        inGlobalDictionary: aSystemDictionary.

    CodeFiler rekeyOrganizerFor: oldName under: newName.
    CodeFiler rekeyOrganizerFor: oldName, ' class' under: newName, ' class'.
    
    CodeFiler systemOrganizer categoryToElement keysAndValuesDo: [:category :classNamesInCategory |
        (classNamesInCategory includes: oldName) ifTrue: [classNamesInCategory remove: oldName; add: newName]].
            
    CodeFiler logRenameClass: oldName to: newName!    ! 
#('July 22, 2006' '01:29:29 PM' 68304)!

(CodeFiler organizerFor: Class) reorganizeFrom: #(
('no category methods' rename:in: )) !


   

ChangeSetItem subclass: #ClassBasedChangeSetItem
  instanceVariableNames: 
    ' className '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'Tools-Change Sets' )
  comment: ''!

  

ClassBasedChangeSetItem subclass: #ChangeSetClassCommentItem
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Change Sets' )
  comment: ''!

 

ClassBasedChangeSetItem subclass: #ChangeSetClassDefinitionItem
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Change Sets' )
  comment: ''!

  

ChangeSetClassDefinitionItem subclass: #ChangeSetClassReorganizationItem
  instanceVariableNames: 
    ' newCategories '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Change Sets' )
  comment: ''!



ClassBasedChangeSetItem subclass: #ChangeSetMethodItem
  instanceVariableNames: 
    ' protocol selector '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Change Sets' )
  comment: ''!

!ChangeSetMethodItem methods !
asHighlightItem

    ^ChangeSetMethodHighlightItem new
        owner: owner; date: date; time: time; className: className; selector: selector; protocol: protocol; yourself.!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: ChangeSetMethodItem) reorganizeFrom: #(
('converting' asHighlightItem )) !


 

ChangeSetMethodItem subclass: #ChangeSetMethodHighlightItem
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Change Sets' )
  comment: ''!

!ChangeSetMethodHighlightItem methods !   
canFileOutSource

    ^false! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: ChangeSetMethodHighlightItem) reorganizeFrom: #(
('testing' canFileOutSource )) !


!ChangeSetMethodHighlightItem methods !   
fileOutErrorOn: aStream with: aCodeFilerClass

    ^self! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: ChangeSetMethodHighlightItem) reorganizeFrom: #(
('filing out' fileOutErrorOn:with: )) !


   

ClassBasedChangeSetItem subclass: #ChangeSetProtocolItem
  instanceVariableNames: 
    ' protocol '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Change Sets' )
  comment: ''!

 

ChangeSetProtocolItem subclass: #ChangeSetAddProtocolItem
  instanceVariableNames: 
    ' beforeProtocol '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Change Sets' )
  comment: ''!

  

ClassBasedChangeSetItem subclass: #ChangeSetRemoveClassItem
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Change Sets' )
  comment: ''!

  

ClassBasedChangeSetItem subclass: #ChangeSetRemoveMethodItem
  instanceVariableNames: 
    ' selector '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Change Sets' )
  comment: ''!

 

ChangeSetProtocolItem subclass: #ChangeSetRemoveProtocolItem
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Change Sets' )
  comment: ''!

 

ChangeSetProtocolItem subclass: #ChangeSetRenameProtocolItem
  instanceVariableNames: 
    ' oldProtocol '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Change Sets' )
  comment: ''!

  

Object subclass: #ClassInstaller
  instanceVariableNames: 
    ' name environment superclass instanceVariableNames classVariableNames poolNames classInstanceVariableNames isVariable isPointers classObject errorString shouldCompileClass shouldCompileMetaclass shouldCompileSubclasses mutators classMutators classInstanceVariablesOnly shouldCompileMetaclassSubclasses '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Source Management' )
  comment: ''!

  

Object subclass: #ClassReader
  instanceVariableNames: 
    ' class '
  classVariableNames: 
    ' DefaultClass '
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'Tools-Code Writers & Readers' )
  comment: ''!

  

Object subclass: #ClipboardManager
  instanceVariableNames: ''
  classVariableNames: 
    ' Open UserFormats '
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Kernel-Host Interfaces' )
  comment: ''!

  

Object subclass: #CodeBrowserSelection
  instanceVariableNames: 
    ' contents '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Navigator' )
  comment: ''!

 

Object subclass: #CodeFiler
  instanceVariableNames: 
    ' classes forClass '
  classVariableNames: 
    ' ChangeSetManagerInstance ClassComments ClassOrganizers SystemOrganizer '
  poolDictionaries: ''
  categories: #( 'Tools-Code Writers & Readers' )
  comment: ''!

!CodeFiler methods ! 
definitionString
    "   ^   <String>
    Return a string which is the definition of the class I represent."

    | stream categories |

    stream := WriteStream on: (String new: 64).
    categories := self class systemOrganizer categoriesOfElement: self forClass name asSymbol.
    self forClass fileOutOn: stream.
    stream cr ;space; space; << 'categories: #( '.
    categories do: [:each | stream store: each; space].
    stream << $).
    
    stream cr; space; space; << 'comment: '; << (self class commentFor: self forClass name asSymbol) printString.
    ^stream contents.!   ! 
#('January 20, 2003' '10:53:20 AM' nil)!

(CodeFiler organizerFor: CodeFiler) reorganizeFrom: #(
('accessing' definitionString )) !


!CodeFiler methods !  
methodOrganizer
    "^ <MethodBasedOrganizer>
    Answer the method organizer for my smalltalkClass"

    ^(self class organizerFor: self forClass name)!   ! 
#('October 26, 2002' '11:12:53 AM' nil)!

(CodeFiler organizerFor: CodeFiler) reorganizeFrom: #(
('accessing' methodOrganizer )) !


!CodeFiler methods !   
logSource: source forSelector: selector withPreviousSourcePosition: previousSourcePosition

    ^self
        logSource: source
        forSelector: selector
        withPreviousSourcePosition: previousSourcePosition
        on: (Sources at: 2)! ! 
#('August 29, 2001' '02:34:51 PM' nil)!

(CodeFiler organizerFor: CodeFiler) reorganizeFrom: #(
('logging' logSource:forSelector:withPreviousSourcePosition: )) !


!CodeFiler methods !
logSource: source forSelector: selector

    ^self
        logSource: source
        forSelector: selector
        withPreviousSourcePosition: nil!    ! 
#('August 29, 2001' '02:35:05 PM' nil)!

(CodeFiler organizerFor: CodeFiler) reorganizeFrom: #(
('logging' logSource:forSelector: )) !


!CodeFiler methods !   
logSource: source forSelector: selector withPreviousSourcePosition: previousSourcePosition on: aStream

    ^self
        logSource: source
        forSelector: selector
        withTimestamp: TimeStamp current
        withPreviousSourcePosition: previousSourcePosition
        on: aStream!   ! 
#('August 29, 2001' '02:34:25 PM' nil)!

(CodeFiler organizerFor: CodeFiler) reorganizeFrom: #(
('logging' logSource:forSelector:withPreviousSourcePosition:on: )) !


!CodeFiler methods ! 
fileOutOn: stream
    "   stream  <WriteStream>
        ^       self
    Put a textual version of my class to stream."

    CursorManager execute changeFor: [
        self classes do: [:aClass |
            self
                forClass: aClass;
                fileOutDefinitionOn: stream.
            stream cr;cr].
        self classes do: [:aClass |
            self
                forSuperclassOfClass: aClass;
                fileOutProtocolsOn: stream.
            self
                forClass: aClass;
                fileOutProtocolsOn: stream;
                fileOutCommentOn: stream]]!   ! 
#('March 9, 2003' '09:44:22 AM' nil)!

(CodeFiler organizerFor: CodeFiler) reorganizeFrom: #(
('filing out' fileOutOn: )) !


!CodeFiler methods !  
logSource: source forSelector: selector withTimestamp: timeStamp withPreviousSourcePosition: previousSourcePosition on: aStream
    "source      <String>
     selector    <Symbol>
     previousSourcePosition  <Integer> | nil
    Log source as the source code for selector for class."

    | stamp compiledMethod |
    aStream setToEnd.
    self fileOutPreambleOn: aStream.
    compiledMethod := self forClass compiledMethodAt: selector.

    aStream setToEnd; cr; cr; << '!!'; << self forClass name; << ' methods !!'.
    compiledMethod sourceIndex: 2 sourcePosition: (SourceManager current getMethodPositionOn: aStream for: source).
    aStream nextChunkPut: source; nextChunkPut: String new.

    stamp := WriteStream on: (String new: 50).
    stamp
        nextPutAll: '#(';
        print: timeStamp date printString; space;
        print: timeStamp time printString; space;
        print: previousSourcePosition;
        nextPutAll: ')'.

    aStream nextChunkPut: stamp contents; cr.
    self fileOutOrganizationFor: (Array with: selector) on: aStream.
    aStream flush.!  ! 
#('April 26, 2002' '01:34:22 PM' nil)!

(CodeFiler organizerFor: CodeFiler) reorganizeFrom: #(
('logging' logSource:forSelector:withTimestamp:withPreviousSourcePosition:on: )) !


!CodeFiler methods !
loadedVersionOf: selector
    "   ^   <MethodVersion>
    Answer the version of the method named selector loaded in the image"

    | method changeLog |

    method := self forClass compiledMethodAt: selector.
    changeLog := Sources at: 2.
    method sourceIndex = 2
        ifTrue: [^self versionOf: selector at: method sourcePosition in: changeLog].

    ^MethodVersion
        smalltalkClass: self forClass
        selector: selector
        source: method sourceString
        timeStamp: (TimeStamp date: (Date fromString: '1 january 1970') time: (Time fromString: '01:01:01 AM'))  "for lack of anything better"!   ! 
#('August 29, 2001' '02:22:16 PM' nil)!

(CodeFiler organizerFor: CodeFiler) reorganizeFrom: #(
('logging' loadedVersionOf: )) !


!CodeFiler methods ! 
compile: source notifying: notifier

    | result oldMethod previousSourcePosition selector sourceString |
    selector := self selectorFor: source.
    (self forClass selectors includes: selector) ifTrue: [
        oldMethod := self forClass compiledMethodAt: selector.

        "Old method isn't in the change log? Save it there first..."
        oldMethod sourceIndex = 2 ifFalse: [
            self
                logSource: (self forClass sourceCodeAt: selector)
                forSelector: selector
                withPreviousSourcePosition: nil].
        previousSourcePosition := oldMethod sourcePosition].

    sourceString := source trimBlanks.
    notifier isNil
        ifTrue: [result := self forClass compile: sourceString]
        ifFalse: [result := self forClass compile: sourceString notifying: notifier].
    result notNil
        ifTrue: [self logSource: sourceString forSelector: result key withPreviousSourcePosition: previousSourcePosition].
    ^result!   ! 
#('August 28, 2001' '02:59:13 PM' nil)!

(CodeFiler organizerFor: CodeFiler) reorganizeFrom: #(
('saving methods' compile:notifying: )) !


!CodeFiler methods !
versionOf: selector at: sourcePosition in: aStream
    "Private - Load the version of the method named selector located at sourcePosition in the change log.
    No checking is done to ensure that this is indeed correct information"

    | sourceString version stampChunk stamp stream previousVersionLocation |

    aStream position: sourcePosition.
    sourceString := aStream nextChunk.

    stampChunk := aStream nextChunk; nextChunk.
    (stampChunk isEmpty or: [(stampChunk first = $# and: [(stampChunk at: 2) = $(]) not]) ifTrue: [
        stamp := TimeStamp date: (Date fromString: '1 january 1970') time: (Time fromString: '01:01:01 AM')  "for lack of anything better".

        ^MethodVersion
            smalltalkClass: self forClass
            selector: selector
            source: sourceString
            timeStamp: stamp].

    "We're now reasonable sure that the chunk represents a timeStamp and previous version pointer.
    Ask the compiler to turn it into an array for us. It will be #('Date' 'Time' previousSourcePositionOrTheSymbolNil) "
    stamp := CompilerInterface evaluate: stampChunk in: UndefinedObject to: nil notifying: self ifFail: [nil].
    stamp isNil
        ifTrue: [
           stamp := (aStream isKindOf: FileStream)
                ifTrue: [aStream file creationTime]
                ifFalse: [TimeStamp date: (Date fromString: '1 january 1970') time: (Time fromString: '01:01:01 AM')  "for lack of anything better"]]
        ifFalse: [
            previousVersionLocation := (stamp last isKindOf: Integer)
                ifTrue: [stamp last]
                ifFalse: [nil].
            stamp := TimeStamp date: stamp first asDate time: (stamp at: 2) asTime].

    version := MethodVersion
            smalltalkClass: self forClass
            selector: selector
            source: sourceString
            timeStamp: stamp.
    version previousVersion: previousVersionLocation sourceStream: aStream.
    ^version!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: CodeFiler) reorganizeFrom: #(
('private' versionOf:at:in: )) !


!CodeFiler methods ! 
compile: source

    ^self compile: source notifying: nil!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: CodeFiler) reorganizeFrom: #(
('saving methods' compile: )) !


!CodeFiler methods !  
fileInFrom: stream
    "   stream  <ReadStream>
        ^       self
    Read chunks from aStream until an empty chunk (a single '!!') is found.
    Compile each chunk as a method for the class I describe.
    Log the source code of the method to the change log."

    | chunk result changeLog selectors |
    selectors := OrderedCollection new.
    changeLog := (Sources at: 2) setToEnd; cr; yourself.

    self fileOutPreambleOn: changeLog.
    [(chunk := stream nextChunk) isEmpty] whileFalse: [result := self compile: chunk].
    changeLog
"        nextPutAll: ' !!';"
        flush.! ! 
#('November 21, 2001' '04:19:52 PM' nil)!

(CodeFiler organizerFor: CodeFiler) reorganizeFrom: #(
('filing in' fileInFrom: )) !


!CodeFiler methods !  
fileOutOrganizationFor: methods on: stream
    "methods:   <Collection withAll: <Symbol>>
    File out a chunk capable of reorganizing methods in the class I'm for"

    | organization |
    organization := (self class organizerFor: self forClass name) organizationFor: methods.
    organization isEmpty ifTrue: [^self].
    stream
        cr; nextPutAll: '(CodeFiler organizerFor: ', self forClass name;
        nextPutAll: ') reorganizeFrom: #('.
     organization do: [:each |
        stream cr; nextPut: $(.
        each do: [:item | item printOn: stream. stream space].
        stream nextPut: $)].

    stream nextPutAll: ') !!';cr.!  ! 
#('October 26, 2002' '11:12:30 AM' nil)!

(CodeFiler organizerFor: CodeFiler) reorganizeFrom: #(
('filing out' fileOutOrganizationFor:on: )) !


!CodeFiler methods !   
codeFilerClass
    ^CodeFiler! ! 
#('March 9, 2003' '08:04:17 AM' nil)!

(CodeFiler organizerFor: CodeFiler) reorganizeFrom: #(
('querying' codeFilerClass )) !


!CodeFiler methods !
forSuperclassOfClass: classOrMeta
    "   classOrMeta   <Class | Meta>
    Set the class I am for"

    forClass := classOrMeta class!  ! 
#('March 9, 2003' '09:37:04 AM' nil)!

(CodeFiler organizerFor: CodeFiler) reorganizeFrom: #(
('accessing' forSuperclassOfClass: )) !


!CodeFiler methods !
fileOutPreambleOn: aStream
    "File out the preamble which, when filed in, will create
    a codeFiler to accept the next chunks"
true ifTrue: [^self].
     aStream
        cr; nextPutAll: '!!CodeFiler forClass: '.
    self forClass name asSymbol printOn: aStream.
    aStream nextPutAll: ' !!'! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: CodeFiler) reorganizeFrom: #(
('filing out' fileOutPreambleOn: )) !


!CodeFiler class methods !  
organizerFor: nameOfClassOrMeta
    "   nameOfClassOrMeta:  <Symbol> | <the class or meta itself>
        ^   <methodBasedOrganizer>
    Answer the method based organizer associated with the named class or meta"

    | theName |
    theName := nameOfClassOrMeta isBehavior
        ifTrue: [nameOfClassOrMeta name asSymbol]
        ifFalse: [nameOfClassOrMeta asSymbol].

    ^self classOrganizers at: theName ifAbsent: [self privateBuildOrganizerFor: theName]!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: CodeFiler class) reorganizeFrom: #(
('class organizers' organizerFor: )) !


!CodeFiler class methods !   
classOrganizers
    "Answer my dictionary of class organizers"

    ClassOrganizers isNil ifTrue: [self initializeClassOrganizers].
    ^ClassOrganizers!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: CodeFiler class) reorganizeFrom: #(
('class organizers' classOrganizers )) !


!CodeFiler class methods ! 
logRenameClass: className to: aSymbol
    "className      <Symbol>
    Log source code to remove the named class from the system on aStream"
    | changeLog |

    changeLog := Sources at: 2.
    changeLog setToEnd.
    self logRenameClass: className to: aSymbol on: changeLog.
    changeLog flush.! ! 
#('May 17, 2006' '12:03:10 PM' nil)!

(CodeFiler organizerFor: CodeFiler class) reorganizeFrom: #(
('logging' logRenameClass:to: )) !


!CodeFiler class methods !  
setCommentFor: nameOfClass to: newComment
    "nameOfClass: <symbol>
      newComment: <string>
    Set the comment for the named class.  Log this on the change log."

    | changeLog theName |

    theName := nameOfClass isBehavior
        ifTrue: [nameOfClass name asSymbol]
        ifFalse: [nameOfClass asSymbol].

    (changeLog := Sources at: 2) setToEnd.
    self classComments at: theName put: newComment.
    (self forClass: (Smalltalk at: theName)) fileOutCommentOn: changeLog.
    changeLog flush.! ! 
#('October 26, 2002' '11:27:10 AM' nil)!

(CodeFiler organizerFor: CodeFiler class) reorganizeFrom: #(
('class comments' setCommentFor:to: )) !


!CodeFiler class methods !
codeWriterMenuWith: aBlock
    "aBlock     <OneArugmentBlock value: <CodeFilerClass>>
           ^            <Menu>
    Answer a menu with all of the code filers in the system.
    When an item is chosen, the menu will evaluate aBlock with the code filer class
    that was chosen"

    | theMenu codeWritersByDescription codeWriterClass |

    theMenu := Menu new
        title: 'Code Writer';
        owner: self;
        yourself.

    "Wilf to Anthony: What could this possibly do... There were no CodeFiler subclasses!!!! Now, I have added one.."
"
    codeWritersByDescription := Dictionary new.
    CodeFiler withAllSubclasses do: [:each |
        codeWritersByDescription at: each description put: each].

    codeWritersByDescription keys asSortedCollection do: [:description |
        codeWriterClass := codeWritersByDescription at: description.
        theMenu
            appendItem: description
            action: (self privateMenuBlockForCodeWriter: codeWriterClass andBlock: aBlock)].
    "

    ^theMenu!   ! 
#('October 26, 2002' '11:19:23 AM' nil)!

(CodeFiler organizerFor: CodeFiler class) reorganizeFrom: #(
('menu building' codeWriterMenuWith: )) !


!CodeFiler class methods !   
resynchronizeClassOrganizers
    "Expensive: Resynchronize the entire system. This may take a while ..."

    | progressDialog maximum index |
    self updateClassOrganizers.
    maximum := self classOrganizers size.
    index := 0.
    progressDialog := ProgressIndicatorDialog new noCancel; open: 'Navigator Browser' message: 'So it''s all screwed up, eh?'.
    self classOrganizers keysAndValuesDo: [:owner :organizer |
        index := index + 1.
        progressDialog percent: ( index / maximum * 100 ) truncated.
        organizer makeDirty; update].
    progressDialog close.!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: CodeFiler class) reorganizeFrom: #(
('class organizers' resynchronizeClassOrganizers )) !


!CodeFiler class methods !
rekeyOrganizerFor: oldKey under: newKey
    "Remove the organizer for nameOfClassOrMeta which has its method categorizations"

    | oldOrganizer |
    oldOrganizer := self classOrganizers at: oldKey asSymbol.
    self classOrganizers removeKey: oldKey asSymbol ifAbsent: [nil].
    self classOrganizers at: newKey asSymbol put: oldOrganizer!    ! 
#('April 23, 2005' '11:25:23 AM' nil)!

(CodeFiler organizerFor: CodeFiler class) reorganizeFrom: #(
('class organizers' rekeyOrganizerFor:under: )) !


!CodeFiler class methods ! 
rekeyOrganizerFor: oldKey under: newKey
    "Remove the organizer for nameOfClassOrMeta which has its method categorizations"

    | oldOrganizer |
    oldOrganizer := self organizerFor: oldKey asSymbol.
    self classOrganizers removeKey: oldKey asSymbol ifAbsent: [nil].
    self classOrganizers at: newKey asSymbol put: oldOrganizer!  ! 
#('April 23, 2005' '11:38:36 AM' 91888)!

(CodeFiler organizerFor: CodeFiler class) reorganizeFrom: #(
('class organizers' rekeyOrganizerFor:under: )) !


!CodeFiler class methods !   
setAndInitializeOrganizerFor: aClass to: aMethodBasedOrganizer
    "set  aMethodBasedOrganizer to be the organizer for the class called nameOfClassOrMeta"

    aMethodBasedOrganizer owner: aClass; update.
    self classOrganizers at: aClass name asSymbol put: aMethodBasedOrganizer
!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: CodeFiler class) reorganizeFrom: #(
('class organizers' setAndInitializeOrganizerFor:to: )) !


!CodeFiler class methods !
setOrganizerFor: nameOfClassOrMeta to: aMethodBasedOrganizer
    "set aMethodBasedOrganizer to be the organizer for the class called nameOfClassOrMeta"

    | owner |
    owner := Smalltalk at: nameOfClassOrMeta firstWord asSymbol ifAbsent: [^self].
    (nameOfClassOrMeta indexOfString: 'class')  > 0 ifTrue: [owner := owner class].
    aMethodBasedOrganizer owner: owner.
    self classOrganizers at: nameOfClassOrMeta asSymbol put: aMethodBasedOrganizer!    ! 
#('January 17, 2002' '10:59:30 AM' nil)!

(CodeFiler organizerFor: CodeFiler class) reorganizeFrom: #(
('class organizers' setOrganizerFor:to: )) !


!CodeFiler class methods !
logRenameClass: className to: aSymbol on: aStream
    "className      <Symbol>
    Log source code to remove the named class from the system on aStream"

    aStream nextChunkPut: className, ' rename: ', aSymbol  storeString!   ! 
#('May 17, 2006' '11:49:32 AM' nil)!

(CodeFiler organizerFor: CodeFiler class) reorganizeFrom: #(
('logging' logRenameClass:to:on: )) !


!CodeFiler class methods !   
removeOrganizerFor: nameOfClassOrMeta
    "Remove the organizer for nameOfClassOrMeta which has its method categorizations"

    ^self classOrganizers removeKey: nameOfClassOrMeta asSymbol ifAbsent: [nil]!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: CodeFiler class) reorganizeFrom: #(
('class organizers' removeOrganizerFor: )) !


!CodeFiler class methods ! 
updateClassOrganizers

    | discard deletedClasses |
    deletedClasses := self classOrganizers keys select: [:className |
        discard := [(self organizerFor: className) owner isDeletedClass]
            on: MessageNotUnderstood do: [false].
        discard := discard or: [(Smalltalk includesKey: className firstWord asSymbol) not].
        discard].
    deletedClasses do: [:each |
        self removeOrganizerFor: each; removeOrganizerFor: (each, ' class') asSymbol].!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: CodeFiler class) reorganizeFrom: #(
('class organizers' updateClassOrganizers )) !


 
CodeGenerationPrivateServices class instanceVariableNames: ' libraryMap '
  categories: #( )
  comment: ''!

 

Object subclass: #CodeWriter
  instanceVariableNames: 
    ' classes forClass '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'Tools-Code Writers & Readers' )
  comment: ''!

!CodeWriter methods !   
privateFileOutMethod: method replacingSpacesWithTabsOn: stream
    "   stream  <WriteStream>
        ^       self
    Put a textual version of method to stream. Replace every occurence of 4 spaces with a tab"

    | source outSource count |
    source := ReadStream on: (self forClass sourceCodeAt: method).
    outSource := WriteStream on: (String new: source size).
    [source atEnd] whileFalse: [
        count := 0.
        [source peek = Space] whileTrue: [
            count := count + 1.
            source next].
        outSource tab: (count // 4).
        (count \\ 4) timesRepeat: [outSource space].
        outSource
            nextPutAll: source nextLine;
            cr].
    outSource skip: -2. "Eliminate last cr..."

    stream
        cr;
        nextChunkPut: outSource contents!  ! 
#('March 9, 2003' '08:57:50 AM' nil)!

(CodeFiler organizerFor: CodeWriter) reorganizeFrom: #(
('private' privateFileOutMethod:replacingSpacesWithTabsOn: )) !


!CodeWriter methods !  
fileOutOn: stream
    "   stream  <WriteStream>
        ^       self
    Put a textual version of my class to stream."

    CursorManager execute changeFor: [
        self fileOutDefinitionsOn: stream.
        self classes do: [:aClass |
            self
                forSuperclassOfClass: aClass;
                fileOutPrologueOn: stream;
                fileOutProtocolsOn: stream;
                fileOutEpilogueOn: stream;

                forClass: aClass;
                fileOutPrologueOn: stream;
                fileOutProtocolsOn: stream;
                fileOutEpilogueOn: stream;

                fileOutCommentOn: stream]]! ! 
#('March 9, 2003' '09:38:17 AM' nil)!

(CodeFiler organizerFor: CodeWriter) reorganizeFrom: #(
('filing out' fileOutOn: )) !


!CodeWriter methods !
codeFilerClass
    ^CodeFiler! ! 
#('March 9, 2003' '08:06:29 AM' nil)!

(CodeFiler organizerFor: CodeWriter) reorganizeFrom: #(
('querying' codeFilerClass )) !


!CodeWriter methods !  
forSuperclassOfClass: classOrMeta
    "   classOrMeta   <Class | Meta>
    Set the class I am for"

    forClass := classOrMeta class!  ! 
#('March 9, 2003' '09:36:50 AM' nil)!

(CodeFiler organizerFor: CodeWriter) reorganizeFrom: #(
('accessing' forSuperclassOfClass: )) !


!CodeWriter methods !  
methodOrganizer
    "^ <MethodBasedOrganizer>
    Answer the method organizer for my smalltalkClass"

    ^(self codeFilerClass organizerFor: self forClass name)!  ! 
#('March 9, 2003' '08:34:30 AM' nil)!

(CodeFiler organizerFor: CodeWriter) reorganizeFrom: #(
('accessing' methodOrganizer )) !


!CodeWriter class methods !  
codeWriterMenuWith: aBlock
    "aBlock     <OneArugmentBlock value: <CodeWriterClass>>
           ^            <Menu>
    Answer a menu with all of the code filers in the system.
    When an item is chosen, the menu will evaluate aBlock with the code filer class
    that was chosen"

    | theMenu validCodeWriters codeWritersByDescription codeWriterClass |

    theMenu := Menu new
        title: 'Code Writer';
        owner: self;
        yourself.

    validCodeWriters := CodeWriter allSubclasses select: [:each |
        (each class methodDictionary includesKey: #description) and: [each codeWriterType == self codeWriterType]].

    codeWritersByDescription := Dictionary new.
    validCodeWriters do: [:each |
        codeWritersByDescription at: each description put: each].

    codeWritersByDescription keys asSortedCollection do: [:description |
        codeWriterClass := codeWritersByDescription at: description.
        theMenu
            appendItem: description
            action: (self privateMenuBlockForCodeWriter: codeWriterClass andBlock: aBlock)].

    ^theMenu!  ! 
#('March 8, 2003' '09:51:43 PM' nil)!

(CodeFiler organizerFor: CodeWriter class) reorganizeFrom: #(
('menu building' codeWriterMenuWith: )) !


!CodeWriter class methods !
codeWriterType
    ^#CodeWriter!   ! 
#('March 8, 2003' '09:36:08 PM' nil)!

(CodeFiler organizerFor: CodeWriter class) reorganizeFrom: #(
('menu building' codeWriterType )) !




CodeWriter subclass: #CodeFilerClassWriter
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Code Writers & Readers' )
  comment: ''!

!CodeFilerClassWriter methods ! 
fileOutMethodsEpilogueFor: methods on: aStream
    "File out any code which succeeds filing out methods"

    aStream nextPutAll: ' !!';cr.
    self fileOutOrganizationFor: methods on: aStream!   ! 
#('February 15, 2002' '11:42:36 AM' nil)!

(CodeFiler organizerFor: CodeFilerClassWriter) reorganizeFrom: #(
('filing out support' fileOutMethodsEpilogueFor:on: )) !


!CodeFilerClassWriter methods ! 
fileOutOrganizationFor: methods on: stream
    "methods:   <Collection withAll: <Symbol>>
    File out a chunk capable of reorganizing methods in the class I'm for"

    stream
        cr; nextPutAll: '(CodeFiler organizerFor: ', self forClass name;
        nextPutAll: ') reorganizeFrom: #('.
    ((CodeFiler organizerFor: self forClass name) organizationFor: methods) do: [:each |
        stream cr; nextPut: $(.
        each do: [:item |
            item printOn: stream.
            stream space].
        stream nextPut: $) ].

    stream nextPutAll: ') !!';cr!    ! 
#('November 21, 2001' '04:18:32 PM' nil)!

(CodeFiler organizerFor: CodeFilerClassWriter) reorganizeFrom: #(
('filing out support' fileOutOrganizationFor:on: )) !


   

CodeFilerClassWriter subclass: #CodeFilerOrganizationWriter
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'Tools-Code Writers & Readers' )
  comment: ''!

 

Object subclass: #Collection
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Collections' )
  comment: ''!

!Collection methods ! 
identitySubtraction: aCollection
    | result |
    result := OrderedCollection new.
    result addAllIfIdenticalAbsent: self.
    result removeAllIdentical: aCollection.
    ^result!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' identitySubtraction: )) !


!Collection methods !
groupsDo: aBlock
    "
    #((1) (10) (100)) groupsDo: [:a |
        Transcript cr; show: a printString].
    #((1 2) (10 20) (100 200)) groupsDo: [:a :b |
        Transcript cr; show: a printString, ' ', b printString].
    #((1 2 3) (10 20 30) (100 200 300)) groupsDo: [:a :b :c |
        Transcript cr; show: a printString, ' ', b printString, ' ', c printString].
    #((1 2 3 4) (10 20 30 40) (100 200 300 400)) groupsDo: [:a :b :c :d |
        Transcript cr; show: a printString, ' ', b printString, ' ', c printString, ' ', d printString].
    "
    self do: [:collection | aBlock evaluateWithArguments: collection]!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' groupsDo: )) !


!Collection methods !   
unflattenedCollect: aBlock

    | result |
    result := self species new: self size.
    self do: [:element |
        result add: (
            (element isCollection and: [element isString not])
                ifTrue: [element unflattenedCollect: aBlock]
                ifFalse: [aBlock value: element])].
    ^result!  ! 
#('May 18, 2006' '04:33:49 PM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' unflattenedCollect: )) !


!Collection methods !
unflattenedCollect: aBlock

    | result |
    result := Array new: self size.
    self indexedDo: [:index :element |
        result at: index put: (
            (element isCollection and: [element isString not])
                ifTrue: [element unflattenedCollect: aBlock]
                ifFalse: [aBlock value: element])].
    ^result! ! 
#('May 18, 2006' '04:40:11 PM' 103132)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' unflattenedCollect: )) !


!Collection methods ! 
indexedDo: aBlock
    | index |
    index := 0.
    self do: [:object | aBlock value: (index := index + 1) value: object]!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' indexedDo: )) !


!Collection methods !  
identityIntersection: aCollection
    | intersection |
    intersection := OrderedCollection new.
    aCollection do: [:element |
        (self includesIdentical: element)
            ifTrue: [intersection add: element]].
    ^intersection!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' identityIntersection: )) !


!Collection methods !   
allButFirstDo: aBlock
    self isEmpty ifTrue: [^self].
    (self copyFrom: 2 to: self size) do: aBlock!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' allButFirstDo: )) !


!Collection methods !  
identityUnion: aCollection
    | union |
    union := OrderedCollection new.
    union addAllIfIdenticalAbsent: self.
    union addAllIfIdenticalAbsent: aCollection.
    ^union!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' identityUnion: )) !


!Collection methods !  
without: anObject
    ^self reject: [:object | object = anObject]! ! 
#('October 1, 2001' '05:00:27 PM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' without: )) !


!Collection methods !
indexOfIdentical: anObject
    "Answer true if the receiver contains an element
    identical to anObject, else answer false."
    self indexedDo: [:index :element | element == anObject ifTrue: [^index]].
    ^0
!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' indexOfIdentical: )) !


!Collection methods !   
none: aBlock

    ^(self any: aBlock) not!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' none: )) !


!Collection methods !   
allIdentical: aBlock
    "Answer true if all of the receiver's elements answer the identical thing when evaluating aBlock"

    | answer |
    answer := aBlock value: self any.
    self do: [:element | (aBlock value: element) ~~ answer ifTrue: [^false]].
    ^true! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' allIdentical: )) !


!Collection methods !   
printOn: aStream
        "Append the ASCII representation
         of the receiver to aStream."
    | limit |

    aStream isStream ifFalse: [^aStream nextPutAll: self printString].

    (RecursiveSet includes: self)
        ifTrue: [^self printRecursionOn: aStream].
    RecursiveSet add: self.
    limit := aStream position + self printLimit.
    self class printOn: aStream.
    aStream nextPut: $(.
    self do: [ :element |
        (aStream position > limit)
            ifTrue: [
                '...etc...)' printOn: aStream.
                RecursiveSet remove: self ifAbsent: [].
                ^self].
        element printOn: aStream.
        aStream space].
    aStream nextPut: $).
    RecursiveSet remove: self ifAbsent: []!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' printOn: )) !


!Collection methods !
printOn: aStream
        "Append the ASCII representation
         of the receiver to aStream."
    | limit firstTime |

    aStream isStream ifFalse: [^aStream nextPutAll: self printString].

    (RecursiveSet includes: self)
        ifTrue: [^self printRecursionOn: aStream].
    RecursiveSet add: self.
    limit := aStream position + self printLimit.
    self class printOn: aStream.
    aStream nextPutAll: ' ('.
    firstTime := true.
    self do: [:element |
        firstTime ifTrue: [firstTime := false] ifFalse: [aStream space].
        (aStream position > limit)
            ifTrue: [
                '...etc...)' printOn: aStream.
                RecursiveSet remove: self ifAbsent: [].
                ^self].
        element printOn: aStream].
    aStream nextPut: $).
    RecursiveSet remove: self ifAbsent: []!   ! 
#('September 15, 2006' '11:12:18 AM' 106764)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' printOn: )) !


!Collection methods !  
any
    "Answer any item in the receiver"

    self do: [:anObject | ^anObject]. ^nil!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' any )) !


!Collection methods ! 
startingAt: index do: aBlock
    self size < index ifTrue: [^self].
    (self copyFrom: index to: self size) do: aBlock!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' startingAt:do: )) !


!Collection methods !  
inclusiveIdentityClosure: aBlock!   ! 
#('February 9, 2010' '04:49:23 PM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('not yet done' inclusiveIdentityClosure: )) !


!Collection methods !
withoutNils
    ^self reject: [:object | object isNil]!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' withoutNils )) !


!Collection methods ! 
choose: aBlock
    ^self detect: aBlock ifNone: [nil]! ! 
#('May 18, 2006' '08:42:35 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' choose: )) !


!Collection methods !
shallowFlattened
    "Only flatten one level deep.
    Example:
    #((1 2 3)((4  5) 6) 7 8) asOrderedCollection shallowFlattened
    "

    | resultCollection |

    resultCollection := self species new: self size.
    self do: [:element |
        element isCollection
            ifTrue: [resultCollection addAll: element]
            ifFalse: [resultCollection add: element]].
    ^resultCollection! ! 
#('May 2, 2003' '08:45:30 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' shallowFlattened )) !


!Collection methods !
shallowFlattened
    "Only flatten one level deep.
    Example #((1 2 3)((4  5) 6) 7 8) asOrderedCollection shallowFlattened
    "

    | resultCollection |

    resultCollection := OrderedCollection new: self size.
    self do: [:element |
        element isCollection
            ifTrue: [resultCollection addAll: element]
            ifFalse: [resultCollection add: element]].
    ^resultCollection!  ! 
#('May 15, 2003' '10:25:22 PM' 109900)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' shallowFlattened )) !


!Collection methods !
shallowFlattened
    "Only flatten one level deep.
    Example #((1 2 3)((4  5) 6) 7 8) asOrderedCollection shallowFlattened
    "

    | resultCollection |

    resultCollection := OrderedCollection new: self size.
    self do: [:element |
        element isCollection
            ifTrue: [resultCollection addAll: element]
            ifFalse: [resultCollection add: element]].
    ^resultCollection!  ! 
#('May 15, 2003' '10:28:45 PM' 110480)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' shallowFlattened )) !


!Collection methods !
average: aBlock

    | average |
    average := aBlock value: self any.
    self indexedDo: [:index :anObject |  index > 1 ifTrue: [average :=  average + (aBlock value: anObject)]].
    ^average / self size!    ! 
#('June 15, 2001' '03:46:37 PM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' average: )) !


!Collection methods !  
separate: aBlock into: collection1 when: result1 into: collection2 when: result2
    "example usage:
        #(1 2 3 4 5 6 7 8 9 10) separate: [:each | each odd]"

    | results |
    results := self separate: aBlock.
    collection1 addAll: (results at: result1 ifAbsent: [#()]).
    collection2 addAll: (results at: result2 ifAbsent: [#()]).
    ^results!   ! 
#('January 17, 2002' '10:57:00 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' separate:into:when:into:when: )) !


!Collection methods !  
with: aCollection indexedDo: aBlock
    | index |
    index := 0.
    self with: aCollection do: [:object1 :object2 | aBlock value: (index := index + 1) value: object1 value: object2]! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' with:indexedDo: )) !


!Collection methods ! 
groupDo: aBlock
    "
    #(1) groupDo: [:a |
        Transcript cr; show: a printString].
    #(1 2) groupDo: [:a :b |
        Transcript cr; show: a printString, ' ', b printString].
    #(1 2 3) groupDo: [:a :b :c |
        Transcript cr; show: a printString, ' ', b printString, ' ', c printString].
    #(1 2 3 4) groupDo: [:a :b :c :d |
        Transcript cr; show: a printString, ' ', b printString, ' ', c printString, ' ', d printString].
    "
    aBlock evaluateWithArguments: self asArray
!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' groupDo: )) !


!Collection methods !
sumFrom: startingValue
    "example: (Array with: 1@1@1) sumFrom: (0@0@0) => [1, 1, 1]"

    ^self from: startingValue sum: [:each | each]!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' sumFrom: )) !


!Collection methods !
maximum: aBlock

    | maximum |
    maximum := aBlock value: self any.
    self do: [:anObject | maximum := maximum max: (aBlock value: anObject)].
    ^maximum! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' maximum: )) !


!Collection methods !
nonNilDo: aBlock
    self do: [:object | object notNil ifTrue: [aBlock value: object]]!    ! 
#('September 21, 2005' '01:25:30 PM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' nonNilDo: )) !


!Collection methods !
smallest: aBlock

    | minimum current element |
    element := self any.
    minimum := aBlock value: element.
    self do: [:anObject |
        current := aBlock value: anObject.
        current < minimum ifTrue: [minimum := current. element := anObject]].
    ^element!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' smallest: )) !


!Collection methods !   
exclusiveEqualityClosure: aBlock!   ! 
#('February 9, 2010' '04:49:47 PM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('not yet done' exclusiveEqualityClosure: )) !


!Collection methods !
removeAll: aCollection ifAbsent: aBlock
        "Answer aCollection.  Remove all the elements
         contained in aCollection from the receiver collection."
    aCollection do: [:element | self remove: element  ifAbsent: aBlock].
    ^aCollection!   ! 
#('October 13, 2006' '12:11:31 PM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' removeAll:ifAbsent: )) !


!Collection methods !
count: aBlock
    "Answer the number of elements in the receiver for which aBlock answers true."

    ^self inject: 0 into: [:count :element | (aBlock value: element) ifTrue: [count + 1] ifFalse: [count]]!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' count: )) !


!Collection methods !  
indexedSelect: aBlock
    | index |
    index := 0.
    ^self select: [:object | aBlock value: (index := index + 1) value: object]!  ! 
#('July 18, 2012' '09:30:30 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' indexedSelect: )) !


!Collection methods !
with: aCollection collect: aBlock
    | answer |
    answer := OrderedCollection new.
    self with: aCollection do: [:object1 :object2 |
        answer add: (aBlock value: object1 value: object2)].
    ^answer!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' with:collect: )) !


!Collection methods !   
withNextDo: aBlock
    | object |
    self do: [:nextObject |
        object notNil ifTrue: [aBlock value: object value: nextObject].
        object := nextObject].
    object notNil ifTrue: [aBlock value: object value: nil].! ! 
#('July 17, 2002' '10:24:58 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' withNextDo: )) !


!Collection methods !   
asSymbols
    ^self collect: [:string | string asSymbol]!  ! 
#('April 23, 2005' '12:51:54 PM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' asSymbols )) !


!Collection methods !
withoutIdentical: anObject
    ^self reject: [:object | object == anObject]!   ! 
#('October 1, 2001' '05:00:27 PM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' withoutIdentical: )) !


!Collection methods !   
groupCollect: aBlock
    "
    #(1) groupCollect: [:a |
       a printString].
    #(1 2) groupCollect: [:a :b |
        a printString, ' ', b printString].
    #(1 2 3) groupCollect: [:a :b :c |
        a printString, ' ', b printString, ' ', c printString].
    #(1 2 3 4) groupCollect: [:a :b :c :d |
        a printString, ' ', b printString, ' ', c printString, ' ', d printString].
    "
    ^aBlock evaluateWithArguments: self asArray!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' groupCollect: )) !


!Collection methods !   
average

    ^self average: [:number | number]!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' average )) !


!Collection methods ! 
maximum

    ^self maximum: [:number | number]!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' maximum )) !


!Collection methods ! 
asLowercase
    ^self collect: [:string | string asLowercase]! ! 
#('January 26, 2007' '09:22:19 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' asLowercase )) !


!Collection methods !
asUppercase
    ^self collect: [:string | string asUppercase]! ! 
#('January 26, 2007' '09:22:38 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' asUppercase )) !


!Collection methods !
includesAll: aCollection
    "Answer true if the receiver contains all elements in aCollection"

    aCollection detect: [:element | (self includes: element) not] ifNone: [^true].
    ^false! ! 
#('November 28, 2002' '10:09:03 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' includesAll: )) !


!Collection methods !  
withoutDuplicates
    "This is stupid!!!!  I don't know why 'asSet' isn't working, but I need a collection with no duplicate entries,
    so here goes."
    
    | result |
    result := OrderedCollection new.
    self do: [:object | (result includes: object) ifFalse: [result add: object]].
    ^result! ! 
#('July 10, 2003' '03:05:46 PM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' withoutDuplicates )) !


!Collection methods ! 
withoutDuplicates
    | result |
    result := OrderedCollection new.
    self do: [:object | (result includes: object) ifFalse: [result add: object]].
    ^result!    ! 
#('February 28, 2005' '01:19:52 PM' 119384)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' withoutDuplicates )) !


!Collection methods !  
with: aCollection indexedCollect: aBlock
    | answer index |
    answer := OrderedCollection new.
    self with: aCollection do: [:object1 :object2 |
        answer add: (aBlock value: (index := index + 1) value: object1 value: object2)].
    ^answer!   ! 
#('October 11, 2008' '05:48:31 PM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' with:indexedCollect: )) !


!Collection methods !   
with: aCollection indexedCollect: aBlock
    | answer index |
    answer := OrderedCollection new. index := 0.
    self with: aCollection do: [:object1 :object2 |
        answer add: (aBlock value: (index := index + 1) value: object1 value: object2)].
    ^answer!   ! 
#('October 11, 2008' '05:55:46 PM' 120212)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' with:indexedCollect: )) !


!Collection methods !
choose: aBlock ifNone: exceptionBlock
    ^self detect: aBlock ifNone: exceptionBlock! ! 
#('May 18, 2006' '08:42:05 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' choose:ifNone: )) !


!Collection methods ! 
withoutAllIdentical: aCollection
    ^self reject: [:object | aCollection includesIdentical: object]!  ! 
#('July 30, 2008' '09:01:57 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' withoutAllIdentical: )) !


!Collection methods !  
asIdentitySortedCollection
    ^IdentitySortedCollection withAll: self!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('no category methods' asIdentitySortedCollection )) !


!Collection methods ! 
inclusiveEqualityClosure: aBlock!   ! 
#('February 9, 2010' '04:49:37 PM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('not yet done' inclusiveEqualityClosure: )) !


!Collection methods !
largest: ratingBlock suchThat: requirementBlock
    "Returns the object with the largest rating that also satisfies the requirement."
    
    | rating bestRating bestObject |
    self do: [:anObject |
        (requirementBlock value: anObject) ifTrue: [
            rating := ratingBlock value: anObject.
            (bestRating isNil or: [rating > bestRating]) ifTrue: [bestRating := rating. bestObject := anObject]]].
    ^bestObject!   ! 
#('April 15, 2005' '11:47:20 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' largest:suchThat: )) !


!Collection methods !
largest: aBlock

    | maximum current element |
    element := self any.
    maximum := aBlock value: element.
    self do: [:anObject |
        current := aBlock value: anObject.
        current > maximum ifTrue: [maximum := current. element := anObject]].
    ^element!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' largest: )) !


!Collection methods !
groupsCollect: aBlock
    "
    #((1) (10) (100)) groupsCollect: [:a |
       a printString].
    #((1 2) (10 20) (100 200)) groupsCollect: [:a :b |
        a printString, ' ', b printString].
    #((1 2 3) (10 20 30) (100 200 300)) groupsCollect: [:a :b :c |
        a printString, ' ', b printString, ' ', c printString].
    #((1 2 3 4) (10 20 30 40) (100 200 300 400)) groupsCollect: [:a :b :c :d |
        a printString, ' ', b printString, ' ', c printString, ' ', d printString].
    "
    ^self collect: [:collection | aBlock evaluateWithArguments: collection]!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' groupsCollect: )) !


!Collection methods !  
suffix: size
    size >= self size ifTrue: [^self].
    ^self copyFrom: self size - size + 1 to: self size!   ! 
#('September 19, 2001' '12:28:54 PM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' suffix: )) !


!Collection methods !  
OBSOLETEdoesNotUnderstand: aMessage
    "Hideous debugging hack."


    | selector |
    self isEmpty ifTrue: [^super doesNotUnderstand: aMessage].
    selector := aMessage selector.
    (self any respondsTo: selector) ifTrue: [^self collect: [:element | element perform: aMessage selector withArguments: aMessage arguments]].
    ^super doesNotUnderstand: aMessage!  ! 
#('July 11, 2009' '09:23:42 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' OBSOLETEdoesNotUnderstand: )) !


!Collection methods !
partitionsUsing: aBlock
    | partitions partitionKey |
    partitions := Dictionary new.
    self do: [:object |
        partitionKey := aBlock value: object.
        (partitions
            at: partitionKey
            ifAbsent: [partitions at: partitionKey put: OrderedCollection new])
                add: object].
    ^partitions!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' partitionsUsing: )) !


!Collection methods !
allButLast
    ^self copyFrom: 1 to: self size - 1!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' allButLast )) !


!Collection methods !  
asMesh

    | frames objects faces |
    frames := self select: [:each | each isFrame].
    objects := self select: [:each | each isObject3D].
    faces := self select: [:each | each isFace].
    ^(Frame3D new addAll: frames; addAll: objects; add: (Object3D new faces: faces)) asMesh!  ! 
#('September 28, 2001' '11:16:12 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' asMesh )) !


!Collection methods !   
collect: aBlock when: aBooleanBlock
    | answer |
    answer := OrderedCollection new.
    self do: [:object | (aBooleanBlock value) ifTrue: [answer add: (aBlock value: object)]].
    ^answer!   ! 
#('July 18, 2012' '08:54:56 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' collect:when: )) !


!Collection methods ! 
collect: aBlock when: aBooleanBlock
    | answer |
    answer := OrderedCollection new.
    self do: [:object | (aBooleanBlock value: object) ifTrue: [answer add: (aBlock value: object)]].
    ^answer!   ! 
#('July 18, 2012' '09:17:03 AM' 125936)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' collect:when: )) !


!Collection methods !  
exists: aBlock
        "Answer whether or not the receiver contains an element
        that causes aBlock to evaluate to true (with that
        element as the argument)."
    self    detect: aBlock ifNone: [^false].
    ^true!    ! 
#('November 28, 2002' '10:03:29 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' exists: )) !


!Collection methods !   
sum: aBlock
    "example: #(2 3 4) sum: [:number | number * 2] --> 18"

    ^self inject: 0 into: [:sum :each | sum + (aBlock value: each)].!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' sum: )) !


!Collection methods !
separate: aBlock
    "example usage:
        #(1 2 3 4 5 6 7 8 9 10) separate: [:each | each odd]"

    | results |
    results := Dictionary new.
    self do: [:each |
        (results at: (aBlock value: each) ifAbsentPut: [OrderedCollection new]) add: each].
    ^results!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' separate: )) !


!Collection methods !   
separate: aBlock
    "example usage:
        #(1 2 3 4 5 6 7 8 9 10) separate: [:each | each odd]
        #(Hi there You guys and gals) separate: [:each | each first]
    "

    | results |
    results := Dictionary new.
    self do: [:each |
        (results at: (aBlock value: each) ifAbsentPut: [OrderedCollection new]) add: each].
    ^results!  ! 
#('November 4, 2010' '10:31:07 AM' 127380)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' separate: )) !


!Collection methods !   
circularWithNextDo: aBlock
    | first last |
    self do: [:object |
        last isNil ifTrue: [first := object] ifFalse: [aBlock value: last value: object].
        last := object].
    last notNil ifTrue: [aBlock value: last value: first].!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' circularWithNextDo: )) !


!Collection methods ! 
allSame: aBlock
    "Answer true if all of the receiver's elements answer the same thing when evaluating aBlock"

    | answer |
    answer := aBlock value: self any.
    self do: [:element | (aBlock value: element) ~= answer ifTrue: [^false]].
    ^true!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' allSame: )) !


!Collection methods !
includesAllIdentical: aCollection
    aCollection do: [:anObject |
        (self includesIdentical: anObject) ifFalse: [^false]].
    ^true! ! 
#('April 15, 2005' '12:30:42 PM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' includesAllIdentical: )) !


!Collection methods !
from: startingValue sum: aBlock
    "example: #(2 3 4) sum: [:number | number * 2] --> 18"

    ^self inject: startingValue into: [:sum :each | sum + (aBlock value: each)].!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' from:sum: )) !


!Collection methods !   
minimum: aBlock

    | minimum |
    minimum := aBlock value: self any.
    self do: [:anObject | minimum := minimum min: (aBlock value: anObject)].
    ^minimum! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' minimum: )) !


!Collection methods !
do: aBlock andBetweenDo: separatorBlock
        "For each element in the receiver, evaluate <aBlock>
         with that element as the argument.  Evaluate the <separatorBlock>
         between successive elements of the receiver."
    | first |
    first := true.
    self do: [ :each |
        first
            ifTrue: [ first := false ]
            ifFalse: [ separatorBlock value ].
        aBlock value: each ]!  ! 
#('August 1, 2008' '09:56:24 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('no category methods' do:andBetweenDo: )) !


!Collection methods !
do: aBlock andBetweenDo: separatorBlock
    "USAGE EXAMPLE: aCollection do: [:object | Transcript print: object] andBetweenDo: [Transcript space]."
    
    "For each element in the receiver, evaluate <aBlock> with that element as the argument.  Also, evaluate the <separatorBlock>
    (without a parameter) between successive elements of the receiver."
    
    | firstTime |
    firstTime := true.
    self do: [:object |
        firstTime ifTrue: [firstTime := false] ifFalse: [separatorBlock value].
        aBlock value: object]!    ! 
#('August 1, 2008' '09:56:33 AM' 130192)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('no category methods' do:andBetweenDo: )) !


!Collection methods ! 
separate
    "Separate the receiver into equal elements."

    ^self separate: [:object | object]!   ! 
#('November 19, 2001' '10:05:48 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' separate )) !


!Collection methods !  
exclusiveIdentityClosure: aBlock!   ! 
#('February 9, 2010' '04:49:55 PM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('not yet done' exclusiveIdentityClosure: )) !


!Collection methods !
all: aBlock
    "Answer true if  each element in the receiver answers true to aBlock; otherwise false."

    self do: [:anObject | (aBlock value: anObject) ifFalse: [^false]].
    ^true!  ! 
#('January 8, 2010' '08:42:15 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' all: )) !


!Collection methods !
asIdentitySet
    "Returns a set without identical objects."
    ^(IdentitySet new: self size * 2)
        addAll: self;
        yourself!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' asIdentitySet )) !


!Collection methods !   
sum
    "example: #(2 3 4) sum --> 9"

    ^self from: 0 sum: [:each | each]!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' sum )) !


!Collection methods ! 
allButFirst
    ^self copyFrom: 2 to: self size!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' allButFirst )) !


!Collection methods ! 
reverseGroupsDo: aBlock
    "
    #((1) (10) (100)) reverseGroupsDo: [:a |
        Transcript cr; show: a printString].
    #((1 2) (10 20) (100 200)) reverseGroupsDo: [:a :b |
        Transcript cr; show: a printString, ' ', b printString].
    #((1 2 3) (10 20 30) (100 200 300)) reverseGroupsDo: [:a :b :c |
        Transcript cr; show: a printString, ' ', b printString, ' ', c printString].
    #((1 2 3 4) (10 20 30 40) (100 200 300 400)) reverseGroupsDo: [:a :b :c :d |
        Transcript cr; show: a printString, ' ', b printString, ' ', c printString, ' ', d printString].
    "
    self reverseDo: [:collection | aBlock evaluateWithArguments: collection]!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' reverseGroupsDo: )) !


!Collection methods !
withNextWithoutNilsDo: aBlock
    | object |
    self do: [:nextObject |
        object notNil ifTrue: [aBlock value: object value: nextObject].
        object := nextObject].!    ! 
#('September 16, 2009' '01:32:22 PM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' withNextWithoutNilsDo: )) !


!Collection methods !   
flattened

    | resultCollection |
    resultCollection := self species new: self size.
    self do: [:element |
        element isCollection
            ifTrue: [resultCollection addAll: element flattened]
            ifFalse: [resultCollection add: element]].
    ^resultCollection!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' flattened )) !


!Collection methods !   
flattened

    | resultCollection |
    resultCollection := self species new: self size.
    self do: [:element |
        (element isCollection and: [element isString not])
            ifTrue: [resultCollection addAll: element flattened]
            ifFalse: [resultCollection add: element]].
    ^resultCollection! ! 
#('November 1, 2007' '09:42:07 AM' 134336)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' flattened )) !


!Collection methods !   
flattened

    | resultCollection |
    resultCollection := self species new: self size.
    self do: [:element |
        (element isCollection and: [element isString not])
            ifTrue: [resultCollection addAll: element flattened]
            ifFalse: [resultCollection add: element]].
    ^resultCollection! ! 
#('November 30, 2007' '04:53:42 PM' 134796)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' flattened )) !


!Collection methods !  
prefix: size
    size >= self size ifTrue: [^self].
    ^self copyFrom: 1 to: size!   ! 
#('September 19, 2001' '12:28:54 PM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' prefix: )) !


!Collection methods !  
includesIdentical: anObject
    "Answer true if the receiver contains an element
    identical to anObject, else answer false."
    self do: [:element | element == anObject ifTrue: [^true]].
    ^false!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' includesIdentical: )) !


!Collection methods !  
allButLastDo: aBlock
    self isEmpty ifTrue: [^self].
    (self copyFrom: 1 to: self size - 1) do: aBlock!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' allButLastDo: )) !


!Collection methods !   
allButLastDo: aBlock
    self isEmpty ifTrue: [^self].
    "(self copyFrom: 1 to: self size - 1) do: aBlock"
    1 to: self size - 1 do: [:index | aBlock value: (self at: index)]!  ! 
#('October 16, 2013' '12:51:10 PM' 136412)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' allButLastDo: )) !


!Collection methods !   
withoutIdenticals
    | result |
    result := OrderedCollection new.
    self do: [:object | (result includesIdentical: object) ifFalse: [result add: object]].
    ^result!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' withoutIdenticals )) !


!Collection methods !   
withWrappingNextAndPreviousDo: aBlock
    | previous next |
    1 to: self size do: [:index |
        previous := index > 1 ifTrue: [self at: index - 1] ifFalse: [self at: self size].
        next := index < self size ifTrue: [self at: index + 1] ifFalse: [self at: 1].
        aBlock value: previous value: (self at: index) value: next].!    ! 
#('April 27, 2005' '06:42:59 PM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' withWrappingNextAndPreviousDo: )) !


!Collection methods !   
includesAnyOf: aCollection
    "Answer true if the receiver contains any element in aCollection"

    aCollection detect: [:first | self includes: first] ifNone: [^false].
    ^true!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' includesAnyOf: )) !


!Collection methods !  
indexedGroupsDo: aBlock
    self indexedDo: [:index :collection | aBlock evaluateWithArguments: (Array with: index), collection]!  ! 
#('July 28, 2009' '05:37:57 PM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' indexedGroupsDo: )) !


!Collection methods !  
minimum

    ^self minimum: [:number | number]!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' minimum )) !


!Collection methods ! 
any: aBlock
    "Answer whether any element in the receiver answers true to aBlock"

    self do: [:anObject | (aBlock value: anObject) ifTrue: [^true]].
    ^false!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' any: )) !


!Collection methods !
indexedCollect: aBlock
    | index |
    index := 0.
    ^self collect: [:object | aBlock value: (index := index + 1) value: object]!    ! 
#('June 9, 2006' '01:29:23 PM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' indexedCollect: )) !


!Collection methods !
identitySeparate: aBlock
    "example usage:
        #(1 2 3 4 5 6 7 8 9 10) identitySeparate: [:each | each odd]"

    | results |
    results := IdentityDictionary new.
    self do: [:each |
        (results at: (aBlock value: each) ifAbsentPut: [OrderedCollection new]) add: each].
    ^results!  ! 
#('February 4, 2003' '03:13:28 PM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' identitySeparate: )) !


!Collection methods !  
reverseIndexedDo: aBlock
    | index |
    index := self size.
    self reverseDo: [:object | aBlock value: index value: object. index := index - 1].!   ! 
#('May 15, 2003' '10:32:07 PM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' reverseIndexedDo: )) !


!Collection methods !  
withCircularPreviousAndNextDo: aBlock
    | previous next |
    1 to: self size do: [:index |
        previous := index > 1 ifTrue: [self at: index - 1] ifFalse: [self at: self size].
        next := index < self size ifTrue: [self at: index + 1] ifFalse: [self first].
        aBlock value: previous value: (self at: index) value: next].!    ! 
#('November 30, 2006' '01:17:30 PM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' withCircularPreviousAndNextDo: )) !


!Collection methods !
indexedReject: aBlock
    | index |
    index := 0.
    ^self reject: [:object | aBlock value: (index := index + 1) value: object]!  ! 
#('July 18, 2012' '09:41:30 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' indexedReject: )) !


!Collection methods !
copyWithoutEquals
    | copy |
    copy := OrderedCollection new.
    self do: [:object | copy addIfAbsent: object].
    ^copy! ! 
#('October 7, 2009' '08:43:44 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' copyWithoutEquals )) !


!Collection methods !   
withPreviousAndNextDo: aBlock
    | previous next |
    1 to: self size do: [:index |
        previous := index > 1 ifTrue: [self at: index - 1] ifFalse: [nil].
        next := index < self size ifTrue: [self at: index + 1] ifFalse: [nil].
        aBlock value: previous value: (self at: index) value: next].!  ! 
#('November 30, 2006' '01:17:30 PM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' withPreviousAndNextDo: )) !


!Collection methods !
copyWithoutIdenticals
    | copy |
    copy := OrderedCollection new.
    self do: [:object | copy addIfIdenticalAbsent: object].
    ^copy!    ! 
#('October 7, 2009' '08:44:24 AM' nil)!

(CodeFiler organizerFor: Collection) reorganizeFrom: #(
('extensions' copyWithoutIdenticals )) !


!Collection class methods ! 
withNonNil: anObject
    "Answer a collection with anObject if it's not nil; otherwise, an empty collection."
    ^anObject isNil ifTrue: [self new] ifFalse: [self with: anObject]!  ! 
#('August 10, 2005' '10:42:37 AM' nil)!

(CodeFiler organizerFor: Collection class) reorganizeFrom: #(
('no category methods' withNonNil: )) !


!Collection class methods !
with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject

    ^self new add: firstObject; add: secondObject; add: thirdObject; add: fourthObject; add: fifthObject; yourself!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Collection class) reorganizeFrom: #(
('no category methods' with:with:with:with:with: )) !


 

Collection variableSubclass: #Array2D
  instanceVariableNames: 
    ' origin extent '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Collections' )
  comment: ''!

!Array2D methods !  
species

    ^Array!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D) reorganizeFrom: #(
('querying' species )) !


!Array2D methods ! 
do: aBlock

    | index size |
    index := 1. size := self size.
    [index > size] whileFalse: [aBlock value: (super at: index). index := index + 1]! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D) reorganizeFrom: #(
('enumerating' do: )) !


!Array2D methods !  
hash

    ^origin hash bitXor: extent hash!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D) reorganizeFrom: #(
('comparing' hash )) !


!Array2D methods !   
inBounds: aPoint

    ^self rectangle containsPoint: aPoint!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D) reorganizeFrom: #(
('querying' inBounds: )) !


!Array2D methods !   
clipped: aPoint

    | inBoundsPoint |
    inBoundsPoint := (aPoint max: origin) min: origin + extent - 1.
    ^inBoundsPoint!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D) reorganizeFrom: #(
('contents accessing' clipped: )) !


!Array2D methods !  
initializeOrigin: originPoint extent: extentPoint

    origin := originPoint. extent := extentPoint.! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D) reorganizeFrom: #(
('initializing' initializeOrigin:extent: )) !


!Array2D methods !
= anArray2D

    self class == anArray2D class ifFalse: [^false].
    self origin = anArray2D origin ifFalse: [^false].
    self extent = anArray2D extent ifFalse: [^false].
    self indexedDo: [:index :object | object = (anArray2D at: index) ifFalse: [^false]].
    ^true! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D) reorganizeFrom: #(
('comparing' = )) !


!Array2D methods !  
indexedDo: aTwoArgumentBlock
    "anArray2D indexedDo: [:index :object | ... ]"

    | index |
    origin y to: origin y + extent y - 1 do: [:y |
        origin x to: origin x + extent x - 1 do: [:x |
            index := x@y. aTwoArgumentBlock value: index value: (self at: index)]].! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D) reorganizeFrom: #(
('enumerating' indexedDo: )) !


!Array2D methods !   
indexOf: anObject

    self indexedDo: [:index :object | object = anObject ifTrue: [^index]].
    ^0!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D) reorganizeFrom: #(
('querying' indexOf: )) !


!Array2D methods !
clippedAt: aPoint

    ^self at: (self clipped: aPoint)!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D) reorganizeFrom: #(
('contents accessing' clippedAt: )) !


!Array2D methods !
collect: aBlock

    | answer |
    answer := self class origin: self origin extent: self extent.
    self indexedDo: [:index :object | answer at: index put: (aBlock value: object)].
    ^answer!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D) reorganizeFrom: #(
('enumerating' collect: )) !


!Array2D methods ! 
containsPoint: aPoint
    ^self inBounds: aPoint!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D) reorganizeFrom: #(
('querying' containsPoint: )) !


!Array2D methods !  
shallowCopy

    | copy |
    copy := self class origin: self origin shallowCopy extent: self extent shallowCopy.
    self indexedDo: [:index :object | copy at: index put: object]!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D) reorganizeFrom: #(
('copying' shallowCopy )) !


!Array2D methods !  
contains: aRectangle

    ^self rectangle contains: aRectangle.!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D) reorganizeFrom: #(
('querying-rectangles' contains: )) !


!Array2D methods !
at: aPoint put: anObject

    | index |
    index := self basicIndexOf: aPoint.
    ^super at: index put: anObject! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D) reorganizeFrom: #(
('contents accessing' at:put: )) !


!Array2D methods !   
mergeAll: array2Ds

    | result rectangle |
    rectangle := self rectangle. array2Ds do: [:array | rectangle := rectangle merge: array rectangle].
    result := self class origin: rectangle origin extent: rectangle extent.
    (Array with: self), array2Ds do: [:array | array indexedDo: [:index :object | result at: index put: object]].
    ^result!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D) reorganizeFrom: #(
('merging' mergeAll: )) !


!Array2D methods !
at: aPoint

    | index |
    index := self basicIndexOf: aPoint.
    ^super at: index! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D) reorganizeFrom: #(
('contents accessing' at: )) !


!Array2D methods !   
printOn: aStream

    aStream  << self class; << '('; << self rectangle; << ')'!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D) reorganizeFrom: #(
('printing' printOn: )) !


!Array2D methods !
deepCopy

    | copy |
    copy := self class origin: self origin shallowCopy extent: self extent shallowCopy.
    self indexedDo: [:index :object | copy at: index put: object shallowCopy]!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D) reorganizeFrom: #(
('copying' deepCopy )) !


!Array2D methods ! 
origin

    ^origin!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D) reorganizeFrom: #(
('querying' origin )) !


!Array2D methods !  
rectangle

    ^Rectangle origin: origin extent: extent!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D) reorganizeFrom: #(
('querying-rectangles' rectangle )) !


!Array2D methods !
merge: anArray2D

    ^self mergeAll: (Array with: anArray2D)!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D) reorganizeFrom: #(
('merging' merge: )) !


!Array2D methods !   
corner
    ^origin + extent!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D) reorganizeFrom: #(
('querying' corner )) !


!Array2D methods !  
basicIndexedDo: aTwoArgumentBlock
    "anArray2D basicIndexedDo: [:index :object | ... ]"

    1 to: self basicSize do: [:index | aTwoArgumentBlock value: index value: (self basicAt: index)]!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D) reorganizeFrom: #(
('enumerating' basicIndexedDo: )) !


!Array2D methods !  
intersects: anArray2D

    ^self rectangle intersects: anArray2D rectangle!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D) reorganizeFrom: #(
('querying-rectangles' intersects: )) !


!Array2D methods !  
intersectsOrTouches: anArray2D

    ^self rectangle intersectsOrTouches: anArray2D rectangle! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D) reorganizeFrom: #(
('querying-rectangles' intersectsOrTouches: )) !


!Array2D methods ! 
basicIndexOf: aPoint

    | offsetPoint index |
    false ifTrue: [self checkBounds: aPoint].

    offsetPoint := aPoint - origin.
    index := (offsetPoint y) * (extent x) + offsetPoint x.
    ^index + 1!    ! 
#('May 16, 2003' '01:43:51 PM' nil)!

(CodeFiler organizerFor: Array2D) reorganizeFrom: #(
('querying' basicIndexOf: )) !


!Array2D methods !  
checkBounds: aPoint

    (self inBounds: aPoint) ifFalse: [self error: 'Index out of bounds.']!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D) reorganizeFrom: #(
('private' checkBounds: )) !


!Array2D methods ! 
extent

    ^extent!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D) reorganizeFrom: #(
('querying' extent )) !


!Array2D class methods !
origin: origin extent: extent

    ^(self basicNew: extent x * extent y) initializeOrigin: origin extent: extent! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D class) reorganizeFrom: #(
('instance creation' origin:extent: )) !


!Array2D class methods ! 
new: extent

    extent isRectangle ifTrue: [^self origin: extent leftTop asPoint extent: extent extent asPoint].
    ^self origin: 1@1 extent: extent.! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array2D class) reorganizeFrom: #(
('instance creation' new: )) !


   

Object subclass: #Color
  instanceVariableNames: ''
  classVariableNames: 
    ' SystemColors '
  poolDictionaries: 
    ' OperatingSystemConstants SystemColorConstants '
  categories: #( 'Base-Graphics' )
  comment: ''!

 

Object subclass: #CompilationError
  instanceVariableNames: 
    ' errorInterval proceedable retryable replacementSource errorMessage sourceCode '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Compiler Support' )
  comment: ''!



Object subclass: #CompilationResult
  instanceVariableNames: 
    ' evaluationResult '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Compiler Support' )
  comment: ''!



Object subclass: #CompiledMethodDefinition
  instanceVariableNames: 
    ' compiledMethod '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Compiler Support' )
  comment: ''!

   

Object subclass: #CompilerErrorHandler
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Compiler Support' )
  comment: ''!

 

Object subclass: #CompilerInterface
  instanceVariableNames: 
    ' nameScope errorHandler compiler options '
  classVariableNames: 
    ' DefaultPoolNames '
  poolDictionaries: ''
  categories: #( 'Kernel-Compiler Support' )
  comment: ''!

!CompilerInterface methods ! 
evaluate: sourceCode withReceiver: receiver
    "Compile the Smalltalk <sourceCode> as an expression
    in the context of the receiver. If compilation is successful,
    answer the result of of evaluating the resulting executable.
    The pseudo-variable <self> be bound to the receiver."

    |result|
    result := self useCompiler compileForEvaluation: sourceCode.
    result wasSuccessful ifTrue: [result evaluateFor: receiver].
    ^result! ! 
#('May 9, 2002' '02:01:49 PM' nil)!

(CodeFiler organizerFor: CompilerInterface) reorganizeFrom: #(
('no category methods' evaluate:withReceiver: )) !


   

Object subclass: #CompilerNameScope
  instanceVariableNames: 
    ' enclosingEnvironment shadowFlag scopeDescription '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Compiler Support' )
  comment: ''!



Object subclass: #Context
  instanceVariableNames: 
    ' homeContext startPC '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Objects' )
  comment: ''!



Object subclass: #CursorManager
  instanceVariableNames: 
    ' handle '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants CursorConstants OperatingSystemConstants '
  categories: #( 'Kernel-Host Interfaces' )
  comment: ''!



Object subclass: #DefinitionInstaller
  instanceVariableNames: 
    ' defaultGlobalDictionary '
  classVariableNames: 
    ' Current '
  poolDictionaries: ''
  categories: #( 'Kernel-Source Management' )
  comment: ''!

!DefinitionInstaller methods ! 
setClassComment: aString forClass: aClass

    CodeFiler setCommentFor: aClass name to: aString!  ! 
#('May 24, 2002' '04:11:58 PM' nil)!

(CodeFiler organizerFor: DefinitionInstaller) reorganizeFrom: #(
('no category methods' setClassComment:forClass: )) !


 
DialogCoordinator class instanceVariableNames: ''
  categories: #( )
  comment: ''!

 

Object subclass: #DIB
  instanceVariableNames: 
    ' bitmapInfo bits '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Base-Graphics' )
  comment: ''!

 

CompilerNameScope subclass: #DictionaryScope
  instanceVariableNames: 
    ' dict '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Compiler Support' )
  comment: ''!

   

CodeWriter subclass: #DigitalkClassWriter
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Code Writers & Readers' )
  comment: ''!

 

Object subclass: #DragDropObject
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Windows-Support' )
  comment: ''!

   

Object subclass: #DragDropSession
  instanceVariableNames: 
    ' source target scroll objects screenLocation operations operation targetSelection defaultOperation cursors '
  classVariableNames: 
    ' Current DefaultClass DragButtonIndex ExtendedDragButtonIndex OperationDescriptions '
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Windows-Support' )
  comment: ''!

   

Object subclass: #Ephemeron
  instanceVariableNames: 
    ' key value manager '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Special Objects' )
  comment: ''!



EvaluableAction subclass: #CollectionAccessor
  instanceVariableNames: 
    ' elementName '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Processes and Events' )
  comment: ''!

   

Object subclass: #Example
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Constructor' )
  comment: ''!

!Example methods !
initialize
    "Nothing to do"!    ! 
#('December 27, 2016' '02:45:53 PM' nil)!

(CodeFiler organizerFor: Example) reorganizeFrom: #(
('initializing' initialize )) !


!Example class methods !  
new
    ^super new initialize! ! 
#('December 27, 2016' '02:46:12 PM' nil)!

(CodeFiler organizerFor: Example class) reorganizeFrom: #(
('no category methods' new )) !



Exception class instanceVariableNames: ''
  categories: #( )
  comment: ''!

 
ExceptionHandler class instanceVariableNames: ' retryToken '
  categories: #( )
  comment: ''!

  

Object subclass: #ExpressionEvaluator
  instanceVariableNames: 
    ' pane '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Messages' 'Tools-Scintilla Pane' )
  comment: ''!

!ExpressionEvaluator methods ! 
compilerError: aString at: anInteger in: codeString for: aClass
        "Private - Display the error message aString
         in reversed form at the indicated
         position anInteger in the source
         codeString."
    pane isReadOnly
        ifTrue: [ ^MessageBox notify: 'Compilation Error' withText: aString ].
    pane evaluating
        ifTrue: [
            self
                doItcompilerError: aString
                at: anInteger
                in: codeString
                for: aClass ]
        ifFalse: [
            self
                saveCompilerError: aString
                at: anInteger
                in: codeString
                for: aClass ]!   ! 
#('May 24, 2002' '11:10:37 AM' nil)!

(CodeFiler organizerFor: ExpressionEvaluator) reorganizeFrom: #(
('no category methods' compilerError:at:in:for: )) !


!ExpressionEvaluator methods !
evaluate: aString ifError: errorBlock
        "Private - evaluate aString as compiled Smalltalk source code.
        If a compilation error occurs, answer the result of evaluating
        errorBlock, otherwise answer the result of the evaluation."
    | result |
    SourceManager current
        logString: aString
        for: [
            result := ( pane owner respondsTo: #doItResult:error: )
                ifTrue: [ pane owner doItResult: self pane error: errorBlock ]
                ifFalse: [
                    CompilerInterface
                        evaluate: aString
                        in: UndefinedObject
                        to: nil
                        notifying: self
                        ifFail: errorBlock ] ].
    ^result
!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: ExpressionEvaluator) reorganizeFrom: #(
('no category methods' evaluate:ifError: )) !


  

Object subclass: #ExternalBuffer
  instanceVariableNames: 
    ' contents '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!

 

Object variableByteSubclass: #ExternalHandle
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants '
  categories: #( 'Kernel-Structures' )
  comment: ''!

   

ExternalHandle variableByteSubclass: #Atom
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!


DynamicLinkLibrary class instanceVariableNames: ' current '
  categories: #( )
  comment: ''!

   

DynamicLinkLibrary variableByteSubclass: #CommonControlsDLL
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Kernel-DLLs' )
  comment: ''!

 

DynamicLinkLibrary variableByteSubclass: #CommonDialogDLL
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-DLLs' )
  comment: ''!

   

ExternalBuffer subclass: #ExternalLong
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!

   

ExternalLong subclass: #ExternalAddress
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Kernel-Structures' )
  comment: ''!

!ExternalAddress methods !
convertToInteger: offset32Bit

    | offset value |

    offset := offset32Bit * 4.
    value := 0.
    offset + 4 to: offset + 1 by: -1 do: [ :index |
        value := ( value bitShift: 8 ) + ( self at: index ) ].
    ^value!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: ExternalAddress) reorganizeFrom: #(
('extensions' convertToInteger: )) !


!ExternalAddress methods ! 
externalAddressAt: offset32Bit

    | offset value |

    offset := offset32Bit * 4.
    value := 0.
    offset + 4 to: offset + 1 by: -1 do: [ :index |
        value := ( value bitShift: 8 ) + ( self at: index ) ].
    ^value asExternalAddress!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: ExternalAddress) reorganizeFrom: #(
('extensions' externalAddressAt: )) !


!ExternalAddress methods !
convertToString

    | newString index |

    newString := String new.
    index := 1.
    self isValid ifFalse:[^newString].

    [(self at: index) = 0] whileFalse:[
        newString := newString, (self at: index) asCharacter asString.
        index := index + 1].
    ^newString!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: ExternalAddress) reorganizeFrom: #(
('extensions' convertToString )) !


 
ExternalSegmentedAddress class instanceVariableNames: ''
  categories: #( )
  comment: ''!

  

Boolean subclass: #False
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Objects' )
  comment: ''!

!False methods !
asInteger
    ^0!  ! 
#('September 26, 2006' '07:56:28 AM' nil)!

(CodeFiler organizerFor: False) reorganizeFrom: #(
('extensions' asInteger )) !


  

Object subclass: #FileSystemEntity
  instanceVariableNames: 
    ' fileSystemLocator '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Files' )
  comment: ''!

!FileSystemEntity methods !  
inspect
        "Open a FieldInspector on the receiver."
    "Field"Inspector new openOn: self
! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: FileSystemEntity) reorganizeFrom: #(
('no category methods' inspect )) !


   

FileSystemComponent subclass: #File
  instanceVariableNames: 
    ' fileId '
  classVariableNames: 
    ' FilePageSize '
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Base-Files' )
  comment: ''!

!File class methods !  
exists: aFileName
in: aDirectory
    "Answer true if the file or subdirectory specified
         by aFileName exists, else return false."

    ^(Directory fromPath: aDirectory drivePathName) hasEntityNamed: aFileName!  ! 
#('April 29, 2003' '10:10:14 AM' nil)!

(CodeFiler organizerFor: File class) reorganizeFrom: #(
('no category methods' exists:in: )) !


!File class methods !  
exists: aFileName
in: aDirectory
    "Answer true if the file or subdirectory specified
         by aFileName exists, else return false."

    ^(Directory fromPath: aDirectory drivePathName) hasEntityNamed: aFileName!  ! 
#('April 29, 2003' '10:10:14 AM' 163636)!

(CodeFiler organizerFor: File class) reorganizeFrom: #(
('no category methods' exists:in: )) !


!File class methods !   
exists: aFileName in: aDirectory
    "Answer true if the file or subdirectory specified by aFileName exists, else return false."

    ^(Directory fromPath: aDirectory drivePathName) hasEntityNamed: aFileName! ! 
#('April 29, 2003' '10:10:14 AM' 164032)!

(CodeFiler organizerFor: File class) reorganizeFrom: #(
('no category methods' exists:in: )) !


!File class methods !   
exists: aFileName
        "Answer true if the file or subdirectory specified
         by aFileName exists, else return false."
    | entity directory |
    entity := aFileName asFileSystemPath.
    directory := Directory fromPath: entity parentPath.
    ^directory hasEntityNamed: entity entityName!   ! 
#('April 29, 2003' '10:10:14 AM' nil)!

(CodeFiler organizerFor: File class) reorganizeFrom: #(
('no category methods' exists: )) !


!File class methods ! 
exists: aFileName
        "Answer true if the file or subdirectory specified
         by aFileName exists, else return false."
    | entity directory |
    entity := aFileName asFileSystemPath.
    directory := Directory fromPath: entity parentPath.
    ^directory hasEntityNamed: entity entityName!   ! 
#('April 29, 2003' '10:10:14 AM' 164820)!

(CodeFiler organizerFor: File class) reorganizeFrom: #(
('no category methods' exists: )) !


!File class methods !  
exists: aFileName
    "Answer true if the file or subdirectory specified by aFileName exists, else return false."
    | entity directory |
    entity := aFileName asFileSystemPath.
    directory := Directory fromPath: entity parentPath.
    ^directory hasEntityNamed: entity entityName! ! 
#('April 29, 2003' '10:10:14 AM' 165296)!

(CodeFiler organizerFor: File class) reorganizeFrom: #(
('no category methods' exists: )) !


!File class methods !  
removeIgnoringErrors: aString ifAbsent: aBlock
        "Erase the file named aString; if the file does not exist,
        answer the result of evaluating aBlock."
    | error errorKnown|
    ( KernelLibrary deleteFile: aString asFileSystemPath asString asParameter ) ifFalse: [
        error := KernelLibrary getLastError.
        errorKnown := (#(2 3 15 18 21) includes: error)]. "ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND, ERROR_INVALID_DRIVE, ERROR_NO_MORE_FILES, ERROR_NOT_READY"! ! 
#('April 13, 2010' '05:18:02 PM' nil)!

(CodeFiler organizerFor: File class) reorganizeFrom: #(
('no category methods' removeIgnoringErrors:ifAbsent: )) !


!File class methods !  
fileSize: aString
    | stream size |
    stream := File pathNameReadOnly: aString.
    size := stream readLimit.
    stream close.
    ^size! ! 
#('September 7, 2005' '08:51:52 AM' nil)!

(CodeFiler organizerFor: File class) reorganizeFrom: #(
('no category methods' fileSize: )) !


!File class methods !
copy: sourcePath
to: destPath
	"Copy the file named oldFile to the
         file named newFile; answer true if successful,
         otherwise false."

	| source dest |
	[source := sourcePath asFileSystemPath asFileWithin: (Directory fromPath: Disk drivePathName).
		dest := destPath asFileSystemPath asFileWithin: (Directory fromPath: Disk drivePathName).
		dest exists
			ifTrue: [dest remove].
		source copyTo: dest directory as: dest name] on: FileError do: [^false].
	^true!  ! 
#('July 14, 2005' '08:03:25 AM' nil)!

(CodeFiler organizerFor: File class) reorganizeFrom: #(
('no category methods' copy:to: )) !


!File class methods ! 
copy: sourcePath to: destPath
    "Copy the file named oldFile to the
         file named newFile; answer true if successful,
         otherwise false."

    | source dest |
    [source := sourcePath asFileSystemPath asFileWithin: (Directory fromPath: Disk drivePathName).
        dest := destPath asFileSystemPath asFileWithin: (Directory fromPath: Disk drivePathName).
        dest exists
            ifTrue: [dest remove].
        source copyTo: dest directory as: dest name] on: FileError do: [^false].
    ^true!    ! 
#('July 14, 2005' '08:03:25 AM' 167244)!

(CodeFiler organizerFor: File class) reorganizeFrom: #(
('no category methods' copy:to: )) !


!File class methods !  
creationTime: pathName
    " File creationTime: 'C:\3D\PhoneGame\Game\textures\air tank.tga' "
    | file creationTime |
    file := File fromPath: pathName.
    creationTime := file creationTime.
    file close.
    ^creationTime!   ! 
#('October 2, 2009' '08:59:33 AM' nil)!

(CodeFiler organizerFor: File class) reorganizeFrom: #(
('extensions' creationTime: )) !


!File class methods !   
creationTime: pathName
    "Returns a time stamp if the file exists; otherwise, nil..."
    
    " File creationTime: 'C:\3D\PhoneGame\Game\textures\air tank.tga' "
    " File creationTime: 'C:\3D\PhoneGame\Game\textures\air tankTHIS DOES NOT EXISTS.tga' "
    
    | file creationTime |
    file := File fromPath: pathName.
    creationTime := file creationTime.
    file close.
    ^creationTime!    ! 
#('October 2, 2009' '09:06:10 AM' 168608)!

(CodeFiler organizerFor: File class) reorganizeFrom: #(
('extensions' creationTime: )) !


!File class methods !
fromPath: path
in: parentDirectory
	"Answer an instance of a subclass of the receiver representing an entity with the given path. If the path is an absolute path, the parent directory is ignored. If the path is a relative path the path name is assumed to be relative to the parentDirectory."

	| locator |
	locator := path asFileSystemLocator.
	locator isRelative
		ifTrue: [^locator asFileWithin: parentDirectory]
		ifFalse: [^locator asFile]!    ! 
#('April 29, 2003' '10:10:14 AM' nil)!

(CodeFiler organizerFor: File class) reorganizeFrom: #(
('no category methods' fromPath:in: )) !


!File class methods !
fromPath: path
in: parentDirectory
    "Answer an instance of a subclass of the receiver representing an entity with the given path. If the path is an absolute path, the parent directory is ignored. If the path is a relative path the path name is assumed to be relative to the parentDirectory."

    | locator |
    locator := path asFileSystemLocator.
    locator isRelative
        ifTrue: [^locator asFileWithin: parentDirectory]
        ifFalse: [^locator asFile]!    ! 
#('April 29, 2003' '10:10:14 AM' 169596)!

(CodeFiler organizerFor: File class) reorganizeFrom: #(
('no category methods' fromPath:in: )) !


!File class methods ! 
fromPath: path in: parentDirectory
    "Answer an instance of a subclass of the receiver representing an entity with the given path. If the path is an absolute path, the parent directory is ignored. If the path
    is a relative path the path name is assumed to be relative to the parentDirectory."

    | locator |
    locator := path asFileSystemLocator.
    locator isRelative
        ifTrue: [^locator asFileWithin: parentDirectory]
        ifFalse: [^locator asFile]!    ! 
#('April 29, 2003' '10:10:14 AM' 170224)!

(CodeFiler organizerFor: File class) reorganizeFrom: #(
('no category methods' fromPath:in: )) !


  

FileSystemContainer subclass: #Directory
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Base-Files' )
  comment: ''!

!Directory methods !
findNext: aSearchResult
        "Private - find the next entry in the directory search;
        answer the findData structure, or nil if no next element."

    | findData |
    findData := Win32FindData new.
    ( KernelLibrary findNextFile: aSearchResult searchHandle findData: findData asParameter )
        ifTrue: [ ^aSearchResult findData: findData ].
    KernelLibrary getLastError = 18   "ERROR_NO_MORE_FILES"
        ifTrue: [ ^nil ]
        ifFalse: [ ^self osError ]
!   ! 
#('June 25, 2009' '12:25:33 PM' nil)!

(CodeFiler organizerFor: Directory) reorganizeFrom: #(
('no category methods' findNext: )) !


!Directory methods !  
findNext: aSearchResult
        "Private - find the next entry in the directory search;
        answer the findData structure, or nil if no next element."

    | findData lastError |
    findData := Win32FindData new.
    ( KernelLibrary findNextFile: aSearchResult searchHandle findData: findData asParameter )
        ifTrue: [ ^aSearchResult findData: findData ].
    lastError := KernelLibrary getLastError.
    (lastError = 0 or: [lastError = 18])   "ERROR_NO_MORE_FILES"
        ifTrue: [ ^nil ]
        ifFalse: [ ^self osError ]!    ! 
#('June 25, 2009' '12:25:33 PM' 171748)!

(CodeFiler organizerFor: Directory) reorganizeFrom: #(
('no category methods' findNext: )) !


!Directory methods !   
pathnamesForFilesNamed: filterString useSubfolders: useSubfolders
    "Answer a collection of file names from the receiver directory, filtered using filterString, e.g. '*.txt'."

    | directoryName filenames pathNames subfolderPathNames |
    directoryName := self drivePathName.
    filenames := self fileNamesMatching: (Pattern new: filterString asUppercase).
    pathNames := filenames collect: [:filename | directoryName, '\', filename].
    
    useSubfolders ifFalse: [^pathNames].
    self directoryNames do: [:name |
        subfolderPathNames := (Directory pathName: directoryName, '\', name) pathnamesForFilesNamed: filterString useSubfolders: useSubfolders.
        pathNames addAll: subfolderPathNames].
        
    ^pathNames!  ! 
#('December 15, 2006' '11:25:55 AM' nil)!

(CodeFiler organizerFor: Directory) reorganizeFrom: #(
('extensions' pathnamesForFilesNamed:useSubfolders: )) !


!Directory methods !   
pathnamesForFilesNamed: filterString useSubfolders: useSubfolders
    "Answer a collection of file names from the receiver directory, filtered using filterString, e.g. '*.txt'."

    | directoryName filenames pathNames subfolderPathNames subDirectory |
    directoryName := self drivePathName.
    filenames := self fileNamesMatching: (Pattern new: filterString asUppercase).
    pathNames := filenames collect: [:filename | directoryName, '\', filename].
    
    useSubfolders ifFalse: [^pathNames].
    self directoryNames do: [:name |
        subDirectory := Directory pathName: directoryName, '\', name.
        subfolderPathNames := subDirectory pathnamesForFilesNamed: filterString useSubfolders: useSubfolders.
        subDirectory close.
        pathNames addAll: subfolderPathNames].
        
    ^pathNames!   ! 
#('June 25, 2009' '10:24:17 AM' 173132)!

(CodeFiler organizerFor: Directory) reorganizeFrom: #(
('extensions' pathnamesForFilesNamed:useSubfolders: )) !


!Directory methods !
pathnamesForFilesNamed: filterString useSubfolders: useSubfolders
    "Answer a collection of file names from the receiver directory, filtered using filterString, e.g. '*.txt'."

    | directoryName filenames pathNames subfolderPathNames subDirectory |
    directoryName := self drivePathName.
    filenames := self fileNamesMatching: (Pattern new: filterString asUppercase).
    pathNames := filenames collect: [:filename | directoryName, '\', filename].

    useSubfolders ifFalse: [^pathNames].
    self directoryNames do: [:name |
        subDirectory := Directory pathName: directoryName, '\', name.
        subfolderPathNames := subDirectory pathnamesForFilesNamed: filterString useSubfolders: useSubfolders.
        pathNames addAll: subfolderPathNames].

    ^pathNames!    ! 
#('June 25, 2009' '12:25:33 PM' 174080)!

(CodeFiler organizerFor: Directory) reorganizeFrom: #(
('extensions' pathnamesForFilesNamed:useSubfolders: )) !


!Directory methods !
allFilePathNamesIncludingSubfolders
    "(Directory pathName: 'C:\3d\helpme\textures') allFilePathNamesIncludingSubfolders"
    ^self pathnamesForFilesNamed: '*.*' useSubfolders: true!  ! 
#('June 25, 2009' '10:28:31 AM' nil)!

(CodeFiler organizerFor: Directory) reorganizeFrom: #(
('extensions' allFilePathNamesIncludingSubfolders )) !


!Directory methods ! 
allImmediateSubDirectoryPathNames
    "(Directory pathName: 'C:\3d\helpme\textures') allDirectoryNames"
    | directoryName allNames |
    directoryName := self drivePathName.
    allNames := OrderedCollection new.
    self directoryNames do: [:name | allNames add: directoryName, '\', name.].
    ^allNames!  ! 
#('June 25, 2009' '12:25:33 PM' nil)!

(CodeFiler organizerFor: Directory) reorganizeFrom: #(
('extensions' allImmediateSubDirectoryPathNames )) !


!Directory methods !   
allSubDirectoryPathNames
    "(Directory pathName: 'C:\3d\helpme\textures') allDirectoryNames"
    | directoryName allNames directory |
    directoryName := self drivePathName.
    allNames := OrderedCollection new.
    self directoryNames do: [:name |
        allNames add: directoryName, '\', name.
        directory := Directory pathName: allNames last.
        allNames addAll: directory allDirectoryPathNames.
        directory close].
    ^allNames!   ! 
#('June 25, 2009' '12:25:33 PM' nil)!

(CodeFiler organizerFor: Directory) reorganizeFrom: #(
('extensions' allSubDirectoryPathNames )) !


!Directory methods !
allSubDirectoryPathNames
    "(Directory pathName: 'C:\3d\helpme\textures') allDirectoryNames"
    | directoryName allNames directory |
    directoryName := self drivePathName.
    allNames := OrderedCollection new.
    self directoryNames do: [:name |
        allNames add: directoryName, '\', name.
        directory := Directory pathName: allNames last.
        allNames addAll: directory allDirectoryPathNames].
    ^allNames! ! 
#('June 25, 2009' '12:25:33 PM' 176960)!

(CodeFiler organizerFor: Directory) reorganizeFrom: #(
('extensions' allSubDirectoryPathNames )) !


!Directory methods ! 
allDirectoryPathNames
    "(Directory pathName: 'C:\3d\helpme\textures') allDirectoryNames"
    | directoryName allNames directory |
    directoryName := self drivePathName.
    allNames := OrderedCollection with: directoryName.
    self directoryNames do: [:name |
        directory := Directory pathName: Directory pathName: directoryName, '\', name.
        allNames addAll: directory allDirectoryPathNames.
        directory close].
    ^allNames!    ! 
#('June 25, 2009' '12:25:33 PM' nil)!

(CodeFiler organizerFor: Directory) reorganizeFrom: #(
('extensions' allDirectoryPathNames )) !


!Directory methods !   
allDirectoryPathNames
    "(Directory pathName: 'C:\3d\helpme\textures') allDirectoryNames"
    | directoryName allNames directory |
    directoryName := self drivePathName.
    allNames := OrderedCollection with: directoryName.
    self directoryNames do: [:name |
        directory := Directory pathName: Directory pathName: directoryName, '\', name.
        allNames addAll: directory allDirectoryPathNames].
    ^allNames!  ! 
#('June 25, 2009' '12:25:33 PM' 178216)!

(CodeFiler organizerFor: Directory) reorganizeFrom: #(
('extensions' allDirectoryPathNames )) !


!Directory methods !
allDirectoryPathNames
    "(Directory pathName: 'C:\3d\helpme\textures') allDirectoryNames"
    | directoryName allNames directory |
    directoryName := self drivePathName.
    allNames := OrderedCollection with: directoryName.
    self directoryNames do: [:name |
        directory := Directory pathName: directoryName, '\', name.
        allNames addAll: directory allDirectoryPathNames].
    ^allNames!  ! 
#('June 25, 2009' '12:32:31 PM' 178852)!

(CodeFiler organizerFor: Directory) reorganizeFrom: #(
('extensions' allDirectoryPathNames )) !


!Directory methods !
directlyContainedFileNames
    ^(self pathnamesForFilesNamed: '*.*' useSubfolders: false) collect: [:path | path fileNameComplete]!    ! 
#('April 16, 2014' '12:30:03 PM' nil)!

(CodeFiler organizerFor: Directory) reorganizeFrom: #(
('extensions' directlyContainedFileNames )) !


!Directory methods ! 
directlyContainedPathNames
    ^self pathnamesForFilesNamed: '*.*' useSubfolders: false!   ! 
#('April 16, 2014' '12:30:17 PM' nil)!

(CodeFiler organizerFor: Directory) reorganizeFrom: #(
('extensions' directlyContainedPathNames )) !


!Directory class methods !   
removeAll: directoryPathName
    "Remove the directory with the path name 'directoryPathName' including everything inside."
    | directory |

    (Directory exists: directoryPathName) ifFalse: [^self halt: 'Directory "', directoryPathName, '" does not exist...'].
    directory := Directory fromPath: directoryPathName.
    
    directory allDirectoryPathNames do: [:subdirectoryPath | self removeAll: subdirectoryPath].
    directory allFilePathNamesIncludingSubfolders do: [:filename | File remove: filename].
    directory close.
        
    Directory remove: directoryPathName!  ! 
#('June 25, 2009' '10:28:19 AM' nil)!

(CodeFiler organizerFor: Directory class) reorganizeFrom: #(
('extensions' removeAll: )) !


!Directory class methods !  
removeAll: directoryPathName
    "Remove the directory with the path name 'directoryPathName' including everything inside."
    | directory |

    (Directory exists: directoryPathName) ifFalse: [^self halt: 'Directory "', directoryPathName, '" does not exist...'].
    directory := Directory fromPath: directoryPathName.

    directory allImmediateSubDirectoryPathNames do: [:subdirectoryPath | self removeAll: subdirectoryPath].
    directory allFilePathNamesIncludingSubfolders do: [:filename | File remove: filename].
    directory close.

    Directory remove: directoryPathName!  ! 
#('June 25, 2009' '12:25:33 PM' 180636)!

(CodeFiler organizerFor: Directory class) reorganizeFrom: #(
('extensions' removeAll: )) !


!Directory class methods !   
removeAll: directoryPathName
    "Remove the directory with the path name 'directoryPathName' including everything inside."
    | directory |

    (Directory exists: directoryPathName) ifFalse: [^self halt: 'Directory "', directoryPathName, '" does not exist...'].
    directory := Directory fromPath: directoryPathName.

    directory allImmediateSubDirectoryPathNames do: [:subdirectoryPath | self removeAll: subdirectoryPath].
    directory allFilePathNamesIncludingSubfolders do: [:filename | File remove: filename].

    Directory remove: directoryPathName!    ! 
#('June 25, 2009' '12:25:33 PM' 181404)!

(CodeFiler organizerFor: Directory class) reorganizeFrom: #(
('extensions' removeAll: )) !


 

Object subclass: #FileSystemLocator
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Files' )
  comment: ''!

 

FileSystemLocator subclass: #FileSystemPath
  instanceVariableNames: 
    ' componentNames absolute '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Files' )
  comment: ''!

  

Object subclass: #FileVolume
  instanceVariableNames: 
    ' fileSystemLocator '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants '
  categories: #( 'Base-Files' )
  comment: ''!



Object subclass: #Font
  instanceVariableNames: 
    ' faceName pointSize handle logicalFont physicalFont graphicsMedium '
  classVariableNames: 
    ' FontHandleTable TempFontList '
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Kernel-Host Interfaces' )
  comment: ''!

 

DynamicLinkLibrary variableByteSubclass: #GDIDLL
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-DLLs' )
  comment: ''!



DictionaryScope subclass: #GlobalPoolScope
  instanceVariableNames: 
    ' bindingClass containsSymbols '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Compiler Support' )
  comment: ''!

 

Object subclass: #GraphicsMedium
  instanceVariableNames: 
    ' deviceContext graphicsTool '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Base-Graphics' )
  comment: ''!

   

GraphicsMedium subclass: #Bitmap
  instanceVariableNames: 
    ' bitmapHandle bitmapInfo archive palette '
  classVariableNames: 
    ' AuxiliaryDC DefaultBitmap DefaultPaletteHandle MemoryContext OldMemoryContext '
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Base-Graphics' )
  comment: ''!

!Bitmap methods !
outputToFile: aFileName
        "Output the receiver in DIB format to aFileName."
    | aFileStream |
    aFileStream := ( File fromPath: aFileName ) binaryWriteStream.
    self outputToFileStream: aFileStream.
    aFileStream close!  ! 
#('February 16, 2010' '04:00:47 PM' nil)!

(CodeFiler organizerFor: Bitmap) reorganizeFrom: #(
('no category methods' outputToFile: )) !


!Bitmap methods !
outputToFile: aFileName
        "Output the receiver in DIB format to aFileName."
    | aFileStream |
(aFileName asLowercase indexOfString: '$modelimposter-atlas0') > 0 ifTrue: [self halt: 'CREATING BMP FILE ', aFileName printString].
    aFileStream := ( File fromPath: aFileName ) binaryWriteStream.
    self outputToFileStream: aFileStream.
    aFileStream close!    ! 
#('February 16, 2010' '04:00:47 PM' 184812)!

(CodeFiler organizerFor: Bitmap) reorganizeFrom: #(
('no category methods' outputToFile: )) !


!Bitmap methods ! 
screenWidth24: w height: h
        "Private - Initialize the receiver with width w and height h."
    | planes hOldBitmap |
    planes := GDILibrary getDeviceCaps: Display deviceContext
        index: Planes.
    self
        initPenWidth: w
        height: h
        planes: planes
        bitCount: 24.
    self createBitmap.

    hOldBitmap := graphicsTool selectObject: self handle.
    graphicsTool patternFill: (0 @ 0 extent: self extent)
        rule: Whiteness.
   graphicsTool selectObject: hOldBitmap!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Bitmap) reorganizeFrom: #(
('no category methods' screenWidth24:height: )) !


!Bitmap methods !  
screenWidth32: w height: h
        "Private - Initialize the receiver with width w and height h."
    | planes hOldBitmap |
    planes := GDILibrary getDeviceCaps: Display deviceContext
        index: Planes.
    self
        initPenWidth: w
        height: h
        planes: planes
        bitCount: 32.
    self createBitmap.

    hOldBitmap := graphicsTool selectObject: self handle.
    graphicsTool patternFill: (0 @ 0 extent: self extent)
        rule: Whiteness.
   graphicsTool selectObject: hOldBitmap!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Bitmap) reorganizeFrom: #(
('no category methods' screenWidth32:height: )) !


!Bitmap class methods !
screenWidth24: w height: h
    "Answer a new screen Bitmap with width w and height h."

    ^self new screenWidth24: w height: h!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Bitmap class) reorganizeFrom: #(
('extensions' screenWidth24:height: )) !


!Bitmap class methods !   
screenWidth32: w height: h
    "Answer a new screen Bitmap with width w and height h."

    ^self new screenWidth32: w height: h!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Bitmap class) reorganizeFrom: #(
('extensions' screenWidth32:height: )) !


  

Object subclass: #GraphicsTool
  instanceVariableNames: 
    ' deviceContext logicalTool location width height foreColor backColor graphicsMedium '
  classVariableNames: 
    ' DefaultObjects StockObjects '
  poolDictionaries: 
    ' OperatingSystemConstants SystemColorConstants '
  categories: #( 'Base-Graphics' )
  comment: ''!

 

Collection subclass: #HashedCollection
  instanceVariableNames: 
    ' elementCount contents '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Collections' )
  comment: ''!

   

HashedCollection subclass: #Dictionary
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Collections' )
  comment: ''!

!Dictionary methods !   
sortedKeysAndValuesDo: aBlock
    self contents asSortedCollection do: [:anAssociation |
        aBlock value: anAssociation key value: anAssociation value]! ! 
#('September 22, 2005' '08:14:17 AM' nil)!

(CodeFiler organizerFor: Dictionary) reorganizeFrom: #(
('extensions' sortedKeysAndValuesDo: )) !


!Dictionary methods !   
sortedKeysAndValuesDo: aBlock
    self contents withoutNils asSortedCollection do: [:anAssociation |
        aBlock value: anAssociation key value: anAssociation value]! ! 
#('September 22, 2005' '08:21:24 AM' 188552)!

(CodeFiler organizerFor: Dictionary) reorganizeFrom: #(
('extensions' sortedKeysAndValuesDo: )) !


!Dictionary methods !
sortedKeysAndValuesDo: aBlock
    "Note: Believe it or not, there is no easy way to get the associations in an array. The object
    you get back always has nils in it... For example, an approach that did not work is the 
    following:
    
        self contents withoutNils asSortedCollection do: [:anAssociation |
            aBlock value: anAssociation key value: anAssociation value]
    "
    self keys asSortedCollection do: [:key |
            aBlock value: key value: (self at: key)]!  ! 
#('September 22, 2005' '08:33:41 AM' 188892)!

(CodeFiler organizerFor: Dictionary) reorganizeFrom: #(
('extensions' sortedKeysAndValuesDo: )) !


!Dictionary methods !
at: key put: element
        "Associate the element with the key."

    self add: ( self associationClass key: key value: element ).
    ^element!  ! 
#('May 31, 2005' '03:40:29 PM' nil)!

(CodeFiler organizerFor: Dictionary) reorganizeFrom: #(
('no category methods' at:put: )) !


!Dictionary methods !   
at: key put: element
        "Associate the element with the key."

key == #effects ifTrue: [self halt: 'ALRIGHT YOU BUGGER'].
    self add: ( self associationClass key: key value: element ).
    ^element!  ! 
#('May 31, 2005' '03:40:30 PM' 189928)!

(CodeFiler organizerFor: Dictionary) reorganizeFrom: #(
('no category methods' at:put: )) !


!Dictionary methods !
at: key put: element
        "Associate the element with the key."

    self add: ( self associationClass key: key value: element ).
    ^element!  ! 
#('May 31, 2005' '04:04:50 PM' 190248)!

(CodeFiler organizerFor: Dictionary) reorganizeFrom: #(
('no category methods' at:put: )) !


!Dictionary methods !
at: key do: aBlock

    aBlock value: (self at: key ifAbsent: [^self])!   ! 
#('December 10, 2001' '12:09:21 PM' nil)!

(CodeFiler organizerFor: Dictionary) reorganizeFrom: #(
('extensions' at:do: )) !


!Dictionary methods !
keysEqualTo: anObject
    "Answer an ordered collection of keys that match."
    | answer |
    answer := OrderedCollection new.
    self associationsDo: [:anAssociation | anAssociation value = anObject ifTrue: [answer add: anAssociation key]].
    ^answer!  ! 
#('March 26, 2011' '01:33:06 PM' nil)!

(CodeFiler organizerFor: Dictionary) reorganizeFrom: #(
('extensions' keysEqualTo: )) !


!Dictionary methods ! 
asAssociations
    "Note: 'self contents' returns a linear hash table of nils and associations which 'withoutNils' ends up returning again which is initialized with 2 extra nils that remains..."
    ^self contents asOrderedCollection asArray withoutNils!    ! 
#('April 28, 2015' '09:34:19 AM' nil)!

(CodeFiler organizerFor: Dictionary) reorganizeFrom: #(
('extensions' asAssociations )) !


!Dictionary methods !   
keysIdenticalTo: anObject
    "Answer an ordered collection of keys that match."
    | answer |
    answer := OrderedCollection new.
    self associationsDo: [:anAssociation | anAssociation value == anObject ifTrue: [answer add: anAssociation key]].
    ^answer! ! 
#('March 26, 2011' '01:33:21 PM' nil)!

(CodeFiler organizerFor: Dictionary) reorganizeFrom: #(
('extensions' keysIdenticalTo: )) !


!Dictionary methods ! 
chooseKey: aBlock ifNone: exceptionBlock
    "Dictionary new at: #one put: #two; chooseKey: [:data | data == #two] ifNone: [nil]"
    self keysAndValuesDo: [:objectKey :objectValue | (aBlock value: objectValue) ifTrue: [^objectKey]].
    ^exceptionBlock value! ! 
#('July 11, 2009' '09:45:38 AM' nil)!

(CodeFiler organizerFor: Dictionary) reorganizeFrom: #(
('extensions' chooseKey:ifNone: )) !


!Dictionary methods ! 
chooseKey: aBlock ifNone: exceptionBlock
    ^self chooseKey: aBlock ifNone: [nil]!    ! 
#('July 11, 2009' '09:52:40 AM' 192476)!

(CodeFiler organizerFor: Dictionary) reorganizeFrom: #(
('extensions' chooseKey:ifNone: )) !


!Dictionary methods !  
chooseKey: aBlock ifNone: exceptionBlock
    "Dictionary new at: #one put: #two; chooseKey: [:data | data == #two] ifNone: [nil]"
    self keysAndValuesDo: [:objectKey :objectValue | (aBlock value: objectValue) ifTrue: [^objectKey]].
    ^exceptionBlock value! ! 
#('July 11, 2009' '09:53:04 AM' 192908)!

(CodeFiler organizerFor: Dictionary) reorganizeFrom: #(
('extensions' chooseKey:ifNone: )) !


!Dictionary methods !  
values
        "Answer a Bag containing all the values of the
         key/value pairs in the receiver."
    | answer |
    answer := Bag new.
    self associationsDo: [ :assoc |
        answer add: assoc value].
    ^answer!    ! 
#('August 4, 2009' '06:43:14 PM' nil)!

(CodeFiler organizerFor: Dictionary) reorganizeFrom: #(
('extensions' values )) !


!Dictionary methods !   
values
    "Answer a Bag containing all the values of the key/value pairs in the receiver."
    | answer |
    answer := OrderedCollection new.
    self associationsDo: [:association | answer add: association value].
    ^answer!  ! 
#('August 4, 2009' '06:43:14 PM' 193604)!

(CodeFiler organizerFor: Dictionary) reorganizeFrom: #(
('extensions' values )) !


!Dictionary methods !
values
    "Answer an ordered collection (instead of a bag as in the old implementation) containing all the values of the key/value pairs in the receiver."
    | answer |
    answer := OrderedCollection new.
    self associationsDo: [:association | answer add: association value].
    ^answer!  ! 
#('August 4, 2009' '06:44:19 PM' 194000)!

(CodeFiler organizerFor: Dictionary) reorganizeFrom: #(
('extensions' values )) !


!Dictionary methods !
keyExists: key
    "Answer true if the receiver contains aKey, else answer false."
    ^ (self contents lookUpKey: key for: self ) notNil!    ! 
#('October 20, 2004' '10:56:25 AM' nil)!

(CodeFiler organizerFor: Dictionary) reorganizeFrom: #(
('no category methods' keyExists: )) !


!Dictionary methods !
identityValues
        "Answer an IdentitySet containing all the values of the
         key/value pairs in the receiver."
    | answer |
    answer := IdentitySet new.
    self associationsDo: [ :association | answer add: association value].
    ^answer!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Dictionary) reorganizeFrom: #(
('no category methods' identityValues )) !


!Dictionary methods ! 
chooseKey: aBlock
    ^self chooseKey: aBlock ifNone: [nil]!   ! 
#('July 11, 2009' '09:52:55 AM' nil)!

(CodeFiler organizerFor: Dictionary) reorganizeFrom: #(
('extensions' chooseKey: )) !


 

Dictionary subclass: #EphemeronDictionary
  instanceVariableNames: 
    ' manager '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Special Objects' )
  comment: ''!



Object subclass: #HelpManager
  instanceVariableNames: 
    ' applicationWindow helpFile aboutDlgClass helpMode mapDictionary defaultTopic '
  classVariableNames: 
    ' HelpHookProc NextMessageFilterProc SystemContextStrings WmStHelp '
  poolDictionaries: 
    ' CursorConstants OperatingSystemConstants VirtualKeyConstants '
  categories: #( 'Kernel-Host Interfaces' )
  comment: ''!

   

Context variableSubclass: #HomeContext
  instanceVariableNames: 
    ' method receiver code frameOffset '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Objects' )
  comment: ''!

  
HostFileSystemError class instanceVariableNames: ''
  categories: #( )
  comment: ''!

   

CodeWriter subclass: #IBMSmalltalkClassWriter
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'Tools-Code Writers & Readers' )
  comment: ''!

   

Object subclass: #Icon
  instanceVariableNames: 
    ' andMask xorMask name hIcon readOnly dllFileName hLibrary '
  classVariableNames: 
    ' RuntimeIcon '
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Kernel-Host Interfaces' )
  comment: ''!

   

Dictionary subclass: #IdentityDictionary
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Collections' )
  comment: ''!

!IdentityDictionary methods ! 
keysDo: iterationBlock
    "Evaluate the <iterationBlock> once for each key in the receiver. If the receiver is empty, the block will not be evaluated."

    self contents keysAndValuesDo: [:key :value | iterationBlock value: key]!  ! 
#('September 19, 2001' '12:28:57 PM' nil)!

(CodeFiler organizerFor: IdentityDictionary) reorganizeFrom: #(
('no category methods' keysDo: )) !


  

Collection variableSubclass: #IdentityDictionary2D
  instanceVariableNames: 
    ' xKeys '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Collections' )
  comment: ''!

!IdentityDictionary2D methods !
withChangingCollectionKeysAndValuesDo: aBlock
    "Make a pass getting all the keys and use those to iterate with..."
    self keys do: [:key | aBlock value: key value: (self at: key)]! ! 
#('July 9, 2007' '01:19:55 PM' nil)!

(CodeFiler organizerFor: IdentityDictionary2D) reorganizeFrom: #(
('extensions' withChangingCollectionKeysAndValuesDo: )) !


!IdentityDictionary2D methods ! 
keysSortedBy: sortBlock andValuesDo: aBlock
    | sortedXKeys sortedYKeys yCollection object |
    sortedXKeys := xKeys asSortedCollection: sortBlock.
    sortedXKeys do: [:xKey |
        yCollection := xKeys at: xKey.
        sortedYKeys := yCollection keys asSortedCollection: sortBlock.
        sortedYKeys do: [:yKey |
            object := yCollection at: yKey.
            aBlock value: xKey @ yKey value: object]]!   ! 
#('July 9, 2007' '11:55:53 AM' nil)!

(CodeFiler organizerFor: IdentityDictionary2D) reorganizeFrom: #(
('extensions' keysSortedBy:andValuesDo: )) !


!IdentityDictionary2D methods !  
keysSortedBy: sortBlock andValuesDo: aBlock
    | sortedXKeys sortedYKeys yCollection object |
    sortedXKeys := xKeys keys asSortedCollection: sortBlock.
    sortedXKeys do: [:xKey |
        yCollection := xKeys at: xKey.
        sortedYKeys := yCollection keys asSortedCollection: sortBlock.
        sortedYKeys do: [:yKey |
            object := yCollection at: yKey.
            aBlock value: xKey @ yKey value: object]]!  ! 
#('July 9, 2007' '02:18:58 PM' 198496)!

(CodeFiler organizerFor: IdentityDictionary2D) reorganizeFrom: #(
('extensions' keysSortedBy:andValuesDo: )) !


!IdentityDictionary2D methods !   
keysAndValuesDo: aBlock
    xKeys keysAndValuesDo: [:xKey :yCollection |
        yCollection keysAndValuesDo: [:yKey :object |
            aBlock value: xKey @ yKey value: object]]!    ! 
#('July 8, 2007' '12:51:26 PM' nil)!

(CodeFiler organizerFor: IdentityDictionary2D) reorganizeFrom: #(
('primitives' keysAndValuesDo: )) !


!IdentityDictionary2D methods !   
xKeysDo: aBlock
    xKeys keysAndValuesDo: [:xKey :yCollection |
        aBlock value: xKey]! ! 
#('July 8, 2007' '02:10:15 PM' nil)!

(CodeFiler organizerFor: IdentityDictionary2D) reorganizeFrom: #(
('extensions' xKeysDo: )) !


!IdentityDictionary2D methods !   
includesKey: key
    self at: key ifAbsent: [^false].
    ^true!  ! 
#('July 8, 2007' '12:49:12 PM' nil)!

(CodeFiler organizerFor: IdentityDictionary2D) reorganizeFrom: #(
('primitives' includesKey: )) !


!IdentityDictionary2D methods !   
keys
    | allKeys |
    allKeys := OrderedCollection new.
    self keysDo: [:key | allKeys add: key].
    ^allKeys!    ! 
#('July 9, 2007' '01:18:10 PM' nil)!

(CodeFiler organizerFor: IdentityDictionary2D) reorganizeFrom: #(
('primitives' keys )) !


!IdentityDictionary2D methods !   
at: key put: object
    "anIdentityDictionary2D at: object1@object2 put: object3"
    (xKeys at: key x ifAbsentPut: [IdentityDictionary new]) at: key y put: object.
    ^object!    ! 
#('July 8, 2007' '12:45:40 PM' nil)!

(CodeFiler organizerFor: IdentityDictionary2D) reorganizeFrom: #(
('primitives' at:put: )) !


!IdentityDictionary2D methods !
at: key
    ^self at: key ifAbsent: [self halt: 'Missing key ', key printString]!  ! 
#('July 8, 2007' '12:48:15 PM' nil)!

(CodeFiler organizerFor: IdentityDictionary2D) reorganizeFrom: #(
('primitives' at: )) !


!IdentityDictionary2D methods !
at: key ifAbsent: aBlock
    "anIdentityDictionary2D at: object1@object2 put: object3"
    ^(xKeys at: key x ifAbsent: [^aBlock value]) at: key y ifAbsent: aBlock!   ! 
#('July 8, 2007' '12:47:13 PM' nil)!

(CodeFiler organizerFor: IdentityDictionary2D) reorganizeFrom: #(
('primitives' at:ifAbsent: )) !


!IdentityDictionary2D methods !   
withChangingCollectionYKeysFor: xKey do: aBlock
    (xKeys at: xKey) keys asArray keysAndValuesDo: [:yKey :object |
        aBlock value: yKey]!  ! 
#('July 9, 2007' '01:23:20 PM' nil)!

(CodeFiler organizerFor: IdentityDictionary2D) reorganizeFrom: #(
('extensions' withChangingCollectionYKeysFor:do: )) !


!IdentityDictionary2D methods ! 
withChangingCollectionYKeysFor: xKey do: aBlock
    (xKeys at: xKey) keys asArray do: [:yKey |
        aBlock value: yKey]!   ! 
#('July 9, 2007' '02:17:05 PM' 201932)!

(CodeFiler organizerFor: IdentityDictionary2D) reorganizeFrom: #(
('extensions' withChangingCollectionYKeysFor:do: )) !


!IdentityDictionary2D methods !  
yKeysFor: xKey do: aBlock
    (xKeys at: xKey) keysAndValuesDo: [:yKey :object |
        aBlock value: yKey]! ! 
#('July 8, 2007' '02:16:04 PM' nil)!

(CodeFiler organizerFor: IdentityDictionary2D) reorganizeFrom: #(
('extensions' yKeysFor:do: )) !


!IdentityDictionary2D methods !   
keysDo: aBlock
    xKeys keysAndValuesDo: [:xKey :yCollection |
        yCollection keysAndValuesDo: [:yKey :object |
            aBlock value: xKey @ yKey]]!   ! 
#('July 8, 2007' '12:52:19 PM' nil)!

(CodeFiler organizerFor: IdentityDictionary2D) reorganizeFrom: #(
('primitives' keysDo: )) !


!IdentityDictionary2D methods !
initialize
    xKeys := IdentityDictionary new!    ! 
#('July 8, 2007' '12:53:43 PM' nil)!

(CodeFiler organizerFor: IdentityDictionary2D) reorganizeFrom: #(
('initializing' initialize )) !


!IdentityDictionary2D class methods ! 
new
    ^super new initialize! ! 
#('July 8, 2007' '12:55:01 PM' nil)!

(CodeFiler organizerFor: IdentityDictionary2D class) reorganizeFrom: #(
('creating' new )) !


   

Object subclass: #ImageList
  instanceVariableNames: 
    ' extent masked images handle '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



Collection subclass: #IndexedCollection
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Collections' )
  comment: ''!

!IndexedCollection methods !   
allPairs

    | pairs |
    pairs := OrderedCollection new.
    1 to: self size do: [:i | i to: self size do: [:j | pairs add: (Array with: (self at: i) with: (self at: j))]].
    ^pairs!    ! 
#('March 1, 2002' '03:49:17 PM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' allPairs )) !


!IndexedCollection methods !
at8
    ^self at: 8!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('lazy' at8 )) !


!IndexedCollection methods ! 
indexMatching: matchingBlock ifNone: noneBlock
    "Answer the index position of the element for which the matchingBlock returns true; the result of noneBlock otherwise."
    self indexedDo: [:index :element | (matchingBlock value: element) ifTrue: [^index]]. ^noneBlock value! ! 
#('June 6, 2002' '10:02:03 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' indexMatching:ifNone: )) !


!IndexedCollection methods !
multiCollect: aBlock
    "
    #(1 2 3 4 5 6) multiCollect: [:x :y | x@y].
    #(1 2 3 4 5 6) multiCollect: [:x :y :z | x@y@z].
    "
    | count arguments |
    count := aBlock argumentCount.
    ^(1 to: self size by: count) collect: [:index1 |
        arguments := Array new: count.
        1 to: count do: [:index2 | arguments at: index2 put: (self at: index1 + index2 - 1)].
        aBlock evaluateWithArguments: arguments].! ! 
#('August 23, 2006' '03:44:56 PM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' multiCollect: )) !


!IndexedCollection methods ! 
at11
    ^self at: 11! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('lazy' at11 )) !


!IndexedCollection methods !
at19
    ^self at: 19! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('lazy' at19 )) !


!IndexedCollection methods !
indexOfIdentical: anObject
    "Answer the index position of the element equal to anObject in the receiver.
    If no such element is found, answer zero."
    ^self indexOfIdentical: anObject ifAbsent: [^0]!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' indexOfIdentical: )) !


!IndexedCollection methods ! 
secondLast
    ^self at: self size - 1!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' secondLast )) !


!IndexedCollection methods !
delimit: keywordPairs
    "KeywordPairs if of the form
        resultName * keyword1 keyword2 WHERE * optional.
    There are 2 cases:
        1. Without *: everything between keyword1 and keyword2 exclusive is placed in an ordered collection
            and associated with resultName.
        2. With *: assumes 0 or more occurrences of 'resultName keyword1 keyword2' and places the 
            result in a collection of collections..."
            
    | stream commands start end name isStar keyword1 keyword2 lookahead collection result |
self halt: 'Watch delimit...'.
    
    "Extract the keyword pair information in a simple collection that permits looking ahead past * situations..."
    stream := (ReadStream on: self). commands := OrderedCollection new.
    [stream atEnd not] whileTrue: [
        name := stream next.
        isStar := stream peek = #*.
        isStar ifTrue: [stream next].
        keyword1 := stream next.
        keyword2 := stream next.
        commands add: (Array with: name with: isStar with: keyword1 with: keyword2)].
        
    "Use this for building up a dictionary of answers..."
    result := IdentityDictionary new. end := 1.
    commands withNextDo: [:command1 :command2 |
        lookahead := (command2 notNil and: [command2 at2 "isStar"]) ifTrue: [command2 at3 "keyword1"] ifFalse: [nil].
        command1 groupDo: [:name :isStar :keyword1 :keyword2 |
            isStar 
                ifTrue: [
                    collection := OrderedCollection new.
                    start := self indexOf: keyword1 startingAt: end. 
                    [start = 0 or: [lookahead notNil and: [(self indexOf: lookahead startingAt: end) < start]]] whileFalse: [
                        end := self indexOf: keyword2 startingAt: start. 
                        end = 0 ifTrue: [self halt: 'Syntax error: pair ', keyword1, ' ', keyword2, ' not found'].
                        collection add: (self copyFrom: start + 1 to: end - 1).
                        start := self indexOf: keyword1 startingAt: end].
                    result at: name put: collection]
                ifFalse: [
                    start := self indexOf: keyword1 startingAt: end. 
                    start = 0 ifTrue: [self halt: 'Syntax error: pair ', keyword1, ' ', keyword2, ' not found'].
                    end := self indexOf: keyword2 startingAt: start. 
                    end = 0 ifTrue: [self halt: 'Syntax error: pair ', keyword1, ' ', keyword2, ' not found'].
                    result at: name put: (self copyFrom: start + 1 to: end - 1)]]].
                    
    ^result!   ! 
#('July 23, 2006' '10:00:40 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' delimit: )) !


!IndexedCollection methods !
delimit: keywordPairs
    "KeywordPairs if of the form
        resultName * keyword1 keyword2 WHERE * optional.
    There are 2 cases:
        1. Without *: everything between keyword1 and keyword2 exclusive is placed in an ordered collection
            and associated with resultName.
        2. With *: assumes 0 or more occurrences of 'resultName keyword1 keyword2' and places the 
            result in a collection of collections..."
            
    | stream commands start end name isStar keyword1 keyword2 lookahead collection result |
    
    "Extract the keyword pair information in a simple collection that permits looking ahead past * situations..."
    stream := (ReadStream on: keywordPairs). commands := OrderedCollection new.
    [stream atEnd not] whileTrue: [
        name := stream next.
        isStar := stream peek = #*.
        isStar ifTrue: [stream next].
        keyword1 := stream next.
        keyword2 := stream next.
        commands add: (Array with: name with: isStar with: keyword1 with: keyword2)].
        
    "Use this for building up a dictionary of answers..."
    result := IdentityDictionary new. end := 1.
    commands withNextDo: [:command1 :command2 |
        lookahead := (command2 notNil and: [command2 at2 "isStar"]) ifTrue: [command2 at3 "keyword1"] ifFalse: [nil].
        command1 groupDo: [:name :isStar :keyword1 :keyword2 |
            isStar 
                ifTrue: [
                    collection := OrderedCollection new.
                    start := self indexOf: keyword1 startingAt: end. 
                    [start = 0 or: [lookahead notNil and: [(self indexOf: lookahead startingAt: end) < start]]] whileFalse: [
                        end := self indexOf: keyword2 startingAt: start. 
                        end = 0 ifTrue: [self halt: 'Syntax error: pair ', keyword1, ' ', keyword2, ' not found'].
                        collection add: (self copyFrom: start + 1 to: end - 1).
                        start := self indexOf: keyword1 startingAt: end].
                    result at: name put: collection]
                ifFalse: [
                    start := self indexOf: keyword1 startingAt: end. 
                    start = 0 ifTrue: [self halt: 'Syntax error: pair ', keyword1, ' ', keyword2, ' not found'].
                    end := self indexOf: keyword2 startingAt: start. 
                    end = 0 ifTrue: [self halt: 'Syntax error: pair ', keyword1, ' ', keyword2, ' not found'].
                    result at: name put: (self copyFrom: start + 1 to: end - 1)]]].
                    
    ^result!   ! 
#('July 23, 2006' '10:02:05 AM' 206724)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' delimit: )) !


!IndexedCollection methods ! 
delimit: keywordPairs
    "KeywordPairs are of the form
        resultName * keyword1 keyword2 WHERE * optional.
    There are 2 cases:
        1. Without *: everything between keyword1 and keyword2 exclusive is placed in an ordered collection
            and associated with resultName.
        2. With *: assumes 0 or more occurrences of 'resultName keyword1 keyword2' and places the 
            result in a collection of collections..."
            
    | stream commands start end name isStar keyword1 keyword2 lookahead collection result |
    
    "Extract the keyword pair information in a simple collection that permits looking ahead past * situations..."
    stream := (ReadStream on: keywordPairs). commands := OrderedCollection new.
    [stream atEnd not] whileTrue: [
        name := stream next.
        isStar := stream peek = #*.
        isStar ifTrue: [stream next].
        keyword1 := stream next.
        keyword2 := stream next.
        commands add: (Array with: name with: isStar with: keyword1 with: keyword2)].
        
    "Use this for building up a dictionary of answers..."
    result := IdentityDictionary new. end := 1.
    commands withNextDo: [:command1 :command2 |
        lookahead := (command2 notNil and: [command2 at2 "isStar"]) ifTrue: [command2 at3 "keyword1"] ifFalse: [nil].
        command1 groupDo: [:name :isStar :keyword1 :keyword2 |
            isStar 
                ifTrue: [
                    collection := OrderedCollection new.
                    start := self indexOf: keyword1 startingAt: end. 
                    [start = 0 or: [lookahead notNil and: [(self indexOf: lookahead startingAt: end) < start]]] whileFalse: [
                        end := self indexOf: keyword2 startingAt: start. 
                        end = 0 ifTrue: [self halt: 'Syntax error: pair ', keyword1, ' ', keyword2, ' not found'].
                        collection add: (self copyFrom: start + 1 to: end - 1).
                        start := self indexOf: keyword1 startingAt: end].
                    result at: name put: collection]
                ifFalse: [
                    start := self indexOf: keyword1 startingAt: end. 
                    start = 0 ifTrue: [self halt: 'Syntax error: pair ', keyword1, ' ', keyword2, ' not found'].
                    end := self indexOf: keyword2 startingAt: start. 
                    end = 0 ifTrue: [self halt: 'Syntax error: pair ', keyword1, ' ', keyword2, ' not found'].
                    result at: name put: (self copyFrom: start + 1 to: end - 1)]]].
                    
    ^result!  ! 
#('October 10, 2008' '10:53:52 AM' 209548)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' delimit: )) !


!IndexedCollection methods !  
at3
    ^self at: 3!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('lazy' at3 )) !


!IndexedCollection methods ! 
fourth
    ^self at: 4!    ! 
#('August 3, 2001' '09:55:35 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' fourth )) !


!IndexedCollection methods ! 
second
    ^self at: 2!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' second )) !


!IndexedCollection methods !
average: aBlock

    | average |
    average := aBlock value: self first.
    self restDo: [:anObject | average :=  average + (aBlock value: anObject)].
    ^average / self size! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' average: )) !


!IndexedCollection methods !  
extract: symbol ifAbsent: aBlock
    "objectAfter: symbol ifAbsent: aBlock"

    | index |

    index := self indexOf: symbol.
    index = 0 ifTrue:[^aBlock value].
    ^self at: index + 1.!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' extract:ifAbsent: )) !


!IndexedCollection methods ! 
substituteAllIn: collection1 by: collection2
    | copy |
    copy := self shallowCopy.
    collection1 with: collection2 do: [:oldName :newName |
        copy indexedDo: [:index :element |
            element = oldName ifTrue: [copy at: index put: newName]]].
    ^copy!   ! 
#('April 26, 2005' '09:31:44 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' substituteAllIn:by: )) !


!IndexedCollection methods !
substituteAllIn: collection1 by: collection2
    collection1 with: collection2 do: [:oldName :newName |
        self indexedDo: [:index :element |
            element = oldName ifTrue: [self at: index put: newName]]]!    ! 
#('April 26, 2005' '09:40:18 AM' 216492)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' substituteAllIn:by: )) !


!IndexedCollection methods ! 
substituteAllIn: collection1 by: collection2
    | copy |
    copy := self shallowCopy.
    collection1 with: collection2 do: [:oldName :newName |
        copy indexedDo: [:index :element |
            element = oldName ifTrue: [copy at: index put: newName]]].
    ^copy!   ! 
#('April 27, 2005' '08:52:51 AM' 216956)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' substituteAllIn:by: )) !


!IndexedCollection methods ! 
zeroBasedIndexOf: anObject
    "Answer the zero-based index position of the element equal to anObject in the receiver.  If no such element
    is found, answer minus one."
    ^(self indexOf: anObject) - 1!   ! 
#('February 29, 2012' '05:00:59 PM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' zeroBasedIndexOf: )) !


!IndexedCollection methods !   
at12
    ^self at: 12! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('lazy' at12 )) !


!IndexedCollection methods !
maximum: aBlock

    | maximum |
    maximum := aBlock value: self first.
    self restDo: [:anObject | maximum := maximum max: (aBlock value: anObject)].
    ^maximum!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' maximum: )) !


!IndexedCollection methods !  
indexMatching: aBlock
    "Answer the index position of the element for which the block returns true; 0 if none."
    ^self indexMatching: aBlock ifNone: [^0]!   ! 
#('June 6, 2002' '10:02:35 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' indexMatching: )) !


!IndexedCollection methods !   
smallest: aBlock

    | minimum current element |
    element := self first.
    minimum := aBlock value: element.
    self restDo: [:anObject |
        current := aBlock value: anObject.
        current < minimum ifTrue: [minimum := current. element := anObject]].
    ^element! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' smallest: )) !


!IndexedCollection methods ! 
shiftLeft
    ^(self suffix: 1), (self prefix: self size - 1)! ! 
#('March 28, 2009' '03:07:48 PM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' shiftLeft )) !


!IndexedCollection methods !  
shiftLeft
    ^(self suffix: self size - 1), (self prefix: 1)! ! 
#('June 23, 2010' '07:25:41 PM' 219584)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' shiftLeft )) !


!IndexedCollection methods !
firstHalf

    ^self copyFrom: 1 to: (self size // 2) truncated!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' firstHalf )) !


!IndexedCollection methods ! 
indexOfCollection: aCollection
        "Answer the index position of the first occurrence
         of aCollection in the receiver.  If no such element
         is found, answer zero."
    | index1 index2 limit1 limit2 |
    limit2 := aCollection size.
    limit1 := self size - limit2 + 1.
    index1 := 1.
    [index1 <= limit1]
        whileTrue: [
            (self at: index1) = (aCollection at: 1)
                ifTrue: [
                    index2 := 2.
                    [index2 <= limit2
                        and: [ (self at: index1 + index2 - 1) =
                            ( aCollection at: index2 ) ] ]
                        whileTrue: [index2 := index2 + 1].
                    index2 > limit2
                        ifTrue: [ ^index1] ].
            index1 := index1 + 1].
    ^0!  ! 
#('March 18, 2005' '02:20:30 PM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('no category methods' indexOfCollection: )) !


!IndexedCollection methods !
indexOfCollection: aCollection
    ^self indexOfCollection: aCollection startingAt: 1! ! 
#('March 18, 2005' '02:20:30 PM' 220308)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('no category methods' indexOfCollection: )) !


!IndexedCollection methods ! 
at6
    ^self at: 6!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('lazy' at6 )) !


!IndexedCollection methods ! 
at20
    ^self at: 20! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('lazy' at20 )) !


!IndexedCollection methods !
at13
    ^self at: 13! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('lazy' at13 )) !


!IndexedCollection methods !
at: key do: aBlock

    aBlock value: (self at: key ifAbsent: [^self])!   ! 
#('December 10, 2001' '12:10:32 PM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' at:do: )) !


!IndexedCollection methods !  
with: collection1 with: collection2 with: collection3 do: aBlock
        "For each quadruple of elements, evaluate aBlock with those elements as the
         arguments.  All collections must contain the same number of elements, else report an error."
    (self size = collection1 size) & (self size = collection2 size) & (self size = collection3 size)
        ifFalse: [^self error: 'Collections are differing lengths'].
    1 to: self size do: [:index |
            aBlock
                value: (self at: index)
                value: (collection1 at: index)
                value: (collection2 at: index)
                value: (collection3 at: index)]!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' with:with:with:do: )) !


!IndexedCollection methods !
randomElement
    ^self at: (RandomNumberStream nextIntegerFrom: 1 to: self size)! ! 
#('February 12, 2003' '11:31:20 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' randomElement )) !


!IndexedCollection methods !   
pairwiseDo: aTwoArgumentBlock
    "Do aTwoArugmentBlock with every possible pairing of the receiver's elements."

    | object1 |
    1 to: self size do: [:index1 |
        object1 := self at: index1.
        index1 to: self size do: [:index2 |
            aTwoArgumentBlock value: object1 value: (self at: index2)]]!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' pairwiseDo: )) !


!IndexedCollection methods !   
pairwiseDo: aTwoArgumentBlock
    "Do aTwoArgmentBlock with every possible pairing of the receiver's elements."

    | object1 |
    1 to: self size do: [:index1 |
        object1 := self at: index1.
        index1 to: self size do: [:index2 |
            aTwoArgumentBlock value: object1 value: (self at: index2)]]! ! 
#('July 31, 2012' '03:03:36 PM' 223548)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' pairwiseDo: )) !


!IndexedCollection methods !  
at1
    ^self at: 1!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('lazy' at1 )) !


!IndexedCollection methods ! 
with: collection1 with: collection2 do: aBlock
        "For each triple of elements (the first from the
         receiver, the second from collection1, and the third from
         collection2), evaluate aBlock with those elements as the
         arguments.  All collections must contain the same
         number of elements, else report an error."
    (self size = collection1 size) & (self size = collection2 size)
        ifFalse: [^self error: 'Collections are differing lengths'].
    1 to: self size do: [:index |
            aBlock
                value: (self at: index)
                value: (collection1 at: index)
                value: (collection2 at: index)]!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' with:with:do: )) !


!IndexedCollection methods ! 
distinctPairwiseDo: aTwoArgumentBlock
    "Do aTwoArugmentBlock with every possible distinct pairing of the receiver's elements."

    | object1 object2 |
    1 to: self size do: [:index1 |
        object1 := self at: index1.
        index1 to: self size do: [:index2 |
            object2 := self at: index2.
            object1 ~~ object2 ifTrue: [aTwoArgumentBlock value: object1 value: object2]]]!   ! 
#('February 12, 2003' '10:58:37 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' distinctPairwiseDo: )) !


!IndexedCollection methods ! 
copyWithoutIndex: index
    "Answer a copy of the receiver excluding the element specified by index..."
    ^(self copyFrom: 1 to: index - 1), (self copyFrom: index + 1 to: self size)!  ! 
#('June 23, 2010' '07:14:34 PM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' copyWithoutIndex: )) !


!IndexedCollection methods !   
at9
    ^self at: 9!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('lazy' at9 )) !


!IndexedCollection methods ! 
restDo: aBlock
    2 to: self size do: [:index | aBlock value: (self at: index)]!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' restDo: )) !


!IndexedCollection methods !   
copyWithoutIdentical: anObject
    "Answer a copy of the receiver excluding the first element that equals anObject, if any."
    | index |
    index := self indexOfIdentical: anObject ifAbsent: [^self shallowCopy].
    ^(self copyFrom: 1 to: index - 1), ((self copyFrom: index + 1 to: self size) copyWithoutIdentical: anObject)!    ! 
#('August 29, 2001' '11:17:51 PM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('no category methods' copyWithoutIdentical: )) !


!IndexedCollection methods !
at14
    ^self at: 14! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('lazy' at14 )) !


!IndexedCollection methods !
copyWithoutAny: anObject
        "Answer a copy of the receiver excluding all elements that equal anObject."

    | inputStream result |
    inputStream := ReadStream on: self.
    result := OrderedCollection new.
    [inputStream atEnd] whileFalse: [result addAll: (inputStream upTo: anObject)].
    ^self species withAll: result!  ! 
#('November 22, 2001' '02:55:45 PM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('no category methods' copyWithoutAny: )) !


!IndexedCollection methods !
objectAfter: symbol

    ^self objectAfter: symbol ifAbsent:[^nil].!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' objectAfter: )) !


!IndexedCollection methods !  
lastHalf

    ^self copyFrom: (self size // 2) truncated + 1 to: self size!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' lastHalf )) !


!IndexedCollection methods !  
indexOf: anObject ifAbsent: aBlock
        "Answer the index position of the element equal
         to anObject in the receiver.  If no such element
         is found, evaluate aBlock (without any arguments)."
    | index size |
    size := self size.
    index := 1.
    [index <= size]
        whileTrue: [
            (self at: index) = anObject
                ifTrue: [^index].
            index := index + 1].
    ^aBlock value!  ! 
#('September 23, 2005' '08:45:10 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('no category methods' indexOf:ifAbsent: )) !


!IndexedCollection methods ! 
indexOf: anObject ifAbsent: aBlock
    "Answer the index position of the element equal to anObject in the receiver.  If no such element
    is found, evaluate aBlock (without any arguments)."
    
    ^self indexOf: anObject startingAt: 1 ifAbsent: aBlock!    ! 
#('September 23, 2005' '08:45:10 AM' 228796)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('no category methods' indexOf:ifAbsent: )) !


!IndexedCollection methods !  
indexOf: anObject startingAt: start
    "Answer the index position of the element equal to anObject in the receiver.  If no such element
    is found, answer zero."
    ^self indexOf: anObject startingAt: start ifAbsent: [^0]!   ! 
#('September 23, 2005' '08:46:14 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' indexOf:startingAt: )) !


!IndexedCollection methods !
at4
    ^self at: 4!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('lazy' at4 )) !


!IndexedCollection methods ! 
at15
    ^self at: 15! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('lazy' at15 )) !


!IndexedCollection methods !
verify: x isSolutionFor: y
    "Verifies that Ax=y (n equations in n unknowns) where self is A (an array of arrays)"
    | sum |
    self with: y do: [:subarray :yElement |
        sum := 0.0.
        subarray with: x do: [:arrayElement :xElement | sum := sum + (arrayElement * xElement)].
        (sum - yElement) abs < WorldGlobal epsilon ifFalse: [self halt: 'Solution does not match']]!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('equation solving' verify:isSolutionFor: )) !


!IndexedCollection methods !   
firstOrNil
    ^self isEmpty ifTrue: [nil] ifFalse: [self first]!  ! 
#('February 25, 2005' '05:24:22 PM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' firstOrNil )) !


!IndexedCollection methods !  
largest: aBlock

    | maximum current element |
    element := self first.
    maximum := aBlock value: element.
    self restDo: [:anObject |
        current := aBlock value: anObject.
        current > maximum ifTrue: [maximum := current. element := anObject]].
    ^element!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' largest: )) !


!IndexedCollection methods !  
indexOfIdenticalCollection: aCollection
        "Answer the index position of the first occurrence
         of aCollection in the receiver.  If no such element
         is found, answer zero."
    | index1 index2 limit1 limit2 |
    limit2 := aCollection size.
    limit1 := self size - limit2 + 1.
    index1 := 1.
    [index1 <= limit1]
        whileTrue: [
            (self at: index1) == (aCollection at: 1)
                ifTrue: [
                    index2 := 2.
                    [index2 <= limit2
                        and: [ (self at: index1 + index2 - 1) ==
                            ( aCollection at: index2 ) ] ]
                        whileTrue: [index2 := index2 + 1].
                    index2 > limit2
                        ifTrue: [ ^index1] ].
            index1 := index1 + 1].
    ^0!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' indexOfIdenticalCollection: )) !


!IndexedCollection methods !   
at7
    ^self at: 7!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('lazy' at7 )) !


!IndexedCollection methods ! 
copyTo: index
    ^self copyFrom: 1 to: index! ! 
#('November 15, 2002' '10:03:49 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' copyTo: )) !


!IndexedCollection methods ! 
rest
    ^self copyFrom: 2 to: self size!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' rest )) !


!IndexedCollection methods !  
at16
    ^self at: 16! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('lazy' at16 )) !


!IndexedCollection methods !
, aCollection
    "Answer a new collection containing the elements of the receiver followed by the elements of aCollection."
    | answer size1 size2 |
    aCollection isCollection ifFalse: [ self error: 'Argument must be a Collection' ].
    size1 := self size.
    size2 := size1 + aCollection size.
    answer := self species new: size2.
    answer replaceFrom: 1 to: size1 with: self startingAt: 1.
    answer replaceFrom: size1 + 1 to: size2 with: aCollection startingAt: 1.
    ^answer!   ! 
#('March 31, 2003' '11:53:21 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('no category methods' , )) !


!IndexedCollection methods ! 
hash
        "Answer the size of the receiver as its hash value."
    ^self size! ! 
#('October 15, 2009' '03:22:34 PM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('no category methods' hash )) !


!IndexedCollection methods !
hash
    "Answer a hash value that uses one element."
    ^self isEmpty ifTrue: [self size] ifFalse: [self size + (self at: 1) hash]! ! 
#('October 15, 2009' '03:22:34 PM' 234540)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('no category methods' hash )) !


!IndexedCollection methods ! 
indexOfIdentical: anObject ifAbsent: aBlock
    "Answer the index position of the element identical
    to anObject in the receiver.  If no such element
    is found, evaluate aBlock (without any arguments)."
    | index size |
    size := self size. index := 1.
    [index <= size] whileTrue: [
        (self at: index) == anObject ifTrue: [^index]. index := index + 1].
    ^aBlock value
!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' indexOfIdentical:ifAbsent: )) !


!IndexedCollection methods !
at2
    ^self at: 2!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('lazy' at2 )) !


!IndexedCollection methods ! 
minimum: aBlock

    | minimum |
    minimum := aBlock value: self first.
   self restDo: [:anObject | minimum := minimum min: (aBlock value: anObject)].
    ^minimum!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' minimum: )) !


!IndexedCollection methods !  
randomElements: number
    "Answer a collection with the given number of random elements from the receiver."

    | uniqueElements duplicateElements numberOfDuplicates |
    number < self size ifTrue: [^self uniqueRandomElements: number].
    uniqueElements := self uniqueRandomElements: self size.
    duplicateElements := OrderedCollection new. numberOfDuplicates := number - self size.
    [duplicateElements size < numberOfDuplicates] whileTrue: [duplicateElements add: (RandomNumberStream nextIntegerFrom: 1 to: self size)].
    ^uniqueElements addAll: (duplicateElements collect: [:index | self at: index]); yourself! ! 
#('March 6, 2002' '11:15:20 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' randomElements: )) !


!IndexedCollection methods ! 
steppingMultiDo: aBlock
    "
    #(1 2 3 4 5 6) steppingMultiDo: [:x :y | Transcript cr; << x; space; << y].
    #(1 2 3 4 5 6) steppingMultiDo: [:x :y :z | Transcript cr; << x; space; << y; space; << z].
    "
    | count group |
    count := aBlock argumentCount.
    1 to: self size - count + 1 do: [:index1 |
        group := Array new: count.
        1 to: count do: [:index2 | group at: index2 put: (self at: index1 + index2 - 1)].
        aBlock evaluateWithArguments: group].! ! 
#('August 24, 2005' '09:08:08 PM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' steppingMultiDo: )) !


!IndexedCollection methods !  
extract: symbol
    "objectAfter: symbol"

    ^self extract: symbol ifAbsent: [^nil].!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' extract: )) !


!IndexedCollection methods !  
third
    ^self at: 3! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' third )) !


!IndexedCollection methods ! 
at17
    ^self at: 17! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('lazy' at17 )) !


!IndexedCollection methods !
shiftRight
    ^(self suffix: self size - 1), (self prefix: 1)!    ! 
#('March 28, 2009' '03:07:11 PM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' shiftRight )) !


!IndexedCollection methods ! 
shiftRight
    ^(self suffix: 1), (self prefix: self size - 1)!    ! 
#('June 23, 2010' '07:25:39 PM' 238404)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' shiftRight )) !


!IndexedCollection methods !   
objectAfter: symbol ifAbsent: aBlock

    | index |

    index := self indexOf: symbol.
    index = 0 ifTrue:[^aBlock value].
    ^self at: index + 1.!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' objectAfter:ifAbsent: )) !


!IndexedCollection methods ! 
indexOfCollection: aCollection startingAt: start
        "Answer the index position of the first occurrence
         of aCollection in the receiver.  If no such element
         is found, answer zero."
    | index1 index2 limit1 limit2 |
    limit2 := aCollection size.
    limit1 := self size - limit2 + 1.
    index1 := start.
    [index1 <= limit1]
        whileTrue: [
            (self at: index1) = (aCollection at: 1)
                ifTrue: [
                    index2 := 2.
                    [index2 <= limit2
                        and: [ (self at: index1 + index2 - 1) =
                            ( aCollection at: index2 ) ] ]
                        whileTrue: [index2 := index2 + 1].
                    index2 > limit2
                        ifTrue: [ ^index1] ].
            index1 := index1 + 1].
    ^0!    ! 
#('March 18, 2005' '02:19:57 PM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('no category methods' indexOfCollection:startingAt: )) !


!IndexedCollection methods ! 
copyReplacingAll: collection1 by: collection2
    "Replace every occurrence of each subcollection in collection1 with the corresponding subcollection in collection2."

    | whichs starts index results resultsWithoutZeros which suffix min stream newIndex |

    whichs := OrderedCollection new. starts := OrderedCollection new.
    index := 1.

    "Make a pass to determine where replacements need to be made."
    [index <= self size] whileTrue: [
        suffix := self suffix: (self size - index + 1).
        results := collection1 collect: [:subcollection | suffix indexOfCollection: subcollection].
        resultsWithoutZeros := results select: [:start | start ~= 0].
        resultsWithoutZeros isEmpty
            ifTrue: [index := self size + 1. "We're done..."]
            ifFalse: [
                min := resultsWithoutZeros minimum.
                which := results indexOf: min.
                newIndex := index + min - 1.
                starts add: newIndex.
                whichs add: which.
                index := newIndex + (collection1 at: which) size]].

    "Make a pass to make the replacements."
    stream := WriteStream on: (self shallowCopy).

    index := 1.
    whichs with: starts do: [:which :start|
        stream nextPutAll: (self copyFrom: index to: start - 1).
        stream nextPutAll: (collection2 at: which).
        index := start + (collection1 at: which) size].

    stream nextPutAll: (self copyFrom: index to: self size).

    ^stream contents!   ! 
#('March 30, 2003' '10:50:29 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' copyReplacingAll:by: )) !


!IndexedCollection methods !   
copyReplacingAll: collection1 by: collection2
    "Replace every occurrence of each subcollection in collection1 with the corresponding subcollection in collection2."

    | whichs starts index results resultsWithoutZeros which min stream newIndex |

    whichs := OrderedCollection new. starts := OrderedCollection new.
    index := 1.

    "Make a pass to determine where replacements need to be made."
    [index <= self size] whileTrue: [
        results := collection1 collect: [:subcollection | self indexOfCollection: subcollection startingAt: index].
        resultsWithoutZeros := results select: [:start | start ~= 0].
        resultsWithoutZeros isEmpty
            ifTrue: [index := self size + 1. "We're done..."]
            ifFalse: [
                min := resultsWithoutZeros minimum.
                which := results indexOf: min.
                newIndex := index + min - 1.
                starts add: newIndex.
                whichs add: which.
                index := newIndex + (collection1 at: which) size]].

    "Make a pass to make the replacements."
    stream := WriteStream on: (self shallowCopy).

    index := 1.
    whichs with: starts do: [:which :start|
        stream nextPutAll: (self copyFrom: index to: start - 1).
        stream nextPutAll: (collection2 at: which).
        index := start + (collection1 at: which) size].

    stream nextPutAll: (self copyFrom: index to: self size).

    ^stream contents!   ! 
#('March 18, 2005' '02:22:57 PM' 240300)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' copyReplacingAll:by: )) !


!IndexedCollection methods !
copyReplacingAll: collection1 by: collection2
    "Replace every occurrence of each subcollection in collection1 with the corresponding subcollection in collection2."

    | whichs starts index results resultsWithoutZeros which min stream |

    whichs := OrderedCollection new. starts := OrderedCollection new.
    index := 1.

    "Make a pass to determine where replacements need to be made."
    [index <= self size] whileTrue: [
        results := collection1 collect: [:subcollection | self indexOfCollection: subcollection startingAt: index].
        resultsWithoutZeros := results select: [:start | start ~= 0].
        resultsWithoutZeros isEmpty
            ifTrue: [index := self size + 1. "We're done..."]
            ifFalse: [
                min := resultsWithoutZeros minimum.
                which := results indexOf: min.
                starts add: min.
                whichs add: which.
                index := min + (collection1 at: which) size]].

    "Make a pass to make the replacements."
    stream := WriteStream on: (self shallowCopy).

    index := 1.
    whichs with: starts do: [:which :start|
        stream nextPutAll: (self copyFrom: index to: start - 1).
        stream nextPutAll: (collection2 at: which).
        index := start + (collection1 at: which) size].

    stream nextPutAll: (self copyFrom: index to: self size).

    ^stream contents!    ! 
#('March 18, 2005' '02:31:43 PM' 242020)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' copyReplacingAll:by: )) !


!IndexedCollection methods !
at5
    ^self at: 5!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('lazy' at5 )) !


!IndexedCollection methods ! 
randomize
    "Randomize the order of the receiver's elements."

    | element randomIndex |
    1 to: self size do: [:index |
        randomIndex := RandomNumberStream nextIntegerFrom: 1 to: index.
        element := self at: randomIndex.
        self
            at: randomIndex put: (self at: index);
            at: index put: element].!  ! 
#('March 6, 2002' '11:02:37 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' randomize )) !


!IndexedCollection methods !   
indexOf: anObject
        "Answer the index position of the element equal
         to anObject in the receiver.  If no such element
         is found, answer zero."
    ^self
        indexOf: anObject
        ifAbsent: [^0]!  ! 
#('September 23, 2005' '08:45:51 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('no category methods' indexOf: )) !


!IndexedCollection methods !  
indexOf: anObject
    "Answer the index position of the element equal to anObject in the receiver.  If no such element
    is found, answer zero."
    ^self indexOf: anObject startingAt: 1 ifAbsent: [^0]! ! 
#('September 23, 2005' '08:45:52 AM' 246016)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('no category methods' indexOf: )) !


!IndexedCollection methods !   
solve: Y
    "Solves Ax=Y (n equations in n unknowns) where self is A (an array of arrays)"
    "self halt. #((2 2) (10 -10)) solve: #(4 0). Should be #(1 1)"
    "self halt. #((1 2 3) (-1 0 -1) (0 3 4)) solve: #(5 - 3 5). Should be #(1 -1 2)"
    "self halt. #((0 0 8.6) (-78 0 8.6) (-78 -78 8.6)) solve: #(0 1 1). Should be (-0.12820513e-1 0.0 0.0)."
    "self halt. #((0 0 8.6) (-78 0 8.6) (-78 -78 8.6)) solve: #(0 0 1). Should be (0.0 -0.12820513e-1 0.0)."

    "Based on the code in Graphics Gems IV, p554-555."
    | array solution rowWithLargestPivotSoFar save currentAbsolutePivot largestAbsolutePivot scale row offDiagonalRow y |
    array := self collect: [:subarray | subarray shallowCopy].
    y := Y shallowCopy.

    "Loop over the columns of array from left to right, eliminating above and below diagonal."
   1 to: array size do: [:i |
        row := array at: i.
        "Find largest pivot in column i among rows i..n"
        rowWithLargestPivotSoFar := i. largestAbsolutePivot := (row at: i) abs.
        i+1 to: array size do: [:k |
            currentAbsolutePivot := ((array at: k) at: i) abs.
            currentAbsolutePivot > largestAbsolutePivot
                ifTrue: [rowWithLargestPivotSoFar := k. largestAbsolutePivot := currentAbsolutePivot]].

        "Swap row i with the row that has the largest pivot candidate.  This puts the pivot on the diagonal. Also, swap the corresponding solutions..."
        i ~= rowWithLargestPivotSoFar ifTrue: [
            save := array at: rowWithLargestPivotSoFar. array at: i put: save. array at: rowWithLargestPivotSoFar put: row. row := save.
            save := y at: i. y at: i put: (y at: rowWithLargestPivotSoFar). y at: rowWithLargestPivotSoFar put: save].

        "Scale row i to have a unit diagonal"
        scale := row at: i.
        scale abs < WorldGlobal epsilon
            ifTrue: [
                (y at: i) abs < WorldGlobal epsilon
                    ifTrue: ["In this special case, 0x = 0 has an infinite number of solutions. Pick x = 0." y at: i put: 0.0]
                    ifFalse: [^nil "^self error: 'Singular matrix, can''t invert!!'"]]
            ifFalse: [
                scale := 1.0 / scale.
                i to: array size do: [:k | row at: k put: (row at: k) * scale].
                y at: i put: (y at: i) * scale.

                "Eliminate off-diagonal elements in column i of array."
                1 to: array size do: [:k |
                    i ~= k ifTrue: [
                        offDiagonalRow := array at: k. scale := offDiagonalRow at: i.
                        i to: array size do: [:j | offDiagonalRow at: j put: (offDiagonalRow at: j) - (scale * (row at: j))].
                        y at: k put: (y at: k) - (scale * (y at: i))]]]].

    self verify: y isSolutionFor: Y.
    ^y!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('equation solving' solve: )) !


!IndexedCollection methods !  
at10
    ^self at: 10! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('lazy' at10 )) !


!IndexedCollection methods !
at18
    ^self at: 18! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('lazy' at18 )) !


!IndexedCollection methods !
multiDo: aBlock
    "
    #(1 2 3 4 5 6) multiDo: [:x :y | Transcript cr; << x; space; << y].
    #(1 2 3 4 5 6) multiDo: [:x :y :z | Transcript cr; << x; space; << y; space; << z].
    "
    | count arguments |
    count := aBlock argumentCount.
    1 to: self size by: count do: [:index1 |
        arguments := Array new: count.
        1 to: count do: [:index2 | arguments at: index2 put: (self at: index1 + index2 - 1)].
        aBlock evaluateWithArguments: arguments].!   ! 
#('November 4, 2002' '11:11:43 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' multiDo: )) !


!IndexedCollection methods ! 
uniqueRandomElements: number
    "Answer a collection with the given number of unique random elements from the receiver."

    | elements |
    number > self size ifTrue: [self error: 'Too few elements.'].
    elements := OrderedCollection new.
    [elements size < number] whileTrue: [elements addIfIdenticalAbsent: (RandomNumberStream nextIntegerFrom: 1 to: self size)].
    ^elements collect: [:index | self at: index]!   ! 
#('March 6, 2002' '11:00:00 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' uniqueRandomElements: )) !


!IndexedCollection methods !   
indexOf: anObject startingAt: start ifAbsent: aBlock
        "Answer the index position of the element equal
         to anObject in the receiver.  If no such element
         is found, evaluate aBlock (without any arguments)."
    | index size |
    size := self size.
    index := start.
    [index <= size] whileTrue: [
            (self at: index) = anObject ifTrue: [^index].
            index := index + 1].
    ^aBlock value!  ! 
#('September 23, 2005' '08:43:45 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' indexOf:startingAt:ifAbsent: )) !


!IndexedCollection methods !   
copyFrom: index
    ^self copyFrom: index to: self size!   ! 
#('June 3, 2002' '09:38:16 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' copyFrom: )) !


!IndexedCollection methods !
randomized
    "Answer a copy of the receiver in random order"

    ^self shallowCopy randomize! ! 
#('March 6, 2002' '10:41:36 AM' nil)!

(CodeFiler organizerFor: IndexedCollection) reorganizeFrom: #(
('extensions' randomized )) !


  

IndexedCollection subclass: #FixedSizeCollection
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Collections' )
  comment: ''!

!FixedSizeCollection methods !
flattened

    | resultCollection |
    resultCollection := OrderedCollection new: self size.
    self do: [:element |
        (element isCollection and: [self isString not])
            ifTrue: [resultCollection addAll: element flattened]
            ifFalse: [resultCollection add: element]].
    ^resultCollection!   ! 
#('November 1, 2007' '09:30:12 AM' nil)!

(CodeFiler organizerFor: FixedSizeCollection) reorganizeFrom: #(
('extensions' flattened )) !


!FixedSizeCollection methods !
flattened

    | resultCollection |
    resultCollection := OrderedCollection new: self size.
    self do: [:element |
        (element isCollection and: [element isString not])
            ifTrue: [resultCollection addAll: element flattened]
            ifFalse: [resultCollection add: element]].
    ^resultCollection!    ! 
#('November 1, 2007' '09:31:56 AM' 252880)!

(CodeFiler organizerFor: FixedSizeCollection) reorganizeFrom: #(
('extensions' flattened )) !


!FixedSizeCollection methods ! 
flattened

    | resultCollection |
    resultCollection := OrderedCollection new: self size.
    self do: [:element |
        (element isCollection and: [element isString not])
            ifTrue: [resultCollection addAll: element flattened]
            ifFalse: [resultCollection add: element]].
    ^resultCollection!    ! 
#('November 30, 2007' '04:53:42 PM' 253388)!

(CodeFiler organizerFor: FixedSizeCollection) reorganizeFrom: #(
('extensions' flattened )) !


!FixedSizeCollection methods !
asBareString
    | aStream |
    aStream := WriteStream on: (String new: 100).
    self do: [:item | aStream << (item); << ' '].
    aStream position: (aStream position - 1).
    ^aStream contents!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: FixedSizeCollection) reorganizeFrom: #(
('no category methods' asBareString )) !


!FixedSizeCollection class methods !   
with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject
    | answer |
    answer := self new: 5.
    answer at: 1 put: firstObject.
    answer at: 2 put: secondObject.
    answer at: 3 put: thirdObject.
    answer at: 4 put: fourthObject.
    answer at: 5 put: fifthObject.
    ^answer! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: FixedSizeCollection class) reorganizeFrom: #(
('no category methods' with:with:with:with:with: )) !




FixedSizeCollection variableSubclass: #Array
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Collections' )
  comment: ''!

!Array methods !  
asFloat
    self halt: 'Cannot convert an array to a float'!   ! 
#('May 28, 2009' '03:06:26 PM' nil)!

(CodeFiler organizerFor: Array) reorganizeFrom: #(
('no category methods' asFloat )) !


!Array methods ! 
printOn: aStream
        "Append the ASCII representation
         of the receiver to aStream."
    | limit |
    aStream isStream ifFalse: [^aStream nextPutAll: self printString].
    (RecursiveSet includes: self)
        ifTrue: [^self printRecursionOn: aStream].
    RecursiveSet add: self.
    limit := aStream position + self printLimit.
    aStream nextPut: $(.
    1 to: self size - 1 do: [ :element |
        (aStream position > limit)
            ifTrue: [
                '...etc...)' printOn: aStream.
                RecursiveSet remove: self ifAbsent: [].
                ^self].
        (self at: element) printOn: aStream.
        aStream space].
    self isEmpty
        ifFalse: [
            self last printOn: aStream].
    aStream nextPut: $).
    RecursiveSet remove: self ifAbsent: []
! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Array) reorganizeFrom: #(
('no category methods' printOn: )) !


 

FixedSizeCollection variableByteSubclass: #ByteArray
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Collections' )
  comment: ''!

!ByteArray methods !   
asByteArray
    ^self "already a byte array"!  ! 
#('October 18, 2013' '04:23:32 PM' nil)!

(CodeFiler organizerFor: ByteArray) reorganizeFrom: #(
('extension' asByteArray )) !


   

Array variableSubclass: #CompiledMethod
  instanceVariableNames: 
    ' byteCodeArray executableCode class selector sourceObject info '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Compiler Support' )
  comment: ''!

!CompiledMethod methods !  
source
        "Answer a String containing the source
        code for the receiver."
    sourceObject == nil ifTrue: [ ^nil ].
    sourceObject isInteger ifFalse: [ ^sourceObject asString ].
    ^( StringReference fromCompiledMethod: self ) asString!    ! 
#('March 30, 2003' '10:30:51 AM' nil)!

(CodeFiler organizerFor: CompiledMethod) reorganizeFrom: #(
('no category methods' source )) !


!CompiledMethod methods !  
source
    "Answer a String containing the source code for the receiver."
    sourceObject == nil ifTrue: [^nil].
    sourceObject isInteger ifFalse: [^sourceObject asString].
    ^(StringReference fromCompiledMethod: self) asString!   ! 
#('March 30, 2003' '10:30:51 AM' 257400)!

(CodeFiler organizerFor: CompiledMethod) reorganizeFrom: #(
('no category methods' source )) !



HashTable class instanceVariableNames: ''
  categories: #( )
  comment: ''!

 

HashTable variableSubclass: #BucketHashTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Collections' )
  comment: ''!

!BucketHashTable methods !
keysAndValuesDo: iterationBlock
        "Evaluate the iterationBlock once for each key/value pair in the receiver.
        The key will be the first argument, the value will be the second argument
        to the block."

    | bucket |
    1 to: self size // 2 do: [:index |
        (bucket := self at: index * 2) == nil
            ifFalse: [bucket keysAndValuesDo: iterationBlock]]!    ! 
#('September 19, 2001' '12:28:58 PM' nil)!

(CodeFiler organizerFor: BucketHashTable) reorganizeFrom: #(
('no category methods' keysAndValuesDo: )) !


!BucketHashTable methods !  
elementsDo: iterationBlock
        "Evaluate the iterationBlock once for each element in the receiver. If the receiver is empty,
        the block will not be evaluated."

    | bucket |
    1 to: self size // 2 do: [:bucketIndex |
        (bucket := self at: bucketIndex * 2) == nil ifFalse: [bucket elementsDo: iterationBlock]]!    ! 
#('December 21, 2001' '05:07:32 PM' nil)!

(CodeFiler organizerFor: BucketHashTable) reorganizeFrom: #(
('no category methods' elementsDo: )) !


  

Color subclass: #IndexedColor
  instanceVariableNames: 
    ' index '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'Base-Graphics' )
  comment: ''!



Object subclass: #InitializationFile
  instanceVariableNames: 
    ' file handle '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Services-Service Manager' )
  comment: ''!

   

Object subclass: #InitializationFileSection
  instanceVariableNames: 
    ' initializationFile section '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Services-Service Manager' )
  comment: ''!

 

Object subclass: #InputEvent
  instanceVariableNames: 
    ' type value x y typeArray button '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Processes and Events' )
  comment: ''!



FixedSizeCollection subclass: #Interval
  instanceVariableNames: 
    ' beginning end increment '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Collections' )
  comment: ''!

!Interval methods ! 
@ anInterval
    ^Point new x: self; y: anInterval!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Interval) reorganizeFrom: #(
('extensions' @ )) !


!Interval methods !   
printOn: aStream
        "Append the ASCII representation of the receiver to aStream."
    beginning printOn: aStream.
    aStream nextPutAll: ' to: '.
    end printOn: aStream.
    increment = 1 ifTrue: [^self].
    aStream nextPutAll: ' by: '.
    increment printOn: aStream!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Interval) reorganizeFrom: #(
('extensions' printOn: )) !


!Interval methods !
random

    beginning isFloat ifTrue: [^RandomNumberStream nextFrom: beginning to: end].
    ^RandomNumberStream nextIntegerFrom: beginning to: end! ! 
#('March 14, 2001' '11:00:05 AM' nil)!

(CodeFiler organizerFor: Interval) reorganizeFrom: #(
('extensions' random )) !


  

DynamicLinkLibrary variableByteSubclass: #KernelDLL
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-DLLs' )
  comment: ''!

 

DynamicLinkLibrary16 variableByteSubclass: #KernelDLL16
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-DLLs' )
  comment: ''!

 

Object subclass: #KeyboardInputEvent
  instanceVariableNames: 
    ' characterValue scanCode virtualKey shiftState '
  classVariableNames: 
    ' ControlKeys CursorKeys '
  poolDictionaries: 
    ' OperatingSystemConstants VirtualKeyConstants '
  categories: #( 'Kernel-Processes and Events' )
  comment: ''!



Object subclass: #LatestChangesExtractor
  instanceVariableNames: 
    ' changeLog stack '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'Tools-Development Support' )
  comment: ''!

!LatestChangesExtractor methods !   
handleImageSaved!   ! 
#('August 29, 2001' '03:07:37 PM' nil)!

(CodeFiler organizerFor: LatestChangesExtractor) reorganizeFrom: #(
('private' handleImageSaved )) !


!LatestChangesExtractor methods !   
identify: chunkString
    "Answer a chunk for the given chunkString."

    (chunkString indexOfString: '"*** Image started on: ') > 0 ifTrue: [^SourceChunk imageStartup: chunkString].
    (chunkString indexOfString: '"*** saved image on: ') > 0 ifTrue: [^SourceChunk imageSave: (chunkString asArrayOfSubstringsSeparatedBy: Cr) last zapCrs].
    (chunkString beginsWith: '''Synchronization Point ') ifTrue: [^SourceChunk synchronizationPoint: chunkString].
    (chunkString beginsWith: '''') ifTrue: [^SourceChunk doit: chunkString].
    (chunkString beginsWith: '"') ifTrue: [^SourceChunk doit: chunkString].
    ^SourceChunk code: chunkString!    ! 
#('August 29, 2001' '03:07:37 PM' nil)!

(CodeFiler organizerFor: LatestChangesExtractor) reorganizeFrom: #(
('private' identify: )) !


!LatestChangesExtractor methods !  
readChangesFrom: filename

    self openFilename: filename.
    self readChunks! ! 
#('August 29, 2001' '03:07:37 PM' nil)!

(CodeFiler organizerFor: LatestChangesExtractor) reorganizeFrom: #(
('reading' readChangesFrom: )) !


!LatestChangesExtractor methods !   
writeChangesTo: filename

    | file |
    file := File pathName: filename.
    Transcript cr; << 'Writing changes to '; << filename; << ' ...'.
    [stack do: [:chunk | chunk isBoundary ifFalse: [chunk storeOn: file]]] ensure: [file close].
    Transcript << 'done.'!  ! 
#('August 29, 2001' '03:07:37 PM' nil)!

(CodeFiler organizerFor: LatestChangesExtractor) reorganizeFrom: #(
('writing' writeChangesTo: )) !


!LatestChangesExtractor methods !
handleImageSynchonized
    "Top of stack is a synchronization point. Abandon previous changes."

    self previousBoundaryChunkOfType: #synchronizationPoint do: [:chunk :index | ^self abandonChangesStartingAt: index].!   ! 
#('August 29, 2001' '03:07:37 PM' nil)!

(CodeFiler organizerFor: LatestChangesExtractor) reorganizeFrom: #(
('private' handleImageSynchonized )) !


!LatestChangesExtractor methods ! 
previousBoundaryChunkDo: aTwoArgumentBlock
    "self previousBoundaryChunkDo: [:chunk :index | ... ]"

    | chunk |
    stack size - 1 to: 1 by: -1 do: [:index | (chunk := stack at: index) isBoundary ifTrue: [^aTwoArgumentBlock value: chunk value: index]].!  ! 
#('September 19, 2001' '12:19:37 PM' nil)!

(CodeFiler organizerFor: LatestChangesExtractor) reorganizeFrom: #(
('private' previousBoundaryChunkDo: )) !


!LatestChangesExtractor methods !
open

    self promptForFilenameAndEdit!  ! 
#('August 29, 2001' '03:07:37 PM' nil)!

(CodeFiler organizerFor: LatestChangesExtractor) reorganizeFrom: #(
('scheduling' open )) !


!LatestChangesExtractor methods !
editChanges

    | stream |
    stream := WriteStream on: (String new: 51200).
    stack do: [:chunk | chunk isBoundary ifFalse: [chunk storeOn: stream]].
    stream contents edit!   ! 
#('August 29, 2001' '03:07:37 PM' nil)!

(CodeFiler organizerFor: LatestChangesExtractor) reorganizeFrom: #(
('writing' editChanges )) !


!LatestChangesExtractor methods !
openFilename: filename

    changeLog := File pathNameReadOnly: filename.!    ! 
#('August 29, 2001' '03:07:37 PM' nil)!

(CodeFiler organizerFor: LatestChangesExtractor) reorganizeFrom: #(
('private' openFilename: )) !


!LatestChangesExtractor methods !  
push: aChunk

    stack addLast: aChunk!  ! 
#('August 29, 2001' '03:07:37 PM' nil)!

(CodeFiler organizerFor: LatestChangesExtractor) reorganizeFrom: #(
('private' push: )) !


!LatestChangesExtractor methods !  
promptForFilenameAndEdit

    | filename |
    filename := FileDialog new
        title: 'Open Change Log';
        shareAware;
        addFilter: '*.log' description: 'Change Logs (*.log)';
        addFilter: '*.txt' description: 'Text Files (*.txt)';
        addFilter: '*.*' description: 'All Files (*.*)';
        fileSpec: '*.log';
        hideReadonly;
        open;
        file.
    filename isNil ifTrue: [^self].

    self readChangesFrom: filename; editChanges! ! 
#('September 10, 2001' '09:13:16 AM' nil)!

(CodeFiler organizerFor: LatestChangesExtractor) reorganizeFrom: #(
('reading' promptForFilenameAndEdit )) !


!LatestChangesExtractor methods !
readChunks

    | chunk progressBar totalSize |
    progressBar := ProgressIndicatorDialogThatWorks new noCancel; open: 'Reading change log ...' message: ''.
    totalSize := changeLog size.
    [[changeLog atEnd] whileFalse: [
        chunk := self identify: changeLog nextChunk.
        progressBar percent: (changeLog position / totalSize * 100.0) truncated.
        self process: chunk]] ensure: [changeLog close. progressBar close].!  ! 
#('August 29, 2001' '03:07:37 PM' nil)!

(CodeFiler organizerFor: LatestChangesExtractor) reorganizeFrom: #(
('private' readChunks )) !


!LatestChangesExtractor methods ! 
handleImageStarted
    "Top of stack is an image startup. If the previous boundary chunk is an image started too, then abandon the changes in between."

    self previousBoundaryChunkDo: [:chunk :index | chunk type == #imageStartup ifTrue: [^self abandonChangesStartingAt: index]].!   ! 
#('August 29, 2001' '03:07:37 PM' nil)!

(CodeFiler organizerFor: LatestChangesExtractor) reorganizeFrom: #(
('private' handleImageStarted )) !


!LatestChangesExtractor methods ! 
process: aChunk

    self push: aChunk.
    aChunk type == #imageStartup ifTrue: [^self handleImageStarted].
    aChunk type == #imageSave ifTrue: [ ^self handleImageSaved].
    aChunk type == #synchronizationPoint ifTrue: [^self handleImageSynchonized].!    ! 
#('September 19, 2001' '12:20:37 PM' nil)!

(CodeFiler organizerFor: LatestChangesExtractor) reorganizeFrom: #(
('private' process: )) !


!LatestChangesExtractor methods !
pop: index

    ^stack removeLast: index! ! 
#('August 29, 2001' '03:07:37 PM' nil)!

(CodeFiler organizerFor: LatestChangesExtractor) reorganizeFrom: #(
('private' pop: )) !


!LatestChangesExtractor methods !   
initialize

    stack := OrderedCollection new.!  ! 
#('August 29, 2001' '03:07:37 PM' nil)!

(CodeFiler organizerFor: LatestChangesExtractor) reorganizeFrom: #(
('initializing' initialize )) !


!LatestChangesExtractor methods !
previousBoundaryChunkOfType: aSymbol do: aTwoArgumentBlock
    "self previousBoundaryChunkOfType: #imageSave do: [:chunk :index | ... ]"

    | chunk |
    stack size - 1 to: 1 by: -1 do: [:index |
        ((chunk := stack at: index) isBoundary and: [chunk type == aSymbol])
            ifTrue: [^aTwoArgumentBlock value: chunk value: index]].!  ! 
#('September 19, 2001' '12:20:23 PM' nil)!

(CodeFiler organizerFor: LatestChangesExtractor) reorganizeFrom: #(
('private' previousBoundaryChunkOfType:do: )) !


!LatestChangesExtractor methods ! 
abandonChangesStartingAt: index

    | startChunk |
    startChunk := stack last.
    self pop: index; push: startChunk!    ! 
#('September 19, 2001' '12:20:12 PM' nil)!

(CodeFiler organizerFor: LatestChangesExtractor) reorganizeFrom: #(
('private' abandonChangesStartingAt: )) !


!LatestChangesExtractor class methods ! 
open

    self new open!  ! 
#('August 29, 2001' '03:07:37 PM' nil)!

(CodeFiler organizerFor: LatestChangesExtractor class) reorganizeFrom: #(
('instance scheduling' open )) !


!LatestChangesExtractor class methods !   
new
    ^super new initialize! ! 
#('August 29, 2001' '03:07:37 PM' nil)!

(CodeFiler organizerFor: LatestChangesExtractor class) reorganizeFrom: #(
('instance creation' new )) !


!LatestChangesExtractor class methods !  
example1
    "(LatestChangesExtractor example1)"

    ^self new
        readChangesFrom: 'C:\3D\Builder in Smalltalk\sampleChangeLog.txt';
        writeChangesTo: 'C:\3D\Builder in Smalltalk\sampleChangeLog2.txt'!  ! 
#('August 29, 2001' '03:07:36 PM' nil)!

(CodeFiler organizerFor: LatestChangesExtractor class) reorganizeFrom: #(
('examples' example1 )) !


 

Object subclass: #LayoutUnit
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Windows-Support' )
  comment: ''!

   

LayoutUnit subclass: #CompositeLayout
  instanceVariableNames: 
    ' layoutList '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Windows-Support' )
  comment: ''!



LayoutUnit subclass: #ComputedLayout
  instanceVariableNames: 
    ' block '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Windows-Support' )
  comment: ''!

  

LayoutUnit subclass: #LayoutFrame
  instanceVariableNames: 
    ' topInset topRatio leftInset leftRatio bottomInset bottomRatio rightInset rightRatio '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Windows-Support' )
  comment: ''!

   

LayoutFrame subclass: #DialogLayoutFrame
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Windows-Support' )
  comment: ''!

   

HashTable variableSubclass: #LinearHashTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Collections' )
  comment: ''!

!LinearHashTable methods !
keysAndValuesDo: iterationBlock
    "Evaluate the <iterationBlock> once for each key/value pair in the receiver. The key will be the first argument, the value will be the second argument to the block. If the receiver is empty, the block will not be evaluated."

    | value |
    1 to: self size do: [:index |
        (value := self at: index) == nil
            ifFalse: [iterationBlock value: value key value: value value]]!    ! 
#('September 19, 2001' '12:28:58 PM' nil)!

(CodeFiler organizerFor: LinearHashTable) reorganizeFrom: #(
('no category methods' keysAndValuesDo: )) !


!LinearHashTable methods !  
elementsDo: iterationBlock
    "Evaluate the <iterationBlock> once for each element in the receiver. If the receiver is empty, the block will not be evaluated."

    | value |
    1 to: self size do: [:index |
        (value := self at: index) == nil ifFalse: [iterationBlock value: value]]!    ! 
#('December 21, 2001' '05:07:32 PM' nil)!

(CodeFiler organizerFor: LinearHashTable) reorganizeFrom: #(
('no category methods' elementsDo: )) !


  

HashTable variableSubclass: #LinearInlineHashTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Collections' )
  comment: ''!

!LinearInlineHashTable methods !
keysAndValuesDo: iterationBlock
    "Evaluate the <iterationBlock> once for each key/value pair in the receiver. The key will be the first argument, the value will be the second argument to the block. If the receiver is empty, the block will not be evaluated."

    | key |
    1 to: self size by: 2 do: [:index |
        (key := self at: index) == nil
            ifFalse: [iterationBlock value: key value: (self at: index + 1)]]!   ! 
#('September 19, 2001' '12:28:58 PM' nil)!

(CodeFiler organizerFor: LinearInlineHashTable) reorganizeFrom: #(
('no category methods' keysAndValuesDo: )) !


!LinearInlineHashTable methods !  
elementsDo: iterationBlock
    "Evaluate the <iterationBlock> once for each element in the receiver. If the receiver is empty, the block will not be evaluated."

    | value |
    1 to: self size by: 2 do: [:index |
        (value := self at: index) == nil ifFalse: [iterationBlock value: (Association key: value value: (self at: index + 1))]]!   ! 
#('December 21, 2001' '05:07:32 PM' nil)!

(CodeFiler organizerFor: LinearInlineHashTable) reorganizeFrom: #(
('no category methods' elementsDo: )) !




LinearInlineHashTable variableSubclass: #LinearIdentityHashTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Collections' )
  comment: ''!

  

LinearInlineHashTable variableSubclass: #LinearSymbolHashTable
  instanceVariableNames: ''
  classVariableNames: 
    ' PowerTwo '
  poolDictionaries: ''
  categories: #( 'Base-Collections' )
  comment: ''!



DialogCoordinator subclass: #ListChooser
  instanceVariableNames: 
    ' list currentSelection selection label '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Windows-Views' )
  comment: ''!



Object subclass: #ListItem
  instanceVariableNames: 
    ' object string '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

ListItem subclass: #ButtonListBoxItem
  instanceVariableNames: 
    ' image state '
  classVariableNames: 
    ' UninitializedValue '
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



ListItem subclass: #HeaderItem
  instanceVariableNames: 
    ' image width alignment '
  classVariableNames: ''
  poolDictionaries: 
    ' WinCommonControlConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

ListItem subclass: #ListViewItem
  instanceVariableNames: 
    ' image smallImage columns '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

DragDropObject subclass: #LocalDragDropObject
  instanceVariableNames: 
    ' formats '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Windows-Support' )
  comment: ''!

   

DragDropSession subclass: #LocalDragDropSession
  instanceVariableNames: 
    ' continue lastEvent extended '
  classVariableNames: ''
  poolDictionaries: 
    ' VirtualKeyConstants '
  categories: #( 'Windows-Support' )
  comment: ''!

  

Object subclass: #Magnitude
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Magnitudes' )
  comment: ''!

!Magnitude methods !
exclusivelyBetween: min and: max
        "Answer true if the receiver is greater than
         min and less than max, else answer false."
    ^(min < self) and: [self < max]!   ! 
#('November 20, 2002' '10:40:07 AM' nil)!

(CodeFiler organizerFor: Magnitude) reorganizeFrom: #(
('no category methods' exclusivelyBetween:and: )) !




Magnitude subclass: #Association
  instanceVariableNames: 
    ' value key '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Magnitudes' )
  comment: ''!

  

Magnitude subclass: #Character
  instanceVariableNames: 
    ' asciiInteger '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'Base-Magnitudes' )
  comment: ''!

!Character methods !   
hyperdriveDigitValue
    "Answer 0-9 if the receiver is $0-$9, 10-35 if it is $A-$Z, and < 0
    otherwise. This is used to parse literal numbers of radix 2-36."

    asciiInteger <= $9 asciiValue
        ifTrue: [^asciiInteger - $0 asciiValue].
    asciiInteger >= $A asciiValue
        ifTrue: [asciiInteger <= $Z asciiValue ifTrue: [^asciiInteger - $A asciiValue + 10]].
    ^ -1! ! 
#('November 21, 2001' '05:01:14 PM' nil)!

(CodeFiler organizerFor: Character) reorganizeFrom: #(
('extensions' hyperdriveDigitValue )) !


!Character methods !
asSymbol
    ^(String with: self) asSymbol!    ! 
#('January 20, 2003' '10:53:30 AM' nil)!

(CodeFiler organizerFor: Character) reorganizeFrom: #(
('extensions' asSymbol )) !


!Character methods ! 
isOperator
    ^('~!!@%&*+-=|\<>?,/' indexOf: self) > 0!   ! 
#('May 19, 2003' '02:18:13 PM' nil)!

(CodeFiler organizerFor: Character) reorganizeFrom: #(
('extensions' isOperator )) !


!Character methods !   
isTerminator
        "Answer true if the receiver character is either a
         carriage-return, line-feed, or form-feed, else answer false."
    ^self == Cr or: [self == Lf or: [self == Ff]]!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Character) reorganizeFrom: #(
('extensions' isTerminator )) !


!Character class methods !
cr
    ^Cr!    ! 
#('November 22, 2001' '02:41:25 PM' nil)!

(CodeFiler organizerFor: Character class) reorganizeFrom: #(
('extensions' cr )) !


!Character class methods !  
tab
    ^Tab!  ! 
#('November 22, 2001' '02:41:37 PM' nil)!

(CodeFiler organizerFor: Character class) reorganizeFrom: #(
('extensions' tab )) !


!Character class methods ! 
lf
    ^Lf!    ! 
#('November 22, 2001' '02:41:30 PM' nil)!

(CodeFiler organizerFor: Character class) reorganizeFrom: #(
('extensions' lf )) !


!Character class methods !  
space
    ^Space!  ! 
#('December 17, 2001' '11:58:34 AM' nil)!

(CodeFiler organizerFor: Character class) reorganizeFrom: #(
('extensions' space )) !


!Character class methods !   
null
    ^Character value: 0!  ! 
#('April 17, 2002' '01:57:13 PM' nil)!

(CodeFiler organizerFor: Character class) reorganizeFrom: #(
('extensions' null )) !


 

Magnitude subclass: #Date
  instanceVariableNames: 
    ' day '
  classVariableNames: 
    ' DayNames MonthNames '
  poolDictionaries: ''
  categories: #( 'Base-Magnitudes' )
  comment: ''!

!Date methods ! 
printUnpredictablyOn: aStream
        "Append a string representing the receiver date
         to aStream in the form specified by the current
         system date format."
    self printOn: aStream
        inFormat: NationalLanguage dateFormat
        twoDigitYear: true.! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Date) reorganizeFrom: #(
('no category methods' printUnpredictablyOn: )) !


!Date methods !  
printOn: aStream
        "Append a string representing the receiver date
         to aStream in the form that will be rereadable without
        ambiguity."
    self printLongOn: aStream! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Date) reorganizeFrom: #(
('no category methods' printOn: )) !


!Date methods !   
day: dayCount
        "Private - Set the day instance variable
         of the receiver to dayCount number of
         days.  Answer the receiver."
    day := dayCount - self class baseDay!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Date) reorganizeFrom: #(
('no category methods' day: )) !


!Date methods !   
day
        "Answer the number of days from the
         receiver to January 1, 1901."
    ^day + self class baseDay!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Date) reorganizeFrom: #(
('no category methods' day )) !


!Date class methods !  
fromString: aString
        "Answer a Date specified by aString.  aString
         must represent a date in one of three formats:
         'Jan 2, 1990'  or '2 Jan, 1990' or '02-01-90'
         but the delimiters between the month, day and
         year can be any sequence of non-alphanumeric
         characters."
    | aStream field1 field2 field3 day month year |
    aStream := aString asStream.
    field1 := aStream nextWord.
    (DayNames includesKey: field1 asSymbol)
        ifTrue: [field1 := aStream nextWord].
    field2 := aStream nextWord.
    (field2 equalsIgnoreCase:  'of')
        ifTrue: [field2 := aStream nextWord].
    field3 := aStream nextWord.
    year := field3 asInteger.
    year < 100 ifTrue: [year := year + 1900].

    field1 first isLetter                            " 'Jan 2, 1990' format"
        ifTrue: [
            month := self monthNameFromString: field1.
            ^self
                newDay: field2 asInteger
                month: month
                year: year].

    field2 first isLetter                             " '2 Jan, 1990' format"
        ifTrue: [
            month := self monthNameFromString: field2.
            ^self
                newDay: field1 asInteger
                month: month
                year: year].

        "Must be '02-01-90' or 02-01-1990' style"
    (NationalLanguage dateFormat) = NationalLanguageSupport dateFormatMDY
        ifTrue: [
            day := field2 asInteger. month := field1 asInteger.
            month > 12 ifTrue: [day := month. month := field2 asInteger].
            ^self
                newDay: day
                month: (self nameOfMonth: month)
                year: year]
        ifFalse: [
            (NationalLanguage dateFormat) = NationalLanguageSupport dateFormatDMY
                ifTrue: [
                    day := field1 asInteger. month := field2 asInteger.
                    month > 12 ifTrue: [day := month. month := field1 asInteger].
                    ^self
                        newDay: day
                        month: (self nameOfMonth: month)
                        year: year]
                ifFalse: [                                          "dateFormatYMD"
                    year := field1 asInteger.
                    year < 100 ifTrue: [year := year + 1900].
                    ^self
                        newDay: field3 asInteger
                        month: (self nameOfMonth: field2 asInteger)
                        year: year]].
!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Date class) reorganizeFrom: #(
('no category methods' fromString: )) !


!Date class methods !
fromString: aString
        "Answer a Date specified by aString.  aString
         must represent a date in one of three formats:
         'Jan 2, 1990'  or '2 Jan, 1990' or '02-01-90'
         but the delimiters between the month, day and
         year can be any sequence of non-alphanumeric
         characters."
    | aStream field1 field2 field3 day month year fixBug |
    fixBug := true. "---------------------------------------------------------------------------------------------------------------->"
    aStream := aString asStream.
    field1 := aStream nextWord.
    (DayNames includesKey: field1 asSymbol)
        ifTrue: [field1 := aStream nextWord].
    field2 := aStream nextWord.
    (field2 equalsIgnoreCase:  'of')
        ifTrue: [field2 := aStream nextWord].
    field3 := aStream nextWord.
    year := field3 asInteger.
    year < 100 ifTrue: [year := year + (fixBug ifTrue: [2000] ifFalse: [1900])].

    field1 first isLetter                            " 'Jan 2, 1990' format"
        ifTrue: [
            month := self monthNameFromString: field1.
            ^self
                newDay: field2 asInteger
                month: month
                year: year].

    field2 first isLetter                             " '2 Jan, 1990' format"
        ifTrue: [
            month := self monthNameFromString: field2.
            ^self
                newDay: field1 asInteger
                month: month
                year: year].

        "Must be '02-01-90' or 02-01-1990' style"
    (NationalLanguage dateFormat) = NationalLanguageSupport dateFormatMDY
        ifTrue: [
            day := field2 asInteger. month := field1 asInteger.
            month > 12 ifTrue: [day := month. month := field2 asInteger].
            ^self
                newDay: day
                month: (self nameOfMonth: month)
                year: year]
        ifFalse: [
            (NationalLanguage dateFormat) = NationalLanguageSupport dateFormatDMY
                ifTrue: [
                    day := field1 asInteger. month := field2 asInteger.
                    month > 12 ifTrue: [day := month. month := field1 asInteger].
                    ^self
                        newDay: day
                        month: (self nameOfMonth: month)
                        year: year]
                ifFalse: [                                          "dateFormatYMD"
                    year := field1 asInteger.
                    year < 100 ifTrue: [year := year + 1900].
                    ^self
                        newDay: field3 asInteger
                        month: (self nameOfMonth: field2 asInteger)
                        year: year]].!  ! 
#('May 5, 2013' '03:31:57 PM' 281400)!

(CodeFiler organizerFor: Date class) reorganizeFrom: #(
('no category methods' fromString: )) !


  

Object subclass: #MciDevice
  instanceVariableNames: 
    ' alias '
  classVariableNames: 
    ' OpenDevices '
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

MciDevice subclass: #MciStream
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



MciStream subclass: #CdAudio
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

MciStream subclass: #MciFileStream
  instanceVariableNames: 
    ' filename '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



MciFileStream subclass: #AviVideo
  instanceVariableNames: 
    ' parentWindow reverse '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

Object subclass: #Menu
  instanceVariableNames: 
    ' owner menuItem title window items accel popup selector '
  classVariableNames: 
    ' AuxUnderScoreChar UnderScoreChar '
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants VirtualKeyConstants '
  categories: #( 'Windows-Support' )
  comment: ''!

!Menu methods ! 
removeItemDynamicallyThatActuallyWorks: stringOrInteger

    "Added by OSI"

    | pos mi collectionOfRemainingItems collectionOfRemainingAccels |

    collectionOfRemainingItems := OrderedCollection new.
    collectionOfRemainingAccels := OrderedCollection new.

    #addedByOSI.
    stringOrInteger isInteger
        ifTrue: [
            mi := items at: stringOrInteger.
            pos := stringOrInteger]
        ifFalse: [
            mi := items at: (self getIndex: stringOrInteger).
            pos := items indexOf: mi].
    items size to: pos by: -1 do:[:index |
        collectionOfRemainingItems addFirst: (items at: index).
        collectionOfRemainingAccels addFirst: (accel at: index).
        mi := items at: index.
        items removeIndex: index.
        accel removeIndex: index.
        window notNil ifTrue: [
            window deleteItem: mi]].
    collectionOfRemainingItems removeFirst.
    collectionOfRemainingAccels removeFirst.
    collectionOfRemainingAccels do: [:acc | accel add: acc].
    collectionOfRemainingItems do: [:item |
        items add: item.
        window notNil ifTrue: [
            item id: (self menuItem id - 1) + items size.
            window
                insertItem: item
                label: item label]].


"
    items removeIndex: pos.
    accel removeIndex: pos.
    window notNil ifTrue: [
        window deleteItem: mi].
"
    "##### Old Code #####
    UserLibrary
        deleteMenu: window asParameter
        position:  pos - 1
        flag: MfByposition.
    ##### ##### #####"!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Menu) reorganizeFrom: #(
('extensions' removeItemDynamicallyThatActuallyWorks: )) !


!Menu methods ! 
checkedItems

    | checkedItems |

    checkedItems := OrderedCollection new.

    self items do: [:menuItem |
        (self isChecked: menuItem label) ifTrue:[checkedItems add: menuItem label]].
    ^checkedItems.!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Menu) reorganizeFrom: #(
('extensions' checkedItems )) !


!Menu methods !
item: itemName checked: trueOrFalse

    trueOrFalse
        ifTrue: [self checkItem: itemName]
        ifFalse: [self uncheckItem: itemName]!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Menu) reorganizeFrom: #(
('extensions' item:checked: )) !


  

Object subclass: #MenuItem
  instanceVariableNames: 
    ' id selector style position submenu label attribute subMenuHandle '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Windows-Support' )
  comment: ''!

 

EvaluableAction subclass: #Message
  instanceVariableNames: 
    ' selector arguments receiver '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Messages' )
  comment: ''!

  

Message subclass: #LinkMessage
  instanceVariableNames: 
    ' resultAction '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Processes and Events' )
  comment: ''!

 

ControlError subclass: #MessageNotUnderstood
  instanceVariableNames: 
    ' message '
  classVariableNames: 
    ' DefaultClass '
  poolDictionaries: ''
  categories: #( 'Kernel-Exception Handling' )
  comment: ''!

  

Behavior subclass: #MetaClass
  instanceVariableNames: 
    ' instanceClass '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Behaviors' )
  comment: ''!



Object subclass: #MethodClassifier
  instanceVariableNames: 
    ' codeFiler sourceManager rules '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Development Support' )
  comment: ''!

!MethodClassifier methods !   
classifySelectors: selectors in: aClass
    "selectors      <Collection withAll: <Symbol>>
    aClass              <Class or Metaclass>
    Classify selectors in aClass"

    self classifyAll: selectors in: aClass.!    ! 
#('March 30, 2003' '06:02:21 PM' nil)!

(CodeFiler organizerFor: MethodClassifier) reorganizeFrom: #(
('classifying' classifySelectors:in: )) !


!MethodClassifier methods !   
sourceManager: aSourceManager
    sourceManager := aSourceManager! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: MethodClassifier) reorganizeFrom: #(
('get/set' sourceManager: )) !


!MethodClassifier methods ! 
codeFiler: aCodeFiler
    codeFiler := aCodeFiler! ! 
#('March 30, 2003' '06:00:07 PM' nil)!

(CodeFiler organizerFor: MethodClassifier) reorganizeFrom: #(
('get/set' codeFiler: )) !


!MethodClassifier methods !  
classificationFor: aSelector in: aClass
    "aSelector      <Symbol>
    aClass              <Class>
        ^                      <String>
    Answer the name of the protocol to which aSelector belongs"

    | ruleBlock |

    ruleBlock := rules
        detect: [:first | (first value: aSelector value: aClass) notNil]
        ifNone: [nil].

    ruleBlock isNil
        ifTrue: [^nil]
        ifFalse: [^ruleBlock value: aSelector value: aClass]! ! 
#('March 30, 2003' '07:13:04 PM' nil)!

(CodeFiler organizerFor: MethodClassifier) reorganizeFrom: #(
('classifying support' classificationFor:in: )) !


!MethodClassifier methods !   
classificationFor: aSelector in: aClass
    "aSelector      <Symbol>
    aClass              <Class>
        ^                      <String>
    Answer the name of the protocol to which aSelector belongs"

    | ruleBlock |

    ruleBlock := rules
        detect: [:first | (first value: aSelector value: aClass) notNil]
        ifNone: [nil].

    ruleBlock isNil
        ifTrue: [^nil]
        ifFalse: [^ruleBlock value: aSelector value: aClass]! ! 
#('March 30, 2003' '07:13:04 PM' 293008)!

(CodeFiler organizerFor: MethodClassifier) reorganizeFrom: #(
('classifying support' classificationFor:in: )) !


!MethodClassifier methods !
classificationFor: aSelector in: aClass
    "aSelector      <Symbol>
    aClass              <Class>
        ^                      <String>
    Answer the name of the protocol to which aSelector belongs"

    | ruleBlock |
    ruleBlock := rules detect: [:first | (first value: aSelector value: aClass) notNil] ifNone: [nil].
    ruleBlock isNil ifTrue: [^nil] ifFalse: [^ruleBlock value: aSelector value: aClass]! ! 
#('March 30, 2003' '07:13:11 PM' 293668)!

(CodeFiler organizerFor: MethodClassifier) reorganizeFrom: #(
('classifying support' classificationFor:in: )) !


!MethodClassifier methods !
codeFiler
    ^codeFiler!  ! 
#('March 30, 2003' '06:00:18 PM' nil)!

(CodeFiler organizerFor: MethodClassifier) reorganizeFrom: #(
('get/set' codeFiler )) !


!MethodClassifier methods !   
sourceManager
    ^sourceManager!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: MethodClassifier) reorganizeFrom: #(
('get/set' sourceManager )) !


!MethodClassifier methods !  
classifySystem
    "Classify all of the methods in the system"

    | classes |

    classes := self sourceManager smalltalk rootClasses inject: (OrderedCollection new: 600) into:[ :all :rootClass |
         all addAll: rootClass withAllSubclasses; yourself].
    self classifyAll: classes!   ! 
#('March 30, 2003' '06:02:58 PM' nil)!

(CodeFiler organizerFor: MethodClassifier) reorganizeFrom: #(
('classifying' classifySystem )) !


!MethodClassifier methods !  
classifyAll: selectors in: aClass
    "classify the given selectors in aClass"

    selectors do: [:each |
        self classify: each in: aClass]! ! 
#('March 30, 2003' '07:13:27 PM' nil)!

(CodeFiler organizerFor: MethodClassifier) reorganizeFrom: #(
('classifying support' classifyAll:in: )) !


!MethodClassifier methods ! 
classifyAll: selectors in: aClass
    "classify the given selectors in aClass"

    selectors do: [:each |
        self classify: each in: aClass]! ! 
#('March 30, 2003' '07:13:27 PM' 295840)!

(CodeFiler organizerFor: MethodClassifier) reorganizeFrom: #(
('classifying support' classifyAll:in: )) !


!MethodClassifier methods !  
classifyAll: selectors in: aClass
    "classify the given selectors in aClass"

    selectors do: [:each | self classify: each in: aClass]!  ! 
#('March 30, 2003' '07:13:27 PM' 296180)!

(CodeFiler organizerFor: MethodClassifier) reorganizeFrom: #(
('classifying support' classifyAll:in: )) !


!MethodClassifier methods !  
classify: aSelector in: aClass
    "Place aSelector in an appropriate method category"

    | protocol |

    protocol := self classificationFor: aSelector in: aClass.
    protocol notNil ifTrue: [
        (self codeFiler organizerFor: aClass) addElement: aSelector toCategory: protocol]! ! 
#('March 30, 2003' '06:21:00 PM' nil)!

(CodeFiler organizerFor: MethodClassifier) reorganizeFrom: #(
('classifying support' classify:in: )) !


!MethodClassifier methods !
classify: aSelector in: aClass
    "Place aSelector in an appropriate method category"

    | protocol |

    protocol := self classificationFor: aSelector in: aClass.
    protocol notNil ifTrue: [(self codeFiler organizerFor: aClass) addElement: aSelector toCategory: protocol]!   ! 
#('March 30, 2003' '07:13:27 PM' 296860)!

(CodeFiler organizerFor: MethodClassifier) reorganizeFrom: #(
('classifying support' classify:in: )) !


!MethodClassifier methods ! 
classify: aSelector in: aClass
    "Place aSelector in an appropriate method category"

    | protocol |
    protocol := self classificationFor: aSelector in: aClass.
    protocol notNil ifTrue: [(self codeFiler organizerFor: aClass) addElement: aSelector toCategory: protocol]! ! 
#('March 30, 2003' '07:14:32 PM' 297340)!

(CodeFiler organizerFor: MethodClassifier) reorganizeFrom: #(
('classifying support' classify:in: )) !


!MethodClassifier methods ! 
classify: aClass
    "Classify all unclassified selectors in aClass"

    | selectors organizer |
    ((organizer := self codeFiler organizerFor: aClass) isKnownCategory: organizer defaultCategory) ifTrue: [
        selectors := organizer elementsOfCategory: organizer defaultCategory.
        self classifySelectors: selectors in: aClass]!  ! 
#('March 30, 2003' '06:00:44 PM' nil)!

(CodeFiler organizerFor: MethodClassifier) reorganizeFrom: #(
('classifying' classify: )) !


!MethodClassifier methods !   
classifyAll: classes
    "Classify all of the methods in the system"

    | dialog size organizer index |
    size := classes size * 2.  "account for the metaclasses too"

    dialog := ProgressIndicatorDialog new
        noCancel;
        open: WindowLabelPrefix message: 'Classifying methods...'.

    index := 0.
    classes do: [:aClass |
        (Array with: aClass with: aClass class) do: [:each |
            organizer := CodeFiler organizerFor: each.
            (organizer isKnownCategory: organizer defaultCategory) ifTrue: [
                self classifyAll: (organizer elementsOfCategory: organizer defaultCategory) in: each.
                organizer update].
            dialog percent: (index / size * 100) truncated.
            index := index + 1]].

    dialog close.!  ! 
#('March 30, 2003' '06:01:42 PM' nil)!

(CodeFiler organizerFor: MethodClassifier) reorganizeFrom: #(
('classifying' classifyAll: )) !


!MethodClassifier methods !
classifyAll: classes
    "Classify all of the methods in the system"

    | dialog size organizer index |
    size := classes size * 2.  "account for the metaclasses too"

    dialog := ProgressIndicatorDialog new
        noCancel;
        open: WindowLabelPrefix message: 'Classifying methods...'.

    index := 0.
    classes do: [:aClass |
        (Array with: aClass with: aClass class) do: [:each |
            organizer := self codeFiler organizerFor: each.
            (organizer isKnownCategory: organizer defaultCategory) ifTrue: [
                self classifyAll: (organizer elementsOfCategory: organizer defaultCategory) in: each.
                organizer update].
            dialog percent: (index / size * 100) truncated.
            index := index + 1]].

    dialog close.! ! 
#('March 30, 2003' '06:08:16 PM' 298812)!

(CodeFiler organizerFor: MethodClassifier) reorganizeFrom: #(
('classifying' classifyAll: )) !


!MethodClassifier methods ! 
classifyAll: classes
    "Classify all of the methods in the system"

    | dialog size organizer index |
    size := classes size * 2.  "account for the metaclasses too"

    dialog := ProgressIndicatorDialog new
        noCancel;
        open: WindowLabelPrefix message: 'Classifying methods...'.

    index := 0.
    classes do: [:aClass |
        (Array with: aClass with: (self codeFiler classFor: aClass)) do: [:each |
            organizer := self codeFiler organizerFor: each.
            (organizer isKnownCategory: organizer defaultCategory) ifTrue: [
                self classifyAll: (organizer elementsOfCategory: organizer defaultCategory) in: each.
                organizer update].
            dialog percent: (index / size * 100) truncated.
            index := index + 1]].

    dialog close.!    ! 
#('March 30, 2003' '06:14:49 PM' 299796)!

(CodeFiler organizerFor: MethodClassifier) reorganizeFrom: #(
('classifying' classifyAll: )) !


!MethodClassifier class methods !   
classifySelectors: selectors in: aClass
    "selectors      <Collection withAll: <Symbol>>
    aClass              <Class or Metaclass>
    Classify selectors in aClass"

    | classifier |

    classifier := self default.
    classifier classifyAll: selectors in: aClass.!   ! 
#('March 30, 2003' '06:03:44 PM' nil)!

(CodeFiler organizerFor: MethodClassifier class) reorganizeFrom: #(
('obsolete' classifySelectors:in: )) !


!MethodClassifier class methods !  
classifySelectors: selectors in: aClass
    "selectors      <Collection withAll: <Symbol>>
    aClass              <Class or Metaclass>
    Classify selectors in aClass"

    | classifier |
    self obsolete.

    classifier := self default.
    classifier classifyAll: selectors in: aClass.!   ! 
#('March 30, 2003' '06:03:44 PM' 301812)!

(CodeFiler organizerFor: MethodClassifier class) reorganizeFrom: #(
('obsolete' classifySelectors:in: )) !


!MethodClassifier class methods !   
classifySystem
    "Classify all of the methods in the system"

    | classes |

    classes := Smalltalk rootClasses inject: (OrderedCollection new: 600) into:[ :all :rootClass |
         all addAll: rootClass withAllSubclasses; yourself].
    self classifyAll: classes!  ! 
#('March 30, 2003' '06:03:49 PM' nil)!

(CodeFiler organizerFor: MethodClassifier class) reorganizeFrom: #(
('obsolete' classifySystem )) !


!MethodClassifier class methods ! 
classifySystem
    "Classify all of the methods in the system"

    | classes |
    self obsolete.

    classes := Smalltalk rootClasses inject: (OrderedCollection new: 600) into:[ :all :rootClass |
         all addAll: rootClass withAllSubclasses; yourself].
    self classifyAll: classes!  ! 
#('March 30, 2003' '06:03:49 PM' 302796)!

(CodeFiler organizerFor: MethodClassifier class) reorganizeFrom: #(
('obsolete' classifySystem )) !


!MethodClassifier class methods !  
forCodeFiler: codeFiler sourceManager: sourceManager
    ^self default codeFiler: codeFiler; sourceManager: sourceManager! ! 
#('March 30, 2003' '05:59:16 PM' nil)!

(CodeFiler organizerFor: MethodClassifier class) reorganizeFrom: #(
('instance creation' forCodeFiler:sourceManager: )) !


!MethodClassifier class methods !   
classify: aClass
    "Classify all unclassified selectors in aClass"

    | selectors organizer |
    ((organizer := CodeFiler organizerFor: aClass) isKnownCategory: organizer defaultCategory) ifTrue: [
        selectors := organizer elementsOfCategory: organizer defaultCategory.
        self classifySelectors: selectors in: aClass]!   ! 
#('March 30, 2003' '06:03:32 PM' nil)!

(CodeFiler organizerFor: MethodClassifier class) reorganizeFrom: #(
('obsolete' classify: )) !


!MethodClassifier class methods !  
classify: aClass
    "Classify all unclassified selectors in aClass"

    | selectors organizer |
    self obsolete.
    ((organizer := CodeFiler organizerFor: aClass) isKnownCategory: organizer defaultCategory) ifTrue: [
        selectors := organizer elementsOfCategory: organizer defaultCategory.
        self classifySelectors: selectors in: aClass]!   ! 
#('March 30, 2003' '06:03:32 PM' 304092)!

(CodeFiler organizerFor: MethodClassifier class) reorganizeFrom: #(
('obsolete' classify: )) !


!MethodClassifier class methods !   
classifyAll: classes
    "Classify all of the methods in the system"

    | dialog size classifier organizer index |

    classifier := MethodClassifier default.
    size := classes size * 2.  "account for the metaclasses too"

    dialog := ProgressIndicatorDialog new
        noCancel;
        open: WindowLabelPrefix message: 'Classifying methods...'.

    index := 0.
    classes do: [:aClass |
        (Array with: aClass with: aClass class) do: [:each |
            organizer := CodeFiler organizerFor: each.
            (organizer isKnownCategory: organizer defaultCategory) ifTrue: [
                classifier classifyAll: (organizer elementsOfCategory: organizer defaultCategory) in: each.
                organizer update].
            dialog percent: (index / size * 100) truncated.
            index := index + 1]].

    dialog close.!  ! 
#('March 30, 2003' '06:03:39 PM' nil)!

(CodeFiler organizerFor: MethodClassifier class) reorganizeFrom: #(
('obsolete' classifyAll: )) !


!MethodClassifier class methods !   
classifyAll: classes
    "Classify all of the methods in the system"

    | dialog size classifier organizer index |

    self obsolete.
    classifier := MethodClassifier default.
    size := classes size * 2.  "account for the metaclasses too"

    dialog := ProgressIndicatorDialog new
        noCancel;
        open: WindowLabelPrefix message: 'Classifying methods...'.

    index := 0.
    classes do: [:aClass |
        (Array with: aClass with: aClass class) do: [:each |
            organizer := CodeFiler organizerFor: each.
            (organizer isKnownCategory: organizer defaultCategory) ifTrue: [
                classifier classifyAll: (organizer elementsOfCategory: organizer defaultCategory) in: each.
                organizer update].
            dialog percent: (index / size * 100) truncated.
            index := index + 1]].

    dialog close.!  ! 
#('March 30, 2003' '06:03:39 PM' 305172)!

(CodeFiler organizerFor: MethodClassifier class) reorganizeFrom: #(
('obsolete' classifyAll: )) !


 

Object subclass: #MethodExecutor
  instanceVariableNames: 
    ' method receiver '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Messages' )
  comment: ''!

!MethodExecutor methods !   
selector
    ^method selector! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: MethodExecutor) reorganizeFrom: #(
('no category methods' selector )) !




Object subclass: #MethodVersion
  instanceVariableNames: 
    ' smalltalkClass selector source timeStamp previousVersion sourceStream '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Development Support' )
  comment: ''!

 

DynamicLinkLibrary variableByteSubclass: #MultimediaDLL
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



CompilerNameScope subclass: #MultiplePoolScope
  instanceVariableNames: 
    ' scopes '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Compiler Support' )
  comment: ''!

   

Object subclass: #NavigatorBrowser
  instanceVariableNames: 
    ' organizer selection classOrInstanceMode '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Navigator' )
  comment: ''!

!NavigatorBrowser methods !   
selectedMethodOrganizer
    "^ <methodBasedOrganizer> | nil
    Answer the methodBasedOrganizer for the selected class,
    or nil if there are no classes, or more than one class selected."

    ^self selectedClasses size >1 | self selectedClasses isEmpty
        ifTrue: [nil]
        ifFalse: [self organizerFor: self selectedClassOrMetaclass]!   ! 
#('November 14, 2001' '12:45:58 PM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('selecting' selectedMethodOrganizer )) !


!NavigatorBrowser methods !
fileOutSelectedCategoriesOn: aStream
    "File out the classes in the selected categories in hierarchical order on aStream"

    | classes |

    classes := self hierarchyOfClasses collect: [:each |
        self systemDictionary at: each trimBlanks asSymbol].

    (self codeFilerClass forClasses: classes)
        fileOutOn: aStream;
        release.!  ! 
#('January 20, 2003' '10:53:19 AM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('filing out' fileOutSelectedCategoriesOn: )) !


!NavigatorBrowser methods !   
sourceManager
    ^SourceManager current!  ! 
#('March 16, 2003' '09:58:37 AM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('querying' sourceManager )) !


!NavigatorBrowser methods !  
removeSelectedProtocols
    "Remove the selected protocols, and all of the methods they contain"

    self selectedProtocols do: [:protocol |
        self selectedMethodOrganizer removeCategory: protocol].
    self privateValidateSelection!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('reorganizing' removeSelectedProtocols )) !


!NavigatorBrowser methods !   
selectedSmalltalkClassOrMetaclass
    "^ <Class or MetaClass> | nil
    Answer the selected class or metaclass in Smalltalk"

    self selectedClass isNil ifTrue: [^nil].
    ^self classForClassName: self selectedClass.!   ! 
#('March 29, 2003' '09:13:13 AM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('selecting' selectedSmalltalkClassOrMetaclass )) !


!NavigatorBrowser methods ! 
copyMethods: methods from: oldClass to: newClass
    "oldClass: <Class or MetaClass>
    newClass: <Class or MetaClass>
    Private - Copy the given methods from oldClass to newClass"

    | stream methodsByProtocol methodsInProtocol methodOrganizer protocol |

    methodOrganizer := self codeFilerClass organizerFor: oldClass.
    methodsByProtocol := Dictionary new.
    methods do: [:each |
        protocol := methodOrganizer categoryOfElement: each.
        (methodsByProtocol includesKey: protocol)
            ifFalse: [methodsByProtocol at: protocol put: OrderedCollection new].
        (methodsByProtocol at: protocol) add: each].

    stream := WriteStream on: (String new: 200).
    methodOrganizer categories do: [:eachProtocol |
        methodsInProtocol := methodsByProtocol at: eachProtocol ifAbsent: [#()].
        methodsInProtocol notEmpty ifTrue: [
            stream
                nextPut: $!!;
                nextPutAll: newClass name;
                nextPutAll: ' methodsFor: ';
                nextPutAll: eachProtocol printString;
                nextPutAll: ' !!';
                cr.
            methodsInProtocol
                do: [:selector | stream nextChunkPut: (oldClass compiledMethodAt: selector) sourceString]
                andBetweenDo: [stream cr].

            stream nextChunkPut: ' ';cr]].
    self sourceManager fileInFrom: stream contents asStream!   ! 
#('March 11, 2003' '09:00:44 PM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('private' copyMethods:from:to: )) !


!NavigatorBrowser methods !
selectedSmalltalkClass
    "^ <Class> | nil
    Answer the selected class in Smalltalk"

    self selectedClass isNil
        ifTrue: [^nil].

    ^self systemDictionary at: self selectedClass asSymbol!   ! 
#('November 13, 2001' '11:06:42 AM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('selecting' selectedSmalltalkClass )) !


!NavigatorBrowser methods ! 
removeSelectedClasses
    "Remove my selected classses from Smalltalk, and from all of the organizers to which they belong"

    | categories |
    self selectedClasses reverseDo: [:each |
        (self systemDictionary at: each asSymbol) removeFromSystem.
        SourceManager current
            logEvaluate: each, ' removeFromSystem';
            logEvaluate: 'CodeFiler removeOrganizerFor: ', each asSymbol storeString;
            logEvaluate: 'CodeFiler removeOrganizerFor: ', (each, ' class') asSymbol storeString.
        self selectedClassOrganizer removeElement: each asSymbol.
        CodeFiler
            removeOrganizerFor: each asSymbol;
            removeOrganizerFor: (each, ' class') asSymbol].
    self selectedClassOrganizer updateDefaultCategory.
    self privateValidateSelection.! ! 
#('July 29, 2002' '02:22:18 PM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('reorganizing' removeSelectedClasses )) !


!NavigatorBrowser methods !   
copySelectedProtocolsTo: newClass
    "newClass: <Class or MetaClass>
    Copy all methods in my selected protocols to newClass"

    | methods methodOrganizer |

    methodOrganizer := self codeFilerClass organizerFor: self selectedClassOrMetaclass.
    methods := self selectedProtocols inject: OrderedCollection new into: [:sum :each |
        sum
            addAll: (methodOrganizer elementsOfCategory: each);
            yourself].

    self copyMethods: methods from: self selectedSmalltalkClassOrMetaclass to: newClass! ! 
#('January 20, 2003' '10:53:19 AM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('reorganizing' copySelectedProtocolsTo: )) !


!NavigatorBrowser methods ! 
selectedSmalltalkClassesOrMetaclasses
    "^ <Collection of Classes or MetaClasses> | nil
    Answer the selected classes or metaclasses in Smalltalk"

    self selectedClass isNil ifTrue: [^nil].
    ^self selectedClassesOrMetaclasses collect: [:each | self classForClassName: each].!  ! 
#('March 29, 2003' '09:13:13 AM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('selecting' selectedSmalltalkClassesOrMetaclasses )) !


!NavigatorBrowser methods ! 
fileOutSelectedCategoriesOn: aStream with: aCodeFiler
    "File out the classes in the selected categories in hierarchical order on aStream"

    | classes |

    classes := self hierarchyOfClasses collect: [:each |
        self systemDictionary at: each trimBlanks asSymbol].

    (aCodeFiler forClasses: classes)
        fileOutOn: aStream;
        release.!  ! 
#('November 13, 2001' '11:06:15 AM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('filing out' fileOutSelectedCategoriesOn:with: )) !


!NavigatorBrowser methods ! 
removeSelectedMethods
    "Remove the selected methods from Smalltalk"

    self selectedMethods do: [:each |
        self selectedMethodOrganizer removeElement: each].
    self selectedMethodOrganizer updateDefaultCategory.
    self privateValidateSelection!   ! 
#('March 30, 2003' '07:25:30 PM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('reorganizing' removeSelectedMethods )) !


!NavigatorBrowser methods !  
removeSelectedMethods
    "Remove the selected methods from Smalltalk"

    self selectedMethods do: [:each | self selectedMethodOrganizer removeElement: each].
    self selectedMethodOrganizer updateDefaultCategory.
    self privateValidateSelection!    ! 
#('March 30, 2003' '07:25:30 PM' 315584)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('reorganizing' removeSelectedMethods )) !


!NavigatorBrowser methods !   
initialize

    organizer := self codeFilerClass systemOrganizer.
    selection := CodeBrowserSelection new.
    self browseInstanceMethods.!   ! 
#('January 20, 2003' '10:53:18 AM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('initializing' initialize )) !


!NavigatorBrowser methods !   
codeFilerClass
    ^CodeFiler! ! 
#('January 20, 2003' '10:53:18 AM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('private' codeFilerClass )) !


!NavigatorBrowser methods !
hierarchyOfClasses
    "^ <collection of strings>
    Answer my classes in hierarchical order, with indentation"

    | classes classesSet hierarchy |
    classes := self classes collect: [:each | self systemDictionary at: each].
    classes isEmpty
        ifTrue: [^classes].
    classesSet := (Set new: classes size * 2)
        addAll: classes;
        yourself.

    CursorManager execute changeFor: [
        hierarchy := OrderedCollection new: classes size.
        self
            putHierarchyFrom: self systemDictionary rootClasses
            with: classesSet
            into: hierarchy
            withIndent: ''].

    ^hierarchy!    ! 
#('November 13, 2001' '11:06:34 AM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('accessing' hierarchyOfClasses )) !


!NavigatorBrowser methods ! 
privateValidateSelectedMethods
    "Private - Make sure that all of my selected methods are in my selected protocols."

    | methods anOrganizer |

    methods := self selectedClassesOrMetaclasses inject: Set new into: [:sum :each |
        anOrganizer := self organizerFor: each.
        sum addAll: (self selectedProtocols inject: Set new into: [:methodsForClass :protocol |
            methodsForClass addAll: (anOrganizer elementsOfCategory: protocol); yourself])].

    self selection methods: (self selectedMethods select: [:each |
        methods includes: each asSymbol]).!   ! 
#('November 14, 2001' '12:44:47 PM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('validating' privateValidateSelectedMethods )) !


!NavigatorBrowser methods !
selectedSmalltalkClasses
    "^ <Collection of Classes> | nil
    Answer the selected classes in Smalltalk"

    | answer class |

    self selectedClass isNil
        ifTrue: [^nil].
    answer := OrderedCollection new.
    self selectedClasses do: [:each |
        answer add: (self systemDictionary at: each asSymbol)].
    ^answer!  ! 
#('November 13, 2001' '11:09:19 AM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('selecting' selectedSmalltalkClasses )) !


!NavigatorBrowser methods !   
systemDictionary
    ^self organizer owner!    ! 
#('November 13, 2001' '11:05:11 AM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('accessing' systemDictionary )) !


!NavigatorBrowser methods !   
smalltalkClasses
    "^ <collection withAll: <Class>>
    Answer all of the classes I am browsing"

    | classes |

    classes := Set new.

    self selectedCategories do: [:each |
        classes addAll: (self organizer elementsOfCategory: each)].
    ^classes asOrderedCollection collect: [:each | self systemDictionary at: each asSymbol]!   ! 
#('November 13, 2001' '11:15:12 AM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('accessing' smalltalkClasses )) !


!NavigatorBrowser methods !   
definitionString
    "Answer the definition string for the selected class.
    If more than one class is selected, or no class is selected,
    then answer an empty string"

    | smalltalkClass template |

    ((self selectedClasses size > 1| self selectedClass isNil) or: [
    ((self systemDictionary includesKey: self selectedClass asSymbol) not)])
        ifTrue: [
            template := WriteStream on: (String new: 60).
            template
                nextPutAll: self codeFilerClass definitionTemplate;
                nextPutAll: '#( '.
            self selectedCategories do: [:each |
                template print: each; space].
            template nextPut: $).
            ^template contents]
        ifFalse: [^(self codeFilerClass forClass: self selectedSmalltalkClass) definitionString]!   ! 
#('January 20, 2003' '10:53:20 AM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('accessing' definitionString )) !


!NavigatorBrowser methods !
renameAllClassesIn: oldClassNames to: newClassNames
    "oldClassNames/newClassNames <indexed collection of strings>
    Rename the classes with names oldClassNames to corresponding elements in newClassNames"

    | oldClass |
    oldClassNames with: newClassNames do: [:oldClassName :newClassName |
        oldClass := Smalltalk at: oldClassName asSymbol ifAbsent: [nil].
        oldClass notNil ifTrue: [oldClass rename: newClassName]]!   ! 
#('April 26, 2005' '09:01:14 AM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('reorganizing' renameAllClassesIn:to: )) !


!NavigatorBrowser methods ! 
renameAllClassesIn: oldClassNames to: newClassNames
    "oldClassNames/newClassNames <indexed collection of symbols>
    Rename the classes with names oldClassNames to corresponding elements in newClassNames"

    | oldClass |
    oldClassNames with: newClassNames do: [:oldClassName :newClassName |
        oldClass := Smalltalk at: oldClassName ifAbsent: [nil].
        oldClass notNil ifTrue: [oldClass rename: newClassName]]!    ! 
#('April 26, 2005' '09:12:59 AM' 320996)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('reorganizing' renameAllClassesIn:to: )) !


!NavigatorBrowser methods !  
classForClassName: className
    ^self isBrowsingClassMethods
        ifTrue: [(self systemDictionary at:  className asSymbol) class]
        ifFalse: [self systemDictionary at: className asSymbol]!   ! 
#('March 29, 2003' '09:11:46 AM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('querying' classForClassName: )) !


!NavigatorBrowser methods ! 
classForClassName: className
    ^self isBrowsingClassMethods
        ifTrue: [self classFor: (self systemDictionary at:  className asSymbol)]
        ifFalse: [self systemDictionary at: className asSymbol].! ! 
#('March 30, 2003' '06:13:26 PM' 322264)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('querying' classForClassName: )) !


!NavigatorBrowser methods !  
putHierarchyFrom: rootCollection with: visibleClasses into: hierarchy withIndent: indentString

    rootCollection do: [:each |
"        each symbol = #Time ifTrue: [self halt]."
        (visibleClasses includes: each)
            ifTrue: [
                hierarchy add: indentString, each symbol.
                self
                    putHierarchyFrom: (each subclasses  asSortedCollection: Class sortBlock)
                    with: visibleClasses
                    into: hierarchy
                    withIndent: indentString, '  ']
            ifFalse: [
                self
                    putHierarchyFrom: (each subclasses  asSortedCollection: Class sortBlock)
                    with: visibleClasses
                    into: hierarchy
                    withIndent: indentString]]!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('private' putHierarchyFrom:with:into:withIndent: )) !


!NavigatorBrowser methods ! 
organizerFor: nameOfClassOrMeta

    ^self codeFilerClass organizerFor: nameOfClassOrMeta!    ! 
#('January 20, 2003' '10:53:19 AM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('accessing' organizerFor: )) !


!NavigatorBrowser methods !   
updateClassOrganizerFrom: aString
    "Update my organizer according to aString"

    | anOrganizer storeString |

    storeString := '(ClassBasedOrganizer fromArray: #(', aString, '))'.
    anOrganizer := Compiler evaluate: storeString.
    anOrganizer isNil
        ifTrue: [^self].
    anOrganizer update.
    (self organizer owner == Smalltalk)
        ifTrue: [
            self codeFilerClass systemOrganizer: anOrganizer.
            SourceManager current logEvaluate: 'CodeFiler systemOrganizer: ', storeString.].
    self organizer: anOrganizer.
    self privateValidateSelection.!   ! 
#('January 20, 2003' '10:53:19 AM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('updating' updateClassOrganizerFrom: )) !


!NavigatorBrowser methods !
classFor: anObject
    ^anObject class!    ! 
#('March 30, 2003' '06:11:48 PM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('querying' classFor: )) !


!NavigatorBrowser methods !  
fileOutSelectedProtocolsOn: aStream
    "File out the selected protocols on aStream"

    | writer |

    writer := self codeFilerClass forClass: self selectedSmalltalkClassOrMetaclass.
    self selectedProtocols do: [:each |
        writer fileOutProtocol: each on: aStream].
    writer release.!   ! 
#('January 20, 2003' '10:53:19 AM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('filing out' fileOutSelectedProtocolsOn: )) !


!NavigatorBrowser methods !
updateMethodOrganizerFrom: aString
    "Update my selected class's method organizer according to aString"

    | anOrganizer storeString |

    self selectedClass isNil | (self selectedClasses size > 1)
        ifTrue: [^self].
    storeString := '(MethodBasedOrganizer fromArray: #(', aString, '))'.
    anOrganizer := Compiler evaluate: storeString.
    anOrganizer isNil
        ifTrue: [^self].
    anOrganizer
        owner: self selectedSmalltalkClassOrMetaclass;
        update;
        updateDefaultCategory.
    self codeFilerClass setOrganizerFor: self selectedClassOrMetaclass to: anOrganizer.
    SourceManager current logEvaluate:
        '(CodeFiler setAndInitializeOrganizerFor: ', self selectedClassOrMetaclass, ' to: ', storeString, ').'.
    self privateValidateSelection.!   ! 
#('January 20, 2003' '10:53:19 AM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('updating' updateMethodOrganizerFrom: )) !


!NavigatorBrowser methods !   
selectedMethodOrganizers
    "^ <methodBasedOrganizer> | nil
    Answer the methodBasedOrganizers for the selected classes."

   ^self selectedClassesOrMetaclasses collect: [:each | self organizerFor: each]! ! 
#('November 14, 2001' '12:46:18 PM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('selecting' selectedMethodOrganizers )) !


!NavigatorBrowser methods !   
renameSelectedCategoriesTo: newCategories
    "newCategories <indexed collection of strings>
    Rename the selected categories to corresponding elements in newCategories in the selected class organizer"

    self selectedCategories size ~= newCategories size
        ifTrue: [^self error: 'arguments are different sizes'].
    1 to: self selectedCategories size do: [:index |
        (self selectedClassOrganizer isKnownCategory: (newCategories at: index))
            ifFalse: [
                self selectedClassOrganizer rename: (self selectedCategories at: index) to: (newCategories at: index).
                SourceManager current logEvaluate: 'CodeFiler systemOrganizer rename: ',
                    (self selectedCategories at: index) printString, ' to: ', (newCategories at: index) printString]].
    self privateValidateSelection.! ! 
#('August 1, 2001' '09:06:33 AM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('reorganizing' renameSelectedCategoriesTo: )) !


!NavigatorBrowser methods !
privateValidateSelectedProtocols
    "Private - Make sure that all of my selected protocols are in my selected classes.  If there are
    no protocols selected, then remove all my selected methods"

    | protocols |

    protocols := self selectedClassesOrMetaclasses inject: Set new into:  [:sum :each |
        sum addAll: (self organizerFor: each) categories; yourself].

    self selection protocols: (self selectedProtocols select: [:each |
        protocols includes: each]).

    self selectedProtocols isEmpty
        ifTrue: [self selection methods: Array new]!    ! 
#('November 13, 2001' '12:39:51 PM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('validating' privateValidateSelectedProtocols )) !


!NavigatorBrowser methods !  
fileOutSelectedMethodsOn: aStream
    "File out the selected methods on aStream"

    (self codeFilerClass forClass: self selectedSmalltalkClassOrMetaclass)
        fileOutMethods: self selectedMethods on: aStream;
        release.!   ! 
#('January 20, 2003' '10:53:19 AM' nil)!

(CodeFiler organizerFor: NavigatorBrowser) reorganizeFrom: #(
('filing out' fileOutSelectedMethodsOn: )) !


 

CompilerErrorHandler subclass: #NonInteractiveErrorHandler
  instanceVariableNames: 
    ' contextDescription '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Compiler Support' )
  comment: ''!

   

Object subclass: #NonRecordingChangeSet
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants '
  categories: #( 'Tools-Change Sets' )
  comment: ''!

!NonRecordingChangeSet methods !
classNames
    ^Set new.!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: NonRecordingChangeSet) reorganizeFrom: #(
('accessing' classNames )) !


!NonRecordingChangeSet methods ! 
copy
    "A copy of myself get a new timestamp"

    ^self species new
        name: self name;
        classNames: self classNames copy;
        addItems: self items!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: NonRecordingChangeSet) reorganizeFrom: #(
('copying' copy )) !


!NonRecordingChangeSet methods ! 
logChangeForProtocolOrganization: string InClass: aClass

    self addItem: (ChangeSetEvaluateItem new
        source:  '(CodeFiler setOrganizerFor: ', aClass name printString, ' to: (MethodBasedOrganizer fromArray: #(', string, ')))')! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: NonRecordingChangeSet) reorganizeFrom: #(
('logging' logChangeForProtocolOrganization:InClass: )) !


!NonRecordingChangeSet methods !
logChangeForRenameClass: oldClass to: newClassName
    self addItem: (ChangeSetEvaluateItem new
        source:  '(CodeFiler renameClass ', oldClass name printString, ' to: ', newClassName printString, ')')!   ! 
#('April 21, 2005' '09:33:25 AM' nil)!

(CodeFiler organizerFor: NonRecordingChangeSet) reorganizeFrom: #(
('logging' logChangeForRenameClass:to: )) !


!NonRecordingChangeSet methods !   
logChangeForRenameClass: oldClass to: newClassName
    self addItem: (ChangeSetEvaluateItem new
        source:  '(CodeFiler renameClass: ', oldClass name printString, ' to: ', newClassName printString, ')')!  ! 
#('April 21, 2005' '09:44:47 AM' 330992)!

(CodeFiler organizerFor: NonRecordingChangeSet) reorganizeFrom: #(
('logging' logChangeForRenameClass:to: )) !


!NonRecordingChangeSet methods !
logChangeForRenameClass: oldClassName to: newClassName
    self addItem: (ChangeSetEvaluateItem new
        source:  '(CodeFiler renameClass: ', oldClassName printString, ' to: ', newClassName printString, ')')!   ! 
#('April 21, 2005' '09:59:04 AM' 331404)!

(CodeFiler organizerFor: NonRecordingChangeSet) reorganizeFrom: #(
('logging' logChangeForRenameClass:to: )) !




NonRecordingChangeSet subclass: #ChangeSet
  instanceVariableNames: 
    ' items classNames name creationDate creationTime comment changesAllowed '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants '
  categories: #( 'Tools-Change Sets' )
  comment: ''!

!ChangeSet methods !   
classNames: aCollection
    "Answer all of the classes of my items"

    classNames := aCollection asSet!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: ChangeSet) reorganizeFrom: #(
('accessing' classNames: )) !


!ChangeSet methods !
highlightsCopy
    "Answer a copy of the receiver with only highlights for the browser."

    | copy newItems |
    copy := self class new
        initializeTimeStamp;
        name: self name, ' highlights';
        comment: self comment.

    newItems := (self items select: [:each | each isMethodItem and: [each isRemoveMethod not]]) collect: [:each | each asHighlightItem].
    newItems do: [:each | copy addItem: each].
    ^copy!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: ChangeSet) reorganizeFrom: #(
('copying' highlightsCopy )) !


!ChangeSet methods !   
addItems: aCollection
    aCollection do: [:each | self addItem: each]!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: ChangeSet) reorganizeFrom: #(
('accessing' addItems: )) !


  

Notification subclass: #AboutToReplaceFile
  instanceVariableNames: 
    ' entity '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

Notification subclass: #KeyboardInterrupt
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Exception Handling' )
  comment: ''!



Object subclass: #NotificationManager
  instanceVariableNames: 
    ' windows savedWindows '
  classVariableNames: 
    ' NewWindow '
  poolDictionaries: 
    ' OperatingSystemConstants VirtualKeyConstants '
  categories: #( 'Kernel-Special Objects' )
  comment: ''!

!NotificationManager methods !
isShiftKeyDownNow
        "Answer whether the SHIFT key is down now."
    ^self isKeyDownNow: ShiftKey!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: NotificationManager) reorganizeFrom: #(
('extensions' isShiftKeyDownNow )) !


!NotificationManager methods ! 
isKeyDownNow: vkConstant
        "Answer true if the key described by vkConstant is down at this time.
         vkConstant is from VirtualKeyConstants pool dictionary."
    ^(UserLibrary getAsyncKeyState: vkConstant ) < 0!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: NotificationManager) reorganizeFrom: #(
('extensions' isKeyDownNow: )) !


!NotificationManager methods ! 
isControlKeyDownNow
        "Answer whether the CTRL key is down now."
    ^self isKeyDownNow: ControlKey!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: NotificationManager) reorganizeFrom: #(
('extensions' isControlKeyDownNow )) !


!NotificationManager methods !   
reopenWindows: oldWindows
        "Private - reopen the saved windows."
    oldWindows do: [ :w | w handle: WindowHandle nullValue ].
    savedWindows do: [ :w |
        ( w isApplicationWindow and: [ w frameWindow parent isWindow not ] )
            ifTrue:  [
                w allChildrenDo: [ :c | c clearGraphicsTool; prepareToValidate ].
                w validate ] ].
    savedWindows := nil.
    self cleanUpAllMessages!  ! 
#('April 17, 2002' '04:11:30 PM' nil)!

(CodeFiler organizerFor: NotificationManager) reorganizeFrom: #(
('no category methods' reopenWindows: )) !


!NotificationManager methods !
resume: oldWindows
        "Private - Recreate all the saved windows and run."
    ( ( oldWindows size = 0 ) or: [ Transcript == nil ] )
        ifTrue: [ ^self initializeTranscript ].
    Transcript setLabel.
    self relocateWindows: oldWindows.
    self haltIfCtrl reopenWindows: oldWindows!    ! 
#('April 15, 2002' '02:36:53 PM' nil)!

(CodeFiler organizerFor: NotificationManager) reorganizeFrom: #(
('no category methods' resume: )) !


!NotificationManager methods !   
isAltKeyDownNow
        "Answer whether the ALT key is down now."
    ^self isKeyDownNow: AltKey! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: NotificationManager) reorganizeFrom: #(
('extensions' isAltKeyDownNow )) !


 

Magnitude subclass: #Number
  instanceVariableNames: ''
  classVariableNames: 
    ' SinValues '
  poolDictionaries: ''
  categories: #( 'Base-Magnitudes' )
  comment: ''!

!Number methods !  
isZero
    ^self abs < WorldGlobal epsilon!    ! 
#('December 3, 2003' '02:26:12 PM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions' isZero )) !


!Number methods ! 
subtractFromPoint3D: aPoint3D
    ^aPoint3D class new
            x: aPoint3D x - self
            y: aPoint3D y - self
            z: aPoint3D z - self
            w: aPoint3D w - self! ! 
#('April 8, 2002' '04:23:31 PM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions for 3D' subtractFromPoint3D: )) !


!Number methods !   
addFromPoint3D: aPoint3D
    ^aPoint3D class new
            x: self + aPoint3D x
            y: self + aPoint3D y
            z: self + aPoint3D z!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions for 3D' addFromPoint3D: )) !


!Number methods !  
strictlyNegative
    "Answer true if the receiver is greater than zero, else answer false."
    ^self < self class additiveIdentity!  ! 
#('September 15, 2011' '03:05:09 PM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('no category methods' strictlyNegative )) !


!Number methods !
strictlyNegative
    "Answer true if the receiver is less than zero, else answer false."
    ^self < self class additiveIdentity! ! 
#('September 15, 2011' '03:05:09 PM' 337796)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('no category methods' strictlyNegative )) !


!Number methods ! 
approximatelyEqual: aNumber
    ^(self - aNumber) abs < WorldGlobal epsilon!   ! 
#('September 19, 2001' '12:28:35 PM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions for 3D' approximatelyEqual: )) !


!Number methods !   
to: number1 by: number2 collect: aBlock
    ^(self to: number1 by: number2) collect: aBlock!   ! 
#('August 24, 2005' '09:21:41 PM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions' to:by:collect: )) !


!Number methods !  
wrapFrom: min to: max
    "200.0 signedModulusFrom: -180.0 to: 180.0 => -160.0"
    "-200.0 signedModulusFrom: -180.0 to: 180.0 => 160.0"
    | range |
    self > max ifTrue: [range := max - min. ^self \\ range - range].
    self < min ifTrue: [range := max - min. ^(self negated \\ range - range) negated].
    ^self!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions for 3D' wrapFrom:to: )) !


!Number methods ! 
ceilingMod: aNumber
    "The nearest multiple of aNumber that is greater than or equal to the receiver"
    ^((self + (aNumber - 1)) // aNumber) * aNumber!   ! 
#('October 8, 2009' '05:53:02 PM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions' ceilingMod: )) !


!Number methods ! 
ceilingMod: aNumber
    "The nearest multiple of aNumber that is greater than or equal to the receiver"
    | floorMod |
    floorMod := self floorMod: aNumber. "Note: This approach works even if aNumber is not an integer..."
    ^floorMod = self ifTrue: [floorMod] ifFalse: [floorMod + aNumber]!    ! 
#('October 8, 2009' '05:58:52 PM' 339416)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions' ceilingMod: )) !


!Number methods !  
asSpaceString
    "Converts an amount in bytes to a string..."
    
    "
    500.0 asSpaceString
    3000.0 asSpaceString
    5000000.0 asSpaceString
    "
    
    | kilobytes megabytes |

    kilobytes := self / 1024.0.
    kilobytes < 1.0 ifTrue: [^self terseString, ' bytes'].
    megabytes := kilobytes / 1024.0.
    megabytes < 1.0 ifTrue: [kilobytes terseString, ' kilobytes'].
    ^megabytes terseString, ' megabytes'!  ! 
#('April 9, 2003' '09:44:11 PM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions' asSpaceString )) !


!Number methods ! 
asSpaceString
    "Converts an amount in bytes to a string..."
    
    "
    500.0 asSpaceString
    3000.0 asSpaceString
    5000000.0 asSpaceString
    "
    
    | kilobytes megabytes |

    kilobytes := self / 1024.0.
    kilobytes < 1.0 ifTrue: [^self terseString, ' bytes'].
    megabytes := kilobytes / 1024.0.
    megabytes < 1.0 ifTrue: [^kilobytes terseString, ' kilobytes'].
    ^megabytes terseString, ' megabytes'! ! 
#('April 9, 2003' '09:46:13 PM' 340196)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions' asSpaceString )) !


!Number methods !  
asSpaceString
    "Converts an amount in bytes to a string..."
    
    "
    500.0 asSpaceString
    3000.0 asSpaceString
    5000000.0 asSpaceString
    5000000000.0 asSpaceString
    "
    
    | kilobytes megabytes gigabytes |

    kilobytes := self / 1024.0.
    kilobytes < 1.0 ifTrue: [^self terseString, ' bytes'].
    megabytes := kilobytes / 1024.0.
    megabytes < 1.0 ifTrue: [^kilobytes terseString, ' kilobytes'].
    gigabytes := megabytes / 1024.0.
    gigabytes < 1.0 ifTrue: [^megabytes terseString, ' megabytes'].
    ^gigabytes terseString, ' gigabytes'!    ! 
#('October 16, 2009' '09:28:58 AM' 340796)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions' asSpaceString )) !


!Number methods !   
arcTan: aNumber
    "Returns an answer in the range -pi to +pi like c's atan2...; arcTanAfterDividingBy: returns an answer in the range 0 to 2pi..."
    | result |
    result := self arcTanAfterDividingBy: aNumber. 
    ^result > Float pi ifTrue: [result - Float twoPi] ifFalse: [result]!    ! 
#('October 13, 2008' '03:58:26 PM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions' arcTan: )) !


!Number methods !
asNumber
    ^self!    ! 
#('May 7, 2002' '09:55:01 AM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions for 3D' asNumber )) !


!Number methods ! 
nextLowestPowerOf2
    | result power|
    self < 0 ifTrue: [^self error: 'Not useful on negative numbers.'].
    result := 1.    power := 0.
    [(result + (1 bitShift: power)) > self] whileFalse: [
        result := result + (1 bitShift: power).
        power := power + 1].
    ^result!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions for 3D' nextLowestPowerOf2 )) !


!Number methods !   
nextHighestPowerOf2
    | lower |
    lower := self nextLowestPowerOf2.
    (lower = self asInteger) ifTrue: [^self].
    ^lower * 2!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions for 3D' nextHighestPowerOf2 )) !


!Number methods !  
divideFromPoint3D: aPoint3D
    ^aPoint3D class new
            x: aPoint3D x / self
            y: aPoint3D y / self
            z: aPoint3D z / self! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions for 3D' divideFromPoint3D: )) !


!Number methods !   
floorMod: aNumber
    "The nearest multiple of aNumber that is less than or equal to the receiver"
    ^(self // aNumber) * aNumber!  ! 
#('October 8, 2009' '05:54:47 PM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions' floorMod: )) !


!Number methods !   
to: aNumber collect: aBlock
    ^(self to: aNumber) collect: aBlock!   ! 
#('August 24, 2005' '09:20:23 PM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions' to:collect: )) !


!Number methods ! 
interpolate: aNumber by: t
    "Returns a interpolated result whereby t = 0 fives self and t = 1 gives aNumber..."
    ^self + (aNumber - self) * t!  ! 
#('June 11, 2010' '01:20:19 PM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions' interpolate:by: )) !


!Number methods !   
asTimeString
    "Converts a millisecond time to a string..."
    
    "
    0 asTimeString
    0.1 asTimeString
    2 asTimeString
    (10.343 *  1000.0) asTimeString
    (10.343 *  60.0 * 1000.0) asTimeString
    (10.343 * 60.0 * 60.0 * 1000.0) asTimeString
    (10.343 * 24.0 * 60.0 * 60.0 * 1000.0) asTimeString
    (1000.343 * 24.0 * 60.0 * 60.0 * 1000.0) asTimeString
    "

    | timeInHoursMinutesSeconds days hours minutes seconds |
    self < WorldGlobal epsilon ifTrue: [^'zero time'].
    self < 1.0 ifTrue: [^(self * 1000.0) terseString, ' microseconds'].
    self < 1000.0 ifTrue: [^(self) terseString, ' milliseconds'].
    self < 60000.0 ifTrue: [^(self / 1000.0) terseString, ' seconds'].
    days := self // (24 * 60.0 * 60.0 * 1000.0) .
    timeInHoursMinutesSeconds := Time fromSeconds: (self - (days * (24 * 60.0 * 60.0 * 1000.0))) // 1000.
    hours := timeInHoursMinutesSeconds hours. minutes := timeInHoursMinutesSeconds minutes. seconds := timeInHoursMinutesSeconds seconds.
    (days < 1) & (hours < 1.0) ifTrue: [^minutes printString, ' minutes ', seconds printString,  ' seconds'].
    days < 1 ifTrue: [^hours printString, ' hours ', minutes printString, ' minutes ', seconds printString,  ' seconds'].
    days < 365 ifTrue: [^days printString, ' days ', hours printString, ' hours ', minutes printString, ' minutes ', seconds printString,  ' seconds'].
    ^'infinite time'!  ! 
#('February 18, 2003' '03:03:08 PM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions' asTimeString )) !


!Number methods !  
raisedToPower: aNumber
    ^self raisedTo: aNumber!    ! 
#('April 22, 2010' '03:58:44 PM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions' raisedToPower: )) !


!Number methods !   
notZero
    ^self isZero not!  ! 
#('December 3, 2003' '02:26:24 PM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions' notZero )) !


!Number methods !
asByteSpaceString
    "Converts an amount in bytes to a string..."
    
    "
    500.0 asByteSpaceString
    3000.0 asByteSpaceString
    5000000.0 asByteSpaceString
    "
    
    | string result |
    
    string := self asInteger printString. result := ''.
    string reversed indexedDo: [:index :character | result := (String with: character), result. (index \\ 3) = 0 ifTrue: [result := ',', result]].
    ^(result first == $,) ifTrue: [result suffix: result size - 1] ifFalse: [result]!  ! 
#('September 9, 2009' '09:14:39 AM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions' asByteSpaceString )) !


!Number methods ! 
asByteSpaceString
    "Converts an amount in bytes to a string..."
    
    "
    500.0 asByteSpaceString
    3000.0 asByteSpaceString
    5000000.0 asByteSpaceString
    "
    
    | string result |
    
    string := self asInteger printString. result := ''.
    string reversed indexedDo: [:index :character | result := (String with: character), result. (index \\ 3) = 0 ifTrue: [result := ',', result]].
    ^((result first == $,) ifTrue: [result suffix: result size - 1] ifFalse: [result]), ' bytes'!  ! 
#('September 9, 2009' '09:15:11 AM' 346724)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions' asByteSpaceString )) !


!Number methods !  
asByteSpaceString
    "Converts an amount in bytes to a string..."
    
    "
    500.0 asByteSpaceString
    3000.0 asByteSpaceString
    5000000.0 asByteSpaceString
    "
    
    | string result |
    
    string := self asInteger printString. result := ''.
    string reversed indexedDo: [:index :character | result := (String with: character), result. (index \\ 3) = 0 ifTrue: [result := ',', result]].
    ^((result first == $,) ifTrue: [result suffix: result size - 1] ifFalse: [result]), ' bytes'!  ! 
#('September 9, 2009' '09:15:31 AM' 347396)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions' asByteSpaceString )) !


!Number methods !  
as16Dot16Decimal
    ^(self * (1 bitShift: 16)) truncated! ! 
#('January 9, 2009' '01:53:38 PM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions for 3D' as16Dot16Decimal )) !


!Number methods ! 
equals: aNumber withTolerance: positiveTolerance
    ^(self - aNumber) abs < positiveTolerance!    ! 
#('October 13, 2011' '04:25:56 PM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions for 3D' equals:withTolerance: )) !


!Number methods !   
arcTanAfterDividingBy: aNumber
    "y/x can be used to find a slope and hence an angle in the range 0 to 360 provided we don't lose the sign
    of the operands; e.g., if y and x are both negative, they are in the 3rd quadrant (not the first)."
    | angle quadrant piMultiplier |
    angle := aNumber abs < 1.0e-6 ifTrue: [Float pi * 0.5] ifFalse: [(self abs / aNumber abs) arcTan].

    quadrant := self positive
        ifTrue: [aNumber positive ifTrue: [1] ifFalse: [2]]
        ifFalse: [aNumber positive ifTrue: [4] ifFalse: [3]].
    piMultiplier := (#(0.0 1.0 1.0 2.0) at: quadrant) * Float pi.
    ^piMultiplier perform: (#(+ - + -) at: quadrant)  with: angle

    "(1 arcTanAfterDividingBy: 1) radiansToDegrees               SHOULD BE 45"
    "(1 arcTanAfterDividingBy: -1) radiansToDegrees              SHOULD BE 135"
    "(-1 arcTanAfterDividingBy: -1) radiansToDegrees             SHOULD BE 225"
    "(-1 arcTanAfterDividingBy: 1) radiansToDegrees              SHOULD BE 315"!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('no category methods' arcTanAfterDividingBy: )) !


!Number methods ! 
clampedTo: min and: max
    "Return this number clamped to the range [min,max]."
    ^max min: (self max: min).!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions for 3D' clampedTo:and: )) !


!Number methods !   
largeEpsilonEquals: aNumber
    ^(self - aNumber) abs < WorldGlobal largeEpsilon!  ! 
#('December 2, 2010' '04:27:49 PM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions for 3D' largeEpsilonEquals: )) !


!Number methods ! 
epsilonEquals: aNumber
    ^(self - aNumber) abs < WorldGlobal epsilon!    ! 
#('December 2, 2010' '04:26:59 PM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions for 3D' epsilonEquals: )) !


!Number methods !  
integerLog2
    ^(self log: 2) truncated!  ! 
#('September 25, 2009' '09:55:16 AM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('no category methods' integerLog2 )) !


!Number methods ! 
multiplyFromPoint3D: aPoint3D
    ^aPoint3D class new
            x: self * aPoint3D x
            y: self * aPoint3D y
            z: self * aPoint3D z!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions for 3D' multiplyFromPoint3D: )) !


!Number methods ! 
as48Dot16LongDecimalBits
    | isPositive positiveNumber bits |
    isPositive := self >= 0. positiveNumber := self abs.
    bits := positiveNumber as16Dot16Decimal.
    ^isPositive ifTrue: [bits] ifFalse: [(1 bitShift: 64) - bits] "NOTE:  ((1 bitShift: 64) - 1) printStringRadix: 16  is '16rFFFFFFFFFFFFFFFF' "!    ! 
#('November 22, 2010' '03:11:15 PM' nil)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions for 3D' as48Dot16LongDecimalBits )) !


!Number methods !   
as48Dot16LongDecimalBits
    "((1 bitShift: 64) negated) as48Dot16LongDecimalBits printStringRadix: 16  "
    | isPositive positiveNumber bits |
    isPositive := self >= 0. positiveNumber := self abs.
    bits := positiveNumber as16Dot16Decimal.
    ^isPositive ifTrue: [bits] ifFalse: [(1 bitShift: 64) - bits] "NOTE:  ((1 bitShift: 64) - 1) printStringRadix: 16  is '16rFFFFFFFFFFFFFFFF' "!  ! 
#('November 22, 2010' '03:12:30 PM' 351788)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions for 3D' as48Dot16LongDecimalBits )) !


!Number methods !
as48Dot16LongDecimalBits
    "((1 / (1 bitShift: 16))              ) as48Dot16LongDecimalBits printStringRadix: 16                                    '16r1'  "
    "((1 / (1 bitShift: 16)) negated) as48Dot16LongDecimalBits printStringRadix: 16 '16rFFFFFFFF FFFFFFFF'  "
    "((1 / (1 bitShift: 8))              ) as48Dot16LongDecimalBits printStringRadix: 16                               '16r100'  "
    "((1 / (1 bitShift: 8)) negated) as48Dot16LongDecimalBits printStringRadix: 16 '16rFFFFFFFF FFFFFF00'  "
    
    "((1 bitShift: 0)               ) as48Dot16LongDecimalBits printStringRadix: 16                           '16r10000'  "
    "((1 bitShift: 0)  negated) as48Dot16LongDecimalBits printStringRadix: 16 '16rFFFFFFFF FFFF0000'  "
    "((1 bitShift: 8)               ) as48Dot16LongDecimalBits printStringRadix: 16                      '16r1000000'  "
    "((1 bitShift: 8)  negated) as48Dot16LongDecimalBits printStringRadix: 16 '16rFFFFFFFF FF000000'  "
    "((1 bitShift: 16)              ) as48Dot16LongDecimalBits printStringRadix: 16                 '16r1 00000000'  "
    "((1 bitShift: 16) negated) as48Dot16LongDecimalBits printStringRadix: 16 '16rFFFFFFFF 00000000'  "
    
    "((1 bitShift: 32)              ) as48Dot16LongDecimalBits printStringRadix: 16 '       16r10000 00000000'  "
    "((1 bitShift: 32) negated) as48Dot16LongDecimalBits printStringRadix: 16 '16rFFFF0000 00000000' "
    
    "((1 bitShift: 44)              ) as48Dot16LongDecimalBits printStringRadix: 16 '16r10000000 00000000'  "
    "((1 bitShift: 44) negated) as48Dot16LongDecimalBits printStringRadix: 16 '16rF0000000 00000000' "
    "((1 bitShift: 46)              ) as48Dot16LongDecimalBits printStringRadix: 16 '16r4000000000000000'  "
    "((1 bitShift: 46) negated) as48Dot16LongDecimalBits printStringRadix: 16 '16rC000000000000000' "
    "((1 bitShift: 47)              ) as48Dot16LongDecimalBits printStringRadix: 16 '16r8000000000000000'  " "TOO FAR => GOES NEGATIVE"
    "((1 bitShift: 47) negated) as48Dot16LongDecimalBits printStringRadix: 16 '16r8000000000000000'  "
    
    | isPositive positiveNumber bits |
    isPositive := self >= 0. positiveNumber := self abs.
    bits := positiveNumber as16Dot16Decimal.
    ^isPositive ifTrue: [bits] ifFalse: [(1 bitShift: 64) - bits] "NOTE:  ((1 bitShift: 64) - 1) printStringRadix: 16  is '16rFFFFFFFFFFFFFFFF' "! ! 
#('November 22, 2010' '03:43:46 PM' 352288)!

(CodeFiler organizerFor: Number) reorganizeFrom: #(
('extensions for 3D' as48Dot16LongDecimalBits )) !


!Number class methods !  
readFrom: stringOrStream
    "Answer a number as described on aStream.  The number may
    include a leading radix specification, as in 16rFADE"
    | value base aStream |
    aStream := (stringOrStream isMemberOf: String)
        ifTrue: [ReadStream on: stringOrStream]
        ifFalse: [stringOrStream].
    base := 10.
    value := Integer readFrom: aStream base: 10.
    (aStream peekFor: $r)
        ifTrue:
            ["<base>r<integer>"
            (base := value) < 2 ifTrue: [^self error: 'Invalid radix'].
            value := Integer readFrom: aStream base: base].
    ^ self readRemainderOf: value from: aStream base: base!  ! 
#('November 21, 2001' '12:42:18 PM' nil)!

(CodeFiler organizerFor: Number class) reorganizeFrom: #(
('hyperdrive compiler extensions' readFrom: )) !


!Number class methods ! 
readFrom: stringOrStream base: base
    "Answer a number as described on aStream in the given number base."
    | aStream |
self halt.
    aStream := (stringOrStream isMemberOf: String)
        ifTrue: [ReadStream on: stringOrStream]
        ifFalse: [stringOrStream].
    ^ self readRemainderOf: (Integer readFrom: aStream base: base)
            from: aStream base: base!   ! 
#('November 21, 2001' '12:45:23 PM' nil)!

(CodeFiler organizerFor: Number class) reorganizeFrom: #(
('hyperdrive compiler extensions' readFrom:base: )) !


!Number class methods !
readRemainderOf: integerPart from: aStream base: base
    "Read optional fractional part and exponent, and return the final result"
    | value fraction fracpos |
    value := integerPart.
    (aStream peekFor: $.)
        ifTrue:
            ["<integer>.<fraction>"
            (aStream atEnd not and: [aStream peek isDigit and: [aStream peek digitValue between: 0 and: base - 1]])
                ifTrue:
                    [fracpos := aStream position.
                    fraction := Integer readFrom: aStream base: base.
                    fraction :=
                        fraction asFloat / (base raisedTo: aStream position - fracpos).
                    value := value asFloat + (value < 0
                                    ifTrue: [fraction negated]
                                    ifFalse: [fraction])]
                ifFalse:
                    ["oops - just <integer>."
                    aStream skip: -1.        "un-gobble the period"
                    ^ value
                    "Number readFrom: '3r-22.2'"]].
    (aStream peekFor: $e)
        ifTrue:
            ["<integer>e<exponent>"
            ^ value * (base raisedTo: (Integer readFrom: aStream))].
    ^ value! ! 
#('March 23, 2002' '03:03:31 PM' nil)!

(CodeFiler organizerFor: Number class) reorganizeFrom: #(
('hyperdrive compiler extensions' readRemainderOf:from:base: )) !


  

Number variableByteSubclass: #Float
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Magnitudes' )
  comment: ''!

!Float methods ! 
terseString
    | string point exponent |
    string := self printString.
    point := string indexOf: $..
    exponent := string indexOf: $e.
    exponent > 0 ifTrue: [^(string copyFrom: 1 to: point + 1), (string copyFrom: exponent to: string size)].

    (string at: point + 1) = $0 ifTrue: [^string copyFrom: 1 to: point - 1].
    1 to: string size do: [:index | ('123456789' includes: (string at: index)) ifTrue: [^string copyFrom: 1 to: (point + 1 max: index)]].
    ^string copyFrom: 1 to: point + 1.!    ! 
#('March 19, 2002' '11:57:02 AM' nil)!

(CodeFiler organizerFor: Float) reorganizeFrom: #(
('extensions' terseString )) !


!Float methods !
terseString
    "1.3e-1 terseString '0.1' "
    | string point exponent |
    string := self printString.
    point := string indexOf: $..
    exponent := string indexOf: $e.
    exponent > 0 ifTrue: [^(string copyFrom: 1 to: point + 1), (string copyFrom: exponent to: string size)].

    (string at: point + 1) = $0 ifTrue: [^string copyFrom: 1 to: point - 1].
    1 to: string size do: [:index | ('123456789' includes: (string at: index)) ifTrue: [^string copyFrom: 1 to: (point + 1 max: index)]].
    ^string copyFrom: 1 to: point + 1.!   ! 
#('October 14, 2013' '12:19:45 PM' 358444)!

(CodeFiler organizerFor: Float) reorganizeFrom: #(
('extensions' terseString )) !


!Float methods !   
isFloat32PartEqual: aFloat
    "Returns true if bytes 5 to 8 are equal..."
    5 to: 8 do: [:index | (self at: index) = (aFloat at: index) ifFalse: [^false]].
    ^true!    ! 
#('April 27, 2015' '10:21:13 AM' nil)!

(CodeFiler organizerFor: Float) reorganizeFrom: #(
('extensions' isFloat32PartEqual: )) !


!Float methods !
isFloat32PartEqual: aFloat
    "Returns true if bytes 6 to 8 are equal... and byte 5 differs by at most 2..."
    | difference |
    6 to: 8 do: [:index | (self at: index) = (aFloat at: index) ifFalse: [^false]].
    difference = (self at: 5) - (aFloat at: 5). difference abs < 2 ifFalse: [^false].
    ^true!  ! 
#('April 27, 2015' '10:28:19 AM' 359828)!

(CodeFiler organizerFor: Float) reorganizeFrom: #(
('extensions' isFloat32PartEqual: )) !


!Float methods ! 
isFloat32PartEqual: aFloat
    "Returns true if bytes 6 to 8 are equal... and byte 5 differs by at most 2..."
    | difference |
    6 to: 8 do: [:index | (self at: index) = (aFloat at: index) ifFalse: [^false]].
    difference := (self at: 5) - (aFloat at: 5). difference abs < 2 ifFalse: [^false].
    ^true! ! 
#('April 27, 2015' '10:29:28 AM' 360164)!

(CodeFiler organizerFor: Float) reorganizeFrom: #(
('extensions' isFloat32PartEqual: )) !


!Float methods ! 
printOn: aStream
        "Append the ASCII representation
         (maximum of 8 digits) of
         the receiver to aStream."
    self printOn: aStream
        decimalSeparator: NationalLanguage decimalSeparator
!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Float) reorganizeFrom: #(
('no category methods' printOn: )) !


!Float methods ! 
as
    "Delete this method after..."
    | s r carry result |
    s := self printString, '000000000'.
    r := s copyFrom: 1 to: 8.
    r last < $5 ifTrue: [^r].
    carry := 1. r at: r size put: $0.
    r size - 1 to: 1 by: -1 do: [:i |
        carry = 1 ifFalse: [^r].
        (r at: i) = $. ifFalse: [
            result := (r at: i) digitValue + carry.
            carry := carry // 10.
            r at: i put: (result printString last)]].
    ^r

    "1.5 as"
    "self halt. 1.46666666666 as"
    "1.5 as"
    "1.5 as"!    ! 
#('May 7, 2002' '10:46:22 AM' nil)!

(CodeFiler organizerFor: Float) reorganizeFrom: #(
('extensions' as )) !


!Float methods !
as
    "WILF: Who wrote this? It's a mess but it returns aFloat withoutExponents (somewhat)."
    "Delete this method after..."
    | s r carry result |
    s := self printString, '000000000'.
    r := s copyFrom: 1 to: 8.
    r last < $5 ifTrue: [^r].
    carry := 1. r at: r size put: $0.
    r size - 1 to: 1 by: -1 do: [:i |
        carry = 1 ifFalse: [^r].
        (r at: i) = $. ifFalse: [
            result := (r at: i) digitValue + carry.
            carry := carry // 10.
            r at: i put: (result printString last)]].
    ^r

    "1.5e6 as"
    "self halt. 1.46666666666 as"
    "1.5e-6 as'0.000001'"
    "1.5 as"! ! 
#('November 19, 2009' '09:10:09 AM' 361508)!

(CodeFiler organizerFor: Float) reorganizeFrom: #(
('extensions' as )) !


!Float methods !   
isApproximatelyEqual: aFloat
    | string1 string2 index1 index2 size |
    "The printString is of the form 2.3411 or 0.12333e-4..."
    (string1 := self printString) = (string2 := aFloat printString) ifTrue: [^true].
    (index1 := string1 indexOf: $e) = (index2 := string2 indexOf: $e) ifFalse: [^false].
    size := (string1 size min: string2 size) min: 7.
    (index1 == 0) ifTrue: [^(string1 copyFrom: 1 to: size) = (string2 copyFrom: 1 to: size)]. 
    size := (index1 min: index2) - 1.
    ^((string1 copyFrom: 1 to: size) = (string2 copyFrom: 1 to: size)) and: [(string1 copyFrom: index1) = (string2 copyFrom: index2)]! ! 
#('April 27, 2015' '12:02:46 PM' nil)!

(CodeFiler organizerFor: Float) reorganizeFrom: #(
('extensions' isApproximatelyEqual: )) !


!Float methods !  
isApproximatelyEqual: aFloat
    | string1 string2 index1 index2 size |
    "The printString is of the form 2.3411 or 0.12333e-4..."
    (string1 := self printString) = (string2 := aFloat printString) ifTrue: [^true].
    (index1 := string1 indexOf: $e) = (index2 := string2 indexOf: $e) ifFalse: [^false].
    size := (string1 size min: string2 size) min: 7.
    (index1 = 0) ifTrue: [^(string1 copyFrom: 1 to: size) = (string2 copyFrom: 1 to: size)]. 
    size := ((index1 min: index2) - 1) min: 7.
    ^((string1 copyFrom: 1 to: size) = (string2 copyFrom: 1 to: size)) and: [(string1 copyFrom: index1) = (string2 copyFrom: index2)]! ! 
#('April 27, 2015' '12:06:04 PM' 363000)!

(CodeFiler organizerFor: Float) reorganizeFrom: #(
('extensions' isApproximatelyEqual: )) !


!Float methods !   
isApproximatelyEqual: aFloat
    | string1 string2 index1 index2 size |
    "The printString is of the form 2.3411 or 0.12333e-4..."
    (string1 := self printString) = (string2 := aFloat printString) ifTrue: [^true].
    ((index1 := string1 indexOf: $e) > 0) = ((index2 := string2 indexOf: $e) > 0) ifFalse: [^false].
    size := (string1 size min: string2 size) min: 7.
    (index1 = 0) ifTrue: [^(string1 copyFrom: 1 to: size) = (string2 copyFrom: 1 to: size)]. 
    size := ((index1 min: index2) - 1) min: 7.
    ^((string1 copyFrom: 1 to: size) = (string2 copyFrom: 1 to: size)) and: [(string1 copyFrom: index1) = (string2 copyFrom: index2)]! ! 
#('April 27, 2015' '12:08:57 PM' 363800)!

(CodeFiler organizerFor: Float) reorganizeFrom: #(
('extensions' isApproximatelyEqual: )) !


!Float methods !   
strictlyNegative
    "Answer true if the receiver is less than zero, else answer false."
    ^self < 0.0! ! 
#('September 15, 2011' '03:05:09 PM' nil)!

(CodeFiler organizerFor: Float) reorganizeFrom: #(
('no category methods' strictlyNegative )) !


!Float class methods !
twoPi
    "Answer the floating point representation of 2pi."
    "^3.14159265358979323846 * 2.0"
      ^6.28318530717958647692!  ! 
#('October 13, 2008' '04:02:11 PM' nil)!

(CodeFiler organizerFor: Float class) reorganizeFrom: #(
('no category methods' twoPi )) !


!Float class methods !   
fromInteger: anInteger
        "Answer a floating point representation
         of the argument anInteger."
    <primitive: 40>
    ^0.0 floatError!    ! 
#('November 8, 2010' '05:15:22 PM' nil)!

(CodeFiler organizerFor: Float class) reorganizeFrom: #(
('no category methods' fromInteger: )) !


!Float class methods !
fromInteger: anInteger
        "Answer a floating point representation
         of the argument anInteger."
    <primitive: 40>
    self clearExceptionFlags.
    ^self privateFromInteger: anInteger! ! 
#('November 8, 2010' '05:15:22 PM' 366024)!

(CodeFiler organizerFor: Float class) reorganizeFrom: #(
('no category methods' fromInteger: )) !


!Float class methods ! 
halfPi
    "Answer the floating point representation of pi/2."
    "^3.14159265358979323846 / 2.0"
    ^1.57079632679489661923!  ! 
#('October 13, 2008' '02:52:24 PM' nil)!

(CodeFiler organizerFor: Float class) reorganizeFrom: #(
('no category methods' halfPi )) !


!Float class methods !  
solveForRealRootsOfQuadraticWithA: a b: b c: c ifNone: errorBlock
    "Solution [-b +- sqrt (b*b - 4ac)] / 2a."
    | rootPart x denominatorInverse |
    a abs < WorldGlobal epsilon ifTrue: [
        b abs < WorldGlobal epsilon ifTrue: [^errorBlock value].
        x := c negated / a.
        "Not really a quadratic." ^Array with: x with: x].
    rootPart := (b * b) - (4.0 * a * c).
    rootPart < 0.0 ifTrue: [^errorBlock value].
    rootPart := rootPart sqrt. denominatorInverse := 0.5 / a.
    ^Array with: (b + rootPart) negated * denominatorInverse with: (b negated + rootPart) * denominatorInverse!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Float class) reorganizeFrom: #(
('extensions' solveForRealRootsOfQuadraticWithA:b:c:ifNone: )) !


!Float class methods ! 
privateFromInteger: anInteger
        "Answer a floating point representation
         of the argument anInteger."
    <primitive: 40>
    ^0.0 floatError! ! 
#('November 8, 2010' '05:13:56 PM' nil)!

(CodeFiler organizerFor: Float class) reorganizeFrom: #(
('no category methods' privateFromInteger: )) !


!Float class methods ! 
tersePrinting
    ^true!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Float class) reorganizeFrom: #(
('extensions' tersePrinting )) !


!Float class methods ! 
readFrom: aStream
    "Answer a new Float as described on the stream, aStream."

    ^(super readFrom: aStream) asFloat! ! 
#('November 21, 2001' '12:44:40 PM' nil)!

(CodeFiler organizerFor: Float class) reorganizeFrom: #(
('hyperdrive compiler extensions' readFrom: )) !


 

Number subclass: #Fraction
  instanceVariableNames: 
    ' numerator denominator '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Magnitudes' )
  comment: ''!



Number subclass: #Integer
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Magnitudes' )
  comment: ''!

!Integer methods !
asMillisecondTimeString
    | seconds milliseconds |
    seconds := (self // 1000) printString.
    milliseconds := '00', (self \\ 1000) printString.
    ^seconds, '.', (milliseconds copyFrom: milliseconds size - 2 to: milliseconds size), ' seconds'!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Integer) reorganizeFrom: #(
('extensions' asMillisecondTimeString )) !


!Integer methods !   
isPowerOfTwo
        "Answer true if receiver is a kind of Integer."
    ^(self bitAnd: (self width - 1)) = 0!    ! 
#('July 16, 2003' '11:57:46 AM' nil)!

(CodeFiler organizerFor: Integer) reorganizeFrom: #(
('no category methods' isPowerOfTwo )) !


!Integer methods !   
isPowerOfTwo
        "Answer true if receiver is a kind of Integer."
    ^(self bitAnd: (self  - 1)) = 0! ! 
#('July 16, 2003' '11:57:57 AM' 369500)!

(CodeFiler organizerFor: Integer) reorganizeFrom: #(
('no category methods' isPowerOfTwo )) !


!Integer methods !
asLong
    ^self!  ! 
#('February 25, 2003' '10:09:15 AM' nil)!

(CodeFiler organizerFor: Integer) reorganizeFrom: #(
('hyperdrive extensions' asLong )) !


!Integer methods !   
asciiValue
    ^self!  ! 
#('October 2, 2009' '02:39:57 PM' nil)!

(CodeFiler organizerFor: Integer) reorganizeFrom: #(
('extensions' asciiValue )) !


!Integer methods !
noMask: mask
    "Treat the argument as a bit mask. Answer whether none of the bits that
    are 1 in the argument are 1 in the receiver."

    ^0 = (self bitAnd: mask)!   ! 
#('November 21, 2001' '05:08:22 PM' nil)!

(CodeFiler organizerFor: Integer) reorganizeFrom: #(
('hyperdrive extensions' noMask: )) !


!Integer methods !  
strictlyNegative
    "Answer true if the receiver is less than zero, else answer false."
    ^self < 0!   ! 
#('September 15, 2011' '03:05:09 PM' nil)!

(CodeFiler organizerFor: Integer) reorganizeFrom: #(
('no category methods' strictlyNegative )) !


!Integer class methods !
readFrom: aStream
        "Read an integer from <aStream> and return it"
    | value char |
    value := 0.
    [ ( char := aStream peek ) ~~ nil and: [ char isDigit ] ]
        whileTrue: [
            value := value * 10 + char digitValue.
            aStream next ].
    char == $r
        ifFalse: [ ^value ].
    aStream next. "skip the r"
    ^self readFrom: aStream radix: value!   ! 
#('November 21, 2001' '12:43:45 PM' nil)!

(CodeFiler organizerFor: Integer class) reorganizeFrom: #(
('no category methods' readFrom: )) !


!Integer class methods !  
readFrom: aStream base: base
    "Answer an instance of one of my concrete subclasses. Initial minus sign
    accepted, and bases > 10 use letters A-Z. Embedded radix specifiers not
    allowed--use Number readFrom: for that. Answer zero (not an error) if
    there are no digits."

    | digit value neg |
    neg := aStream peekFor: $-.
    value := 0.
    [aStream atEnd]
        whileFalse:
            [digit := aStream next hyperdriveDigitValue.
            (digit < 0 or: [digit >= base])
                ifTrue:
                    [aStream skip: -1.
                    neg ifTrue: [^ value negated].
                    ^ value]
                ifFalse: [value := value * base + digit]].
    neg ifTrue: [^ value negated].
    ^ value!    ! 
#('November 21, 2001' '05:01:26 PM' nil)!

(CodeFiler organizerFor: Integer class) reorganizeFrom: #(
('hyperdrive compiler extensions' readFrom:base: )) !


  

LargeInteger variableByteSubclass: #LargeNegativeInteger
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Magnitudes' )
  comment: ''!

!LargeNegativeInteger methods ! 
strictlyNegative
    "Answer true if the receiver is less than zero, else answer false."
    ^true!   ! 
#('September 15, 2011' '03:05:09 PM' nil)!

(CodeFiler organizerFor: LargeNegativeInteger) reorganizeFrom: #(
('no category methods' strictlyNegative )) !


   

LargeInteger variableByteSubclass: #LargePositiveInteger
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Magnitudes' )
  comment: ''!

!LargePositiveInteger methods ! 
strictlyNegative
    "Answer true if the receiver is less than zero, else answer false."
    ^false!  ! 
#('September 15, 2011' '03:05:09 PM' nil)!

(CodeFiler organizerFor: LargePositiveInteger) reorganizeFrom: #(
('no category methods' strictlyNegative )) !


   

Object subclass: #ObjectChangeMap
  instanceVariableNames: 
    ' sourceClassName sourceVariables destinationClassName destinationVariables variableMappings destinationSlotArray '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

Object subclass: #ObjectFiler
  instanceVariableNames: 
    ' objectStream objectVersion textStream messageStream messageCounts numBehaviors numObjects behaviors objects remappedObjects idCharacterZero idIntegerZero operationAborted clientContext clientMessageHandler clientAllocateDictionaryAction libraryMappings libraryDependencies eventTable useBindingInformation objectTransformationMap softSlotValues '
  classVariableNames: 
    ' ClassIdDBSymbol ClassIdSymbol IdNil IdNUL NUL NumPredefinedIds Platform RepFixedPointers RepVariableBytes RepVariablePointers ReservedIdDescriptions ReservedIdMap Seal TagClass TagMetaClass TerminalClasses Version '
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

Object subclass: #ObjectReference
  instanceVariableNames: 
    ' type value resolveWhenLoaded '
  classVariableNames: 
    ' ResolveActions '
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

Object subclass: #ObjectStoreExternal
  instanceVariableNames: 
    ' type value '
  classVariableNames: ''
  poolDictionaries: 
    ' ObjectStoreExternalTypes '
  categories: #( 'Kernel-Object Libraries' )
  comment: ''!



Object subclass: #ObjectStoreFile
  instanceVariableNames: 
    ' stream externals dir fileName spaces currentSpace objectStore '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



ObjectStoreExternal subclass: #ObjectStoreFileExternal
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



ObjectStoreFile subclass: #ObjectStoreFileWithVersion
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

Object subclass: #ObjectStoreObject
  instanceVariableNames: 
    ' offset '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

Object subclass: #ObjectStoreObjects
  instanceVariableNames: 
    ' objects imports toAdd remaps prereqs eventTable externalsStrings inverseGlobals autoPrereq objectProperties objectEventTables includeObjectSlots '
  classVariableNames: 
    ' FixedClasses '
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

ObjectStoreObjects subclass: #ObjectStoreFileObjects
  instanceVariableNames: 
    ' objectStore '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

Object subclass: #ObjectStoreReader
  instanceVariableNames: 
    ' objectStore eventTable globalNames '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Object Libraries' )
  comment: ''!

  

ObjectStoreReader subclass: #ObjectLoader
  instanceVariableNames: 
    ' clientContext feedback objectChangeMaps objectVersion remappedObjects actualChangeMaps operationAborted clientMessageHandler messageCounts useBindingInformation '
  classVariableNames: 
    ' Platform StandardLoadMaps SupportedVersions Version '
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



Object subclass: #ObjectStoreRoot
  instanceVariableNames: 
    ' root '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

Object subclass: #ObjectStoreSpace
  instanceVariableNames: 
    ' offset type objects externalReferences stream missing objectStoreObjects '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



Object subclass: #ObjectStoreSpaceExternals
  instanceVariableNames: 
    ' objectToExternal externalToIndex includeFixed includeChars objectToIndex '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

ObjectStore subclass: #ObjectStoreWithClient
  instanceVariableNames: 
    ' client '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



Object subclass: #ObjectStoreWriter
  instanceVariableNames: 
    ' feedback objectStore counter '
  classVariableNames: ''
  poolDictionaries: 
    ' ObjectStoreExternalTypes '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

ObjectStoreWriter subclass: #ObjectDumper
  instanceVariableNames: 
    ' clientContext clientAllocateDictionaryAction clientMessageHandler libraryMappings '
  classVariableNames: 
    ' Version '
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

Object subclass: #OperatingSystemInformation
  instanceVariableNames: 
    ' hInstanceExe hInstanceDLL dialogProc kernelHandle mathChip winClassName '
  classVariableNames: 
    ' SystemColors SystemValues '
  poolDictionaries: 
    ' OperatingSystemConstants SystemValueConstants VirtualMachineConstants '
  categories: #( 'Kernel-Host Interfaces' )
  comment: ''!

!OperatingSystemInformation methods !  
dingle
        "Beep the speaker"
    ( UserLibrary messageBeep: MbIconasterisk )
        ifFalse: [ ^self osError ]!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: OperatingSystemInformation) reorganizeFrom: #(
('extensions' dingle )) !


   

IndexedCollection subclass: #OrderedCollection
  instanceVariableNames: 
    ' startPosition endPosition contents '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Collections' )
  comment: ''!

!OrderedCollection methods !  
addAllIfIdenticalAbsent: aCollection
    aCollection do: [:anObject | self addIfIdenticalAbsent: anObject]!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: OrderedCollection) reorganizeFrom: #(
('extension' addAllIfIdenticalAbsent: )) !


!OrderedCollection methods !   
copyFrom: beginning to: end
        "Answer an OrderedCollection containing the
         elements of the receiver from index position
         beginning through index position end."
    | answer endPos |
    ( endPos := end - beginning + 1 ) negative ifTrue: [ self errorInBounds: endPos ].
    ( answer := self species new: self size )
        startPosition: 1
        endPosition: endPos.
    ^answer
        replaceFrom: 1
        to: endPos
        with: self
        startingAt: beginning! ! 
#('October 15, 2009' '02:54:37 PM' nil)!

(CodeFiler organizerFor: OrderedCollection) reorganizeFrom: #(
('no category methods' copyFrom:to: )) !


!OrderedCollection methods !
copyFrom: beginning to: end
    "Answer an OrderedCollection containing the elements of the receiver from index position beginning through index position end."
    | answer newSize |
    (newSize := end - beginning + 1) negative ifTrue: [self errorInBounds: newSize].
    ^(self species new: newSize)
        startPosition: 1 endPosition: newSize;
        replaceFrom: 1 to: newSize with: self startingAt: beginning!  ! 
#('October 15, 2009' '02:54:37 PM' 379844)!

(CodeFiler organizerFor: OrderedCollection) reorganizeFrom: #(
('no category methods' copyFrom:to: )) !


!OrderedCollection methods ! 
addAllIfAbsent: aCollection
    aCollection do: [:anObject | self addIfAbsent: anObject]!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: OrderedCollection) reorganizeFrom: #(
('extension' addAllIfAbsent: )) !


!OrderedCollection methods !
add: anObject ifNoneSatisfies: aBlock
    self do: [:element | (aBlock value: element) ifTrue: [^self]].
    self add: anObject!  ! 
#('July 10, 2009' '10:59:10 AM' nil)!

(CodeFiler organizerFor: OrderedCollection) reorganizeFrom: #(
('extension' add:ifNoneSatisfies: )) !


!OrderedCollection methods ! 
removeIdentical: anObject
    | where |
    (where := self indexOfIdentical: anObject) = 0 ifTrue: [^nil]. "already done"
    self removeIndex: where.
    ^anObject!   ! 
#('May 18, 2001' '02:04:53 PM' nil)!

(CodeFiler organizerFor: OrderedCollection) reorganizeFrom: #(
('extension' removeIdentical: )) !


!OrderedCollection methods !  
removeAll
    "Answer self.  Remove all elements."
    startPosition to: endPosition do: [:index | contents at: index put: nil].
    startPosition := 1. endPosition := 0.!  ! 
#('May 15, 2003' '10:29:59 PM' nil)!

(CodeFiler organizerFor: OrderedCollection) reorganizeFrom: #(
('extension' removeAll )) !


!OrderedCollection methods ! 
removeAllIdentical: aCollection
    aCollection do: [:anObject | self removeIdentical: anObject]!  ! 
#('May 18, 2001' '02:22:49 PM' nil)!

(CodeFiler organizerFor: OrderedCollection) reorganizeFrom: #(
('extension' removeAllIdentical: )) !


!OrderedCollection methods !   
addAllIfIdenticalCollectionAbsent: aCollection
    "Add a collection to the receiver if it doesn't already contain it."

    ((self indexOfIdenticalCollection: aCollection) = 0) ifFalse: [^self].
    self addAll: aCollection!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: OrderedCollection) reorganizeFrom: #(
('extension' addAllIfIdenticalCollectionAbsent: )) !


!OrderedCollection methods ! 
removeLast: size

    | removals |
    removals := OrderedCollection new.
    (size min: self size) timesRepeat: [removals addFirst: self removeLast].
    ^removals!  ! 
#('August 28, 2001' '10:44:53 AM' nil)!

(CodeFiler organizerFor: OrderedCollection) reorganizeFrom: #(
('extension' removeLast: )) !


!OrderedCollection methods !
addIfNotNil: anObject
    anObject isNil ifTrue: [^self].
    self add: anObject! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: OrderedCollection) reorganizeFrom: #(
('extension' addIfNotNil: )) !


!OrderedCollection methods !   
addIfNotNilOrEmptyString: anObject
    anObject isNil ifTrue: [^self].
    anObject = '' ifTrue: [^self].
    self add: anObject!    ! 
#('July 12, 2006' '06:17:56 PM' nil)!

(CodeFiler organizerFor: OrderedCollection) reorganizeFrom: #(
('extension' addIfNotNilOrEmptyString: )) !


!OrderedCollection methods !
addIfIdenticalAbsent: anObject
    (self includesIdentical: anObject) ifTrue: [^self].
    self add: anObject!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: OrderedCollection) reorganizeFrom: #(
('extension' addIfIdenticalAbsent: )) !


!OrderedCollection methods !  
add: anObject
        "Answer anObject.  Add anObject after the
         last element of the receiver collection."

    endPosition = contents size
        ifTrue: [self putSpaceAtEnd].
    endPosition := endPosition + 1.
    contents at: endPosition put: anObject.
    ^anObject!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: OrderedCollection) reorganizeFrom: #(
('no category methods' add: )) !


!OrderedCollection methods ! 
collectIfNotNil: aBlock
    | answer |
    answer := self species new: self size.
    self do: [:element|
        answer addIfNotNil: (aBlock value: element)].
    ^answer!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: OrderedCollection) reorganizeFrom: #(
('extension' collectIfNotNil: )) !


!OrderedCollection methods !   
removeFirst: size

    | removals |
    removals := OrderedCollection new.
    (size min: self size) timesRepeat: [removals addLast: self removeFirst].
    ^removals! ! 
#('August 28, 2001' '10:45:08 AM' nil)!

(CodeFiler organizerFor: OrderedCollection) reorganizeFrom: #(
('extension' removeFirst: )) !


!OrderedCollection methods !   
addIfAbsent: anObject
    (self includes: anObject) ifTrue: [^self].
    self add: anObject!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: OrderedCollection) reorganizeFrom: #(
('extension' addIfAbsent: )) !


!OrderedCollection methods !   
addAllIfCollectionAbsent: aCollection
    "Add a collection to the receiver if it doesn't already contain it."
    ((self indexOfCollection: aCollection) == 0) ifFalse: [^self].
    self addAll: aCollection!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: OrderedCollection) reorganizeFrom: #(
('extension' addAllIfCollectionAbsent: )) !


  

OrderedCollection subclass: #MonitoredCollection
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Collections' )
  comment: ''!

!MonitoredCollection methods !
indexOfIdentical: anObject

    | r |
    r := super indexOfIdentical: anObject.
    Transcript cr; << 'Index is: '; << r; << ' [ '; << anObject; <<' ]'.
    ^r!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: MonitoredCollection) reorganizeFrom: #(
('no category methods' indexOfIdentical: )) !


!MonitoredCollection methods !
add: anObject
    | r |
    r := super add: anObject.
    Transcript cr; << 'Collection size is now: '; << self size; << ' [ '; << anObject; <<' ]'.
    ^r
!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: MonitoredCollection) reorganizeFrom: #(
('no category methods' add: )) !


   

Collection subclass: #OrderedDictionary
  instanceVariableNames: 
    ' dictionary orderedCollection '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Collections' )
  comment: ''!

!OrderedDictionary methods !   
indexOfKey: key
    ^self indexOfKey: key ifAbsent: [0]!   ! 
#('March 19, 2011' '03:02:10 PM' nil)!

(CodeFiler organizerFor: OrderedDictionary) reorganizeFrom: #(
('manipulating' indexOfKey: )) !


!OrderedDictionary methods !  
keysAndValuesDo: aBlock
    orderedCollection do: [:key | aBlock value: key value: (dictionary at: key)]!  ! 
#('December 1, 2004' '09:31:56 AM' nil)!

(CodeFiler organizerFor: OrderedDictionary) reorganizeFrom: #(
('manipulating' keysAndValuesDo: )) !


!OrderedDictionary methods !   
size
    ^orderedCollection size!  ! 
#('December 1, 2004' '11:36:07 AM' nil)!

(CodeFiler organizerFor: OrderedDictionary) reorganizeFrom: #(
('manipulating' size )) !


!OrderedDictionary methods !   
includesKey: key
    ^dictionary includesKey: key! ! 
#('December 1, 2004' '09:34:07 AM' nil)!

(CodeFiler organizerFor: OrderedDictionary) reorganizeFrom: #(
('manipulating' includesKey: )) !


!OrderedDictionary methods !   
indexOfKey: key ifAbsent: aBlock
    ^orderedCollection indexOf: key ifAbsent: aBlock! ! 
#('March 19, 2011' '03:00:52 PM' nil)!

(CodeFiler organizerFor: OrderedDictionary) reorganizeFrom: #(
('manipulating' indexOfKey:ifAbsent: )) !


!OrderedDictionary methods ! 
keys
    ^orderedCollection!   ! 
#('December 1, 2004' '09:33:14 AM' nil)!

(CodeFiler organizerFor: OrderedDictionary) reorganizeFrom: #(
('manipulating' keys )) !


!OrderedDictionary methods !   
at: key put: element
    (dictionary includesKey: key) ifFalse: [orderedCollection add: key]. 
    ^dictionary at: key put: element!  ! 
#('December 1, 2004' '09:27:50 AM' nil)!

(CodeFiler organizerFor: OrderedDictionary) reorganizeFrom: #(
('manipulating' at:put: )) !


!OrderedDictionary methods !
keyExists: key
    ^dictionary includesKey: key!   ! 
#('December 1, 2004' '09:35:24 AM' nil)!

(CodeFiler organizerFor: OrderedDictionary) reorganizeFrom: #(
('manipulating' keyExists: )) !


!OrderedDictionary methods ! 
do: aBlock
    orderedCollection do: [:key | aBlock value: (dictionary at: key)]!  ! 
#('December 1, 2004' '09:32:49 AM' nil)!

(CodeFiler organizerFor: OrderedDictionary) reorganizeFrom: #(
('manipulating' do: )) !


!OrderedDictionary methods !
at: key
    ^dictionary at: key!   ! 
#('December 1, 2004' '09:28:49 AM' nil)!

(CodeFiler organizerFor: OrderedDictionary) reorganizeFrom: #(
('manipulating' at: )) !


!OrderedDictionary methods !
at: key ifAbsent: exceptionBlock
    ^dictionary at: key ifAbsent: exceptionBlock! ! 
#('December 1, 2004' '04:53:53 PM' nil)!

(CodeFiler organizerFor: OrderedDictionary) reorganizeFrom: #(
('manipulating' at:ifAbsent: )) !


!OrderedDictionary methods !   
containsKey: key
    "Correct terminology: A set contains an element and includes another set..."
    ^dictionary includesKey: key!   ! 
#('December 1, 2004' '09:36:44 AM' nil)!

(CodeFiler organizerFor: OrderedDictionary) reorganizeFrom: #(
('manipulating' containsKey: )) !


!OrderedDictionary methods !   
keysDo: aBlock
    orderedCollection do: aBlock!   ! 
#('December 1, 2004' '09:32:19 AM' nil)!

(CodeFiler organizerFor: OrderedDictionary) reorganizeFrom: #(
('manipulating' keysDo: )) !


!OrderedDictionary methods !
initialize
    dictionary := Dictionary new. orderedCollection := OrderedCollection new!   ! 
#('December 1, 2004' '09:19:38 AM' nil)!

(CodeFiler organizerFor: OrderedDictionary) reorganizeFrom: #(
('initializing' initialize )) !


!OrderedDictionary methods ! 
values
    ^orderedCollection collect: [:key | dictionary at: key]!    ! 
#('December 1, 2004' '11:34:29 AM' nil)!

(CodeFiler organizerFor: OrderedDictionary) reorganizeFrom: #(
('manipulating' values )) !


!OrderedDictionary methods ! 
printOn: aStream
    | firstTime |
    self class printOn: aStream.
    aStream nextPutAll: ' ('.
    firstTime := true.
    self keysAndValuesDo: [:key :value |
        firstTime ifTrue: [firstTime := false] ifFalse: [aStream space].
        key printOn: aStream. aStream nextPutAll: '=>'. value printOn: aStream].
    aStream nextPutAll: ')'!    ! 
#('December 1, 2004' '11:05:13 AM' nil)!

(CodeFiler organizerFor: OrderedDictionary) reorganizeFrom: #(
('printing' printOn: )) !


!OrderedDictionary class methods ! 
new
    ^super new initialize! ! 
#('December 1, 2004' '09:22:44 AM' nil)!

(CodeFiler organizerFor: OrderedDictionary class) reorganizeFrom: #(
('instance creation' new )) !


 

OrderedDictionary subclass: #OrderedIdentityDictionary
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Collections' )
  comment: ''!

!OrderedIdentityDictionary methods !
indexOfKey: key ifAbsent: aBlock
    ^orderedCollection indexOfIdentical: key ifAbsent: aBlock!    ! 
#('March 19, 2011' '03:01:34 PM' nil)!

(CodeFiler organizerFor: OrderedIdentityDictionary) reorganizeFrom: #(
('manipulating' indexOfKey:ifAbsent: )) !


!OrderedIdentityDictionary methods ! 
initialize
    dictionary := IdentityDictionary new. orderedCollection := OrderedCollection new!   ! 
#('December 1, 2004' '09:24:22 AM' nil)!

(CodeFiler organizerFor: OrderedIdentityDictionary) reorganizeFrom: #(
('initializing' initialize )) !


 

Object subclass: #Organizer
  instanceVariableNames: 
    ' categories categoryToElement dirty owner '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'Tools-Navigator' )
  comment: ''!

!Organizer methods !  
basicReorganizeFrom: collection
    "collection     <Collection withAll: organizationCollection>
                    organizationCollection      <Collection with: category withAll: elementsOfCategory>
    Reorganize myself so that category contains elementsOfCategory
    for each organizationCollection"

    collection do: [:each |
        self addElements: (each copyFrom: 2 to: each size) toCategories: (Array with: each first)]!    ! 
#('March 7, 2003' '06:04:46 PM' nil)!

(CodeFiler organizerFor: Organizer) reorganizeFrom: #(
('primitive elements' basicReorganizeFrom: )) !


!Organizer methods !
elementsOfCategory: categoryName

    ^self elementsOfCategory: categoryName ifAbsent: [self error: 'unknown category: ', categoryName].! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Organizer) reorganizeFrom: #(
('categories' elementsOfCategory: )) !


!Organizer methods !   
rename: oldCategoryName to: newCategoryName
    ^self basicRename: oldCategoryName to: newCategoryName!    ! 
#('February 25, 2003' '10:09:31 AM' nil)!

(CodeFiler organizerFor: Organizer) reorganizeFrom: #(
('categories' rename:to: )) !


!Organizer methods !  
removeCategory: categoryName ifAbsent: errorBlock
    "Remove the category named categoryName.  If it isn't there, evaluate errorBlock"

    self categories remove: categoryName ifAbsent: errorBlock.
    self categoryToElement removeKey: categoryName.
    self makeDirty.!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Organizer) reorganizeFrom: #(
('categories' removeCategory:ifAbsent: )) !


!Organizer methods !  
removeCategory: categoryName
    "Remove the category named categoryName.
    If it isn't there, evaluate an error"

    self removeCategory: categoryName ifAbsent: [self makeDirty. ^nil]!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Organizer) reorganizeFrom: #(
('categories' removeCategory: )) !


!Organizer methods !   
removeElements: objects
    "objects    <collection of objects>
    remove the contents of objects from each of their categories."

  objects do: [:each |
        self removeElement: each fromCategories: (self categoriesOfElement: each)]! ! 
#('March 30, 2003' '07:18:04 PM' nil)!

(CodeFiler organizerFor: Organizer) reorganizeFrom: #(
('elements' removeElements: )) !


!Organizer methods !  
removeElements: objects
    "objects    <collection of objects>
    remove the contents of objects from each of their categories."

  objects do: [:each | self removeElement: each fromCategories: (self categoriesOfElement: each)]!  ! 
#('March 30, 2003' '07:18:04 PM' 395012)!

(CodeFiler organizerFor: Organizer) reorganizeFrom: #(
('elements' removeElements: )) !


!Organizer methods !   
basicRename: oldCategoryName to: newCategoryName

    | index |
    index := self categories indexOf: oldCategoryName.
    index = 0 ifTrue: [^self makeDirty].
    self categories at: index put: newCategoryName.
    self categoryToElement
        at: newCategoryName
        put: (self categoryToElement at: oldCategoryName);
        removeKey: oldCategoryName.
    self makeDirty.!    ! 
#('February 25, 2003' '10:09:31 AM' nil)!

(CodeFiler organizerFor: Organizer) reorganizeFrom: #(
('categories' basicRename:to: )) !


!Organizer methods ! 
removeElement: anObject fromCategories: aCollectionOfCategoryNames
    "Remove anObject from the named categories"

    ^aCollectionOfCategoryNames do: [:each |
        self removeElement: anObject fromCategory: each]!  ! 
#('March 30, 2003' '07:17:35 PM' nil)!

(CodeFiler organizerFor: Organizer) reorganizeFrom: #(
('elements' removeElement:fromCategories: )) !


!Organizer methods !
removeElement: anObject fromCategories: aCollectionOfCategoryNames
    "Remove anObject from the named categories"

    ^aCollectionOfCategoryNames do: [:each | self removeElement: anObject fromCategory: each]!   ! 
#('March 30, 2003' '07:17:35 PM' 396388)!

(CodeFiler organizerFor: Organizer) reorganizeFrom: #(
('elements' removeElement:fromCategories: )) !


!Organizer methods ! 
elementsOfCategory: categoryName ifAbsent: aBlock
    "Answer the set of elements of the category named categoryName"

    (self isKnownCategory: categoryName) ifFalse: [^aBlock value].
    ^self categoryToElement at: categoryName! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Organizer) reorganizeFrom: #(
('categories' elementsOfCategory:ifAbsent: )) !


!Organizer methods !  
editStringForCategories: selectedCategories
    "selectedCategories        <Collection withAll: <Symbol>>
        ^                           <String>
    Answer a string with the named categories, and their contents listed
    one per line with brackets around each one"

    | stream sizeSoFar |
    stream := WriteStream on: String new.
    self categories do: [:category |
        (selectedCategories includes: category) ifTrue: [
            stream << '('; << category storeString; space.
            sizeSoFar := 0.
            (self elementsOfCategory: category) asSortedCollection 
                do: [:element | stream nextPutAll: element. sizeSoFar := sizeSoFar + element size + 1]
                andBetweenDo: [sizeSoFar > 250 ifTrue: [sizeSoFar := 0. stream cr; << '        '] ifFalse: [stream space]].
            stream << ')'; cr]].
    ^stream contents! ! 
#('April 26, 2002' '12:10:18 PM' nil)!

(CodeFiler organizerFor: Organizer) reorganizeFrom: #(
('storing' editStringForCategories: )) !


!Organizer methods !  
basicAddElement: anObject toCategory: categoryName
    "Add anObject to the category named categoryName.  If I don't have such a category, I'll create it."

    (self isKnownCategory: categoryName)
        ifFalse: [self addCategory: categoryName].
    (self categoryToElement at: categoryName) add: anObject.
    self makeDirty.!    ! 
#('March 30, 2003' '06:33:46 PM' nil)!

(CodeFiler organizerFor: Organizer) reorganizeFrom: #(
('primitive elements' basicAddElement:toCategory: )) !


!Organizer methods !
removeElement: anObject fromCategory: categoryName
    "Remove anObject from the category named categoryName."

    (self isKnownCategory: categoryName)
        ifFalse: [self error: 'no category named ', categoryName].
    (self categoryToElement at: categoryName)
        remove: anObject
        ifAbsent: [self error: 'object not in category'].
    self makeDirty.!   ! 
#('March 30, 2003' '07:18:51 PM' nil)!

(CodeFiler organizerFor: Organizer) reorganizeFrom: #(
('elements' removeElement:fromCategory: )) !


!Organizer methods !  
removeElement: anObject fromCategory: categoryName
    "Remove anObject from the category named categoryName."

    (self isKnownCategory: categoryName)
        ifFalse: [self error: 'no category named ', categoryName].
    (self categoryToElement at: categoryName)
        remove: anObject ifAbsent: [self error: 'object not in category'].
    self makeDirty.!    ! 
#('March 30, 2003' '07:18:51 PM' 399184)!

(CodeFiler organizerFor: Organizer) reorganizeFrom: #(
('elements' removeElement:fromCategory: )) !


!Organizer methods !   
basicReorganize: elements into: newCategories
    "elements   <collection of objects>
    newCategories <collection of strings>
    Make every object in elements a member of only those categories in newCategories"

    "first step is to primitively remove every element from its categories"
    elements do: [:each |
        (self categoriesOfElement: each) do: [:category |
            (self categoryToElement at: category) remove: each ifAbsent: [nil]]].
    "next, add elements to their new categories"
    self addElements: elements toCategories: newCategories.
    self updateDefaultCategory.
    self makeDirty.!  ! 
#('March 5, 2003' '10:31:09 PM' nil)!

(CodeFiler organizerFor: Organizer) reorganizeFrom: #(
('primitive elements' basicReorganize:into: )) !


!Organizer methods !   
basicRemoveCategory: categoryName ifAbsent: errorBlock
    "Remove the category named categoryName.  If it isn't there, evaluate errorBlock"

    self categories remove: categoryName ifAbsent: errorBlock.
    self categoryToElement removeKey: categoryName.
    self makeDirty.!  ! 
#('March 8, 2003' '03:27:04 PM' nil)!

(CodeFiler organizerFor: Organizer) reorganizeFrom: #(
('categories' basicRemoveCategory:ifAbsent: )) !


!Organizer methods !   
renameElementsOfCategory: categoryName from: oldElementNames to: newElementNames

    | index |
    self categoryToElement 
        at: categoryName 
        put: ((self categoryToElement at: categoryName) collect: [:name |
            index := oldElementNames indexOf: name.
            index == 0 ifTrue: [name] ifFalse: [newElementNames at: index]])!    ! 
#('April 23, 2005' '12:22:39 PM' nil)!

(CodeFiler organizerFor: Organizer) reorganizeFrom: #(
('categories' renameElementsOfCategory:from:to: )) !


!Organizer methods !  
renameElementsOfCategory: categoryName from: oldElementNames to: newElementNames

    | index |
    self categoryToElement
        at: categoryName
        put: ((self categoryToElement at: categoryName) collect: [:name |
            index := oldElementNames indexOfIdentical: name.
            index == 0 ifTrue: [name] ifFalse: [newElementNames at: index]])! ! 
#('April 23, 2005' '12:52:47 PM' 401568)!

(CodeFiler organizerFor: Organizer) reorganizeFrom: #(
('categories' renameElementsOfCategory:from:to: )) !


!Organizer methods !   
addElement: anObject toCategory: categoryName
    "Add anObject to the category named categoryName.  If I don't have such a category, I'll create it."

    (self isKnownCategory: categoryName)
        ifFalse: [self addCategory: categoryName].
    (self categoryToElement at: categoryName) add: anObject.
    self makeDirty.! ! 
#('March 30, 2003' '06:35:40 PM' nil)!

(CodeFiler organizerFor: Organizer) reorganizeFrom: #(
('elements' addElement:toCategory: )) !


!Organizer methods !   
addElement: anObject toCategory: categoryName
    "Add anObject to the category named categoryName.  If I don't have such a category, I'll create it."
    ^self basicAddElement: anObject toCategory: categoryName!  ! 
#('March 30, 2003' '06:35:40 PM' 402672)!

(CodeFiler organizerFor: Organizer) reorganizeFrom: #(
('elements' addElement:toCategory: )) !


!Organizer methods !
sourceManager
    ^SourceManager current!  ! 
#('March 3, 2003' '10:13:24 AM' nil)!

(CodeFiler organizerFor: Organizer) reorganizeFrom: #(
('querying' sourceManager )) !


!Organizer methods ! 
basicRemoveElement: anObject
    "Remove anObject from all of my categories"

    ^self removeElement: anObject fromCategories: (self categoriesOfElement: anObject)!    ! 
#('March 8, 2003' '03:22:36 PM' nil)!

(CodeFiler organizerFor: Organizer) reorganizeFrom: #(
('primitive elements' basicRemoveElement: )) !


!Organizer methods ! 
removeCategories: categoryNames
    "categoryNames: <collection of strings>
    Remove the categories named in categoryNames"

    categoryNames do: [:each |
        self removeCategory: each ifAbsent: [self makeDirty. ^nil]]! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Organizer) reorganizeFrom: #(
('categories' removeCategories: )) !


 

Organizer subclass: #ClassBasedOrganizer
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Navigator' )
  comment: ''!

!ClassBasedOrganizer methods ! 
removeElement: aMethodSelector
    "Remove aMethodSelector from all of my categories, and from my owner"
    ^self basicRemoveElement: aMethodSelector!   ! 
#('March 30, 2003' '06:33:15 PM' nil)!

(CodeFiler organizerFor: ClassBasedOrganizer) reorganizeFrom: #(
('elements' removeElement: )) !


!ClassBasedOrganizer methods !   
update
    "Make sure that all of the classes in my categories are indeed classes in Smalltalk, and that all
    classes in Smalltalk are categorized."

     | uncategorized allClassNames |

    super update.
    self notDirty
        ifTrue: [^self].

    self elements do: [:each |
        (self isNameOfValidClass: each)
            ifFalse: [self removeElement: each fromCategories: (self categoriesOfElement: each)]].

    allClassNames := (self systemDictionary rootClasses inject: OrderedCollection new into: [:sum :each |
            sum, (each withAllSubclasses collect: [:aClass | aClass symbol])]).

    uncategorized := allClassNames copy.
    self elements do: [:each |
        uncategorized remove: each ifAbsent: [nil]].
    uncategorized notEmpty
        ifTrue: [
            uncategorized do: [:each |
                self addElement: each toCategory: self defaultCategory]].
    self
        updateDefaultCategory;
        makeClean.! ! 
#('November 13, 2001' '11:19:26 AM' nil)!

(CodeFiler organizerFor: ClassBasedOrganizer) reorganizeFrom: #(
('updating' update )) !


!ClassBasedOrganizer methods !
reorganize: elements into: newCategories
    "elements   <collection of objects>
    newCategories <collection of strings>
    Make every object in elements a member of only those categories in newCategories.
    Log these changes to the change log."

    | changeLog result |
    (changeLog := Sources at: 2) setToEnd.
    result := self basicReorganize: elements into: newCategories.
    self sourceManager logEvaluate: 'CodeFiler systemOrganizer reorganize: #',
        elements asArray printString,
        ' into: #', newCategories asArray printString.
    ^result!  ! 
#('March 5, 2003' '10:31:32 PM' nil)!

(CodeFiler organizerFor: ClassBasedOrganizer) reorganizeFrom: #(
('elements' reorganize:into: )) !


!ClassBasedOrganizer methods !  
isNameOfValidClass: className
    "Return true if the given symbol is a name for a valid class in Smalltalk."

    | theClass |
    (self systemDictionary includesKey: className)
        ifFalse: [^false].

    theClass := self systemDictionary at: className.
    (theClass isBehavior or: [theClass isClassPointer])
        ifFalse: [^false].
    ^theClass name asString = className asString!  ! 
#('November 14, 2001' '12:45:22 PM' nil)!

(CodeFiler organizerFor: ClassBasedOrganizer) reorganizeFrom: #(
('private' isNameOfValidClass: )) !


!ClassBasedOrganizer methods !
removeCategory: categoryName ifAbsent: errorBlock
    "Remove the category named categoryName.  If it isn't there, evaluate errorBlock"

    self basicRemoveCategory: categoryName ifAbsent: [^errorBlock value].
    self sourceManager logEvaluate: 'CodeFiler systemOrganizer removeCategory: ', categoryName printString, ' ifAbsent: [nil].'! ! 
#('March 8, 2003' '03:27:40 PM' nil)!

(CodeFiler organizerFor: ClassBasedOrganizer) reorganizeFrom: #(
('categories' removeCategory:ifAbsent: )) !


!ClassBasedOrganizer methods !
systemDictionary
    ^self owner!  ! 
#('November 13, 2001' '11:18:57 AM' nil)!

(CodeFiler organizerFor: ClassBasedOrganizer) reorganizeFrom: #(
('querying' systemDictionary )) !




Organizer subclass: #MethodBasedOrganizer
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Navigator' )
  comment: ''!

!MethodBasedOrganizer methods !   
removeElement: aMethodSelector
    "Remove aMethodSelector from all of my categories, and from my owner"

    self owner removeSelector: aMethodSelector.
    self sourceManager logEvaluate: owner name, ' removeSelector: #', aMethodSelector.
    ^self basicRemoveElement: aMethodSelector.!   ! 
#('March 8, 2003' '03:23:26 PM' nil)!

(CodeFiler organizerFor: MethodBasedOrganizer) reorganizeFrom: #(
('elements' removeElement: )) !


!MethodBasedOrganizer methods !  
reorganizeFrom: collection
    "collection     <Collection withAll: organizationCollection>
                    organizationCollection      <Collection with: category withAll: elementsOfCategory>
    Reorganize myself so that category contains elementsOfCategory
    for each organizationCollection.
    Log the reorganization to the change log."

    | methods changeLog |

    collection isEmpty ifTrue: [^self].
    (changeLog := Sources at: 2) setToEnd.
    self basicReorganizeFrom: collection.
    methods := collection inject: OrderedCollection new into: [:sum :each |
        sum addAll: (each copyFrom: 2 to: each size); yourself].
    (CodeFiler forClass: self owner)
        fileOutOrganizationFor: methods on: changeLog.
    changeLog flush.!  ! 
#('March 7, 2003' '06:06:52 PM' nil)!

(CodeFiler organizerFor: MethodBasedOrganizer) reorganizeFrom: #(
('elements' reorganizeFrom: )) !


!MethodBasedOrganizer methods ! 
addElement: selector toCategory: categoryName
    "Add selector to the protocol named category name.  Since, a method
    may appear in only one protocol, first remove that selector from any
    protocols in which it now appears"

    self
        removeElement: selector
        fromCategories: (self categoriesOfElement: selector).
    ^super addElement: selector toCategory: categoryName! ! 
#('March 30, 2003' '06:37:08 PM' nil)!

(CodeFiler organizerFor: MethodBasedOrganizer) reorganizeFrom: #(
('elements' addElement:toCategory: )) !


!MethodBasedOrganizer methods ! 
addElement: selector toCategory: categoryName
    "Add selector to the protocol named category name.  Since, a method
    may appear in only one protocol, first remove that selector from any
    protocols in which it now appears"

    self removeElement: selector fromCategories: (self categoriesOfElement: selector).
    ^super addElement: selector toCategory: categoryName!   ! 
#('March 30, 2003' '06:37:08 PM' 409944)!

(CodeFiler organizerFor: MethodBasedOrganizer) reorganizeFrom: #(
('elements' addElement:toCategory: )) !


!MethodBasedOrganizer methods !  
owner: anObject
    "Set my owner, and create a default categorization for his selectors"
    super owner: anObject.! ! 
#('January 17, 2002' '11:00:00 AM' nil)!

(CodeFiler organizerFor: MethodBasedOrganizer) reorganizeFrom: #(
('accessing' owner: )) !


!MethodBasedOrganizer methods !  
reorganize: methodNames into: newCategories
    "methodNames   <collection of method names>
    newCategories <collection of strings>
    Make every object in elements a member of only those categories in newCategories.
    Log these changes to the change log."

    | changeLog result |

    (changeLog := Sources at: 2) setToEnd.
    result := self basicReorganize: methodNames into: newCategories.
    (CodeFiler forClass: self owner)
        fileOutOrganizationFor: methodNames on: changeLog.
    changeLog flush.
    ^result! ! 
#('March 5, 2003' '10:32:06 PM' nil)!

(CodeFiler organizerFor: MethodBasedOrganizer) reorganizeFrom: #(
('elements' reorganize:into: )) !


!MethodBasedOrganizer methods !
rename: oldCategoryName to: newCategoryName

    super rename: oldCategoryName to: newCategoryName.
    self sourceManager logEvaluate: '(CodeFiler organizerFor: ', self owner name, ') rename: ', oldCategoryName printString,  ' to: ', newCategoryName printString.! ! 
#('March 3, 2003' '10:13:24 AM' nil)!

(CodeFiler organizerFor: MethodBasedOrganizer) reorganizeFrom: #(
('categories' rename:to: )) !


!MethodBasedOrganizer methods !
removeCategory: protocol ifAbsent: aBlock
    "Remove all of the methods in protocol, and then remove the protocol"

    (protocol = self defaultCategory and: [(self elementsOfCategory: protocol ifAbsent: [#()]) notEmpty]) ifTrue: [^self].
    (self isKnownCategory: protocol) ifFalse: [^aBlock value].
    (self elementsOfCategory: protocol) do: [:selector |
        self owner removeSelector: selector].
    self basicRemoveCategory: protocol ifAbsent: aBlock.
    self sourceManager logEvaluate: '(CodeFiler organizerFor: ', self owner name, ') removeCategory: ', protocol printString, ' ifAbsent: [nil]'!    ! 
#('March 8, 2003' '03:41:51 PM' nil)!

(CodeFiler organizerFor: MethodBasedOrganizer) reorganizeFrom: #(
('categories' removeCategory:ifAbsent: )) !


 

Object subclass: #ParcPlaceClassReader
  instanceVariableNames: 
    ' class protocols protocol '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Code Writers & Readers' )
  comment: ''!

!ParcPlaceClassReader methods ! 
fileInFrom: stream
    "   stream  <ReadStream>
        ^       self
    Read chunks from aStream until an empty chunk (a single '!!') is found.
    Compile each chunk as a method for the class I describe.
    Log the source code of the method to the change log."

    | chunk result changeLog selectors codeFiler |
     selectors := OrderedCollection new.
    changeLog := (Sources at: 2)
        setToEnd;cr;
        yourself.

    (codeFiler := CodeFiler forClass: self forClass) fileOutPreambleOn: changeLog.
    [(chunk := stream nextChunk) isEmpty] whileFalse: [
        result := class compile: chunk.
        result notNil ifTrue: [
            result value sourceString: chunk.
            selectors add: result key]].

    "changeLog nextPutAll: ' !!'.    THIS IS A BUG..."
    codeFiler methodOrganizer reorganize: selectors into: (Array with: self protocol).
    codeFiler fileOutOrganizationFor: selectors on: changeLog.
    changeLog flush!   ! 
#('November 21, 2001' '04:13:33 PM' nil)!

(CodeFiler organizerFor: ParcPlaceClassReader) reorganizeFrom: #(
('filing in' fileInFrom: )) !


   

LinkMessage subclass: #PARTSAliasMessage
  instanceVariableNames: 
    ' realSelector '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

Object subclass: #PARTSApplication
  instanceVariableNames: 
    ' wrapper eventTable componentDictionary property editor editorState externalMessages externalEvents '
  classVariableNames: 
    ' DefaultIcon '
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 
PARTSApplicationCoordinator class instanceVariableNames: ''
  categories: #( )
  comment: ''!

   

Object subclass: #PARTSApplicationHolder
  instanceVariableNames: 
    ' application eventTable '
  classVariableNames: 
    ' RecyclingBin '
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSApplicationHolder subclass: #PARTSAddObjectDialog
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



Error subclass: #PARTSApplicationLoadError
  instanceVariableNames: 
    ' file '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



Object subclass: #PARTSApplicationProperty
  instanceVariableNames: 
    ' fileDescriptor icon hint description reuseMode userProperties properties '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!


PARTSCatalog class instanceVariableNames: ''
  categories: #( )
  comment: ''!

  

Object subclass: #PARTSCodeGeneratorInterface
  instanceVariableNames: 
    ' inputDirectoryName outputDirectoryName logStream fileDescriptor interactive '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSCodeGeneratorInterface subclass: #PARTSCodeGeneratorReaderInterface
  instanceVariableNames: 
    ' inputStream '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSCodeGeneratorInterface subclass: #PARTSCodeGeneratorWriterInterface
  instanceVariableNames: 
    ' partApplication outputStream inputFilename '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



CursorManager subclass: #PARTSCursorManager
  instanceVariableNames: 
    ' hotSpot '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSApplicationLoadError subclass: #PARTSCyclicReference
  instanceVariableNames: 
    ' cycleFile '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

Object subclass: #PARTSDial
  instanceVariableNames: 
    ' pen lastChange reading lowReading highReading lowDegree highDegree center r readingsPerDegree tip interval defaultSize numberOfTicks ticks autoLabels '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

Directory subclass: #PARTSDosDirectory
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



Object subclass: #PARTSDragDropSpec
  instanceVariableNames: 
    ' dragSource dragTarget dragFormats dragOperations '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

Object subclass: #PARTSDragResult
  instanceVariableNames: 
    ' action destinationRectangle destinationPoint destinationWindow '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   
PARTSEditor class instanceVariableNames: ''
  categories: #( )
  comment: ''!

   

Object subclass: #PARTSEditorState
  instanceVariableNames: 
    ' extent settings frameRectangle isShrunk eventTable '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSApplicationLoadError subclass: #PARTSEmptyFile
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

Object subclass: #PARTSException
  instanceVariableNames: 
    ' exception '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 
PARTSFile class instanceVariableNames: ''
  categories: #( )
  comment: ''!

 

Object subclass: #PARTSFileDescriptor
  instanceVariableNames: 
    ' universalId fileType directory '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSFileDescriptor subclass: #PARTSDosFileDescriptor
  instanceVariableNames: 
    ' fileName '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSApplicationLoadError subclass: #PARTSFileNotFound
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



Object subclass: #PARTSFileOperationContext
  instanceVariableNames: 
    ' owner fileVersion fileDescriptor fileName filePathName properties '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

Object subclass: #PARTSFileProcessor
  instanceVariableNames: 
    ' fileDescriptor properties '
  classVariableNames: 
    ' FileTypeRegistry '
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

Object subclass: #PARTSFileType
  instanceVariableNames: 
    ' type pattern description '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

Object subclass: #PARTSFileVersion
  instanceVariableNames: 
    ' versionString description canBeLoaded canBeDescribed canReadIcon canReadProperties readerClass writerClass loadAction '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

Object subclass: #PARTSFormGenerator
  instanceVariableNames: 
    ' creatorPart partEditor dialogWindow links parts title mouseTrackIcon getNamesAction getItemsAction '
  classVariableNames: 
    ' LayoutHorizontalGroupClass LayoutItemClass LayoutManagerClass LayoutVerticalGroupClass '
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

Object subclass: #PARTSFormGeneratorItem
  instanceVariableNames: 
    ' partItem labelItem labelPosition sourceEvent partMessage partEvent sourceMessage '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

Object subclass: #PARTSFramer
  instanceVariableNames: 
    ' left bottom right top mask scaleUnit '
  classVariableNames: 
    ' DefaultScaleUnit '
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

Exception subclass: #PARTSGetExecutionContext
  instanceVariableNames: 
    ' contents isResumable '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

HelpManager variableSubclass: #PARTSHelpManager
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 
PARTSHostInterface class instanceVariableNames: ''
  categories: #( )
  comment: ''!



Icon subclass: #PARTSIcon
  instanceVariableNames: 
    ' parent connection origin label showLabel '
  classVariableNames: ''
  poolDictionaries: 
    ' GraphicsConstants SystemValueConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSApplicationLoadError subclass: #PARTSIncorrectVersion
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

Object subclass: #PARTSIniFile
  instanceVariableNames: 
    ' partsSettings stream normalizedTagDict colorValueDict '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

Object subclass: #PARTSInterfaceList
  instanceVariableNames: 
    ' items separators defaultItem '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSApplicationLoadError subclass: #PARTSInvalidApplication
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

Object subclass: #PARTSLink
  instanceVariableNames: 
    ' source trigger receiver selector messageArgLinks resultLink editState traceFire '
  classVariableNames: ''
  poolDictionaries: 
    ' PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSLink subclass: #PARTSAliasLink
  instanceVariableNames: 
    ' realSelector '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

Object subclass: #PARTSLinkEditState
  instanceVariableNames: 
    ' launchSide landingSide pathPoints leftTopEventLabel leftTopMessageLabel '
  classVariableNames: ''
  poolDictionaries: 
    ' PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

Object subclass: #PARTSLinkReference
  instanceVariableNames: 
    ' partName event index '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

Object subclass: #PARTSLinkSettings
  instanceVariableNames: 
    ' labelFont labelLineHeight labelAscender labelHeight messageLabelSideWidth dataSlotWidth dataSlotRadius '
  classVariableNames: 
    ' CurrentSettings '
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSFileOperationContext subclass: #PARTSLoadContext
  instanceVariableNames: 
    ' isCurrentVersion debugger loadingExe scaleFactor '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

LocalDragDropObject subclass: #PARTSLocalDragDropObject
  instanceVariableNames: 
    ' object session '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSLocalDragDropObject subclass: #PARTSAddPartObject
  instanceVariableNames: 
    ' offset '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSLocalDragDropObject subclass: #PARTSEditorMoveObject
  instanceVariableNames: 
    ' dragRect startRect '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

LocalDragDropSession subclass: #PARTSLocalDragDropSession
  instanceVariableNames: 
    ' dragStart cursor validCursor invalidCursor '
  classVariableNames: ''
  poolDictionaries: 
    ' GraphicsConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSLocalDragDropSession subclass: #PARTSAddPartSession
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSAddPartSession subclass: #PARTSCatalogDragSession
  instanceVariableNames: 
    ' initialOperation '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSLocalDragDropSession subclass: #PARTSDragSession
  instanceVariableNames: 
    ' icon '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSLocalDragDropSession subclass: #PARTSEditorMoveSession
  instanceVariableNames: 
    ' pen prevObjectLocation prevScreenLocation prevTargetWindow parentRect fence editorPane initialOperation '
  classVariableNames: ''
  poolDictionaries: 
    ' GraphicsConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   
PARTSMessageNotUnderstood class instanceVariableNames: ''
  categories: #( )
  comment: ''!

 

IdentityDictionary subclass: #PARTSMirrorCopyDictionary
  instanceVariableNames: 
    ' useMode debugger operation sharedObjects '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSApplicationLoadError subclass: #PARTSNestedPartLoadError
  instanceVariableNames: 
    ' nestedPart precursiveError '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

Object subclass: #PARTSNonvisualPart
  instanceVariableNames: 
    ' wrapper eventTable '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSNonvisualPart subclass: #PARTSAddObject
  instanceVariableNames: 
    ' classNames object '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSNonvisualPart subclass: #PARTSClipboardAccessorPart
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSNonvisualPart subclass: #PARTSComparisonPart
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSNonvisualPart subclass: #PARTSComputationPart
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSNonvisualPart subclass: #PARTSConversionPart
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSNonvisualPart subclass: #PARTSDiskAccessorPart
  instanceVariableNames: 
    ' drive directoryPath pattern '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSNonvisualPart subclass: #PARTSFileAccessorPart
  instanceVariableNames: 
    ' sizeThreshold '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSNonvisualPart subclass: #PARTSLaunchPadPart
  instanceVariableNames: 
    ' commandString '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSNonvisualPart subclass: #PARTSLinkJunctionPart
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

Object subclass: #PARTSNotebookPage
  instanceVariableNames: 
    ' id window style tab statusText key notebook tabRectangle '
  classVariableNames: ''
  poolDictionaries: 
    ' PARTSNotebookConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSNotebookPage subclass: #PARTSNotebookPageAttributes
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSFileNotFound subclass: #PARTSNotOnSearchPath
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSNonvisualPart subclass: #PARTSPartAccessorPart
  instanceVariableNames: 
    ' application fileDescriptor lastUpdateTime demandLoad '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSFileProcessor subclass: #PARTSPartFileProcessor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  
PARTSExecutablePartFileProcessor class instanceVariableNames: ''
  categories: #( )
  comment: ''!

  

PARTSExecutablePartFileProcessor subclass: #PARTSExeFileProcessor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSAddPartObject subclass: #PARTSPasteObject
  instanceVariableNames: 
    ' wrapper '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSAddPartSession subclass: #PARTSPasteSession
  instanceVariableNames: 
    ' minBox '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSNonvisualPart subclass: #PARTSPrebuiltDialog
  instanceVariableNames: 
    ' diagBox suspendClient '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSPrebuiltDialog subclass: #PARTSFileDialogPart
  instanceVariableNames: 
    ' pattern '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSFileDialogPart subclass: #PARTSAnyFileDialogPart
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSPrebuiltDialog subclass: #PARTSPrebuiltMessageBox
  instanceVariableNames: 
    ' title text style '
  classVariableNames: ''
  poolDictionaries: 
    ' PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSPrebuiltMessageBox subclass: #PARTSConfirmerPart
  instanceVariableNames: ''
  classVariableNames: 
    ' ButtonLabelLabels ButtonLabelValues '
  poolDictionaries: 
    ' PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSPrebuiltMessageBox subclass: #PARTSConfirmerWithCancelPart
  instanceVariableNames: ''
  classVariableNames: 
    ' ButtonLabelLabels ButtonLabelValues '
  poolDictionaries: 
    ' PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSPrebuiltMessageBox subclass: #PARTSInformationDialogPart
  instanceVariableNames: ''
  classVariableNames: 
    ' IconTypeLabels IconTypeValues '
  poolDictionaries: 
    ' PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSNonvisualPart subclass: #PARTSPrinterPart
  instanceVariableNames: 
    ' printerName printer font jobStarted wrap '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSPrebuiltDialog subclass: #PARTSPrompterPart
  instanceVariableNames: 
    ' prompt default removeBlanks '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

Object subclass: #PARTSPropertyStructure
  instanceVariableNames: 
    ' part partContext eventTable actions oldStyle newStyle undoActions propertyUnits unitOrdering nextId editor dialog doingValidation operation propertiesValid '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

Object subclass: #PARTSPropertyUnit
  instanceVariableNames: 
    ' propertyStructure oldValue newValue validationMessage immediateValidationMessage changeSelector controls label sameLine leftTop extent column modified enabled '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSPropertyUnit subclass: #PARTSPropertyBoolean
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSPropertyUnit subclass: #PARTSPropertyButton
  instanceVariableNames: 
    ' clickedSelector '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSPropertyUnit subclass: #PARTSPropertyButtonGroup
  instanceVariableNames: 
    ' labelsMap initialSelection widestLabelPELS actions '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSPropertyButtonGroup subclass: #PARTSPropertyButtonGroupWS
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSPropertyButtonGroupWS subclass: #PARTSPropertyButtonGroupWSExtended
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSPropertyUnit subclass: #PARTSPropertyColorAndFont
  instanceVariableNames: 
    ' currentForeColor currentBackColor currentFont '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSPropertyUnit subclass: #PARTSPropertyDateFormat
  instanceVariableNames: 
    ' dialogWindow '
  classVariableNames: ''
  poolDictionaries: 
    ' PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSPropertyUnit subclass: #PARTSPropertyDragDrop
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSPropertyButton subclass: #PARTSPropertyEditButton
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSPropertyUnit subclass: #PARTSPropertyFixedList
  instanceVariableNames: 
    ' list '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSPropertyButton subclass: #PARTSPropertyFormGeneratorButton
  instanceVariableNames: 
    ' dialogWindow forms '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSPropertyFormGeneratorButton subclass: #PARTSPropertyCreateForm
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSPropertyFormGeneratorButton subclass: #PARTSPropertyCreateTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSPropertyUnit subclass: #PARTSPropertyGraphic
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSPropertyUnit subclass: #PARTSPropertyIcon
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSPropertyUnit subclass: #PARTSPropertyLineOfButtons
  instanceVariableNames: 
    ' labelsAndSelectors '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSPropertyUnit subclass: #PARTSPropertyList
  instanceVariableNames: 
    ' listPane validateValueMessage '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSPropertyUnit subclass: #PARTSPropertyMenuAccelerator
  instanceVariableNames: ''
  classVariableNames: 
    ' VirtualKeys '
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSPropertyBoolean subclass: #PARTSPropertyPseudoStyle
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSPropertyButton subclass: #PARTSPropertySequenceChildren
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSPropertyUnit subclass: #PARTSPropertyStaticText
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSPropertyUnit subclass: #PARTSPropertyString
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSPropertyString subclass: #PARTSPropertyExpression
  instanceVariableNames: 
    ' result '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSPropertyString subclass: #PARTSPropertyFormattedString
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSPropertyString subclass: #PARTSPropertyNumber
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSPropertyString subclass: #PARTSPropertyText
  instanceVariableNames: 
    ' textExtent '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSPropertyBoolean subclass: #PARTSPropertyWindowStyle
  instanceVariableNames: 
    ' constant '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSPropertyWindowStyle subclass: #PARTSPropertyBinaryStyle
  instanceVariableNames: 
    ' constant2 '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSAddPartSession subclass: #PARTSRepeatDropSession
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

Object subclass: #PARTSScenario
  instanceVariableNames: 
    ' links name locked editor comment nestedScenarios '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

Object subclass: #PARTSScenarioEditor
  instanceVariableNames: 
    ' scenarios scenariosSorted currentScenario selectedScenario defaultScenario partEditor linkEditor exclusiveDisplay addNewLinks selectedScenarioCurrent commentWindow '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

CompiledMethod variableSubclass: #PARTSScript
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

CompilerInterface subclass: #PARTSScriptCompilerInterface
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   
PARTSScriptContext class instanceVariableNames: ''
  categories: #( )
  comment: ''!



CompiledMethodDefinition subclass: #PARTSScriptDefinition
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 
PARTSScriptDictionary class instanceVariableNames: ''
  categories: #( )
  comment: ''!

 

Object subclass: #PARTSScriptSource
  instanceVariableNames: 
    ' source componentDictionary part '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



Object subclass: #PARTSSessionManager
  instanceVariableNames: ''
  classVariableNames: 
    ' PlatformFilePrefix PlatformProductName PlatformProductVersion ReportObsoleteMessageUse VersionNumbers WorkbenchSupportLibraries WorkbenchSupportLibraryIndex '
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 
PARTSDevelopmentSessionManager class instanceVariableNames: ''
  categories: #( )
  comment: ''!


PARTSRuntimeSessionManager class instanceVariableNames: ''
  categories: #( )
  comment: ''!



Object subclass: #PARTSSettings
  instanceVariableNames: 
    ' colorWellDefinedBaseLink colorWellDefinedArgLink colorUndefinedBaseLink colorUndefinedArgLink fontLinkLabels fontIconLabels fontDialogs userName colorWorkbench colorCatalog colorLinkLabel isDeveloper gridExtent showHints showLinkLabels showLinksWithSelection fileName options mouseButtonDrag mouseButtonLink mouseButtonPopupMenu mouseButtonSelect catalogs orthogonalLinks '
  classVariableNames: 
    ' CurrentSettings '
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSNonvisualPart subclass: #PARTSSizeWindowPart
  instanceVariableNames: 
    ' commonFramer commonFlag framers parentRect '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSFileProcessor subclass: #PARTSSmalltalkLibraryFileProcessor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSFileProcessor subclass: #PARTSSourceFileProcessor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



DynamicLinkLibrary variableByteSubclass: #PARTSSpeakerDLL
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSNonvisualPart subclass: #PARTSSpeakerPart
  instanceVariableNames: 
    ' frequency duration '
  classVariableNames: 
    ' PlatformLibrary SpeakerLibrary '
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!


PARTSStandardMenu class instanceVariableNames: ''
  categories: #( )
  comment: ''!

 

PARTSStandardMenu subclass: #PARTSStandardBracketsMenu
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSStandardMenu subclass: #PARTSStandardEditMenu
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 
PARTSEditMenu class instanceVariableNames: ''
  categories: #( )
  comment: ''!

 

PARTSStandardMenu subclass: #PARTSStandardFileMenu
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSStandardFileMenu subclass: #PARTSFileMenu
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSStandardMenu subclass: #PARTSStandardHelpMenu
  instanceVariableNames: ''
  classVariableNames: 
    ' LabelGeneralHelp LabelHelpIndex LabelKeysHelp LabelSearchHelp LabelUsingHelp '
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSStandardHelpMenu subclass: #PARTSHelpMenu
  instanceVariableNames: ''
  classVariableNames: 
    ' LabelProductInformation LabelSamples '
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSFileOperationContext subclass: #PARTSStoreContext
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



Object subclass: #PARTSStringTemplate
  instanceVariableNames: 
    ' template parameters endMarker startMarker typeMarker wildcardChar escapeChar parameterPoints parameterTypes parameterNames '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSNonvisualPart subclass: #PARTSStringTemplatePart
  instanceVariableNames: 
    ' stringTemplate '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSLinkReference subclass: #PARTSSublinkReference
  instanceVariableNames: 
    ' parentReference '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



Object subclass: #PARTSTextIcon
  instanceVariableNames: 
    ' connection rectangle window isEditing '
  classVariableNames: ''
  poolDictionaries: 
    ' GraphicsConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSNonvisualPart subclass: #PARTSTimerPart
  instanceVariableNames: 
    ' id interval '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

Object subclass: #PARTSUpgradeObject
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSUpgradeObject subclass: #PARTSUpgradeVisualPart
  instanceVariableNames: 
    ' handle rectangle children parent owner style graphicsTool properties '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSUpgradeVisualPart subclass: #PARTSUpgradePanePart
  instanceVariableNames: 
    ' handlers margin topCorner framingBlock curFont menu popup '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSUpgradePanePart subclass: #PARTSUpgradeTablePane
  instanceVariableNames: 
    ' newTablePanePart pwo20ExtendedStyleDictionary rows topLeftCell columnLefts rowTops cellsToDisplay displayRect visibleRect leftOffset topOffset labelsHeight labelsWidth selectedCell selectedRectangle extStyle entryField wmMoveSelector button1MoveSelector button1DownSelector button1DoubleClickSelector button1UpSelector button2DownSelector button2MoveSelector button2UpSelector movingLine columnLabels rowLabels cornerLabel lafDEMode fixedExtent cellWidth cellHeight currentRow columnNames rowNames modified '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSNonvisualPart subclass: #PARTSValueHolderPart
  instanceVariableNames: 
    ' value class '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSValueHolderPart subclass: #PARTSTypedValueHolder
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSTypedValueHolder subclass: #PARTSCollectionHolder
  instanceVariableNames: 
    ' showKeys '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSCollectionHolder subclass: #PARTSArrayHolderPart
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSCollectionHolder subclass: #PARTSDictionaryHolderPart
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSTypedValueHolder subclass: #PARTSNumberHolderPart
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSTypedValueHolder subclass: #PARTSOrderedCollectionHolderPart
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSTypedValueHolder subclass: #PARTSStringHolderPart
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSApplicationHolder subclass: #PARTSWindow
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSWindow subclass: #PARTSChooseFileDialog
  instanceVariableNames: 
    ' title fileTypes defaultType answer startFile pattern operation selectedDirectory '
  classVariableNames: 
    ' LastDirectoryUsed '
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSChooseFileDialog subclass: #PARTSOpenSaveFileDialog
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSWindow subclass: #PARTSPartBrowser
  instanceVariableNames: 
    ' title fileDisplayAttribute '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSPartBrowser subclass: #PARTSNestedPartBrowser
  instanceVariableNames: 
    ' root nestedPartDict '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSWindow subclass: #PARTSPartPropertiesEditor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSPartPropertiesEditor subclass: #PARTSPartPropertyDialog
  instanceVariableNames: 
    ' part newPartIcon applyChangesActions undoChangesActions changesAccepted '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSPartPropertyDialog subclass: #PARTSNonvisualPartPropertyDialog
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSPartPropertiesEditor subclass: #PARTSPartPropertySubdialog
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSPartPropertySubdialog subclass: #PARTSOpenWindowPropertiesEditor
  instanceVariableNames: 
    ' settings '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSOpenWindowPropertiesEditor subclass: #PARTSOpenDialogWindowPropertiesEditor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSWindow subclass: #PARTSPictureMaskEditor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSWindow subclass: #PARTSReferenceBrowser
  instanceVariableNames: 
    ' fileReference '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSWindow subclass: #PARTSScenarioComment
  instanceVariableNames: 
    ' scenario workbenchView '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSWindow subclass: #PARTSScenarioPairs
  instanceVariableNames: 
    ' parentScenario nestedParts '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSWindow subclass: #PARTSSettingsViewer
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSSettingsViewer subclass: #PARTSBackgroundColorSettingsEditor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSSettingsViewer subclass: #PARTSLinkColorSettingsEditor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSSettingsViewer subclass: #PARTSMouseButtonsSettingsEditor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSSettingsViewer subclass: #PARTSSettingsEditor
  instanceVariableNames: 
    ' settings newSettings searchPath searchPathChanged '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSNestedPartBrowser subclass: #PARTSTeamVNestedPartBrowser
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSPartPropertyDialog subclass: #PARTSVisualPartPropertyDialog
  instanceVariableNames: 
    ' newSize newForeColor newBackColor newFont '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSVisualPartPropertyDialog subclass: #PARTSCommonPropertiesEditor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSVisualPartPropertyDialog subclass: #PARTSGroupPanePropertiesEditor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSVisualPartPropertyDialog subclass: #PARTSOrderedVisualPartPropertyDialog
  instanceVariableNames: 
    ' newOrderedChildren '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSPartPropertySubdialog subclass: #PARTSWindowSizeEditor
  instanceVariableNames: 
    ' parentRect framers '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 
PARTSWorkbenchSessionManager class instanceVariableNames: ''
  categories: #( )
  comment: ''!

  

Object subclass: #PARTSWrapper
  instanceVariableNames: 
    ' object name rectangle parent components eventHandlers scriptDictionary instanceEvents helpInfo properties '
  classVariableNames: 
    ' KeepInExecutable '
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

Object subclass: #Pattern
  instanceVariableNames: 
    ' input fail state matchBlock first '
  classVariableNames: 
    ' WildcardChar '
  poolDictionaries: ''
  categories: #( 'Base-Text' )
  comment: ''!

!Pattern class methods !   
new: aString
        "Answer a new pattern with aString
         as the pattern to match."

    ^(self usesWildcards: aString) ifTrue: [WildPattern new: aString] ifFalse: [super new build: (aString copyWithout: $\)].!   ! 
#('October 1, 2001' '04:53:50 PM' nil)!

(CodeFiler organizerFor: Pattern class) reorganizeFrom: #(
('no category methods' new: )) !


!Pattern class methods ! 
usesWildcards: aString

    | currentCharacter previousCharacter escapeCharacter |
    escapeCharacter := $\.
    aString isString ifFalse: [^aString includes: (String with: WildcardChar)].
    2 to: aString size do: [:index |
        currentCharacter := aString at: index. previousCharacter := aString at: index - 1.
        (currentCharacter = WildcardChar and: [previousCharacter ~= escapeCharacter]) ifTrue: [^true]].
    ^false!   ! 
#('October 1, 2001' '04:44:08 PM' nil)!

(CodeFiler organizerFor: Pattern class) reorganizeFrom: #(
('no category methods' usesWildcards: )) !


   

Object subclass: #Point
  instanceVariableNames: 
    ' x y '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Base-Magnitudes' )
  comment: ''!

!Point methods ! 
asFloat
    ^self x asFloat @ self y asFloat!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point) reorganizeFrom: #(
('extensions' asFloat )) !


!Point methods !   
integerLog2
    ^self x integerLog2 @ self y integerLog2!  ! 
#('September 25, 2009' '09:58:34 AM' nil)!

(CodeFiler organizerFor: Point) reorganizeFrom: #(
('extensions' integerLog2 )) !


!Point methods !
rem: aNumber
    "Answer the integer remainder after dividingthe receiver by aNumber with truncation towards zero."
    ^(x rem: aNumber) @ (y rem: aNumber)! ! 
#('September 17, 2009' '06:08:19 PM' nil)!

(CodeFiler organizerFor: Point) reorganizeFrom: #(
('extensions' rem: )) !


!Point methods !   
nextHighestPowerOf2

    ^self x nextHighestPowerOf2 @ self y nextHighestPowerOf2!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point) reorganizeFrom: #(
('extensions' nextHighestPowerOf2 )) !


!Point methods !   
@ aNumber
    ^Point3D x: self x y: self y z: aNumber! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point) reorganizeFrom: #(
('extensions' @ )) !


!Point methods ! 
cross: aPoint
    ^(self x * aPoint y) - (self y * aPoint x)!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point) reorganizeFrom: #(
('extensions' cross: )) !


!Point methods !
floor
    ^x floor @ y floor!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point) reorganizeFrom: #(
('extensions' floor )) !


!Point methods ! 
multiplyFromPoint3D: aPoint3D

    ^(self @ 1.0) * aPoint3D!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point) reorganizeFrom: #(
('extensions' multiplyFromPoint3D: )) !


!Point methods !  
reciprocal
    ^(x reciprocal) @ (y reciprocal)!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point) reorganizeFrom: #(
('extensions' reciprocal )) !


!Point methods !
ceiling
    ^x ceiling @ y ceiling!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point) reorganizeFrom: #(
('extensions' ceiling )) !


!Point methods !   
distanceTo: aPoint
    ^((aPoint x - self x) squared + (aPoint y - self y) squared) sqrt!  ! 
#('September 16, 2009' '11:26:42 AM' nil)!

(CodeFiler organizerFor: Point) reorganizeFrom: #(
('extensions' distanceTo: )) !


!Point methods !
as3DTranslation
    ^Point3D x: self x y: self y z: 0.0!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point) reorganizeFrom: #(
('extensions' as3DTranslation )) !


!Point methods !   
roundTo: aNumber
    ^(x roundTo: aNumber) @ (y roundTo: aNumber)! ! 
#('September 17, 2009' '05:35:08 PM' nil)!

(CodeFiler organizerFor: Point) reorganizeFrom: #(
('extensions' roundTo: )) !


!Point methods !   
hasZero
    ^(x = 0) | (y = 0)!    ! 
#('October 6, 2009' '09:10:52 AM' nil)!

(CodeFiler organizerFor: Point) reorganizeFrom: #(
('extensions' hasZero )) !


   

Object subclass: #Point3D
  instanceVariableNames: 
    ' x y z '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( '3D-Basic' 'Base-Magnitudes' )
  comment: ''!

!Point3D methods !
isOnOrInFrontOfPlane: aPlane
    ^(aPlane distanceToPoint: self) >= -1.0e-6!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('nearness' isOnOrInFrontOfPlane: )) !


!Point3D methods !   
convexNormals: aVector3D
    ^self inclusiveBetweenMinus180And0: aVector3D!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('normals' convexNormals: )) !


!Point3D methods !   
distanceToLineFrom: point1 to: point2
    ^(self squaredDistanceToLineFrom: point1 to: point2) sqrt!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('distance queries' distanceToLineFrom:to: )) !


!Point3D methods !  
nearestPointOnInfiniteLine: aLine
    "NOTE: assumes the line was defined with a direction that is unit length.
    Let R = self, let P + tN be the equation of a line, let R.N + d = 0 be the
    equation of the plane that goes through R and is directed in the same direction
    as the line, and let Q be the intersection point of the line with the plane. Then
        d = -R.N (1)
        Q = P + tN for some t (2)
        Q.N + d = 0 (3)
    So
        (P+tN).N + d = 0
        P.N + tN.N + d = 0
        P.N + t + d = 0 (since N is a unit normal)
        t = -P.N - d = -P.N + R.N = (R - P).N"

    | t |
    t := (self - aLine point) dot: aLine direction.
    ^aLine point + (aLine direction * t)!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('nearness' nearestPointOnInfiniteLine: )) !


!Point3D methods ! 
squaredLength
    ^self dot: self! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' squaredLength )) !


!Point3D methods !   
/ aPoint3DOrANumber
    ^aPoint3DOrANumber divideFromPoint3D: self!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('arithmetic' / )) !


!Point3D methods ! 
rounded
    ^self class new
            x: self x rounded
            y: self y rounded
            z: self z rounded!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('converting' rounded )) !


!Point3D methods !   
isStrictlyInsideFace: aFace
    "This is true if the point is in front of each line's inward facing plane."
    | inwardFacingPlane |
    aFace linesDo: [:point1 :point2 |
        inwardFacingPlane := aFace plane
            leftPointingPerpendicularPlaneThrough: point1 and: point2.
        inwardFacingPlane notNil ifTrue: [
            "Will only be nil if point1 and point2 are too close.
            Use line before and after instead."
            (self isStrictlyInFrontOfPlane: inwardFacingPlane) ifFalse: [^false]]].
    "Each line passed the test."
    ^true! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('nearness' isStrictlyInsideFace: )) !


!Point3D methods !   
printOn: aStream

    Notifier isControlKeyDown ifFalse: [^self printXyzOn: aStream].
    aStream << self class; << ' ['; << x; << ', '; << y; << ', '; << z; << ']'.!   ! 
#('January 27, 2003' '01:17:27 PM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('printing' printOn: )) !


!Point3D methods !   
cross: aPoint3D
    "U cross V  = [u2v3-u3v2, u3v1-u1v3, u1v2-u2v1]."
    ^self class new
            x: (self y * aPoint3D z) - (self z * aPoint3D y)
            y: (self z * aPoint3D x) - (self x * aPoint3D z)
            z: (self x * aPoint3D y) - (self y * aPoint3D x)!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' cross: )) !


!Point3D methods !  
xzSquaredLength
    | xz |
    xz := self x @ 0.0 @ self z.
    ^xz dot: xz! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' xzSquaredLength )) !


!Point3D methods ! 
xzLength
    | xz |
    xz := x @ 0.0 @ z.
    ^(xz dot: xz) sqrt!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' xzLength )) !


!Point3D methods !
render

    self render: self!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('rendering' render )) !


!Point3D methods ! 
exclusiveBetweenMinus180And0: aVector3D
    ^(self cross: aVector3D) >= 0.0!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('normals' exclusiveBetweenMinus180And0: )) !


!Point3D methods !
projectionTOnUnitVector: aVector
    ^self dot: aVector!   ! 
#('November 27, 2009' '03:56:41 PM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' projectionTOnUnitVector: )) !


!Point3D methods !  
projectionTOnUnitVector: aVector
    "Similar to projectionTOn: but does not need the extra squared length divide for a unit vector..."
    ^self dot: aVector!   ! 
#('November 27, 2009' '03:59:55 PM' 466020)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' projectionTOnUnitVector: )) !


!Point3D methods !   
radiansToDegrees
    ^Point3D x: x radiansToDegrees y: y radiansToDegrees z: z radiansToDegrees!   ! 
#('August 26, 2006' '09:08:42 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('converting' radiansToDegrees )) !


!Point3D methods !  
length
    ^(self dot: self) sqrt! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' length )) !


!Point3D methods !  
distanceSquaredTo: aPoint3D
    ^(self - aPoint3D) squaredLength!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('distance queries' distanceSquaredTo: )) !


!Point3D methods !  
xz
    ^x @ z! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('get/set' xz )) !


!Point3D methods !   
x: number1 y: number2 z: number3
    x := number1. y := number2. z := number3! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('get/set' x:y:z: )) !


!Point3D methods !   
isPointingUp
    ^self alignedWith: Vector3D up!   ! 
#('April 27, 2004' '09:17:34 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('querying' isPointingUp )) !


!Point3D methods ! 
wrapFrom: min to: max
    "Return a new instance of the receiver with components wrapping from max to min."

    ^self class x: (x wrapFrom: min to: max) y: (y wrapFrom: min to: max) z: (z wrapFrom: min to: max)! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('arithmetic' wrapFrom:to: )) !


!Point3D methods !  
multiplyFromPoint3D: aPoint3D

    | newPoint |
    newPoint := (aPoint3D isMoreSpecificThan: self) ifTrue: [aPoint3D shallowCopy] ifFalse: [self shallowCopy].
    ^newPoint
            x: self x * aPoint3D x
            y: self y * aPoint3D y
            z: self z * aPoint3D z!  ! 
#('March 21, 2003' '01:56:29 PM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('arithmetic support' multiplyFromPoint3D: )) !


!Point3D methods !   
angleInDegreesToUsingCrossProduct: vector
    "Returns the angle between self and vector. If either is zero length, returns 0.0."
    "|AxB| = |A| |B| sin theta
    sinTheta = |AxB| / (|A||B|)"
     ^(self angleInRadiansToUsingCrossProduct: vector) * (180.0 / Float pi)!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' angleInDegreesToUsingCrossProduct: )) !


!Point3D methods !  
angleInDegreesToUsingCrossProduct: vector
    "Returns the angle between self and vector. If either is zero length, returns 0.0."
    "|AxB| = |A| |B| sin theta
    sinTheta = |AxB| / (|A||B|)"
     ^(self angleInRadiansToUsingCrossProduct: vector) radiansToDegrees!  ! 
#('May 17, 2004' '08:33:09 AM' 468728)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' angleInDegreesToUsingCrossProduct: )) !


!Point3D methods !  
angleInDegreesToUsingCrossProduct: vector
    "Returns the angle between self and vector. If either is zero length, returns 0.0."
    "|AxB| = |A| |B| sin theta
    sinTheta = |AxB| / (|A||B|)"
self halt: 'This does not work for angles greater than 90 degrees...'.
     ^(self angleInRadiansToUsingCrossProduct: vector) radiansToDegrees!  ! 
#('August 7, 2008' '10:43:33 AM' 469184)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' angleInDegreesToUsingCrossProduct: )) !


!Point3D methods !
normalize

    | normalized |
    normalized := self normalized.
    x := normalized x. y := normalized y. z := normalized z.
    ^self!   ! 
#('March 5, 2002' '01:33:19 PM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' normalize )) !


!Point3D methods ! 
xy
    ^x @ y! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('get/set' xy )) !


!Point3D methods !   
angleInRadiansToUsingCrossProduct: vector
    "Returns the angle between self and vector. If either is zero length, returns 0.0."
    | length1 length2 |
    (length1 := self length) < WorldGlobal epsilon ifTrue: [^0.0].
    (length2 := vector length) < WorldGlobal epsilon ifTrue: [^0.0].

    "sinTheta = |AxB| / (|A||B|)"
    ^(self / length1 cross: vector / length2) length arcSin
!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' angleInRadiansToUsingCrossProduct: )) !


!Point3D methods !  
angleInRadiansToUsingCrossProduct: vector
    "Returns the angle between self and vector. If either is zero length, returns 0.0."
    | length1 length2 |
self halt: 'This does not work for angles greater than 90 degrees...'.
    (length1 := self length) < WorldGlobal epsilon ifTrue: [^0.0].
    (length2 := vector length) < WorldGlobal epsilon ifTrue: [^0.0].

    "sinTheta = |AxB| / (|A||B|)"
    ^(self / length1 cross: vector / length2) length arcSin!    ! 
#('August 7, 2008' '10:43:56 AM' 470620)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' angleInRadiansToUsingCrossProduct: )) !


!Point3D methods !
subtractFromPoint3D: aPoint3D

    | newPoint |
    newPoint := (aPoint3D isMoreSpecificThan: self) ifTrue: [aPoint3D shallowCopy] ifFalse: [self shallowCopy].
    ^newPoint
            x: aPoint3D x - self x
            y: aPoint3D y - self y
            z: aPoint3D z - self z!  ! 
#('March 21, 2003' '01:55:40 PM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('arithmetic support' subtractFromPoint3D: )) !


!Point3D methods !   
degreesToRadians
    ^Point3D x: x degreesToRadians y: y degreesToRadians z: z degreesToRadians!   ! 
#('August 26, 2006' '09:08:26 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('converting' degreesToRadians )) !


!Point3D methods !  
asPoint
    ^x @ y!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('converting' asPoint )) !


!Point3D methods !   
@ aNumber
    ^Point4D x: self x y: self y z: self z w: aNumber!   ! 
#('December 27, 2016' '02:52:26 PM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('converting' @ )) !


!Point3D methods !   
asGamePoint
    ^GamePoint fromPoint: self!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('converting' asGamePoint )) !


!Point3D methods !   
signedAngleInRadiansTo: vector withUpReferenceAxis: up
    "Returns the angle from pi to -pi (a full 360 degrees) between self and vector.  If self rotates left to get to vector, the angle is
    positive; if self rotates right, the angle is negative... Note that self x vector should be in the same direction as up...
    If either vector is zero length, returns 0.0."
    
    | length1 length2 angle |
    (length1 := self length) < WorldGlobal epsilon ifTrue: [^0.0].
    (length2 := vector length) < WorldGlobal epsilon ifTrue: [^0.0].

    
    "cosTheta = |A.B| / (|A||B|) = |A.B| if |A|=|B|=1."
    "Note: clamping just eliminates epsilon errors that cause the bounds to be crossed which arcCos does not like..."
    angle := ((self normalized dot: vector normalized) clampedTo: -1.0 and: 1.0) arcCos.
    
    ^((self cross: vector) alignedWith: up) ifTrue: [angle] ifFalse: [angle negated]!  ! 
#('January 20, 2010' '09:49:57 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' signedAngleInRadiansTo:withUpReferenceAxis: )) !


!Point3D methods !
signedAngleInDegreesTo: vector withUpReferenceAxis: up 
    ^(self signedAngleInRadiansTo: vector withUpReferenceAxis: up) radiansToDegrees!   ! 
#('January 20, 2010' '09:50:52 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' signedAngleInDegreesTo:withUpReferenceAxis: )) !


!Point3D methods !
isOnes
    ^(self distanceSquaredTo: self class ones) < WorldGlobal epsilonSquared!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('querying' isOnes )) !


!Point3D methods !  
render: color

    | clampedColor |
    clampedColor := color clampedTo: 0.0 and: 1.0.
    CanvasLibrary
        drawPoint: self x and: self y and: self z color: clampedColor x and: clampedColor y and: clampedColor z and: clampedColor w radius: 6.0!  ! 
#('September 12, 2001' '10:49:32 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('rendering' render: )) !


!Point3D methods ! 
minimalPoint: aPoint
    "By a minimal point, we mean one with the least x; and if more than one exists, the one with the least y; and if more than one exists, the one with the least z..."
    ^
        x < aPoint x ifTrue: [self] ifFalse: [
        x > aPoint x ifTrue: [aPoint] ifFalse: [
        y < aPoint y ifTrue: [self] ifFalse: [
        y > aPoint y ifTrue: [aPoint] ifFalse: [
        z < aPoint z ifTrue: [self] ifFalse: [
        z > aPoint z ifTrue: [aPoint] ifFalse: [
        self "Everything is equal..."]]]]]]!    ! 
#('July 29, 2008' '10:07:03 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('querying' minimalPoint: )) !


!Point3D methods ! 
yz
    ^y @ z! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('get/set' yz )) !


!Point3D methods !   
normalized
    ^self / self length!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' normalized )) !


!Point3D methods !  
normalized
    | length |
    length := self length.
    length < WorldGlobal epsilon ifTrue: [^self].
    ^self / self length! ! 
#('July 28, 2008' '03:15:54 PM' 476128)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' normalized )) !


!Point3D methods ! 
printXyzOn: aStream
    aStream << '('; << x terseString; << ' @ '; << y terseString; << ' @ '; << z terseString; << ')'.! ! 
#('May 6, 2002' '02:00:56 PM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('printing' printXyzOn: )) !


!Point3D methods ! 
whyFace: aFace
    "Why is aFace a neighbour? See 'squaredDistanceToFace: aFace' for details."

    | point squaredDistance candidate originalPoint1 originalPoint2 where |

    Transcript nextPutAll: 'face '; cr; tab; tab; tab.
    "Deal with the nearest point on the face's plane."
    point := self nearestPointOnPlane: aFace plane.
    (point isOnOrInsideFace: aFace) ifTrue: [
        where := (point isStrictlyInsideFace: aFace) ifTrue: ['inside'] ifFalse: ['boundary'].
        ^Transcript
            nextPutAll: '(perpendicular hits '; nextPutAll: where; nextPutAll: ' at '; print: point;
            nextPutAll: ', distance '; print: (aFace plane distanceToPoint: self);
            nextPutAll: ')'].

    "Deal with the nearest point on the face's lines."
    squaredDistance := nil.
    aFace linesDo: [:point1 :point2 |
        candidate := self squaredDistanceToLineFrom: point1 to: point2.
        (squaredDistance isNil or: [candidate < squaredDistance])
            ifTrue: [squaredDistance := candidate. originalPoint1 := point1. originalPoint2 := point2]].

    Transcript nextPutAll: 'perimeter '.
    self whyLineFrom: originalPoint1 to: originalPoint2
!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('nearness' whyFace: )) !


!Point3D methods !
addToBoundingBox: aBox

    aBox addPoint: self!  ! 
#('March 20, 2002' '11:27:09 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('private' addToBoundingBox: )) !


!Point3D methods ! 
reciprocal
    ^self class x: self x reciprocal y: self y reciprocal z: self z reciprocal! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('arithmetic' reciprocal )) !


!Point3D methods !
distanceToFace: aFace
    | point distance candidate |
    "Deal with the nearest point on the face's plane."
    point := self nearestPointOnPlane: aFace plane.
    (point isOnOrInsideFace: aFace)
        ifTrue: [^aFace plane distanceToPoint: self].

    "Deal with the nearest point on the face's lines."
    distance := nil.
    aFace linesDo: [:point1 :point2 |
        candidate := self distanceToLineFrom: point1 to: point2.
        (distance isNil or: [candidate < distance])
            ifTrue: [distance := candidate]].

    ^distance
!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('distance queries' distanceToFace: )) !


!Point3D methods ! 
horizontalDistanceTo: aPoint3D
    ^(self - aPoint3D) xzLength!    ! 
#('September 16, 2009' '11:56:53 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('distance queries' horizontalDistanceTo: )) !


!Point3D methods !
w
    ^1.0!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('default values' w )) !


!Point3D methods ! 
storeString

    ^'(', self x printString, ' @ ', self y printString, ' @ ', self z printString, ')'! ! 
#('April 5, 2002' '11:04:47 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('printing' storeString )) !


!Point3D methods !   
isMoreSpecificThan: aPoint3D

    ^aPoint3D generality <= self generality!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('querying' isMoreSpecificThan: )) !


!Point3D methods ! 
isOnOrInsideFace: aFace
    "This is true if the point is on or in front of each line's inward facing plane."
    | inwardFacingPlane |
    aFace linesDo: [:point1 :point2 |
        inwardFacingPlane := aFace plane
            leftPointingPerpendicularPlaneThrough: point1 and: point2.
        inwardFacingPlane notNil ifTrue: [
            "Will only be nil if point1 and point2 are too close.
            Use line before and after instead."
            (self isOnOrInFrontOfPlane: inwardFacingPlane) ifFalse: [^false]]].
    "Each line passed the test."
    ^true!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('nearness' isOnOrInsideFace: )) !


!Point3D methods !   
* aPoint3DOrANumberOrTransformation
    ^aPoint3DOrANumberOrTransformation multiplyFromPoint3D: self!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('arithmetic' * )) !


!Point3D methods ! 
isStrictlyInFrontOfPlane: aPlane

    ^(aPlane distanceToPoint: self) > WorldGlobal epsilon
!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('nearness' isStrictlyInFrontOfPlane: )) !


!Point3D methods !   
squaredDistanceToFace: aFace
    | point squaredDistance candidate |
    "Deal with the nearest point on the face's plane."
    point := self nearestPointOnPlane: aFace plane.
    (point isOnOrInsideFace: aFace)
        ifTrue: [^(aFace plane distanceToPoint: self) squared].

    "Deal with the nearest point on the face's lines."
    squaredDistance := nil.
    aFace linesDo: [:point1 :point2 |
        candidate := self squaredDistanceToLineFrom: point1 to: point2.
        (squaredDistance isNil or: [candidate < squaredDistance])
            ifTrue: [squaredDistance := candidate]].

    ^squaredDistance!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('nearness' squaredDistanceToFace: )) !


!Point3D methods !  
exclusiveBetweenMinus90AndPlus90: aVector3D
    ^(self dot: aVector3D) >= 0.0! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('normals' exclusiveBetweenMinus90AndPlus90: )) !


!Point3D methods !
angleFrom0To360To: vector withUpReferenceAxis: up 
    | angle |
    angle := self signedAngleInDegreesTo: vector withUpReferenceAxis: up.
    ^angle negative ifTrue: [360.0 + angle] ifFalse: [angle].!    ! 
#('January 20, 2010' '09:55:49 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' angleFrom0To360To:withUpReferenceAxis: )) !


!Point3D methods ! 
alignedAgainst: aVector3D
    "Pointing in the opposite direction."
    ^(self dot: aVector3D) < 0.0 "Vectors do not have to be normalized..."!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('normals' alignedAgainst: )) !


!Point3D methods !  
distanceTo: aPoint3D
    ^(self - aPoint3D) length!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('distance queries' distanceTo: )) !


!Point3D methods ! 
x
    ^x!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('get/set' x )) !


!Point3D methods !
inclusiveBetweenMinus180And0: aVector3D
    ^(self cross: aVector3D) length >= -1.0e-6 "permitting a little error"
!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('normals' inclusiveBetweenMinus180And0: )) !


!Point3D methods !
x: number1 y: number2 z: number3 w: number4
    ^self x: number1 y: number2 z: number3!    ! 
#('April 8, 2002' '05:15:53 PM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('get/set' x:y:z:w: )) !


!Point3D methods !   
addFromPoint3D: aPoint3D

    | newPoint |
    newPoint := (aPoint3D isMoreSpecificThan: self) ifTrue: [aPoint3D shallowCopy] ifFalse: [self shallowCopy].
    ^newPoint
            x: self x + aPoint3D x
            y: self y + aPoint3D y
            z: self z + aPoint3D z!   ! 
#('March 21, 2003' '01:57:57 PM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('arithmetic support' addFromPoint3D: )) !


!Point3D methods !
whyLineFrom: point1 to: point2
    "Why is this line a neighbour? See 'squaredDistanceToLineFrom: point1 to: point2' for details."

    | line point3 distance1 distance2 distance3 |
    line := Line3D fromPoint: point1 toPoint: point2.
    point3 := self nearestPointOnInfiniteLine: line.
    distance1 := self distanceSquaredTo: point1.
    distance2 := self distanceSquaredTo: point2.
    distance3 := self distanceSquaredTo: point3.
    (distance1 > distance3 and: [distance2 > distance3])
        ifTrue: [
            distance1 < distance2
                ifTrue: [
                    ^Transcript
                        nextPutAll: 'point '; print: point1;
                        nextPutAll: ' distance '; print: distance1 sqrt]
                ifFalse: [
                    ^Transcript
                        nextPutAll: 'point '; print: point2;
                        nextPutAll: ' distance '; print: distance2 sqrt]]
        ifFalse: [
            ^Transcript
                nextPutAll: 'perpendicular to line from '; print: point1;
                nextPutAll: ' to '; print: point2;
                nextPutAll: ' distance '; print: distance3 sqrt]!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('nearness' whyLineFrom:to: )) !


!Point3D methods ! 
rotated180DegreesAroundY
    ^x negated@y@z negated!   ! 
#('September 29, 2006' '09:15:25 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('converting' rotated180DegreesAroundY )) !


!Point3D methods !   
isGrosslyAlignedWith: aPoint3D
    ^(self dot: aPoint3D) abs > 0.9!    ! 
#('February 10, 2003' '03:20:55 PM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('querying' isGrosslyAlignedWith: )) !


!Point3D methods ! 
alignedWith: aVector3D
    "Pointing in the same direction."
    ^(self dot: aVector3D) >= 0.0 "Vectors do not have to be normalized..."! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('normals' alignedWith: )) !


!Point3D methods ! 
divideFromPoint3D: aPoint3D

    | newPoint |
    newPoint := (aPoint3D isMoreSpecificThan: self) ifTrue: [aPoint3D shallowCopy] ifFalse: [self shallowCopy].
    ^newPoint
            x: aPoint3D x / self x
            y: aPoint3D y / self y
            z: aPoint3D z / self z!    ! 
#('March 21, 2003' '01:57:09 PM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('arithmetic support' divideFromPoint3D: )) !


!Point3D methods ! 
// scale

    | newPoint |
    newPoint := self copy.
    (scale isKindOf: Point3D) ifTrue: [^newPoint x: (x // scale x); y: (y // scale y); z: (z // scale z); yourself].
    (scale isKindOf: Point) ifTrue: [^newPoint x: (x // scale x); y: (y // scale y); yourself].
    ^newPoint x: (x // scale); y: (y // scale); z: (z // scale); yourself! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('arithmetic' // )) !


!Point3D methods !
scaleZeroToOne
    "Assume that the values are in the range 0..255 -- convert them to the range 0..1"
    ^(x / 255) @ (y / 255) @ (z / 255)! ! 
#('November 21, 2003' '11:54:08 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('conversion' scaleZeroToOne )) !


!Point3D methods !  
projectionTOn: aVector
    ^ self dot: aVector!    ! 
#('November 27, 2009' '03:53:13 PM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' projectionTOn: )) !


!Point3D methods !
projectionTOn: aVector
    ^self dot: aVector! ! 
#('November 27, 2009' '03:53:55 PM' 488116)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' projectionTOn: )) !


!Point3D methods ! 
projectionTOn: aVector
    "Projection of A on B = (A.B / |B|^2) B. This returns the relative length of B..."
    ^(self dot: aVector) / aVector squaredLength!   ! 
#('November 27, 2009' '03:59:57 PM' 488328)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' projectionTOn: )) !


!Point3D methods ! 
negated
    ^self class new
            x: self x negated
            y: self y negated
            z: self z negated!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('arithmetic' negated )) !


!Point3D methods !   
+ aPoint3DOrANumber
    ^aPoint3DOrANumber addFromPoint3D: self!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('arithmetic' + )) !


!Point3D methods ! 
nearestPointOnLineFrom: point1 to: point2
    | line point3 distance1 distance2 distance3 |
    line := Line3D fromPoint: point1 toPoint: point2.
    point3 := self nearestPointOnInfiniteLine: line.
    distance1 := self distanceSquaredTo: point1.
    distance2 := self distanceSquaredTo: point2.
    distance3 := self distanceSquaredTo: point3.
    distance1 < distance2
        ifTrue: [distance1 < distance3 ifTrue: [^point1] ifFalse: [^point3]]
        ifFalse: [distance2 < distance3 ifTrue: [^point2] ifFalse: [^point3]]!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('nearness' nearestPointOnLineFrom:to: )) !


!Point3D methods !  
horizontalProjection
    ^x @ 0 @ y!   ! 
#('January 20, 2010' '09:30:34 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' horizontalProjection )) !


!Point3D methods !   
horizontalProjection
    ^x @ 0 @ z!   ! 
#('January 20, 2010' '01:14:24 PM' 490076)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' horizontalProjection )) !


!Point3D methods !
y
    ^y!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('get/set' y )) !


!Point3D methods !
angleInDegreesTo: vector
    "Returns the angle between self and vector. If either is zero length, returns 0.0."
     ^(self angleInRadiansTo: vector) * (180.0 / Float pi)!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' angleInDegreesTo: )) !


!Point3D methods !   
angleInDegreesTo: vector
    "Returns the angle between self and vector. If either is zero length, returns 0.0."
     ^(self angleInRadiansTo: vector) radiansToDegrees!  ! 
#('April 27, 2004' '09:17:30 AM' 490648)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' angleInDegreesTo: )) !


!Point3D methods ! 
projectionOn: aVector
    "Projection of A on B = (A.B / |B|^2) B."
    ^ aVector * ((self dot: aVector) / aVector squaredLength)
!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' projectionOn: )) !


!Point3D methods !   
dot: aPoint3D
    "U.V  = u1v1 + u2v2 + u3v3."
    ^(self x * aPoint3D x) + (self y * aPoint3D y) + (self z * aPoint3D z)!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' dot: )) !


!Point3D methods !
reflectAroundNormal: normal
    "See engine for mathematics of reflection."
    ^self - (normal * ((self dot: normal) * 2.0))!    ! 
#('February 11, 2003' '02:39:19 PM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' reflectAroundNormal: )) !


!Point3D methods !  
floor
    ^x floor @ y floor @ z floor!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('converting' floor )) !


!Point3D methods ! 
angleInRadiansTo: vector
    "Returns the angle between self and vector. If either is zero length, returns 0.0."
    | length1 length2 |
    (length1 := self length) < WorldGlobal epsilon ifTrue: [^0.0].
    (length2 := vector length) < WorldGlobal epsilon ifTrue: [^0.0].
    self = vector ifTrue: [^0.0].
    self = vector negated ifTrue: [^Float pi].
    "Note: clamping just eliminates epsilon errors that cause the bounds to be crossed which arcCos does not like..."
    ^((self / length1 dot: vector / length2) clampedTo: -1.0 and: 1.0) arcCos!  ! 
#('July 26, 2006' '08:47:19 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' angleInRadiansTo: )) !


!Point3D methods ! 
angleInRadiansTo: vector
    "Returns the angle between self and vector. If either is zero length, returns 0.0."
    | length1 length2 |
    (length1 := self length) < WorldGlobal epsilon ifTrue: [^0.0].
    (length2 := vector length) < WorldGlobal epsilon ifTrue: [^0.0].
    self = vector ifTrue: [^0.0].
    self = vector negated ifTrue: [^Float pi].
    
    "cosTheta = |A.B| / (|A||B|)"
    "Note: clamping just eliminates epsilon errors that cause the bounds to be crossed which arcCos does not like..."
    ^((self / length1 dot: vector / length2) clampedTo: -1.0 and: 1.0) arcCos! ! 
#('August 5, 2008' '09:20:19 AM' 492392)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' angleInRadiansTo: )) !


!Point3D methods ! 
angleInRadiansTo: vector
    "Returns the angle between self and vector in the range 0 to 180. If either is zero length, returns 0.0."
    | length1 length2 |
    (length1 := self length) < WorldGlobal epsilon ifTrue: [^0.0].
    (length2 := vector length) < WorldGlobal epsilon ifTrue: [^0.0].
    self = vector ifTrue: [^0.0].
    self = vector negated ifTrue: [^Float pi].
    
    "cosTheta = |A.B| / (|A||B|)"
    "Note: clamping just eliminates epsilon errors that cause the bounds to be crossed which arcCos does not like..."
    ^((self / length1 dot: vector / length2) clampedTo: -1.0 and: 1.0) arcCos!   ! 
#('January 20, 2010' '12:38:47 PM' 493112)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' angleInRadiansTo: )) !


!Point3D methods !   
fuzzyEquals: aPoint3D
    "Should probably use = but people converting to C++ will not
    realize it's this equal when they see it used elsewhere."
    (x - aPoint3D x) abs > WorldGlobal epsilon ifTrue: [^false].
    (y - aPoint3D y) abs > WorldGlobal epsilon ifTrue: [^false].
    (z - aPoint3D z) abs > WorldGlobal epsilon ifTrue: [^false].
    ^true!    ! 
#('February 23, 2004' '09:42:46 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('arithmetic' fuzzyEquals: )) !


!Point3D methods !
fuzzyEquals: aPoint3D
    "This is substantially less accurate..."
    (x - aPoint3D x) abs > WorldGlobal epsilon ifTrue: [^false].
    (y - aPoint3D y) abs > WorldGlobal epsilon ifTrue: [^false].
    (z - aPoint3D z) abs > WorldGlobal epsilon ifTrue: [^false].
    ^true!   ! 
#('July 10, 2008' '03:23:22 PM' 494668)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('arithmetic' fuzzyEquals: )) !


!Point3D methods ! 
abs
    ^self class new
            x: self x abs
            y: self y abs
            z: self z abs!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('arithmetic' abs )) !


!Point3D methods !   
x: aNumber
    x := aNumber!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('get/set' x: )) !


!Point3D methods !   
hash
    ^(self x + self y + self z) hash! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('arithmetic' hash )) !


!Point3D methods !  
copy: aPoint3D
    x := aPoint3D x.
    y := aPoint3D y.
    z := aPoint3D z.!   ! 
#('May 9, 2002' '10:54:30 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('copying' copy: )) !


!Point3D methods !
z
    ^z!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('get/set' z )) !


!Point3D methods !
cannonicallyLessThan: aPoint3D
    "Find a stable ordering for  the receiver and aPoint3D."

    | difference epsilon negativeEpsilon |
    epsilon := WorldGlobal epsilon. negativeEpsilon := epsilon negated.

    difference := aPoint3D x - self x.
    difference < negativeEpsilon ifTrue: [^true].
    difference > epsilon ifTrue: [^false].

    difference := aPoint3D y - self y.
    difference < negativeEpsilon ifTrue: [^true].
    difference > epsilon ifTrue: [^false].

    difference := aPoint3D z - self z.
    difference < negativeEpsilon ifTrue: [^true].
    difference > epsilon ifTrue: [^false].

    "they're equal...so i don't know how to order them stably. hopefully it won't make a difference"
    ^true!  ! 
#('February 18, 2002' '10:09:10 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('querying' cannonicallyLessThan: )) !


!Point3D methods ! 
inclusiveBetweenMinus90AndPlus90: aVector3D
    ^(self dot: aVector3D) >= -1.0e-6 "permitting a little error"! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('normals' inclusiveBetweenMinus90AndPlus90: )) !


!Point3D methods !
isZero
    ^(self distanceSquaredTo: self class zero) < WorldGlobal epsilonSquared!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('querying' isZero )) !


!Point3D methods !  
withinAMillimiterOf: aPoint3D
    "This is even less accurate than fuzzyEquals:..."
    
    (self x - aPoint3D x) > WorldGlobal oneMillimeter ifFalse: [^false].
    (self y - aPoint3D y) > WorldGlobal oneMillimeter ifFalse: [^false].
    (self z - aPoint3D z) > WorldGlobal oneMillimeter ifFalse: [^false].
    ^true!    ! 
#('July 10, 2008' '03:23:47 PM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('arithmetic' withinAMillimiterOf: )) !


!Point3D methods !
withinAMillimiterOf: aPoint3D
    "This is even less accurate than fuzzyEquals:..."
    
    (x - aPoint3D x) abs > WorldGlobal oneMillimeter ifFalse: [^false].
    (y - aPoint3D y) abs > WorldGlobal oneMillimeter ifFalse: [^false].
    (z - aPoint3D z) abs > WorldGlobal oneMillimeter ifFalse: [^false].
    ^true!   ! 
#('July 10, 2008' '03:33:18 PM' 498088)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('arithmetic' withinAMillimiterOf: )) !


!Point3D methods ! 
withinAMillimiterOf: aPoint3D
    "This is even less accurate than fuzzyEquals:..."
    
    (x - aPoint3D x) abs > WorldGlobal oneMillimeter ifTrue: [^false].
    (y - aPoint3D y) abs > WorldGlobal oneMillimeter ifTrue: [^false].
    (z - aPoint3D z) abs > WorldGlobal oneMillimeter ifTrue: [^false].
    ^true!  ! 
#('July 10, 2008' '03:37:02 PM' 498580)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('arithmetic' withinAMillimiterOf: )) !


!Point3D methods ! 
exportOn: aStream
    aStream << '{'; << self x; << ', '; << self y; << ', '; << self z; << '}'!   ! 
#('September 19, 2001' '12:29:43 PM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('printing' exportOn: )) !


!Point3D methods !
safelyNormalized
    | length |
    length := self length. length < WorldGlobal epsilon ifTrue: [^self].
    ^self / self length!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('geometry' safelyNormalized )) !


!Point3D methods !
clampedTo: min and: max
    "Return a new instance of the receiver with components clamped to the range [min,max]."

    ^self class x: (x clampedTo: min and: max) y: (y clampedTo: min and: max) z: (z clampedTo: min and: max)!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('arithmetic' clampedTo:and: )) !


!Point3D methods !
colored: aColor

    ^RenderingWrapper object: self color: aColor!    ! 
#('April 8, 2002' '02:12:55 PM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('rendering' colored: )) !


!Point3D methods ! 
- aPoint3DOrANumber
    ^aPoint3DOrANumber subtractFromPoint3D: self!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('arithmetic' - )) !


!Point3D methods ! 
string2D
    | string index |
    string := self printString reversed.
    index := string indexOf: $,.
    ^(string copyFrom: index+1 to: string size) reversed, ']'!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('printing' string2D )) !


!Point3D methods !
nearestPointOnPlane: aPlane
    "Let R = self, let N.P + d = 0 be the equation of the plane, and
    let Q be the answer, Then
        N.Q + d = 0. (1)
    Since R - Q is parallel to N, we can write
        R - Q = tN for some t. So
        Q = R - tN (2)
    Plugging into (1), we get
        N.(R - tN) + d = 0
        N.R - tN.N + d = 0
        N.R - t + d = 0 (N.N = 1 since the normal is unit length)
        t = N.R + d
    Compute the answer from (2)"

    | t |
    t := (aPlane normal dot: self) + aPlane minusP0DotNormal.
    ^self - (aPlane normal * t)!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('nearness' nearestPointOnPlane: )) !


!Point3D methods !
truncated
    ^self class new
            x: self x truncated
            y: self y truncated
            z: self z truncated!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('arithmetic' truncated )) !


!Point3D methods ! 
y: aNumber
    y:= aNumber!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('get/set' y: )) !


!Point3D methods !   
distanceToPoint: aPoint3D
    ^(self - aPoint3D) length!   ! 
#('June 24, 2005' '09:49:06 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('distance queries' distanceToPoint: )) !


!Point3D methods !  
min: aPoint3D
    ^Point3D x: (x min: aPoint3D x) y: (y min: aPoint3D y) z: (z min: aPoint3D z)!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('arithmetic' min: )) !


!Point3D methods !  
saveOn: aStream
    aStream << '('; << self x; space; << self y; space; << self z; << ')'! ! 
#('September 19, 2001' '12:29:43 PM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('printing' saveOn: )) !


!Point3D methods !  
= aPoint3D
    (aPoint3D isKindOf: Point3D) ifFalse: [^false].
    ^self equals: aPoint3D
!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('arithmetic' = )) !


!Point3D methods ! 
max: aPoint3D
    ^Point3D x: (x max: aPoint3D x) y: (y max: aPoint3D y) z: (z max: aPoint3D z)!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('arithmetic' max: )) !


!Point3D methods !  
equals: aPoint3D toAccuracy: epsilon
    (x - aPoint3D x) abs > epsilon ifTrue: [^false].
    (y - aPoint3D y) abs > epsilon ifTrue: [^false].
    (z - aPoint3D z) abs > epsilon ifTrue: [^false].
    ^true!  ! 
#('July 10, 2009' '08:55:30 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('arithmetic' equals:toAccuracy: )) !


!Point3D methods !  
notZero
    ^self isZero not!  ! 
#('March 31, 2003' '04:03:28 PM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('querying' notZero )) !


!Point3D methods !  
squaredDistanceToFaceBoundary: aFace
    | squaredDistance candidate |

    "Deal with the nearest point on the face's lines."
    squaredDistance := nil.
    aFace pointsDo: [:point |
        candidate := self distanceSquaredTo: point.
        candidate < WorldGlobal epsilon ifTrue: [^candidate "close enough to zero"].
        (squaredDistance isNil or: [candidate < squaredDistance])
            ifTrue: [squaredDistance := candidate]].

    ^squaredDistance
!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('nearness' squaredDistanceToFaceBoundary: )) !


!Point3D methods !  
ceiling
    ^x ceiling @ y ceiling @ z ceiling!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('converting' ceiling )) !


!Point3D methods !   
squaredDistanceTo: aPoint3D
    ^self distanceSquaredTo: aPoint3D! ! 
#('January 5, 2007' '11:09:50 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('distance queries' squaredDistanceTo: )) !


!Point3D methods !  
asPoint3D
    ^self!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('converting' asPoint3D )) !


!Point3D methods ! 
z: aNumber
    z := aNumber!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('get/set' z: )) !


!Point3D methods !   
equals: aPoint3D
    "This is = to within a millimeter..."
    
    "^(self distanceSquaredTo: aPoint3D) < WorldGlobal epsilonSquared "    "WILF: THIS REQUIRED TOO MUCH ACCURACY"
    
    (self x - aPoint3D x) > WorldGlobal oneMillimeter ifFalse: [^false].
    (self y - aPoint3D y) > WorldGlobal oneMillimeter ifFalse: [^false].
    (self z - aPoint3D z) > WorldGlobal oneMillimeter ifFalse: [^false].
    ^true!   ! 
#('July 10, 2008' '03:17:07 PM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('arithmetic' equals: )) !


!Point3D methods ! 
equals: aPoint3D
    "Should probably use = but people converting to C++ will not
    realize it's this equal when they see it used elsewhere."
    ^(self distanceSquaredTo: aPoint3D) < WorldGlobal epsilonSquared!    ! 
#('July 10, 2008' '03:22:25 PM' 505736)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('arithmetic' equals: )) !


!Point3D methods !  
equals: aPoint3D
    "This is quite accurate..."
    ^(self distanceSquaredTo: aPoint3D) < WorldGlobal epsilonSquared!    ! 
#('July 10, 2008' '03:22:57 PM' 506312)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('arithmetic' equals: )) !


!Point3D methods !  
generality

    ^1!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('querying' generality )) !


!Point3D methods !  
squaredDistanceToLineFrom: point1 to: point2
    | line nearestPointOnLine distance1 distance2 perpendicularDistance lineLength |
    line := Line3D fromPoint: point1 toPoint: point2.
    lineLength := point1 distanceSquaredTo: point2.
    nearestPointOnLine := self nearestPointOnInfiniteLine: line.
    perpendicularDistance := self distanceSquaredTo: nearestPointOnLine.
    distance1 := self distanceSquaredTo: point1.
    distance2 := self distanceSquaredTo: point2.
    ((nearestPointOnLine distanceSquaredTo: point1) > lineLength or: [
    (nearestPointOnLine distanceSquaredTo: point2) > lineLength])
        ifTrue: [^distance1 min: distance2]
        ifFalse: [^perpendicularDistance]
!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('nearness' squaredDistanceToLineFrom:to: )) !


!Point3D methods !   
asBareString
    | aStream |
    aStream := WriteStream on: (String new: 100).
    aStream << (self  x); << ' '; << (self y); << ' '; << (self z).
    ^aStream contents!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('converting' asBareString )) !


!Point3D methods !  
initialize
    super initialize.
    x := y := z := 0.0.! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('initializing' initialize )) !


!Point3D methods !  
isPoint3D
    ^true!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('querying' isPoint3D )) !


!Point3D class methods ! 
normalFromPoint: p1 point: p2 point: p3
    "Assumption: p1, p2, p3 are counter-clockwise."
    "^((p2 - p1) cross: (p3 - p1)) asPoint3D normalized"
    ^((p2 - p1) cross: (p3 - p2)) asPoint3D normalized! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('instance creation' normalFromPoint:point:point: )) !


!Point3D class methods !   
normalFromPoints: points
    "Newell's method on page 231 of Graphics Gems III."
    "Assumption: points are counter-clockwise."
    | nx ny nz previous normal |
    nx := ny := nz := 0.0.
    previous := points last.
    points do: [:next |
        nx := nx + ((previous y - next y) * (previous z + next z)).
        ny := ny + ((previous z - next z) * (previous x + next x)).
        nz := nz + ((previous x - next x) * (previous y + next y)).
        previous := next].
    normal := Vector3D x: nx asFloat  y: ny asFloat z: nz asFloat.
    normal isZero ifTrue: [
        "Resort to the standard technique."
        normal := Vector3D normalFromPoint: (points at: 1) point: (points at: 2) point: (points at: 3)].
    ^normal "negated" normalized!   ! 
#('June 17, 2002' '12:10:33 PM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('instance creation' normalFromPoints: )) !


!Point3D class methods !
down
    ^self x: 0.0 y: -1.0 z: 0.0!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('direction vectors' down )) !


!Point3D class methods !   
randomizedVerticalDirection
    ^((RandomNumberStream nextFrom: 0.000001 to: 1.0) @ 1.0 @ (RandomNumberStream nextFrom: 0.000001 to: 1.0)) normalized! ! 
#('May 13, 2004' '03:48:06 PM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('direction vectors' randomizedVerticalDirection )) !


!Point3D class methods !   
randomizedVerticalDirection
    | xRotation zRotation |
    xRotation := RandomNumberStream nextFrom: -90.0 to: 90.0.
    zRotation := RandomNumberStream nextFrom: -90.0 to: 90.0.
    ^Point3D up * (Transformation4D stepwiseRotatedByDegrees: (xRotation @ 0.0 @ zRotation))

"
    | min max dp |

    100000 timesRepeat: [
        dp := Point3D randomizedVerticalDirection dot: Point3D up.
        min isNil ifTrue: [min := dp] ifFalse: [min := min min: dp].
        max isNil ifTrue: [max := dp] ifFalse: [max := max max: dp]].

    Transcript cr; << 'Max '; << max; cr; << 'Min '; << min
"!  ! 
#('May 13, 2004' '03:48:06 PM' 510340)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('direction vectors' randomizedVerticalDirection )) !


!Point3D class methods !
randomizedVerticalDirection
    | xRotation zRotation |
    xRotation := RandomNumberStream nextFrom: -90.0 to: 90.0.
    zRotation := RandomNumberStream nextFrom: -90.0 to: 90.0.
    ^Point3D up * (Transformation4D stepwiseRotatedByDegrees: (xRotation @ 0.0 @ zRotation))!   ! 
#('May 13, 2004' '03:48:06 PM' 510684)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('direction vectors' randomizedVerticalDirection )) !


!Point3D class methods !
cosineBetween: point1 and: point2 and: point3
    "Use the law of cosines <c2 = a2 + b2 -2abcos x> to compute the angle at
    point2 where a = p1 - p2, b = p3 - p2, c is the other side."
    | a b c aLength bLength |
    a := point1 - point2. b := point3 - point2. c := point1 - point3.
    aLength := a length. bLength := b length.
    ^(aLength squared + bLength squared - c squaredLength) / (2.0 * aLength * bLength)! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('queries' cosineBetween:and:and: )) !


!Point3D class methods !   
ones
    ^self x: 1.0 y: 1.0 z: 1.0!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('instance creation' ones )) !


!Point3D class methods !   
xVector
    ^self x: 1.0 y: 0.0 z: 0.0!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('instance creation' xVector )) !


!Point3D class methods !
additiveIdentity
    ^self zero!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('queries' additiveIdentity )) !


!Point3D class methods ! 
yVector
    ^self x: 0.0 y: 1.0 z: 0.0!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('instance creation' yVector )) !


!Point3D class methods !
zVector
    ^self x: 0.0 y: 0.0 z: 1.0!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('instance creation' zVector )) !


!Point3D class methods !
example1
    "Point3D example1"
    "self halt. Point3D example1"
    "Vector3D example1"
    | c1 c2 |
    c1 := self x: 1 y: 1 z: 1.
    c2 := self x: 2 y: 3 z: 4.
    ^100 - (c1 + c2 + 1)!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('examples' example1 )) !


!Point3D class methods !
example1
    "Point3D example1"
    "self halt. Point3D example1"
    "Point3D example1"
    | c1 c2 |
    c1 := self x: 1 y: 1 z: 1.
    c2 := self x: 2 y: 3 z: 4.
    ^100 - (c1 + c2 + 1)!   ! 
#('December 27, 2016' '02:50:55 PM' 513632)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('examples' example1 )) !


!Point3D class methods !   
example1
    "Point3D example1"
    | c1 c2 |
    c1 := self x: 1 y: 1 z: 1.
    c2 := self x: 2 y: 3 z: 4.
    ^100 - (c1 + c2 + 1)!  ! 
#('December 27, 2016' '02:57:07 PM' 513996)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('examples' example1 )) !


!Point3D class methods !   
null
    "x, y, and z are nil"
    ^self new! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('instance creation' null )) !


!Point3D class methods !   
right
    ^self x: 1.0 y: 0.0 z: 0.0!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('direction vectors' right )) !


!Point3D class methods !  
defaultColor
    "(170@27@54) / 255.0"

    ^0.66666667 @ 0.10588235 @ 0.21176471 @ 0.75!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('constants' defaultColor )) !


!Point3D class methods !   
random

    ^(self
        x: (RandomNumberStream nextFrom: -1.0 to: 1.0)
        y: (RandomNumberStream nextFrom: -1.0 to: 1.0)
        z: (RandomNumberStream nextFrom: -1.0 to: 1.0)) normalized!   ! 
#('March 14, 2001' '10:56:40 AM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('instance creation' random )) !


!Point3D class methods !  
x: number1 y: number2 z: number3
    ^self new x: number1 y: number2 z: number3!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('instance creation' x:y:z: )) !


!Point3D class methods ! 
zero
    ^self x: 0.0 y: 0.0 z: 0.0!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('instance creation' zero )) !


!Point3D class methods !   
left
    ^self x: -1.0 y: 0.0 z: 0.0!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('direction vectors' left )) !


!Point3D class methods !   
ahead
    ^self x: 0.0 y: 0.0 z: -1.0! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('direction vectors' ahead )) !


!Point3D class methods !  
randomizedDirectionAround: source
    | xRotation yRotation zRotation |
    xRotation := RandomNumberStream nextFrom: -90.0 to: 90.0.
    yRotation := RandomNumberStream nextFrom: -90.0 to: 90.0.
    zRotation := RandomNumberStream nextFrom: -90.0 to: 90.0.
    ^source * (Transformation4D stepwiseRotatedByDegrees: (xRotation @ yRotation @ zRotation))!  ! 
#('May 14, 2004' '03:15:16 PM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('direction vectors' randomizedDirectionAround: )) !


!Point3D class methods !
normalFromDangerousPoints: points
    "Newell's method on page 231 of Graphics Gems III."
    "Assumption: points are counter-clockwise."
    | nx ny nz previous normal |
    nx := ny := nz := 0.0.
    previous := points last.
    points do: [:next |
        nx := nx + ((previous y - next y) * (previous z + next z)).
        ny := ny + ((previous z - next z) * (previous x + next x)).
        nz := nz + ((previous x - next x) * (previous y + next y)).
        previous := next].
    normal := Vector3D x: nx y: ny z: nz.

    normal isZero ifTrue: [^nil].
    ^normal "negated" normalized
!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('instance creation' normalFromDangerousPoints: )) !


!Point3D class methods ! 
randomizedHorizontalDirection
    ^((RandomNumberStream nextFrom: 0.000001 to: 1.0) @ 0.0 @ (RandomNumberStream nextFrom: 0.000001 to: 1.0)) normalized!   ! 
#('November 11, 2003' '11:11:09 AM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('direction vectors' randomizedHorizontalDirection )) !


!Point3D class methods !
far
    ^1.0e9!    ! 
#('June 3, 2004' '11:44:01 AM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('queries' far )) !


!Point3D class methods ! 
far
    ^1.0e5!    ! 
#('June 3, 2004' '11:44:01 AM' 518352)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('queries' far )) !


!Point3D class methods !  
far
    ^1.0e10!   ! 
#('June 3, 2004' '11:51:41 AM' 518528)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('queries' far )) !


!Point3D class methods !  
cosineBetweenNormals: normal1 and: normal2
    "Modification of 'cosineBetween: point1 and: point2 and: point3' where
    the points are known to be unit length normals and a = normal1, b = normal2.
    So | a | = | a2 | = 1, | b | = | b2 | = 1; c is the only unknown quantity.
    Simplifying <c2 = a2 + b2 -2abcos x>, we get
        <c2 = 1 + 1 - 2*1*1*cos x> or <cos x = (2 - c2) / 2>."
    | c |
    c := normal1 - normal2.
    ^(2.0 - c squaredLength) / 2.0! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('queries' cosineBetweenNormals:and: )) !


!Point3D class methods !
new
    ^super new initialize! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('instance creation' new )) !


!Point3D class methods !
medium
    ^1.0e3! ! 
#('July 4, 2001' '03:31:02 PM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('queries' medium )) !


!Point3D class methods !  
close
    ^1.0e2!  ! 
#('August 9, 2001' '02:45:04 PM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('queries' close )) !


!Point3D class methods ! 
justAhead
    ^self x: 0.0 y: 0.0 z: -1.0! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('instance creation' justAhead )) !


!Point3D class methods !  
up
    ^self x: 0.0 y: 1.0 z: 0.0! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('direction vectors' up )) !


!Point3D class methods ! 
fromArray: array
    array size ~= 3 ifTrue: [self halt: 'incorrect array size'].
    ^self x: (array at: 1) asFloat y: (array at: 2) asFloat z: (array at: 3) asFloat!   ! 
#('January 31, 2003' '01:11:53 PM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('instance creation' fromArray: )) !


!Point3D class methods !
back
    ^self x: 0.0 y: 0.0 z: 1.0!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('direction vectors' back )) !


!Point3D class methods !   
fromUnconvertedArray: array
    ^self x: (array at: 1) y: (array at: 2) z: (array at: 3)!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('instance creation' fromUnconvertedArray: )) !


!Point3D class methods !  
normalFromDangerousPoint: p1 point: p2 point: p3
    "Assumption: p1, p2, p3 are counter-clockwise."
    | normal |
    normal := ((p2 - p1) cross: (p3 - p2)) asPoint3D.
    normal isZero ifTrue: [^nil].
    ^normal normalized!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('instance creation' normalFromDangerousPoint:point:point: )) !


!Point3D class methods !  
isPoint1: point1 point2: point2 point3: point3 leftTurningWithRespectTo: normal
    ^((point2 - point1) cross: (point3 - point1)) alignedWith: normal! ! 
#('January 28, 2010' '09:15:26 AM' nil)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('queries' isPoint1:point2:point3:leftTurningWithRespectTo: )) !


!Point3D class methods !
isPoint1: point1 point2: point2 point3: point3 leftTurningWithRespectTo: normal
    | pointsNormal |
    pointsNormal := (point2 - point1) cross: (point3 - point1).
    pointsNormal isZero ifTrue: [^true]. "We will consider a sequence of points forming a straight line as left turning (of course, it's NOT RIGHT TURNING)."
    ^pointsNormal alignedWith: normal!   ! 
#('January 28, 2010' '09:32:21 AM' 521804)!

(CodeFiler organizerFor: Point3D class) reorganizeFrom: #(
('queries' isPoint1:point2:point3:leftTurningWithRespectTo: )) !


 

Point3D subclass: #Point4D
  instanceVariableNames: 
    ' w '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( '3D-Basic' )
  comment: ''!

!Point4D methods ! 
asArray
    ^Array with: self x with: self y with: self z with: self w!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point4D) reorganizeFrom: #(
('conversion' asArray )) !


!Point4D methods !   
printXyzwOn: aStream
    aStream << '['; << x terseString; << ', '; << y terseString; << ', '; << z terseString;  << ', '; << w terseString; << ']'.!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point4D) reorganizeFrom: #(
('printing' printXyzwOn: )) !


!Point4D methods !
x: number1 y: number2 z: number3 w: number4
    x := number1. y := number2. z := number3. w := number4!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point4D) reorganizeFrom: #(
('get/set' x:y:z:w: )) !


!Point4D methods ! 
w: aNumber
    w := aNumber!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point4D) reorganizeFrom: #(
('get/set' w: )) !


!Point4D methods !   
generality

    ^2!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point4D) reorganizeFrom: #(
('querying' generality )) !


!Point4D methods !  
yw
    ^y @ w! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point4D) reorganizeFrom: #(
('get/set' yw )) !


!Point4D methods !   
clampedTo: min and: max
    "Return a new instance of the receiver with components clamped to the range [min,max]."

    ^self class x: (x clampedTo: min and: max) y: (y clampedTo: min and: max) z: (z clampedTo: min and: max) w: (w clampedTo: min and: max)!    ! 
#('September 7, 2001' '03:35:10 PM' nil)!

(CodeFiler organizerFor: Point4D) reorganizeFrom: #(
('arithmetic' clampedTo:and: )) !


!Point4D methods !  
asPoint3D
    ^Point3D new
        x: self x / self w;
        y: self y / self w;
        z: self z / self w!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point4D) reorganizeFrom: #(
('conversion' asPoint3D )) !


!Point4D methods ! 
asBareString
    | aStream |
    aStream := WriteStream on: (String new: 100).
    aStream << (self  x); << ' '; << (self y); << ' '; << (self z); << ' '; << (self w).
    ^aStream contents!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point4D) reorganizeFrom: #(
('conversion' asBareString )) !


!Point4D methods !  
isPoint4D
    ^true!   ! 
#('October 8, 2002' '02:04:24 PM' nil)!

(CodeFiler organizerFor: Point4D) reorganizeFrom: #(
('querying' isPoint4D )) !


!Point4D methods !   
w
    ^w!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point4D) reorganizeFrom: #(
('get/set' w )) !


!Point4D methods !
xw
    ^x @ w! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point4D) reorganizeFrom: #(
('get/set' xw )) !


!Point4D methods !   
exportOn: aStream
    aStream << '('; << self x; space; << self y; space; << self z; space; << self w; << ')'! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point4D) reorganizeFrom: #(
('printing' exportOn: )) !


!Point4D methods !   
asRGBPoint
    ^Point3D new
        x: self x;
        y: self y;
        z: self z!    ! 
#('January 20, 2003' '10:55:01 AM' nil)!

(CodeFiler organizerFor: Point4D) reorganizeFrom: #(
('conversion' asRGBPoint )) !


!Point4D methods !   
wInterpolateTo: aPoint4D
    "Interpolate from self to aPoint4D to the point where w = 1.
    Return a 3D point rather than a 4D point."
    | ratio |
    ratio := (1.0 - self w) / (aPoint4D w - self w).
    ^Point3D new
        x: self x + ((aPoint4D x - self x) * ratio)
        y: self y + ((aPoint4D y - self y) * ratio)
        z: self z + ((aPoint4D z - self z) * ratio)!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point4D) reorganizeFrom: #(
('solving' wInterpolateTo: )) !


!Point4D methods !  
zw
    ^z @ w! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point4D) reorganizeFrom: #(
('get/set' zw )) !


!Point4D methods !   
asOpenGLColor
    ^self!   ! 
#('July 19, 2007' '11:48:43 AM' nil)!

(CodeFiler organizerFor: Point4D) reorganizeFrom: #(
('conversion' asOpenGLColor )) !


!Point4D methods !   
divideFromPoint3D: aPoint3D

    | newPoint |
    newPoint := (aPoint3D isMoreSpecificThan: self) ifTrue: [aPoint3D shallowCopy] ifFalse: [self shallowCopy].
    ^newPoint
            x: aPoint3D x / self x
            y: aPoint3D y / self y
            z: aPoint3D z / self z!    ! 
#('March 21, 2003' '01:57:27 PM' nil)!

(CodeFiler organizerFor: Point4D) reorganizeFrom: #(
('arithmetic support' divideFromPoint3D: )) !


!Point4D methods ! 
scaleZeroToOne
    "Assume that the values are in the range 0..255 -- convert them to the range 0..1"
    ^(x / 255) @ (y / 255) @ (z / 255) @ (w / 255)! ! 
#('July 8, 2002' '10:09:37 AM' nil)!

(CodeFiler organizerFor: Point4D) reorganizeFrom: #(
('conversion' scaleZeroToOne )) !


!Point4D methods !   
printOn: aStream

    Notifier isControlKeyDown ifFalse: [^self printXyzwOn: aStream].
    aStream << self class; << ' ['; << x; << ', '; << y; << ', '; << z; << ', '; << w; << ']'.!   ! 
#('December 14, 2001' '05:16:54 PM' nil)!

(CodeFiler organizerFor: Point4D) reorganizeFrom: #(
('printing' printOn: )) !


!Point4D class methods !
x: number1 y: number2 z: number3 w: number4
    ^self new x: number1 y: number2 z: number3 w: number4! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point4D class) reorganizeFrom: #(
('instance creation' x:y:z:w: )) !


!Point4D class methods !   
interpolatedPointFrom: p1 and: p2 withT: t
    ^self new
        x: p1 x + ((p2 x - p1 x) * t);
        y: p1 y + ((p2 y - p1 y) * t);
        z: p1 z + ((p2 z - p1 z) * t);
        w: p1 w + ((p2 w - p1 w) * t);
        yourself.!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point4D class) reorganizeFrom: #(
('instance creation' interpolatedPointFrom:and:withT: )) !


!Point4D class methods !   
zero
    ^self x: 0.0 y: 0.0 z: 0.0 w: 0.0!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point4D class) reorganizeFrom: #(
('instance creation' zero )) !


!Point4D class methods !   
fromArray: array
    array size = 3 ifTrue: [^(super fromArray: array) w: 1.0].
    ^self x: (array at: 1) asFloat y: (array at: 2) asFloat z: (array at: 3) asFloat w: (array at: 4) asFloat!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point4D class) reorganizeFrom: #(
('instance creation' fromArray: )) !


!Point4D class methods ! 
ones
    ^self x: 1.0 y: 1.0 z: 1.0 w: 1.0!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Point4D class) reorganizeFrom: #(
('instance creation' ones )) !


   

GraphicsMedium subclass: #Printer
  instanceVariableNames: 
    ' name abort jobid '
  classVariableNames: 
    ' AbortProc '
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Base-Graphics' )
  comment: ''!

   

Collection subclass: #PriorityQueue
  instanceVariableNames: 
    ' elements compareBlock needToHeapify '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Collections' )
  comment: 'This priority queue always returns the ''maximum'' element.  ''compareBlock'' should return true when element1 is higher priority than element2'!

!PriorityQueue methods ! 
removeIdentical: anObject
    ^elements removeIdentical: anObject! ! 
#('August 4, 2003' '09:47:39 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('operations' removeIdentical: )) !


!PriorityQueue methods !   
removeIdentical: anObject
    elements removeIdentical: anObject.
    self heapify.!  ! 
#('August 4, 2003' '09:47:50 AM' 530468)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('operations' removeIdentical: )) !


!PriorityQueue methods !
removeIdentical: anObject
    elements removeIdentical: anObject.
    needToHeapify := true. "We don't want to heapify yet, in case we do additional removes right away."!    ! 
#('August 4, 2003' '04:36:44 PM' 530712)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('operations' removeIdentical: )) !


!PriorityQueue methods !
compareBlock
    ^compareBlock!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('get/set' compareBlock )) !


!PriorityQueue methods ! 
addLast
    ^self invalidMessage!  ! 
#('August 4, 2003' '09:18:17 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('invalid messages' addLast )) !


!PriorityQueue methods !  
heapify: baseIndex
    "Enforce the heap property (parent elements > children elements) in the subtree starting at baseIndex."
    | left right largest |
    left := self leftChild: baseIndex.
    right := self rightChild: baseIndex.
    largest := baseIndex.
    (left <= elements size and: [self is: left higherPriorityThan: baseIndex]) ifTrue: [largest := left].
    (right <= elements size and: [self is: right higherPriorityThan: baseIndex]) ifTrue: [largest := right].
    largest = baseIndex ifFalse: [
        self 
            swapElements: baseIndex and: largest; 
            heapify: largest].!   ! 
#('August 4, 2003' '08:56:30 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('private' heapify: )) !


!PriorityQueue methods !  
heapify: baseIndex
    "Enforce the heap property (parent elements > children elements) in the subtree starting at baseIndex."
    | left right largest |
    left := self leftChild: baseIndex.
    right := self rightChild: baseIndex.
    largest := baseIndex.
    (left <= elements size and: [self is: (elements at: left) higherPriorityThan: (elements at: baseIndex)]) ifTrue: [largest := left].
    (right <= elements size and: [self is: (elements at: right) higherPriorityThan: (elements at: baseIndex)]) ifTrue: [largest := right].
    largest = baseIndex ifFalse: [
        self 
            swapElements: baseIndex and: largest; 
            heapify: largest].!   ! 
#('August 4, 2003' '09:12:33 AM' 531740)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('private' heapify: )) !


!PriorityQueue methods !   
heapify: baseIndex
    "Enforce the heap property (parent elements > children elements) in the subtree starting at baseIndex."
    | left right largest |
    left := self leftChild: baseIndex.
    right := self rightChild: baseIndex.
    largest := baseIndex.
    (left <= elements size and: [self is: (elements at: left) higherPriorityThan: (elements at: baseIndex)]) ifTrue: [largest := left].
    (right <= elements size and: [self is: (elements at: right) higherPriorityThan: (elements at: largest)]) ifTrue: [largest := right].
    largest = baseIndex ifFalse: [
        self 
            swapElements: baseIndex and: largest; 
            heapify: largest].! ! 
#('August 4, 2003' '09:38:48 AM' 532524)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('private' heapify: )) !


!PriorityQueue methods !   
sanityCheck: index
    "Make sure the heap property is enforced for all elements in the heap."
    | left right |
    left := self leftChild: index.
    right := self rightChild: index.
    left <= self size ifTrue: [
        (self is: (elements at: index) higherPriorityThan: (elements at: left)) ifFalse: [self error: 'Heap property violated.']].
    right <= self size ifTrue: [
        (self is: (elements at: index) higherPriorityThan: (elements at: right)) ifFalse: [self error: 'Heap property violated.']].!  ! 
#('August 4, 2003' '10:01:08 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('operations' sanityCheck: )) !


!PriorityQueue methods !   
sanityCheck: index
    "Make sure the heap property is enforced for all elements in the heap."
    | left right |
    left := self leftChild: index.
    right := self rightChild: index.
    left <= self size ifTrue: [
        (self is: (elements at: index) higherPriorityThan: (elements at: left)) ifFalse: [self error: 'Heap property violated.'].
        self sanityCheck: left].
    right <= self size ifTrue: [
        (self is: (elements at: index) higherPriorityThan: (elements at: right)) ifFalse: [self error: 'Heap property violated.'].
        self sanityCheck: right].!   ! 
#('August 4, 2003' '10:01:31 AM' 534216)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('operations' sanityCheck: )) !


!PriorityQueue methods !
sanityCheck: index
    "Make sure the heap property is enforced for all elements in the heap."
    | left right |
    left := self leftChild: index.
    right := self rightChild: index.
    left <= self size ifTrue: [
        (self is: (elements at: left) higherPriorityThan: (elements at: index)) ifTrue: [self error: 'Heap property violated.'].
        self sanityCheck: left].
    right <= self size ifTrue: [
        (self is: (elements at: right) higherPriorityThan: (elements at: index)) ifTrue: [self error: 'Heap property violated.'].
        self sanityCheck: right].! ! 
#('August 4, 2003' '10:03:47 AM' 534912)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('operations' sanityCheck: )) !


!PriorityQueue methods !
maxQueue
    "This is the same as 'SortedCollection' does -- we implement a value:value: message in this class and make it be its own compareBlock."
    self compareBlock: self.!    ! 
#('August 4, 2003' '09:07:34 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('private' maxQueue )) !


!PriorityQueue methods !  
addFirst
    ^self invalidMessage! ! 
#('August 4, 2003' '09:18:20 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('invalid messages' addFirst )) !


!PriorityQueue methods ! 
sanityCheck
    ^self sanityCheck: 1!  ! 
#('August 4, 2003' '10:01:49 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('operations' sanityCheck )) !


!PriorityQueue methods !
sanityCheck
    true ifTrue: [^self].
    ^self sanityCheck: 1!   ! 
#('August 4, 2003' '04:08:28 PM' 536992)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('operations' sanityCheck )) !


!PriorityQueue methods ! 
sanityCheck
    true ifTrue: [^self].
    needToHeapify ifTrue: [self heapify].
    ^self sanityCheck: 1!    ! 
#('August 4, 2003' '04:37:32 PM' 537200)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('operations' sanityCheck )) !


!PriorityQueue methods ! 
heapify
    "Enforce the heap property (parent elements > children elements) in the entire tree."
    "This is the CLR implementation of 'build-heap'."
    
    (elements size / 2) floor to: 1 by: -1 do: [:index | self heapify: index].!    ! 
#('August 4, 2003' '09:26:50 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('operations' heapify )) !


!PriorityQueue methods !
heapify
    "Enforce the heap property (parent elements > children elements) in the entire tree."
    "This is the CLR implementation of 'build-heap'."
    
    (elements size / 2) floor to: 1 by: -1 do: [:index | self heapify: index].
    
    self sanityCheck!    ! 
#('August 4, 2003' '10:02:01 AM' 537724)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('operations' heapify )) !


!PriorityQueue methods ! 
heapify
    "Enforce the heap property (parent elements > children elements) in the entire tree."
    "This is the CLR implementation of 'build-heap'."
    
    (elements size / 2) floor to: 1 by: -1 do: [:index | self heapify: index].
    needToHeapify := false.
    self sanityCheck! ! 
#('August 4, 2003' '04:37:21 PM' 538132)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('operations' heapify )) !


!PriorityQueue methods ! 
leftChild: index
    "Return the index of the parent of the queue element specified by 'index'."
    ^2 * index!  ! 
#('August 4, 2003' '08:49:02 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('private' leftChild: )) !


!PriorityQueue methods !
leftChild: index
    "Return the index of the left child of the queue element specified by 'index'."
    ^2 * index!  ! 
#('August 4, 2003' '08:49:25 AM' 539032)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('private' leftChild: )) !


!PriorityQueue methods ! 
add: anObject
    "Add anObject to the queue."
    
    | index |
    elements addLast: nil.
    index := elements size.
    [index > 1 and: [self is: anObject higherPriorityThan: (elements at: (self parent: index))]] whileTrue: [
        elements at: index put: (elements at: (self parent: index)).
        index := self parent: index].
    elements at: index put: anObject!    ! 
#('August 4, 2003' '09:38:01 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('add/remove' add: )) !


!PriorityQueue methods !   
add: anObject
    "Add anObject to the queue."
    
    | index |
    elements addLast: nil.
    index := elements size.
    [index > 1 and: [self is: anObject higherPriorityThan: (elements at: (self parent: index))]] whileTrue: [
        elements at: index put: (elements at: (self parent: index)).
        index := self parent: index].
    elements at: index put: anObject.
    
    self sanityCheck.!  ! 
#('August 4, 2003' '10:02:20 AM' 539600)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('add/remove' add: )) !


!PriorityQueue methods !
add: anObject
    "Add anObject to the queue."
    
    | index |
    
    needToHeapify ifTrue: [self heapify].
    
    elements addLast: nil.
    index := elements size.
    [index > 1 and: [self is: anObject higherPriorityThan: (elements at: (self parent: index))]] whileTrue: [
        elements at: index put: (elements at: (self parent: index)).
        index := self parent: index].
    elements at: index put: anObject.
    
    self sanityCheck.!   ! 
#('August 4, 2003' '04:37:51 PM' 540152)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('add/remove' add: )) !


!PriorityQueue methods !
size
    ^elements size!   ! 
#('August 4, 2003' '09:19:38 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('operations' size )) !


!PriorityQueue methods !   
rightChild: index
    "Return the index of the right child of the queue element specified by 'index'."
    ^2 * index + 1!    ! 
#('August 4, 2003' '08:49:19 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('private' rightChild: )) !


!PriorityQueue methods !   
add: newObject after: oldObject
        "Add newObject after the element oldObject in the
         receiver.  This method reports an error since
         the sortBlock determines element order."
    ^self invalidMessage!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('invalid messages' add:after: )) !


!PriorityQueue methods !  
add: newObject after: oldObject
    ^self invalidMessage!  ! 
#('August 4, 2003' '09:19:27 AM' 541856)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('invalid messages' add:after: )) !


!PriorityQueue methods !
initialSize: anInteger
    elements := OrderedCollection new: anInteger!   ! 
#('August 4, 2003' '09:22:48 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('initializing' initialSize: )) !


!PriorityQueue methods ! 
initialSize: anInteger
    elements := OrderedCollection new: anInteger.
    needToHeapify := false.! ! 
#('August 4, 2003' '04:36:07 PM' 542496)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('initializing' initialSize: )) !


!PriorityQueue methods !  
first
    ^elements first! ! 
#('August 4, 2003' '09:46:30 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('operations' first )) !


!PriorityQueue methods !  
first
    needToHeapify ifTrue: [self heapify].
    ^elements first!  ! 
#('August 4, 2003' '04:37:11 PM' 543024)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('operations' first )) !


!PriorityQueue methods !   
at: index put: element
    ^self invalidMessage!   ! 
#('August 4, 2003' '09:18:10 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('invalid messages' at:put: )) !


!PriorityQueue methods !  
swapElements: element1 and: element2
    | temp |
    temp := elements at: element1.
    elements at: element1 put: (elements at: element2).
    elements at: element2 put: temp.!  ! 
#('August 4, 2003' '08:57:44 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('private' swapElements:and: )) !


!PriorityQueue methods ! 
elements
    ^elements!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('get/set' elements )) !


!PriorityQueue methods ! 
addAll: aCollection
    "We'll just add all the elements and then re-heapify."
    elements addAll: aCollection.
    self heapify.!  ! 
#('August 4, 2003' '09:15:56 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('add/remove' addAll: )) !


!PriorityQueue methods !
printOn: aStream
    
    aStream << 'a '; << self class name.
    elements isEmpty ifTrue: [aStream << ' with no elements'] ifFalse: [
        aStream << 'with '; << elements size; << ' elements (max = '; << elements first; << ')'].!  ! 
#('August 4, 2003' '09:31:11 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('printing' printOn: )) !


!PriorityQueue methods ! 
printOn: aStream
    
    aStream << 'a '; << self class name.
    elements isEmpty ifTrue: [aStream << ' with no elements'] ifFalse: [
        aStream << ' with '; << elements size; << ' elements (max = '; << elements first; << ')'].! ! 
#('August 4, 2003' '09:31:51 AM' 544528)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('printing' printOn: )) !


!PriorityQueue methods !  
printOn: aStream
    
    aStream << 'a '; << self class name.
    elements isEmpty ifTrue: [aStream << ' with no elements'] ifFalse: [
        aStream << ' with '; << elements size; << ' elements (max element = '; << elements first; << ')'].! ! 
#('August 4, 2003' '09:31:54 AM' 544932)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('printing' printOn: )) !


!PriorityQueue methods !  
add: newObject before: oldObject
        "Add newObject before the element oldObject in the
         receiver.  This method reports an error since
         the sortBlock determines element order."
    ^self invalidMessage!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('invalid messages' add:before: )) !


!PriorityQueue methods ! 
add: newObject before: oldObject
    ^self invalidMessage! ! 
#('August 4, 2003' '09:19:23 AM' 545756)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('invalid messages' add:before: )) !


!PriorityQueue methods !   
addAllFirst: aCollection
        "Add all the elements of aCollection to the
         receiver before its first element.  This
         method reports an error since the sortBlock
         determines element order."
    ^self invalidMessage!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('invalid messages' addAllFirst: )) !


!PriorityQueue methods !
addAllFirst: aCollection
    ^self invalidMessage! ! 
#('August 4, 2003' '09:19:19 AM' 546400)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('invalid messages' addAllFirst: )) !


!PriorityQueue methods !  
is: element1 higherPriorityThan: element2
    ^compareBlock value: element1 value: element2!   ! 
#('August 4, 2003' '08:56:53 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('private' is:higherPriorityThan: )) !


!PriorityQueue methods !
is: element1 higherPriorityThan: element2
    ^compareBlock value: (elements at: element1) value: (elements at: element2)! ! 
#('August 4, 2003' '09:07:19 AM' 547056)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('private' is:higherPriorityThan: )) !


!PriorityQueue methods ! 
is: object1 higherPriorityThan: object2
    ^compareBlock value: object1 value: object2!   ! 
#('August 4, 2003' '09:12:02 AM' 547328)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('private' is:higherPriorityThan: )) !


!PriorityQueue methods ! 
addAllLast: aCollection
        "Add all the elements of aCollection to the
         receiver after its last element.  This
         method reports an error since the sortBlock
         determines element order."
    ^self invalidMessage! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('invalid messages' addAllLast: )) !


!PriorityQueue methods ! 
addAllLast: aCollection
    ^self invalidMessage!  ! 
#('August 4, 2003' '09:19:14 AM' 547904)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('invalid messages' addAllLast: )) !


!PriorityQueue methods !   
elements: aCollection
    elements := aCollection! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('get/set' elements: )) !


!PriorityQueue methods !
parent: index
    "Return the index of the parent of the queue element specified by 'index'."
    ^index asInteger  / 2!  ! 
#('August 4, 2003' '08:48:45 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('private' parent: )) !


!PriorityQueue methods !   
parent: index
    "Return the index of the parent of the queue element specified by 'index'."
    ^(index asInteger  / 2) floor!  ! 
#('August 4, 2003' '09:24:45 AM' 548772)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('private' parent: )) !


!PriorityQueue methods !
removeFirst
    | first |
    first := elements first.
    elements at: 1 put: elements last.
    elements removeLast.
    self heapify: 1.
    ^first!   ! 
#('August 4, 2003' '09:56:59 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('add/remove' removeFirst )) !


!PriorityQueue methods !
removeFirst
    | first |
    first := elements first.
    elements at: 1 put: elements last.
    elements removeLast.
    self heapify: 1.
    self sanityCheck.
    ^first!    ! 
#('August 4, 2003' '10:02:12 AM' 549356)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('add/remove' removeFirst )) !


!PriorityQueue methods ! 
removeFirst
    | first |
    needToHeapify ifTrue: [self heapify].
    first := elements first.
    elements at: 1 put: elements last.
    elements removeLast.
    self heapify: 1.
    self sanityCheck.
    ^first! ! 
#('August 4, 2003' '04:38:05 PM' 549684)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('add/remove' removeFirst )) !


!PriorityQueue methods ! 
compareBlock: aTwoArgumentBlock
    compareBlock := aTwoArgumentBlock! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('get/set' compareBlock: )) !


!PriorityQueue methods !
compareBlock: aTwoArgumentBlock
    "'compareBlock' should return true when element1 is higher priority than element2."
    compareBlock := aTwoArgumentBlock!    ! 
#('August 4, 2003' '09:03:23 AM' 550436)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('get/set' compareBlock: )) !


!PriorityQueue methods !  
compareBlock: aTwoArgumentBlock
    "'compareBlock' should return true when element1 is higher priority than element2."
    compareBlock := aTwoArgumentBlock.
    needToHeapify := true.!   ! 
#('August 4, 2003' '04:38:51 PM' 550676)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('get/set' compareBlock: )) !


!PriorityQueue methods !  
value: object1 value: object2
    ^object1 >= object2! ! 
#('August 4, 2003' '09:06:53 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('private' value:value: )) !


!PriorityQueue methods !  
value: object1 value: object2
    ^object1 > object2!  ! 
#('August 4, 2003' '09:07:00 AM' 551376)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('private' value:value: )) !


!PriorityQueue methods !   
minQueue
    self compareBlock: [:object1 :object2 | object1 < object2].!  ! 
#('August 4, 2003' '09:08:06 AM' nil)!

(CodeFiler organizerFor: PriorityQueue) reorganizeFrom: #(
('private' minQueue )) !


!PriorityQueue class methods !
on: aCollection compareBlock: compareBlock
    "Build a priority queue out of 'aCollection' of objects."
    | pq |
    pq := PriorityQueue new elements: aCollection; compareBlock: compareBlock.
    pq heapify.
    ^pq!    ! 
#('August 4, 2003' '09:00:58 AM' nil)!

(CodeFiler organizerFor: PriorityQueue class) reorganizeFrom: #(
('instance creation' on:compareBlock: )) !


!PriorityQueue class methods !
new: anInteger
    ^(super new: anInteger) maxQueue!   ! 
#('August 4, 2003' '09:05:10 AM' nil)!

(CodeFiler organizerFor: PriorityQueue class) reorganizeFrom: #(
('instance creation' new: )) !


!PriorityQueue class methods !
new: anInteger
    ^(self basicNew) initialSize: anInteger; maxQueue!  ! 
#('August 4, 2003' '09:23:22 AM' 552492)!

(CodeFiler organizerFor: PriorityQueue class) reorganizeFrom: #(
('instance creation' new: )) !


!PriorityQueue class methods ! 
new: anInteger
    ^self basicNew initialSize: anInteger; maxQueue!    ! 
#('August 4, 2003' '09:23:34 AM' 552728)!

(CodeFiler organizerFor: PriorityQueue class) reorganizeFrom: #(
('instance creation' new: )) !


!PriorityQueue class methods ! 
new
    ^self new: 12! ! 
#('August 4, 2003' '09:24:09 AM' nil)!

(CodeFiler organizerFor: PriorityQueue class) reorganizeFrom: #(
('instance creation' new )) !


!PriorityQueue class methods ! 
example1
    "
    self example1
    "
    | pq |
    self halt.
    pq := PriorityQueue new.
    pq add: 2; add: 3; add: 4; add: 1.
    pq addAll: #(5 6 7 3 2 1 76).
    pq removeFirst.!    ! 
#('August 4, 2003' '09:27:03 AM' nil)!

(CodeFiler organizerFor: PriorityQueue class) reorganizeFrom: #(
('examples' example1 )) !


!PriorityQueue class methods ! 
example1
    "
    self example1
    "
    | pq |
    self halt.
    pq := PriorityQueue new.
    pq add: 2; add: 3; add: 4; add: 1.
    pq addAll: #(5 6 7 3 2 1 76).
    pq removeIdentical: 76.
    pq removeFirst.!   ! 
#('August 4, 2003' '09:55:31 AM' 553444)!

(CodeFiler organizerFor: PriorityQueue class) reorganizeFrom: #(
('examples' example1 )) !


!PriorityQueue class methods !  
example1
    "
    self example1
    "
    | pq |
    self halt.
    pq := PriorityQueue new.
    pq add: 2; add: 3; add: 4; add: 1.
    pq addAll: #(5 6 7 3 2 1 76).
    Transcript cr; << 'pq size is '; << pq size.
    pq removeIdentical: 76.
    Transcript cr; << 'pq size is '; << pq size.
    pq removeFirst.
    Transcript cr; << 'pq size is '; << pq size.! ! 
#('August 4, 2003' '09:56:35 AM' 553820)!

(CodeFiler organizerFor: PriorityQueue class) reorganizeFrom: #(
('examples' example1 )) !




OrderedCollection subclass: #Process
  instanceVariableNames: 
    ' topFrame frameBias priority sendFrame runable isUserIF debugger name interruptFrame exceptionEnvironment terminationBlock protectionBlock '
  classVariableNames: 
    ' DropStack '
  poolDictionaries: 
    ' StackOffsets '
  categories: #( 'Kernel-Processes and Events' )
  comment: ''!

 

Object subclass: #ProcessScheduler
  instanceVariableNames: 
    ' readyProcesses bytesCollected bytesFlipped oldSpacePages newSpacePages newSpaceLimit gcOperation traceMode bytesTenured unboundComponents oldSpaceThreshold inTrouble inPanic '
  classVariableNames: 
    ' Finalizer OldSpaceThresholdIncrement '
  poolDictionaries: ''
  categories: #( 'Kernel-Processes and Events' )
  comment: ''!



Association subclass: #PropertyAccessor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PropertyAccessor subclass: #ObjectPropertyAccessor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



ObjectPropertyAccessor subclass: #GroupPropertyAccessor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

ApplicationCoordinator subclass: #PropertyInterface
  instanceVariableNames: 
    ' object propertyHandler propertyNames initEvents setMessages oldValues newValues initiator '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

Dictionary subclass: #PropertyManager
  instanceVariableNames: 
    ' metaProperties '
  classVariableNames: 
    ' CachedHandlers '
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

Object subclass: #PropertyPage
  instanceVariableNames: 
    ' label image description items '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   
ProtectedFrameMarker class instanceVariableNames: ''
  categories: #( )
  comment: ''!

  

Object subclass: #RandomNumberStream
  instanceVariableNames: 
    ' idum iy ir iff iset gset '
  classVariableNames: 
    ' DefaultInstance IA IC M '
  poolDictionaries: ''
  categories: #( 'Base-Magnitudes' )
  comment: ''!

!RandomNumberStream methods !   
nextUniform: idumValue
    "Answer the next number in the receiver's sequence with the given idumValue."

    | oldIdum result |
    oldIdum := idum.
    idum := idumValue.
    result := self nextUniform.
    idum := oldIdum.
    ^result!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: RandomNumberStream) reorganizeFrom: #(
('sequencing' nextUniform: )) !


!RandomNumberStream methods !
nextUniform
    "Answer the next uniform pseudo-random number in the receiver's sequence."

    | j |
    (idum < 0 or: [iff = 0]) ifTrue: [
        iff := 1.
        idum := IC - idum.
        (idum \\ M) < 0 ifTrue: [idum := idum negated].
        1 to: 98 do: [:index |
            idum := (IA * idum + IC) \\ M.
            ir at: index put: idum].
        idum := (IA * idum + IC) \\ M.
        iy := idum].

    j := (1 + (96.0 * iy / M)) asInteger.
    iy := ir at: j + 1.
    idum := (IA * idum + IC) \\ M.
    ir at: j + 1 put: idum.
    ^iy / M * 1.0! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: RandomNumberStream) reorganizeFrom: #(
('sequencing' nextUniform )) !


!RandomNumberStream methods ! 
initialize

    ir := Array new: 98.
    iff := 0.
    iset := 0.!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: RandomNumberStream) reorganizeFrom: #(
('initializing' initialize )) !


!RandomNumberStream methods !
nextFrom: start to: end

    ^self next * (end - start) + start!  ! 
#('November 18, 2010' '01:25:38 PM' nil)!

(CodeFiler organizerFor: RandomNumberStream) reorganizeFrom: #(
('extension from class' nextFrom:to: )) !


!RandomNumberStream methods !
nextIntegerFrom: start to: end
    "Answer the next integer in the range [start, end]."

    ^(self nextFrom: start truncated to: end truncated + 0.999999) truncated!   ! 
#('November 18, 2010' '02:26:43 PM' nil)!

(CodeFiler organizerFor: RandomNumberStream) reorganizeFrom: #(
('extension from class' nextIntegerFrom:to: )) !


!RandomNumberStream methods ! 
next
    ^self nextUniform!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: RandomNumberStream) reorganizeFrom: #(
('sequencing' next )) !


!RandomNumberStream methods !
nextGaussian
    "Answer a pseudo-random number with a normal (Gaussian) distribution."

    | fac r v1 v2 |
    iset = 0 ifTrue: [
        [
            v1 := 2.0 * self nextUniform - 1.0.
            v2 := 2.0 * self nextUniform - 1.0.
            r := v1 squared + v2 squared.
            r >= 1.0 or: [r = 0.0]] whileTrue.
        fac := (-2.0 * r ln / r) sqrt.
        gset := v1 * fac.
        iset := 1.
        ^v2 * fac].
    iset := 0.
    ^gset! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: RandomNumberStream) reorganizeFrom: #(
('sequencing' nextGaussian )) !


!RandomNumberStream methods !
idum: anInteger
    idum := anInteger! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: RandomNumberStream) reorganizeFrom: #(
('initializing' idum: )) !


!RandomNumberStream class methods !   
nextUniform

    ^self defaultInstance nextUniform!   ! 
#('August 23, 2001' '02:13:27 PM' nil)!

(CodeFiler organizerFor: RandomNumberStream class) reorganizeFrom: #(
('random numbers' nextUniform )) !


!RandomNumberStream class methods ! 
initialize
    "(RandomNumberStream initialize)"

    M := 714025.
    IA := 1366.
    IC := 150889.!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: RandomNumberStream class) reorganizeFrom: #(
('initializing' initialize )) !


!RandomNumberStream class methods !
new
    "Answer a new instance of the receiver with a somewhat arbitrarily chosen seed value."

    ^self new: Time millisecondClockValue!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: RandomNumberStream class) reorganizeFrom: #(
('instance creation' new )) !


!RandomNumberStream class methods !  
randomDouble: double percent: percent 
    "Randomly perturb 'double' by percent * | 'double' | ."
    | value positiveValue valueDelta |
    value := double asFloat. positiveValue := value abs * percent * 0.01.
    valueDelta := self nextFrom: positiveValue negated to: positiveValue.
    ^value + valueDelta! ! 
#('March 5, 2005' '10:54:38 AM' nil)!

(CodeFiler organizerFor: RandomNumberStream class) reorganizeFrom: #(
('random numbers' randomDouble:percent: )) !


!RandomNumberStream class methods ! 
nextFrom: start to: end

    ^self next * (end - start) + start!  ! 
#('March 5, 2002' '02:58:12 PM' nil)!

(CodeFiler organizerFor: RandomNumberStream class) reorganizeFrom: #(
('random numbers' nextFrom:to: )) !


!RandomNumberStream class methods !  
new: seedValue
    "seedValue can be any integer value."

    RandomNumberStream initialize.
    ^super new initialize; idum: seedValue negated; yourself!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: RandomNumberStream class) reorganizeFrom: #(
('instance creation' new: )) !


!RandomNumberStream class methods ! 
comment
    "This is a uniform random number generator which answers floats in the range [0.0..1.0].
    It is taken from:
        Numerical Recipes in C (Press, Flannery, Teukolski, Vetterling) pp. 211-212.

    #nextUniform and #nextUniform: are derived from ran2 () on pg. 212.
    #nextGaussian is derived from gasdev () on pg. 217."!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: RandomNumberStream class) reorganizeFrom: #(
('comment' comment )) !


!RandomNumberStream class methods !
randomBoolean

    ^(self nextIntegerFrom: 0 to: 1) = 1!  ! 
#('March 13, 2001' '11:29:49 AM' nil)!

(CodeFiler organizerFor: RandomNumberStream class) reorganizeFrom: #(
('random numbers' randomBoolean )) !


!RandomNumberStream class methods !
nextIntegerFrom: start to: end
    "Answer the next integer in the range [start, end]."

    ^(self nextFrom: start truncated to: end truncated + 0.999999) truncated!   ! 
#('March 6, 2002' '10:56:32 AM' nil)!

(CodeFiler organizerFor: RandomNumberStream class) reorganizeFrom: #(
('random numbers' nextIntegerFrom:to: )) !


!RandomNumberStream class methods !   
next

    ^self nextUniform!  ! 
#('August 23, 2001' '02:13:33 PM' nil)!

(CodeFiler organizerFor: RandomNumberStream class) reorganizeFrom: #(
('random numbers' next )) !


!RandomNumberStream class methods !
nextGaussian

    ^self defaultInstance nextGaussian! ! 
#('August 23, 2001' '02:13:48 PM' nil)!

(CodeFiler organizerFor: RandomNumberStream class) reorganizeFrom: #(
('random numbers' nextGaussian )) !


!RandomNumberStream class methods !
defaultInstance
    "(DefaultInstance := nil)"

    DefaultInstance isNil ifTrue: [DefaultInstance := RandomNumberStream new].
    ^DefaultInstance!    ! 
#('August 23, 2001' '02:14:06 PM' nil)!

(CodeFiler organizerFor: RandomNumberStream class) reorganizeFrom: #(
('random numbers' defaultInstance )) !




Notification subclass: #RecompilationNotification
  instanceVariableNames: 
    ' compiledMethod '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Exception Handling' )
  comment: ''!

  

Object subclass: #Rectangle
  instanceVariableNames: 
    ' leftTop rightBottom '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'Base-Magnitudes' )
  comment: ''!

!Rectangle methods !   
withinExactDistance: distance ofRectangle: aRectangle
    self right < aRectangle left ifTrue: [
        self bottom < aRectangle top ifTrue: [^(self bottomRight distanceTo: aRectangle topLeft) <= distance].
        self top > aRectangle bottom ifTrue: [^(self topRight distanceTo: aRectangle bottomLeft) <= distance].
        ^(aRectangle left - self right) <= distance].
    self left > aRectangle right ifTrue: [
        self bottom < aRectangle top ifTrue: [^(self bottomLeft distanceTo: aRectangle topRight) <= distance].
        self top > aRectangle bottom ifTrue: [^(self topLeft distanceTo: aRectangle bottomRight) <= distance].
        ^(self left - aRectangle right) <= distance].
        
    self bottom < aRectangle top ifTrue: [^(aRectangle top - self bottom) <= distance].
    self top > aRectangle bottom ifTrue: [^(self top - aRectangle bottom) <= distance].
    ^true "overlapping"!   ! 
#('September 11, 2009' '02:21:07 PM' nil)!

(CodeFiler organizerFor: Rectangle) reorganizeFrom: #(
('extensions' withinExactDistance:ofRectangle: )) !


!Rectangle methods !   
mergeAll: rectangles

    ^rectangles inject: self into: [:coverRectangle :rectangle | coverRectangle merge: rectangle]!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Rectangle) reorganizeFrom: #(
('extensions' mergeAll: )) !


!Rectangle methods ! 
intersectsOrTouches: aRectangle

    ^(self expandBy: 1@1) intersects: (aRectangle expandBy: 1@1)!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Rectangle) reorganizeFrom: #(
('extensions' intersectsOrTouches: )) !


!Rectangle class methods !
topLeft: topLeftPoint extent: extentPoint
    ^self leftTop: topLeftPoint extent: extentPoint! ! 
#('September 11, 2009' '02:46:14 PM' nil)!

(CodeFiler organizerFor: Rectangle class) reorganizeFrom: #(
('extensions' topLeft:extent: )) !


!Rectangle class methods !
topLeft: topLeftPoint bottomRight: bottomRightPoint
    ^self new topLeft: topLeftPoint; bottomRight: bottomRightPoint!    ! 
#('September 11, 2009' '02:25:55 PM' nil)!

(CodeFiler organizerFor: Rectangle class) reorganizeFrom: #(
('extensions' topLeft:bottomRight: )) !


!Rectangle class methods !   
enclosingAll: points

    | origin corner |
    origin := points first shallowCopy. corner := points first shallowCopy.
    points do: [:point | origin := origin min: point. corner := corner max: point].
    ^Rectangle origin: origin corner: corner + (1@1@0)!    ! 
#('September 26, 2001' '09:53:51 AM' nil)!

(CodeFiler organizerFor: Rectangle class) reorganizeFrom: #(
('extensions' enclosingAll: )) !




Object subclass: #ResidueObject
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Special Objects' )
  comment: ''!

 

Color subclass: #RGBColor
  instanceVariableNames: 
    ' red green blue '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Base-Graphics' )
  comment: ''!

  
RichEdit32DLL class instanceVariableNames: ''
  categories: #( )
  comment: ''!

 

DialogCoordinator subclass: #RichEditParagraphFormatDialog
  instanceVariableNames: 
    ' result '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

RichEditParagraphFormatDialog subclass: #RichEditTabStopDialog
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



CodeWriter subclass: #RTFClassWriter
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Code Writers & Readers' )
  comment: ''!

!RTFClassWriter methods ! 
fileOutOn: stream
    "   stream  <WriteStream>
        ^       self
    Put a textual version of my class to stream."

    CursorManager execute changeFor: [
        self fileOutPrologueOn: stream.
        self classes do: [:aClass |
             self
                forClass: aClass;
                fileOutDefinitionOn: stream;
                forSuperclassOfClass: aClass;
                fileOutProtocolsOn: stream;
                forClass: aClass;
                fileOutProtocolsOn: stream].
        self fileOutEpilogueOn: stream]!    ! 
#('March 9, 2003' '09:38:49 AM' nil)!

(CodeFiler organizerFor: RTFClassWriter) reorganizeFrom: #(
('filing out' fileOutOn: )) !


 

DynamicLinkLibrary variableByteSubclass: #ScintillaDLL
  classVariableNames: ''
  poolDictionaries: 
    ' ScintillaConstants '
  categories: #( 'Tools-Scintilla Pane' )
  comment: ''!

!ScintillaDLL methods !
bufferAt: index

    <c: GetBufferCharacter long long>
    ^self invalidArgument!    ! 
#('April 17, 2002' '01:59:59 PM' nil)!

(CodeFiler organizerFor: ScintillaDLL) reorganizeFrom: #(
('buffer access' bufferAt: )) !


!ScintillaDLL methods ! 
longFromTwoShorts: a and: b

    ^a bitOr: (b bitShift: 16)!  ! 
#('April 15, 2002' '01:08:20 PM' nil)!

(CodeFiler organizerFor: ScintillaDLL) reorganizeFrom: #(
('type conversion' longFromTwoShorts:and: )) !


!ScintillaDLL methods !  
bufferAt: index put: character

    <c: SetBufferCharacter long long none>
    ^self invalidArgument!    ! 
#('April 17, 2002' '02:00:05 PM' nil)!

(CodeFiler organizerFor: ScintillaDLL) reorganizeFrom: #(
('buffer access' bufferAt:put: )) !


!ScintillaDLL methods ! 
privateSendToHandle: windowHandle message: message argument: argument

    <c: SendMessageWithBuffer long long long long>
    ^self invalidArgument! ! 
#('April 15, 2002' '01:17:50 PM' nil)!

(CodeFiler organizerFor: ScintillaDLL) reorganizeFrom: #(
('sending messages' privateSendToHandle:message:argument: )) !


!ScintillaDLL methods !  
send: message to: aPane with: long1 with: long2

    ^UserLibrary sendMessage: aPane handle msg: message wparam: long1 lparam: long2! ! 
#('April 19, 2002' '11:17:18 AM' nil)!

(CodeFiler organizerFor: ScintillaDLL) reorganizeFrom: #(
('sending messages' send:to:with:with: )) !


!ScintillaDLL methods ! 
buffer

    | index string next |
    index := 0.
    string := WriteStream on: String new.
    [next := self bufferAt: index. next ~= 0] whileTrue: [index := index + 1. string nextPut: (Character value: next)].
    ^string contents! ! 
#('April 17, 2002' '02:00:14 PM' nil)!

(CodeFiler organizerFor: ScintillaDLL) reorganizeFrom: #(
('buffer access' buffer )) !


!ScintillaDLL methods !
send: message to: aPane buffer: aString

    self buffer: aString.
    ^self privateSendToHandle: aPane handle message: message argument: 0! ! 
#('April 19, 2002' '11:16:21 AM' nil)!

(CodeFiler organizerFor: ScintillaDLL) reorganizeFrom: #(
('sending messages' send:to:buffer: )) !


!ScintillaDLL methods !
privateSendToHandle: windowHandle message: message

    ^self privateSendToHandle: windowHandle message: message argument: 0! ! 
#('April 15, 2002' '01:18:12 PM' nil)!

(CodeFiler organizerFor: ScintillaDLL) reorganizeFrom: #(
('sending messages' privateSendToHandle:message: )) !


!ScintillaDLL methods !   
buffer: aString

    1 to: (aString size min: self maxBufferSize) do: [:index | self bufferAt: index - 1 put: (aString at: index) asciiValue].
    self bufferAt:  (aString size min: self maxBufferSize) put: 0.!   ! 
#('April 17, 2002' '02:00:31 PM' nil)!

(CodeFiler organizerFor: ScintillaDLL) reorganizeFrom: #(
('buffer access' buffer: )) !


!ScintillaDLL methods !   
send: message to: aPane 

    ^UserLibrary sendMessage: aPane handle msg: message wparam: 0 lparam: 0!    ! 
#('April 19, 2002' '11:17:00 AM' nil)!

(CodeFiler organizerFor: ScintillaDLL) reorganizeFrom: #(
('sending messages' send:to: )) !


!ScintillaDLL methods !   
maxBufferSize
    "const unsigned long BufferSize = 102400;"

    ^102400!   ! 
#('April 16, 2002' '01:35:39 PM' nil)!

(CodeFiler organizerFor: ScintillaDLL) reorganizeFrom: #(
('buffer access' maxBufferSize )) !


!ScintillaDLL methods ! 
colorAsLongRed: red green: green blue: blue

    ^(red bitOr: (green bitShift: 8)) bitOr: (blue bitShift: 16)!    ! 
#('April 16, 2002' '03:05:58 PM' nil)!

(CodeFiler organizerFor: ScintillaDLL) reorganizeFrom: #(
('type conversion' colorAsLongRed:green:blue: )) !


!ScintillaDLL methods !  
lowShortFromLong: a

    ^a bitAnd: 16r0FFFF! ! 
#('April 15, 2002' '01:34:12 PM' nil)!

(CodeFiler organizerFor: ScintillaDLL) reorganizeFrom: #(
('type conversion' lowShortFromLong: )) !


!ScintillaDLL methods !   
getClientRect: window rect: winRect

    <c: GetClientRect long struct none>
    ^self invalidArgument!  ! 
#('April 15, 2002' '04:23:59 PM' nil)!

(CodeFiler organizerFor: ScintillaDLL) reorganizeFrom: #(
('sending messages' getClientRect:rect: )) !


!ScintillaDLL methods !
highShortFromLong: a

    ^a bitShift: -16!   ! 
#('April 15, 2002' '01:08:47 PM' nil)!

(CodeFiler organizerFor: ScintillaDLL) reorganizeFrom: #(
('type conversion' highShortFromLong: )) !


!ScintillaDLL methods !  
send: message to: aPane buffer: aString with: aLong

    self buffer: aString.
    ^self privateSendToHandle: aPane handle message: message argument: aLong! ! 
#('April 19, 2002' '11:16:13 AM' nil)!

(CodeFiler organizerFor: ScintillaDLL) reorganizeFrom: #(
('sending messages' send:to:buffer:with: )) !


!ScintillaDLL methods !   
send: message to: aPane with: long1

    ^UserLibrary sendMessage: aPane handle msg: message wparam: long1 lparam: 0! ! 
#('April 19, 2002' '11:17:10 AM' nil)!

(CodeFiler organizerFor: ScintillaDLL) reorganizeFrom: #(
('sending messages' send:to:with: )) !


!ScintillaDLL class methods !
fileName
    ^'scilexer.dll'!  ! 
#('April 12, 2002' '01:24:30 PM' nil)!

(CodeFiler organizerFor: ScintillaDLL class) reorganizeFrom: #(
('private' fileName )) !


 

ExpressionEvaluator subclass: #ScintillaExpressionEvaluator
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Messages' 'Tools-Scintilla Pane' )
  comment: ''!

!ScintillaExpressionEvaluator methods !  
compilerError: aString at: anInteger in: codeString for: aClass
        "Private - Display the error message aString
         in reversed form at the indicated
         position anInteger in the source
         codeString."
    
    | validIndex |
    validIndex := anInteger min: pane length.
    pane isReadOnly ifTrue: [ ^MessageBox notify: 'Compilation Error' withText: aString ].

    pane evaluating
        ifTrue: [
            self
                doItcompilerError: aString
                at: validIndex
                in: codeString
                for: aClass ]
        ifFalse: [
            self
                saveCompilerError: aString
                at: validIndex
                in: codeString
                for: aClass ]!   ! 
#('May 24, 2002' '11:10:31 AM' nil)!

(CodeFiler organizerFor: ScintillaExpressionEvaluator) reorganizeFrom: #(
('no category methods' compilerError:at:in:for: )) !


!ScintillaExpressionEvaluator methods !  
doItcompilerError: aString at: anInteger in: codeString for: aClass
        "Private - Display the error message aString
         as the selected text at the indicated position
         anInteger in the source codeString."

    self pane 
        insertAndSelectText: aString at: self pane cursorPosition;
        forceSelectionOntoDisplay! ! 
#('May 3, 2002' '03:51:25 PM' nil)!

(CodeFiler organizerFor: ScintillaExpressionEvaluator) reorganizeFrom: #(
('no category methods' doItcompilerError:at:in:for: )) !


!ScintillaExpressionEvaluator methods !   
saveCompilerError: aString at: anInteger in: codeString for: aClass
        "Private - Display the error message aString
         in reversed form at the indicated
         position anInteger in the source
         codeString."

    self pane
        cursorPosition: anInteger;
        insertAndSelectText: aString at: anInteger;
        forceSelectionOntoDisplay;
        sendInputEvent: #setFocus!   ! 
#('May 3, 2002' '03:50:53 PM' nil)!

(CodeFiler organizerFor: ScintillaExpressionEvaluator) reorganizeFrom: #(
('no category methods' saveCompilerError:at:in:for: )) !


  

ExternalBuffer subclass: #ScNotification
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Scintilla Pane' )
  comment: ''!

!ScNotification methods ! 
code
    ^self longAtOffset: 8!    ! 
#('April 12, 2002' '02:50:13 PM' nil)!

(CodeFiler organizerFor: ScNotification) reorganizeFrom: #(
('no category methods' code )) !


!ScNotification methods !
ch
    ^Character value: (self byteAtOffset: 16)!  ! 
#('April 12, 2002' '02:56:37 PM' nil)!

(CodeFiler organizerFor: ScNotification) reorganizeFrom: #(
('no category methods' ch )) !


   

GraphicsMedium subclass: #Screen
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' GraphicsConstants OperatingSystemConstants '
  categories: #( 'Base-Graphics' )
  comment: ''!

   

PropertyAccessor subclass: #SelectorPropertyAccessor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

SelectorPropertyAccessor subclass: #LinkPropertyAccessor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

ExternalBuffer subclass: #SelfDefinedStructure
  instanceVariableNames: 
    ' definition '
  classVariableNames: 
    ' AtPutSelectors AtSelectors Definitions MethodDictionaries '
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!



Object subclass: #Service
  instanceVariableNames: 
    ' referenceCount eventHandlers name description category requiredServices includeFiles libraryNames libraryPath documentationFiles documentationPath preInstallExpression postInstallExpression preUninstallExpression postUninstallExpression modified mapCategory '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Services-Service Manager' )
  comment: ''!



Object subclass: #ServiceManager
  instanceVariableNames: 
    ' installedServiceRegistry knownServices currentActionCollection serviceInfoCache eventHandlers masterService masterFileName iniFileInterface '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Services-Service Manager' )
  comment: ''!

   
ServiceManagerWindow class instanceVariableNames: ''
  categories: #( )
  comment: ''!

  
ServiceRegistry class instanceVariableNames: ''
  categories: #( )
  comment: ''!

   

EventManager subclass: #SessionModel
  instanceVariableNames: 
    ' imageName bindProgress exeName runningApplications commandLine gui guiLoaded '
  classVariableNames: 
    ' CurrentSession ErrorLogFileName Headless '
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants '
  categories: #( 'Kernel-Special Objects' 'Tools-Browsers' )
  comment: ''!

!SessionModel methods ! 
startupDevelopment
        "Private - start up the development system."
    self bindDevelopment.
    self openSourceFiles.
    self fileInGoFile.
    (Smalltalk includesKey: #SmalltalkEmulator)
        ifTrue: [(Smalltalk at: #SmalltalkEmulator) startUp].

    (Sources at: 2) setToEnd; nextChunkPut: '"*** Image started on: ', Date today printString, ' ', Time now printString, ' ***"'; flush.

    OpenGLCanvasDLL startUp.
    Headless notNil ifTrue: [
        [Compiler evaluate: Headless] ensure: [Smalltalk exit]].!   ! 
#('January 12, 2007' '04:57:25 PM' nil)!

(CodeFiler organizerFor: SessionModel) reorganizeFrom: #(
('extensions' startupDevelopment )) !


!SessionModel methods ! 
startupDevelopment
        "Private - start up the development system."
    self bindDevelopment.
    self openSourceFiles.
    self fileInGoFile.
    (Smalltalk includesKey: #SmalltalkEmulator)
        ifTrue: [(Smalltalk at: #SmalltalkEmulator) startUp].

    (Sources at: 2) setToEnd; nextChunkPut: '"*** Image started on: ', Date today printString, ' ', Time now printString, ' ***"'; flush.

    OpenGLCanvasDLL startUp. LayoutSectionWithFileStreams startUp.
    Headless notNil ifTrue: [
        [Compiler evaluate: Headless] ensure: [Smalltalk exit]].! ! 
#('August 20, 2009' '01:32:07 PM' 580148)!

(CodeFiler organizerFor: SessionModel) reorganizeFrom: #(
('extensions' startupDevelopment )) !


!SessionModel methods !   
startupDevelopment
        "Private - start up the development system."
    self bindDevelopment.
    self openSourceFiles.
    self fileInGoFile.
    (Smalltalk includesKey: #SmalltalkEmulator)
        ifTrue: [(Smalltalk at: #SmalltalkEmulator) startUp].

    (Sources at: 2) setToEnd; nextChunkPut: '"*** Image started on: ', Date today printString, ' ', Time now printString, ' ***"'; flush.

    "OpenGLCanvasDLL startUp. LayoutSectionWithFileStreams startUp."
    Headless notNil ifTrue: [
        [Compiler evaluate: Headless] ensure: [Smalltalk exit]].!   ! 
#('December 27, 2016' '02:26:39 PM' 580860)!

(CodeFiler organizerFor: SessionModel) reorganizeFrom: #(
('extensions' startupDevelopment )) !


!SessionModel methods ! 
initializeImageName
        "Private - Initialize commandLine, exeName, and imageName variables.
        The commandLine variable is an array of substrings which contain the
        command line arguments (including the exe name).  The exeName variable
        is the name of the exe that started this session.  The imageName is the name
        of the image (which defaults to V.EXE if not specified) following the exeName,
        or the name of the runtime EXE."
    | name cmdLineString token file |
    cmdLineString := self getCommandLineString.
    ( cmdLineString includes: $" )
        ifTrue: [
            token := cmdLineString asArrayOfSubstringsSeparatedBy: $".
            self commandLine: ( token asOrderedCollection reject: [ :subStr | subStr = '' or: [ subStr = ' ' ] ] ) asArray ]
        ifFalse: [ self commandLine: cmdLineString asArrayOfSubstrings ].
    self exeName: self commandLine first fileNameLessPath fileName.

    (self commandLine size > 1 and: [self commandLine first = 'vdevw -headless ']) ifTrue:[
        Headless := self commandLine second rest.
        self commandLine: #('vdevw').
        Notifier initialize].

    name := String new: 255.
    VirtualMachineLibrary getImageName: name.
    self imageName: name trimBlanks!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SessionModel) reorganizeFrom: #(
('no category methods' initializeImageName )) !


!SessionModel methods !
startUpApplication: oldWindows
        "Private - start up the application, using the saved list of oldWindows
        to restore the system state if necessary (in development)."
    self isRunTime
        ifTrue: [ self startUpApplication ]
        ifFalse: [ self resumeDevelopment: oldWindows ]! ! 
#('February 9, 2004' '10:03:57 AM' nil)!

(CodeFiler organizerFor: SessionModel) reorganizeFrom: #(
('no category methods' startUpApplication: )) !


!SessionModel methods !   
startUpApplication: oldWindows
        "Private - start up the application, using the saved list of oldWindows
        to restore the system state if necessary (in development)."
    "self isRunTime
        ifTrue: [ self startUpApplication ]
        ifFalse: [ self resumeDevelopment: oldWindows ]"

    WorldViewer new open.!  ! 
#('February 9, 2004' '10:03:57 AM' 583844)!

(CodeFiler organizerFor: SessionModel) reorganizeFrom: #(
('no category methods' startUpApplication: )) !


!SessionModel methods !
startUpApplication: oldWindows
        "Private - start up the application, using the saved list of oldWindows
        to restore the system state if necessary (in development)."
    self isRunTime
        ifTrue: [ self startUpApplication ]
        ifFalse: [ self resumeDevelopment: oldWindows ]! ! 
#('February 9, 2004' '12:09:41 PM' 584336)!

(CodeFiler organizerFor: SessionModel) reorganizeFrom: #(
('no category methods' startUpApplication: )) !


!SessionModel class methods !  
diskSpaceRequiredToSaveImage: imageName backup: backupBoolean
        "Private - answer the number of bytes required to save the image
        to the specified image file name, and to backup the current image
        if backupBoolean is true."
    | imageSize bytesRequired backupFileName |
    imageSize := ( File fromPath: self current imageName ) size.
    bytesRequired := Processor oldSpacePages * 4096.  "estimated size of the new image file"
    Smalltalk platformIsWin32
        ifTrue: [ bytesRequired := bytesRequired * 2 ].  "estimated size of temp coff files"
    backupBoolean ifTrue: [
        backupFileName := ( imageName upTo: $. ), '.bak'.
        bytesRequired := bytesRequired + imageSize.  "backup size = current image size"
        ( File exists: backupFileName )
        ifTrue: [ bytesRequired := bytesRequired - ( File fromPath: backupFileName ) size ] ].
    ^bytesRequired!  ! 
#('June 25, 2010' '03:15:07 PM' nil)!

(CodeFiler organizerFor: SessionModel class) reorganizeFrom: #(
('no category methods' diskSpaceRequiredToSaveImage:backup: )) !


!SessionModel class methods ! 
diskSpaceRequiredToSaveImage: imageName backup: backupBoolean
        "Private - answer the number of bytes required to save the image
        to the specified image file name, and to backup the current image
        if backupBoolean is true."
    | imageSize bytesRequired backupFileName |
    imageSize := ( File fromPath: self current imageName ) size.
    bytesRequired := Processor oldSpacePages * 4096.  "estimated size of the new image file"
    Smalltalk platformIsWin32
        ifTrue: [ bytesRequired := bytesRequired * 2 ].  "estimated size of temp coff files"
    backupBoolean ifTrue: [
        backupFileName := ( imageName upTo: $. ), '.bak'.
        bytesRequired := bytesRequired + imageSize.  "backup size = current image size"
        ( File exists: backupFileName )
        ifTrue: [ bytesRequired := bytesRequired - ( File fromPath: backupFileName ) size ] ].
    ^bytesRequired!  ! 
#('June 25, 2010' '03:15:07 PM' 585360)!

(CodeFiler organizerFor: SessionModel class) reorganizeFrom: #(
('no category methods' diskSpaceRequiredToSaveImage:backup: )) !


   

HashedCollection subclass: #Set
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Collections' )
  comment: ''!

   

EventManager subclass: #SharedValue
  instanceVariableNames: 
    ' value '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Processes and Events' )
  comment: ''!

   

SharedValue subclass: #SharedBoolean
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Processes and Events' )
  comment: ''!

   

DynamicLinkLibrary variableByteSubclass: #ShellDLL
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-DLLs' )
  comment: ''!

  

CompilerErrorHandler subclass: #SilentErrorHandler
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Compiler Support' )
  comment: ''!

 

SilentErrorHandler subclass: #HaltingErrorHandler
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Compiler Support' )
  comment: ''!

  

SilentErrorHandler subclass: #PARTSSilentErrorHandler
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

ObjectStore subclass: #SmalltalkLibrary
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Object Libraries' )
  comment: ''!



ObjectStoreReader subclass: #SmalltalkLibraryBinder
  instanceVariableNames: 
    ' dummyGlobals skipPostBindCleanUp '
  classVariableNames: 
    ' Bound BoundNames CurrentClass GroupBind IndexToLib LibToIndex NameMap SavedNameMap '
  poolDictionaries: ''
  categories: #( 'Kernel-Object Libraries' )
  comment: ''!

  

ObjectStoreWriter subclass: #SmalltalkLibraryBuilder
  instanceVariableNames: 
    ' bindAction unBindAction '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

ObjectStoreObjects subclass: #SmalltalkLibraryObjects
  instanceVariableNames: 
    ' classes methods globals poolVars source library includeSource '
  classVariableNames: ''
  poolDictionaries: 
    ' ObjectStoreExternalTypes '
  categories: #( 'PARTS and Others' )
  comment: ''!



Object subclass: #SmalltalkLibraryReporter
  instanceVariableNames: 
    ' library unbindWhenDone libraryFileName libraryVersion imports exports prerequisites shapes classes methods globals bindAction unbindAction prereqLibraries '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



Object subclass: #SmalltalkToolInterface
  instanceVariableNames: 
    ' textWindowClass textPaneClass windowPolicyClass helpFileNames helpTopics resourceFileName '
  classVariableNames: 
    ' Current '
  poolDictionaries: ''
  categories: #( 'Tools-Development Support' )
  comment: ''!

!SmalltalkToolInterface methods !
useTextPane

    self textPaneClass: #TextPane!   ! 
#('April 18, 2002' '04:12:23 PM' nil)!

(CodeFiler organizerFor: SmalltalkToolInterface) reorganizeFrom: #(
('extensions' useTextPane )) !


!SmalltalkToolInterface methods !  
useScintilla

    self textPaneClass: #ScintillaPane! ! 
#('April 18, 2002' '04:12:33 PM' nil)!

(CodeFiler organizerFor: SmalltalkToolInterface) reorganizeFrom: #(
('extensions' useScintilla )) !


  

OrderedCollection subclass: #SortedCollection
  instanceVariableNames: 
    ' sortBlock '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Collections' )
  comment: ''!

!SortedCollection methods ! 
is: object1 lessThan: object2

    ^sortBlock value: object1 value: object2!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SortedCollection) reorganizeFrom: #(
('private' is:lessThan: )) !


!SortedCollection methods !   
basicIndexOf: anObject between: low and: high
    "Private - Answer the index of anObject in receiver, or 0 if absent."

    low to: high do: [:index | (self is: anObject equalTo: (self at: index)) ifTrue: [^index]].
    ^0!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SortedCollection) reorganizeFrom: #(
('private' basicIndexOf:between:and: )) !


!SortedCollection methods !  
basicIncludes: anObject between: low and: high

    low to: high do: [:index | (self is: anObject equalTo: (self at: index)) ifTrue: [^true]].
    ^false!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SortedCollection) reorganizeFrom: #(
('private' basicIncludes:between:and: )) !


!SortedCollection methods ! 
is: object1 equalTo: object2
    ^object1 = object2!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SortedCollection) reorganizeFrom: #(
('private' is:equalTo: )) !


!SortedCollection methods !
indexForInserting: newObject

    | index low high |
    low := startPosition. high := endPosition.
    [index := high + low // 2. low > high] whileFalse: [
            (sortBlock value: (contents at: index) value: newObject) ifTrue: [low := index + 1] ifFalse: [high := index - 1]].
    ^low! ! 
#('December 1, 2001' '02:02:26 PM' nil)!

(CodeFiler organizerFor: SortedCollection) reorganizeFrom: #(
('hyperdrive extensions' indexForInserting: )) !


!SortedCollection methods !  
includes: anObject
    "Binary search for anObject. Return true if found, false otherwise."

    ^(self indexOf: anObject) > 0!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SortedCollection) reorganizeFrom: #(
('querying' includes: )) !


!SortedCollection methods ! 
indexOf: anObject
    "Binary search for anObject. Return its index if found, or 0 otherwise."

    | low high middle middleElement |
    low := 1. high := self size.
    [low <= high] whileTrue: [
        (high - low) < 12 ifTrue: [^self basicIndexOf: anObject between: low and: high].
        middle := (low + high) // 2.
        middleElement := self at: middle.
        (self is: anObject equalTo: middleElement) ifTrue: [^middle].
        (self is: anObject lessThan: middleElement)
            ifTrue: [high := middle - 1]
            ifFalse: [low := middle + 1]].
    ^0!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SortedCollection) reorganizeFrom: #(
('querying' indexOf: )) !


 

SortedCollection subclass: #IdentitySortedCollection
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Collections' )
  comment: ''!

!IdentitySortedCollection methods !   
is: object1 equalTo: object2

    ^object1 == object2!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IdentitySortedCollection) reorganizeFrom: #(
('private' is:equalTo: )) !


!IdentitySortedCollection methods !
descendingOrder
    self invalidMessage!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IdentitySortedCollection) reorganizeFrom: #(
('invalid messages' descendingOrder )) !


!IdentitySortedCollection methods !   
value: object1 value: object2

    ^object1 basicHash <= object2 basicHash!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IdentitySortedCollection) reorganizeFrom: #(
('private' value:value: )) !


!IdentitySortedCollection methods !   
asIdentitySortedCollection
    ^self!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IdentitySortedCollection) reorganizeFrom: #(
('converting' asIdentitySortedCollection )) !


!IdentitySortedCollection methods !  
basicIndexOf: anObject withHashNear: middle
    "Private - Answer the index of anObject in the reciever, or 0 if not found."

    | hash element index |
    hash := anObject basicHash.
    index := middle.
    [element := self at: index. element basicHash == hash] whileTrue: [
        element == anObject ifTrue: [^index].
        index := index - 1].

    index := middle.
    [element := self at: index. element basicHash == hash] whileTrue: [
        element == anObject ifTrue: [^index].
        index := index + 1].
    ^0! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IdentitySortedCollection) reorganizeFrom: #(
('private' basicIndexOf:withHashNear: )) !


!IdentitySortedCollection methods ! 
asSortedCollection

    ^SortedCollection withAll: self!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IdentitySortedCollection) reorganizeFrom: #(
('converting' asSortedCollection )) !


!IdentitySortedCollection methods !  
indexOf: anObject
    "Binary search for anObject. Return its index in the receiver, or 0 if not found."

    | low high middle middleElementHash anObjectHash |
    low := 1. high := self size.
    anObjectHash := anObject basicHash.
    [low <= high] whileTrue: [
        (high - low) < 12 ifTrue: [^self basicIndexOf: anObject between: low and: high].
        middle := (low + high) // 2.
        middleElementHash := (self at: middle) basicHash.
        anObjectHash == middleElementHash ifTrue: [^self basicIndexOf: anObject withHashNear: middle].
        (anObjectHash < middleElementHash)
            ifTrue: [high := middle - 1]
            ifFalse: [low := middle + 1]].
    ^false!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IdentitySortedCollection) reorganizeFrom: #(
('querying' indexOf: )) !


!IdentitySortedCollection class methods !
comment
    "The receiver sorts objects according to their basicHash in order to look them up by identity quickly."!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IdentitySortedCollection class) reorganizeFrom: #(
('comment' comment )) !


!IdentitySortedCollection class methods !
sortBlock: aBlock

    self error: 'Create instances of the receiver with #new or #new:'! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: IdentitySortedCollection class) reorganizeFrom: #(
('instance creation' sortBlock: )) !




Object subclass: #SourceChunk
  instanceVariableNames: 
    ' type source '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'Tools-Browsers' )
  comment: ''!

!SourceChunk methods !
isBoundary

    ^#(#imageStartup #imageSave #synchronizationPoint) includes: type!    ! 
#('August 28, 2001' '02:10:52 PM' nil)!

(CodeFiler organizerFor: SourceChunk) reorganizeFrom: #(
('querying' isBoundary )) !


!SourceChunk methods !  
initialize

    type := #unkown.
    source := ''.!  ! 
#('August 28, 2001' '10:07:00 AM' nil)!

(CodeFiler organizerFor: SourceChunk) reorganizeFrom: #(
('initializing' initialize )) !


!SourceChunk methods !  
source
    ^source!    ! 
#('August 28, 2001' '10:01:47 AM' nil)!

(CodeFiler organizerFor: SourceChunk) reorganizeFrom: #(
('querying' source )) !


!SourceChunk methods !  
source: aString
    source := aString! ! 
#('August 28, 2001' '10:01:37 AM' nil)!

(CodeFiler organizerFor: SourceChunk) reorganizeFrom: #(
('private' source: )) !


!SourceChunk methods !  
printOn: aStream

    | string |
    aStream << self class name; << '('; << type; << ': '.
    string := source upTo: Cr.
    aStream << string.
    source size > string size ifTrue: [aStream << '...'].
    aStream << ')'!   ! 
#('August 28, 2001' '10:04:26 AM' nil)!

(CodeFiler organizerFor: SourceChunk) reorganizeFrom: #(
('printing' printOn: )) !


!SourceChunk methods !
type
    ^type!    ! 
#('August 28, 2001' '02:01:59 PM' nil)!

(CodeFiler organizerFor: SourceChunk) reorganizeFrom: #(
('querying' type )) !


!SourceChunk methods !
type: aSymbol
    type := aSymbol! ! 
#('August 28, 2001' '09:57:53 AM' nil)!

(CodeFiler organizerFor: SourceChunk) reorganizeFrom: #(
('private' type: )) !


!SourceChunk methods !
storeOn: aStream

    aStream cr; nextChunkPut: source!   ! 
#('August 28, 2001' '02:46:16 PM' nil)!

(CodeFiler organizerFor: SourceChunk) reorganizeFrom: #(
('printing' storeOn: )) !


!SourceChunk class methods !  
imageStartup

    ^self new type: #imageStartup!  ! 
#('August 28, 2001' '10:18:53 AM' nil)!

(CodeFiler organizerFor: SourceChunk class) reorganizeFrom: #(
('instance creation' imageStartup )) !


!SourceChunk class methods !   
doit: sourceString

    ^self new type: #doit; source: sourceString!  ! 
#('August 28, 2001' '10:01:08 AM' nil)!

(CodeFiler organizerFor: SourceChunk class) reorganizeFrom: #(
('instance creation' doit: )) !


!SourceChunk class methods !  
new
    ^super new initialize! ! 
#('August 28, 2001' '10:11:47 AM' nil)!

(CodeFiler organizerFor: SourceChunk class) reorganizeFrom: #(
('instance creation' new )) !


!SourceChunk class methods !
code: sourceString

    ^self new type: #code; source: sourceString!  ! 
#('August 28, 2001' '01:52:46 PM' nil)!

(CodeFiler organizerFor: SourceChunk class) reorganizeFrom: #(
('instance creation' code: )) !


!SourceChunk class methods !  
synchronizationPoint: aString

    ^self new type: #synchronizationPoint; source: aString!    ! 
#('August 28, 2001' '10:48:26 AM' nil)!

(CodeFiler organizerFor: SourceChunk class) reorganizeFrom: #(
('instance creation' synchronizationPoint: )) !


!SourceChunk class methods !  
synchronizationPoint

    ^self new type: #synchronizationPoint!  ! 
#('August 28, 2001' '10:48:18 AM' nil)!

(CodeFiler organizerFor: SourceChunk class) reorganizeFrom: #(
('instance creation' synchronizationPoint )) !


!SourceChunk class methods !   
imageSave: sourceString

    ^self new type: #imageSave; source: sourceString!    ! 
#('August 28, 2001' '10:01:17 AM' nil)!

(CodeFiler organizerFor: SourceChunk class) reorganizeFrom: #(
('instance creation' imageSave: )) !


!SourceChunk class methods ! 
imageStartup: sourceString

    ^self new type: #imageStartup; source: sourceString!  ! 
#('August 28, 2001' '10:01:19 AM' nil)!

(CodeFiler organizerFor: SourceChunk class) reorganizeFrom: #(
('instance creation' imageStartup: )) !


  

Object subclass: #SourceManager
  instanceVariableNames: ''
  classVariableNames: 
    ' Current '
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'Kernel-Source Management' )
  comment: ''!

!SourceManager methods !  
referencesTo: globalSymbol in: aClass
        "Open a MethodBrowser on all methods in aClass or a subclass of aClass
        referencing the global named globalSymbol."
    self sendersOf: (self smalltalk associationAt: globalSymbol asSymbol) in: aClass!   ! 
#('March 15, 2003' '05:05:39 PM' nil)!

(CodeFiler organizerFor: SourceManager) reorganizeFrom: #(
('no category methods' referencesTo:in: )) !


!SourceManager methods !  
implementorsOf: aSymbol in: aClass ifNone: aBlock
    | methods |
    
    CursorManager execute changeFor: [
        aClass isCollection
            ifTrue: [methods := OrderedCollection new. aClass do: [:class | methods addAll: (class implementorsOf: aSymbol)]]
           ifFalse: [methods := aClass implementorsOf: aSymbol].
        methods := methods asSortedCollection: [:a :b | a classField name < b classField name]].
    methods isEmpty ifTrue: [^aBlock value].

    MethodBrowser new
        label: 'Implementors of ', aSymbol printString;
        openOn: methods!  ! 
#('March 30, 2003' '05:15:15 PM' nil)!

(CodeFiler organizerFor: SourceManager) reorganizeFrom: #(
('extensions' implementorsOf:in:ifNone: )) !


!SourceManager methods !  
sendersOf: aSymbol
        "Open a MethodBrowser on all methods
         that reference aSymbol."
    self sendersOf: aSymbol in: self smalltalk rootClasses!    ! 
#('March 15, 2003' '05:07:34 PM' nil)!

(CodeFiler organizerFor: SourceManager) reorganizeFrom: #(
('no category methods' sendersOf: )) !


!SourceManager methods !
sendersOf: aSymbol in: aClass ifNone: aBlock

    | methods |
    methods := SortedCollection sortBlock: [:a :b | a classField name < b classField name].
    CursorManager execute changeFor: [
        aClass isCollection
            ifTrue: [aClass do: [:class | methods := methods, (class sendersOf: aSymbol)]]
            ifFalse: [methods := aClass sendersOf: aSymbol]].
    methods isEmpty ifTrue: [^aBlock value].
    MethodBrowser new
        label: 'Senders of ', aSymbol printString;
        literal: aSymbol;
        openOn: methods!  ! 
#('April 17, 2002' '04:33:26 PM' nil)!

(CodeFiler organizerFor: SourceManager) reorganizeFrom: #(
('extensions' sendersOf:in:ifNone: )) !


!SourceManager methods !   
logString: aString
        "Private - Append 'evaluate' followed by
         aString (in chunk format) to the change log."
    self logString: aString for: [ ]! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SourceManager) reorganizeFrom: #(
('extensions' logString: )) !


!SourceManager methods !
referencesTo: globalSymbol
        "Open a MethodBrowser on all methods
        referencing the global named globalSymbol."
    self sendersOf: (self smalltalk associationAt: globalSymbol asSymbol)!   ! 
#('March 15, 2003' '05:05:43 PM' nil)!

(CodeFiler organizerFor: SourceManager) reorganizeFrom: #(
('no category methods' referencesTo: )) !


!SourceManager methods ! 
newCompressChanges
        "Build a new change log file retaining
         only the latest version of changed
         methods in the current change log.
         Save the image to the image file."

    | logDirectory stream tempLogName dialog compressor |
    (SessionModel testDiskSpaceRequiredToCompressChanges: BackupImage) ifFalse: [^self].
    BackupImage ifTrue: [self backupChanges ifFalse: [^self error: 'Error backing up change.log']].
    logDirectory := (Sources at: 2) file directory.
    stream := logDirectory newFile: 'ChangeLog.tmp'.
    stream lineDelimiter: Cr.
    tempLogName := stream pathName.
    compressor := ChangeLogCompressor new.
    compressor promptForOptions; scanClasses; writeChangesOn: stream.

    stream close.
    (Sources at: 2) close.
    File remove: (Sources at: 2) pathName.
    File rename: tempLogName to: (Sources at: 2) pathName.
    Sources at: 2 put: (logDirectory file: (Sources at: 2) file name).
    (Sources at: 2) lineDelimiter: Cr.
    SessionModel current saveSession.
    Sync printString!  ! 
#('February 15, 2002' '11:41:30 AM' nil)!

(CodeFiler organizerFor: SourceManager) reorganizeFrom: #(
('change log' newCompressChanges )) !


!SourceManager methods !  
newCompressChanges
        "Build a new change log file retaining
         only the latest version of changed
         methods in the current change log.
         Save the image to the image file."

    | logDirectory stream tempLogName dialog compressor |
    (SessionModel testDiskSpaceRequiredToCompressChanges: BackupImage) ifFalse: [^self].
    BackupImage ifTrue: [self backupChanges ifFalse: [^self error: 'Error backing up change.log']].
    logDirectory := (Sources at: 2) file directory.
    stream := logDirectory newFile: 'ChangeLog.tmp'.
    stream lineDelimiter: Cr.
    tempLogName := stream pathName.
    
    compressor := ChangeLogCompressor new.
    compressor 
        promptForOptionsIfCancel: [stream close. File remove: tempLogName. ^self]; 
        scanClasses; 
        writeChangesOn: stream.

    stream close.
    (Sources at: 2) close.
    File remove: (Sources at: 2) pathName.
    File rename: tempLogName to: (Sources at: 2) pathName.
    Sources at: 2 put: (logDirectory file: (Sources at: 2) file name).
    (Sources at: 2) lineDelimiter: Cr.
    SessionModel current saveSession.
    Sync printString! ! 
#('July 21, 2006' '09:35:24 AM' 605244)!

(CodeFiler organizerFor: SourceManager) reorganizeFrom: #(
('change log' newCompressChanges )) !


!SourceManager methods !   
smalltalk
    ^Smalltalk!  ! 
#('March 15, 2003' '05:03:37 PM' nil)!

(CodeFiler organizerFor: SourceManager) reorganizeFrom: #(
('extensions' smalltalk )) !


!SourceManager methods !  
getSourceClasses
        "Private - Answer an OrderedCollection of all
         classes in hierarchical order."
    | classes |
    classes := OrderedCollection new: self smalltalk size.
    self smalltalk rootClasses do: [ :rootClass |
        rootClass withAllSubclasses do: [ :c |
            c name first == Space
                ifFalse: [ classes add: c ] ] ].
    ^classes!   ! 
#('March 15, 2003' '05:06:10 PM' nil)!

(CodeFiler organizerFor: SourceManager) reorganizeFrom: #(
('no category methods' getSourceClasses )) !


!SourceManager methods !  
implementorsOf: aSymbol in: aClass
    "Open a MethodBrowser on all methods named aSymbol in aClass and its subclasses. aClass can be a class or a collection of classes."
    | methods |
    
    CursorManager execute changeFor: [
        aClass isCollection
            ifTrue: [methods := OrderedCollection new. aClass do: [:class | methods addAll: (class implementorsOf: aSymbol )]]
            ifFalse: [methods := aClass implementorsOf: aSymbol].
        methods := methods asSortedCollection: [:a :b | a classField name < b classField name]].
    MethodBrowser new
        label: 'Implementors of ', aSymbol printString;
        openOn: methods!  ! 
#('March 30, 2003' '11:34:24 AM' nil)!

(CodeFiler organizerFor: SourceManager) reorganizeFrom: #(
('no category methods' implementorsOf:in: )) !


!SourceManager methods !
sendersOf: aSymbol ifNone: aBlock

    self sendersOf: aSymbol in: self smalltalk rootClasses ifNone: aBlock! ! 
#('March 15, 2003' '05:06:16 PM' nil)!

(CodeFiler organizerFor: SourceManager) reorganizeFrom: #(
('extensions' sendersOf:ifNone: )) !


!SourceManager methods !  
implementorsOf: aSymbol
        "Open a MethodBrowser on all methods
         named aSymbol."
    self implementorsOf: aSymbol in: self smalltalk rootClasses!   ! 
#('March 15, 2003' '05:07:14 PM' nil)!

(CodeFiler organizerFor: SourceManager) reorganizeFrom: #(
('no category methods' implementorsOf: )) !


!SourceManager methods !   
referencesToString: aString in: aClass
        "Open a MethodBrowser on all methods whose source code
        includes the substring aString."
    | methods |
    methods := SortedCollection sortBlock: [:a :b | a selector < b selector].
    CursorManager execute changeFor: [
        aClass isCollection
            ifTrue: [
                aClass do: [ :class |
                    methods := methods, ( class referencesToString: aString ) ] ]
           ifFalse: [ methods := aClass referencesToString: aString ] ].
    methods := methods reject: [ :m | m selector = #Doit ].
    MethodBrowser new
        literal: aString;
        label: 'References to ', aString printString;
        openOn: methods!    ! 
#('April 17, 2002' '04:27:02 PM' nil)!

(CodeFiler organizerFor: SourceManager) reorganizeFrom: #(
('no category methods' referencesToString:in: )) !


!SourceManager methods !
logString: aString for: aZeroArgumentBlock
        "Private - evaluate aZeroArgumentBlock, and then append
        'evaluate' followed by aString (in chunk format) to the change log.
        Answer the result of the block evaluation."
    | result |
    result := aZeroArgumentBlock value.
    ( Sources at: 2 )
        setToEnd;
        cr;
        cr;
        "nextPutAll: '""evaluate""'; REMOVE SO THAT CODE DOES NOT EXECUTE ON A FILE-IN"
        nextChunkPut: aString printString; "ADDED printString TO MAKE ABOVE WORK"
        flush.
    ^result
!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SourceManager) reorganizeFrom: #(
('extensions' logString:for: )) !


!SourceManager methods !
referencesToString: aString
        "Open a MethodBrowser on all methods whose source code
        includes the substring aString."
    self referencesToString: aString in: self smalltalk rootClasses! ! 
#('March 15, 2003' '05:06:22 PM' nil)!

(CodeFiler organizerFor: SourceManager) reorganizeFrom: #(
('no category methods' referencesToString: )) !


!SourceManager methods !   
fileInFrom: aStream
        "Private - read and execute the Smalltalk source code chunks
        from aStream.  If a chunk starts with !! send it the message
        fileInFrom: aStream"
    [ self fileInFromNoCancel: aStream ] on: Notification do: [ :exception |
        exception messageText = 'Abort Compilation'
            ifTrue: [^nil ].
        exception pass ]!   ! 
#('August 29, 2001' '03:27:57 PM' nil)!

(CodeFiler organizerFor: SourceManager) reorganizeFrom: #(
('no category methods' fileInFrom: )) !


!SourceManager methods !  
messagesIn: aCompiledMethod
        "Open a SelectorBrowser on all messages
        sent from aCompiledMethod."
    SelectorBrowser new openOn: aCompiledMethod! ! 
#('March 30, 2003' '05:18:22 PM' nil)!

(CodeFiler organizerFor: SourceManager) reorganizeFrom: #(
('no category methods' messagesIn: )) !


!SourceManager methods !   
messagesIn: aCompiledMethod
    "Open a SelectorBrowser on all messages sent from aCompiledMethod."
    SelectorBrowser new sourceManager: self; openOn: aCompiledMethod! ! 
#('March 30, 2003' '05:18:22 PM' 612700)!

(CodeFiler organizerFor: SourceManager) reorganizeFrom: #(
('no category methods' messagesIn: )) !


!SourceManager methods !
implementorsOf: aSymbol ifNone: aBlock

    self implementorsOf: aSymbol in: self smalltalk rootClasses ifNone: aBlock!   ! 
#('March 15, 2003' '05:07:25 PM' nil)!

(CodeFiler organizerFor: SourceManager) reorganizeFrom: #(
('extensions' implementorsOf:ifNone: )) !


!SourceManager methods ! 
sendersOf: aSymbol in: aClass
        "Open a MethodBrowser on all methods in aClass
        and its subclasses that reference aSymbol.
        aClass can be a class or a collection of classes."
    | methods |
    methods := SortedCollection sortBlock: [:a :b | a classField name < b classField name].
    CursorManager execute changeFor: [
        aClass isCollection
            ifTrue: [
                aClass do: [ :class |
                    methods := methods, ( class sendersOf: aSymbol ) ] ]
            ifFalse: [ methods := aClass sendersOf: aSymbol ] ].
    MethodBrowser new
        label: 'Senders of ', aSymbol printString;
        literal: aSymbol;
        openOn: methods!  ! 
#('April 17, 2002' '04:34:06 PM' nil)!

(CodeFiler organizerFor: SourceManager) reorganizeFrom: #(
('no category methods' sendersOf:in: )) !


 

Collection subclass: #SparseRectangleArray
  instanceVariableNames: 
    ' rectangles '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Collections' )
  comment: ''!

!SparseRectangleArray methods !   
containsPoint: aPoint

    ^(self rectangleContaining: aPoint ifNone: [nil]) notNil!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SparseRectangleArray) reorganizeFrom: #(
('querying' containsPoint: )) !


!SparseRectangleArray methods !
at: aPoint

    | rectangle |
    rectangle := self rectangleContaining: aPoint.
    ^rectangle at: aPoint! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SparseRectangleArray) reorganizeFrom: #(
('contents accessing' at: )) !


!SparseRectangleArray methods ! 
printOn: aStream

    aStream << self class; << '('; << rectangles size; << ' rectangles)'!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SparseRectangleArray) reorganizeFrom: #(
('printing' printOn: )) !


!SparseRectangleArray methods !  
at: aPoint put: anObject

    | rectangle |
    rectangle := self rectangleContaining: aPoint.
    rectangle at: aPoint put: anObject!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SparseRectangleArray) reorganizeFrom: #(
('contents accessing' at:put: )) !


!SparseRectangleArray methods ! 
initialize

    rectangles := OrderedCollection new.! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SparseRectangleArray) reorganizeFrom: #(
('initializing' initialize )) !


!SparseRectangleArray methods !
rectangleContaining: aPoint

    ^self rectangleContaining: aPoint ifNone: [self error: 'Out of bounds.']!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SparseRectangleArray) reorganizeFrom: #(
('querying' rectangleContaining: )) !


!SparseRectangleArray methods !  
mergeAll: rectangles

    | result |
    result := rectangles first mergeAll: rectangles rest.
    ^self merge: result.!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SparseRectangleArray) reorganizeFrom: #(
('expanding' mergeAll: )) !


!SparseRectangleArray methods !
rectangleContaining: aPoint ifNone: aBlock

    ^rectangles detect: [:rectangle | rectangle containsPoint: aPoint] ifNone: aBlock!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SparseRectangleArray) reorganizeFrom: #(
('private' rectangleContaining:ifNone: )) !


!SparseRectangleArray methods !
merge: aRectangle

    | intersectingRectangles coverRectangle |
    intersectingRectangles := rectangles select: [:rectangle | rectangle intersectsOrTouches: aRectangle].
    coverRectangle := aRectangle mergeAll: intersectingRectangles.
    rectangles removeAllIdentical: intersectingRectangles; add: coverRectangle.!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SparseRectangleArray) reorganizeFrom: #(
('expanding' merge: )) !


!SparseRectangleArray methods !   
containsRectangle: aRectangle
    "Answer true if the receiver contains a rectangle that completely encloses aRectangle."

    ^rectangles any: [:rectangle | rectangle contains: aRectangle]!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SparseRectangleArray) reorganizeFrom: #(
('querying' containsRectangle: )) !


!SparseRectangleArray methods !
rectangles

    ^rectangles!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SparseRectangleArray) reorganizeFrom: #(
('querying' rectangles )) !


!SparseRectangleArray class methods !  
new
    ^super new initialize! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SparseRectangleArray class) reorganizeFrom: #(
('instance creation' new )) !


   

Object subclass: #StatusBox
  instanceVariableNames: 
    ' contents width space rectangle state statusPane name '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants SystemColorConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

Object subclass: #StatusField
  instanceVariableNames: 
    ' parent contents type width name '
  classVariableNames: ''
  poolDictionaries: 
    ' WinCommonControlConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

GraphicsMedium subclass: #StoredPicture
  instanceVariableNames: 
    ' hMetaFile apmHeader '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Base-Graphics' )
  comment: ''!

   

Object subclass: #Stream
  instanceVariableNames: 
    ' collection position readLimit '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'Base-Streams' )
  comment: ''!

!Stream methods !  
nextTwoBytes
    "Answer the next two bytes from a byte array."
    ^self next + (self next * 256)!   ! 
#('October 2, 2009' '02:25:13 PM' nil)!

(CodeFiler organizerFor: Stream) reorganizeFrom: #(
('extensions - binary' nextTwoBytes )) !


!Stream methods !   
nextTwoBytes
    "Answer the next two bytes from a byte array."
    ^self next + (self nextByte * 256)!   ! 
#('October 2, 2009' '02:40:32 PM' 619472)!

(CodeFiler organizerFor: Stream) reorganizeFrom: #(
('extensions - binary' nextTwoBytes )) !


!Stream methods !
nextTwoBytes
    "Answer the next two bytes from a byte array."
    ^self nextByte + (self nextByte * 256)!   ! 
#('October 19, 2013' '05:31:26 PM' 619744)!

(CodeFiler organizerFor: Stream) reorganizeFrom: #(
('extensions - binary' nextTwoBytes )) !


!Stream methods !   
nextBinaryULongPut: anInteger
    "Like nextULongPut: but intended for a byte array stream rather than a string stream..."
    self
        nextPut: (anInteger bitAnd: 255);
        nextPut: ((anInteger bitShift: -8) bitAnd: 255);
        nextPut: ((anInteger bitShift: -16) bitAnd: 255);
        nextPut: ((anInteger bitShift: -24) bitAnd: 255)!    ! 
#('October 23, 2013' '10:30:32 AM' nil)!

(CodeFiler organizerFor: Stream) reorganizeFrom: #(
('extensions - binary (byte array streams)' nextBinaryULongPut: )) !


!Stream methods !  
nextBinaryUShort
    "Like nextUShort but intended for a byte array stream rather than a string stream..."
    ^self next + (256 * self next)!    ! 
#('October 23, 2013' '10:47:20 AM' nil)!

(CodeFiler organizerFor: Stream) reorganizeFrom: #(
('extensions - binary (byte array streams)' nextBinaryUShort )) !


!Stream methods ! 
indexOf: aCollection startingAt: position
        "Answer the position of the first occurrence
         of aCollection in the receiver.  If no such element
         is found, answer zero."
    self position: position. ^self indexOf: aCollection!   ! 
#('July 13, 2005' '04:04:10 PM' nil)!

(CodeFiler organizerFor: Stream) reorganizeFrom: #(
('extensions' indexOf:startingAt: )) !


!Stream methods !   
nextByte
    "Answer the next byte accessible by the receiver and advance the stream position.  Report an error if the stream is positioned at end."
    ^self next asciiValue!   ! 
#('October 2, 2009' '02:23:54 PM' nil)!

(CodeFiler organizerFor: Stream) reorganizeFrom: #(
('extensions - binary' nextByte )) !


!Stream methods !   
nextBinaryULong
    "Like nextULong but intended for a byte array stream rather than a string stream..."
    | answer |
    answer := 0.
    #(1 256 65536 16777216) do: [:multiplier | answer := answer + (self next * multiplier)].
    ^answer! ! 
#('October 23, 2013' '10:46:07 AM' nil)!

(CodeFiler organizerFor: Stream) reorganizeFrom: #(
('extensions - binary (byte array streams)' nextBinaryULong )) !


!Stream methods !  
nextULong
    "Answer the next four bytes as a uLong integer."
    | answer |
    answer := 0.
    #(1 256 65536 16777216) do: [: n | answer := answer + (self nextByte * n)].
    ^answer!    ! 
#('October 2, 2009' '02:25:49 PM' nil)!

(CodeFiler organizerFor: Stream) reorganizeFrom: #(
('extensions - binary' nextULong )) !


!Stream methods !  
nextKeyword
        "Answer a String containing the next word in the
         receiver stream.  A keyword starts with a letter,
         followed by a sequence of letters and digits, possibly ending with a colon."
         
    | first aChar |
    [self atEnd ifTrue: [^nil].
    self next isAlphaNumeric]
        whileFalse: [].  "skip separators"
    first := self position.
    [self atEnd
        ifTrue: [^self copyFrom: first to: self position].
     ((aChar := self next) isAlphaNumeric or: [aChar = $:])]
        whileTrue: [].
    self backupOver: aChar.
    ^self copyFrom: first to: self position! ! 
#('April 18, 2002' '04:22:28 PM' nil)!

(CodeFiler organizerFor: Stream) reorganizeFrom: #(
('extensions' nextKeyword )) !


!Stream methods !  
nextBinaryUShortPut: anInteger
    "Like nextUShortPut: but intended for a byte array stream rather than a string stream..."
    self
        nextPut: (anInteger bitAnd: 255);
        nextPut: ((anInteger bitShift: -8) bitAnd: 255)!    ! 
#('October 22, 2013' '02:08:18 PM' nil)!

(CodeFiler organizerFor: Stream) reorganizeFrom: #(
('extensions - binary (byte array streams)' nextBinaryUShortPut: )) !


!Stream methods ! 
nextIntegerAfterSeparators
    ^self skipSeparators; nextInteger!  ! 
#('October 16, 2013' '12:44:54 PM' nil)!

(CodeFiler organizerFor: Stream) reorganizeFrom: #(
('extensions' nextIntegerAfterSeparators )) !


!Stream methods ! 
upToEnd
    ^self contents copyFrom: self position to: self size.! ! 
#('December 10, 2001' '01:52:28 PM' nil)!

(CodeFiler organizerFor: Stream) reorganizeFrom: #(
('extensions' upToEnd )) !


!Stream methods !   
nextByte: howMany
    | result |
    result := ByteArray new: howMany.
    (self next: howMany) indexedDo: [:index :character | result at: index put: character asciiValue].
    ^result!   ! 
#('October 19, 2013' '05:38:03 PM' nil)!

(CodeFiler organizerFor: Stream) reorganizeFrom: #(
('extensions - binary' nextByte: )) !


!Stream methods ! 
nextBinaryFloatAsADouble
    "Intended for a byte array stream rather than a string stream... Since Smalltalk's float is actually a double, we make use of an OpenGLCanvasDLL routine
    called floatToDouble: which converts the first 4 bytes of an 8-byte ByteArray into a double for Smalltalk use..."
    | float double |
    
    float := ByteArray with: self next with: self next with: self next with: self next.
    double := CanvasLibrary floatToDouble: float, float.
    ^double!  ! 
#('April 27, 2015' '09:48:21 AM' nil)!

(CodeFiler organizerFor: Stream) reorganizeFrom: #(
('extensions - binary (byte array streams)' nextBinaryFloatAsADouble )) !


!Stream methods !   
nextFourBytes
    "Answer the next four bytes from a byte array."
    | answer |
    answer := 0.
    #( 1 256 65536 16777216 ) do: [: n | answer := answer + (self next * n)].
    ^answer!   ! 
#('October 2, 2009' '02:24:46 PM' nil)!

(CodeFiler organizerFor: Stream) reorganizeFrom: #(
('extensions - binary' nextFourBytes )) !


!Stream methods !  
nextFourBytes
    "Answer the next four bytes from a byte array."
    | answer |
    answer := 0.
    #(1 256 65536 16777216) do: [: n | answer := answer + (self next * n)].
    ^answer! ! 
#('October 2, 2009' '02:25:58 PM' 625484)!

(CodeFiler organizerFor: Stream) reorganizeFrom: #(
('extensions - binary' nextFourBytes )) !


!Stream methods !   
nextFourBytes
    "Answer the next four bytes from a byte array."
    | answer |
    answer := 0.
    #(1 256 65536 16777216) do: [: n | answer := answer + (self nextByte * n)].
    ^answer! ! 
#('October 2, 2009' '02:40:26 PM' 625848)!

(CodeFiler organizerFor: Stream) reorganizeFrom: #(
('extensions - binary' nextFourBytes )) !


!Stream methods !   
skipSeparatorsAndComments
    "Skip over any separators and comments."
    | next |
    [self atEnd not and: [(next := self peek) isSeparator or: [next == $"]]] whileTrue: [
        next == $" 
            ifTrue: [
                self next. "First double quote"
                [self atEnd not and: [(next := self peek) ~~ $"]] whileTrue: [self next].
                self atEnd ifFalse: [self next]. "Last double quote"]
            ifFalse: [self next]]! ! 
#('October 16, 2013' '12:02:48 PM' nil)!

(CodeFiler organizerFor: Stream) reorganizeFrom: #(
('extensions' skipSeparatorsAndComments )) !


!Stream methods !  
nextUShort
    "Answer the next two bytes as a ushort integer."
    ^self nextByte + (self nextByte * 256)!   ! 
#('October 2, 2009' '02:26:34 PM' nil)!

(CodeFiler organizerFor: Stream) reorganizeFrom: #(
('extensions - binary' nextUShort )) !


  

Stream subclass: #ReadStream
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Streams' )
  comment: ''!

!ReadStream methods ! 
match: anObject ifError: aBlock
    (self nextMatchFor: anObject) ifFalse: [^aBlock value].!   ! 
#('December 28, 2013' '11:58:29 AM' nil)!

(CodeFiler organizerFor: ReadStream) reorganizeFrom: #(
('matching' match:ifError: )) !


!ReadStream methods !  
match: aCollectionOfObjects ifError: aBlock
    aCollectionOfObjects do: [:object | self match: object ifError: aBlock]!   ! 
#('December 28, 2013' '11:59:40 AM' 627668)!

(CodeFiler organizerFor: ReadStream) reorganizeFrom: #(
('matching' match:ifError: )) !


!ReadStream methods !   
match: anArrayOfObjectsOrASingleObject ifError: aBlock
    anArrayOfObjectsOrASingleObject isArray 
        ifTrue: [anArrayOfObjectsOrASingleObject do: [:object | (self nextMatchFor: object) ifFalse: [^aBlock value]]]
        ifFalse: [(self nextMatchFor: anArrayOfObjectsOrASingleObject) ifFalse: [^aBlock value]].!    ! 
#('December 28, 2013' '12:04:05 PM' 627932)!

(CodeFiler organizerFor: ReadStream) reorganizeFrom: #(
('matching' match:ifError: )) !




Object subclass: #StreamReference
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Source Management' )
  comment: ''!

 

StreamReference subclass: #LibrarySourceReference
  instanceVariableNames: 
    ' stream library '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'Kernel-Source Management' )
  comment: ''!

 

FixedSizeCollection variableByteSubclass: #String
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'Base-Collections' )
  comment: ''!

!String methods !   
space
    ^String with: Character space!   ! 
#('January 20, 2003' '10:53:26 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('single character versions' space )) !


!String methods !   
withoutSlashSlashComments
    "Preserves // if inside quotes; i.e. matches single and double quotes..."
    | input output character endCharacter |
    input := self asStream. output := WriteStream on: (String new: self size).
    
    [input atEnd] whileFalse: [
        character := input next.
        (character == $') | (character == $") ifTrue: [
            output nextPut: character; nextPutAll: input upTo: character; nextPut: character] ifFalse: [
        (character == $/ and: [input peek == $/]) ifTrue: [
            (input atEnd not and: [input peek isTerminator not]) whileTrue: [input next].
            (input atEnd not and: [input peek isTerminator]) whileTrue: [input next]] ifFalse: [
        "otherwise"
            output nextPut: character]]].
            
    ^output contents!    ! 
#('July 22, 2006' '05:26:42 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('parser preprocessing' withoutSlashSlashComments )) !


!String methods !   
withoutSlashSlashComments
    "Preserves // if inside quotes; i.e. matches single and double quotes..."
    | input output character endCharacter |
    input := self asStream. output := WriteStream on: (String new: self size).
    
    [input atEnd] whileFalse: [
        character := input next.
        (character == $') | (character == $") ifTrue: [
            output nextPut: character; nextPutAll: input upTo: character; nextPut: character] ifFalse: [
        (character == $/ and: [input peek == $/]) ifTrue: [
            [input atEnd not and: [input peek isTerminator not]] whileTrue: [input next].
            [input atEnd not and: [input peek isTerminator]] whileTrue: [input next]] ifFalse: [
        "otherwise"
            output nextPut: character]]].
            
    ^output contents!    ! 
#('July 22, 2006' '05:29:19 PM' 629552)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('parser preprocessing' withoutSlashSlashComments )) !


!String methods !
withoutSlashSlashComments
    "Preserves // if inside quotes; i.e. matches single and double quotes..."
    | input output character endCharacter |
    input := self asStream. output := WriteStream on: (String new: self size).
    
    [input atEnd] whileFalse: [
        character := input next.
        (character == $') | (character == $") ifTrue: [
            output nextPut: character; nextPutAll: (input upTo: character); nextPut: character] ifFalse: [
        (character == $/ and: [input peek == $/]) ifTrue: [
            [input atEnd not and: [input peek isTerminator not]] whileTrue: [input next].
            [input atEnd not and: [input peek isTerminator]] whileTrue: [input next]] ifFalse: [
        "otherwise"
            output nextPut: character]]].
            
    ^output contents!  ! 
#('July 22, 2006' '05:29:46 PM' 630552)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('parser preprocessing' withoutSlashSlashComments )) !


!String methods !
capitalizedWithoutSpaces
    "   'big bad wolf' capitalizedWithoutSpaces   "
    ^(self asArrayOfSubstrings collect: [:word | word asCapitalizedString])
         inject: '' into: [:string :element | string, element]! ! 
#('June 9, 2007' '03:16:03 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('parser preprocessing' capitalizedWithoutSpaces )) !


!String methods ! 
withoutSlashSlashCommentsAndReplacingDoubleQuotesBySingleQuotesAndRemovingCommas
    "Preserves // if inside quotes; i.e. matches single and double quotes..."
    | input output character endCharacter |
    input := self asStream. output := WriteStream on: (String new: self size).
    
    [input atEnd] whileFalse: [
        character := input next.
        (character == $,) ifTrue: [
            output space] ifFalse: [
        (character == $') ifTrue: [
            "Leaves interior double quotes unchanged."
            output nextPut: $'; nextPutAll: (input upTo: character); nextPut: $'] ifFalse: [
        (character == $") ifTrue: [
            "Replaces each interior single quote by two single quotes..."
            output nextPut: $'; nextPutAll: ((input upTo: character) copyReplacingAll: #('''') by: #('''''')); nextPut: $'] ifFalse: [
        (character == $/ and: [input peek == $/]) ifTrue: [
            [input atEnd not and: [input peek isTerminator not]] whileTrue: [input next].
            [input atEnd not and: [input peek isTerminator]] whileTrue: [input next]] ifFalse: [
        "otherwise"
            output nextPut: character]]]]].
            
    ^output contents!    ! 
#('July 23, 2014' '09:13:10 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('parser preprocessing' withoutSlashSlashCommentsAndReplacingDoubleQuotesBySingleQuotesAndRemovingCommas )) !


!String methods !
isSelectorName
    self isEmpty ifTrue: [^false].
    self do: [:character | character isAlphaNumeric | (character == $:) ifFalse: [^false]].
    ^self first isLetter!  ! 
#('March 30, 2003' '07:13:57 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' isSelectorName )) !


!String methods !   
withoutSlashSlashCommentsAndReplacingDoubleQuotesBySingleQuotesAndCExponentsToSmalltalkExponentsAndRemovingCommas
    ^(self copyReplacingAll: #('e+') by: #('e')) withoutSlashSlashCommentsAndReplacingDoubleQuotesBySingleQuotesAndRemovingCommas!   ! 
#('July 23, 2014' '09:13:27 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('parser preprocessing' withoutSlashSlashCommentsAndReplacingDoubleQuotesBySingleQuotesAndCExponentsToSmalltalkExponentsAndRemovingCommas )) !


!String methods !   
matchesOneOf: stringCollection at: start
    "Returns the matching string or nil..."
    
    stringCollection do: [:string | (self matches: string at: start) ifTrue: [^string]].
    ^nil!    ! 
#('September 23, 2005' '08:09:16 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' matchesOneOf:at: )) !


!String methods ! 
lf
    ^String with: Character lf! ! 
#('January 20, 2003' '10:53:25 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('single character versions' lf )) !


!String methods !  
asHyperdriveCodeString
    "Deal with standardizing a string representing that code that might have come from the Hyperdrive virtual machine in a uniform manner."
    ^self copyWithStandarizedCrsAndLfs  trimBlanks convertTabsToSpaces convertUnderscoreToColonEquals! ! 
#('March 30, 2003' '11:05:59 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('hyperdrive extensions' asHyperdriveCodeString )) !


!String methods !
copyWithStandarizedCrsAndLfs
    "Replace cr/lf pairs by just lf and isolated crs by lf."
    
    | answer outputIndex inputIndex character |
    answer := self shallowCopy.
    outputIndex := inputIndex := 0.
    
    [inputIndex < self size] whileTrue: [
        character := self at: (inputIndex := inputIndex + 1).
        (character == Character cr)
            ifTrue: [
                (inputIndex < self size and: [(self at: inputIndex + 1) == Character lf]) ifTrue: [inputIndex := inputIndex + 1].
                answer at: (outputIndex := outputIndex + 1) put: Character lf]
            ifFalse: [
                answer at: (outputIndex := outputIndex + 1) put: character]].
    
    outputIndex = self size ifTrue: [^answer].
    ^answer prefix: outputIndex!   ! 
#('March 30, 2003' '11:03:51 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' copyWithStandarizedCrsAndLfs )) !


!String methods ! 
withoutSlashSlashCommentsAndReplacingDoubleQuotesBySingleQuotes
    "Preserves // if inside quotes; i.e. matches single and double quotes..."
    | input output character endCharacter |
    input := self asStream. output := WriteStream on: (String new: self size).
    
    [input atEnd] whileFalse: [
        character := input next.
        (character == $') ifTrue: [
            "Leaves interior double quotes unchanged."
            output nextPut: $'; nextPutAll: (input upTo: character); nextPut: $'] ifFalse: [
        (character == $") ifTrue: [
            "Replaces each interior single quote by two single quotes..."
            output nextPut: $'; nextPutAll: ((input upTo: character) copyReplacingAll: #('''') by: #('''''')); nextPut: $'] ifFalse: [
        (character == $/ and: [input peek == $/]) ifTrue: [
self halt: 'Processing comment: '. Transcript cr; << '/'.  
            [input atEnd not and: [input peek isTerminator not]] whileTrue: [Transcript nextPut: input peek. input next].
            [input atEnd not and: [input peek isTerminator]] whileTrue: [input next]] ifFalse: [
        (character == $/ and: [input peek == $/]) ifTrue: [
self halt: 'Processing sSTANDALONE SLASH...'. output nextPut: character
        ] ifFalse: [
        "otherwise"
            output nextPut: character]]]]].
            
    ^output contents!   ! 
#('June 4, 2007' '03:40:56 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('parser preprocessing' withoutSlashSlashCommentsAndReplacingDoubleQuotesBySingleQuotes )) !


!String methods !  
withoutSlashSlashCommentsAndReplacingDoubleQuotesBySingleQuotes
    "Preserves // if inside quotes; i.e. matches single and double quotes..."
    | input output character endCharacter |
    input := self asStream. output := WriteStream on: (String new: self size).
    
    [input atEnd] whileFalse: [
        character := input next.
        (character == $') ifTrue: [
            "Leaves interior double quotes unchanged."
            output nextPut: $'; nextPutAll: (input upTo: character); nextPut: $'] ifFalse: [
        (character == $") ifTrue: [
            "Replaces each interior single quote by two single quotes..."
            output nextPut: $'; nextPutAll: ((input upTo: character) copyReplacingAll: #('''') by: #('''''')); nextPut: $'] ifFalse: [
        (character == $/ and: [input peek == $/]) ifTrue: [
self halt: 'Processing comment: '. Transcript cr; << '/'.  
            [input atEnd not and: [input peek isTerminator not]] whileTrue: [Transcript nextPut: input peek. input next].
            [input atEnd not and: [input peek isTerminator]] whileTrue: [input next]] ifFalse: [
        (character == $/) ifTrue: [
self halt: 'Processing STANDALONE SLASH...'. output nextPut: character
        ] ifFalse: [
        "otherwise"
            output nextPut: character]]]]].
            
    ^output contents!    ! 
#('June 4, 2007' '03:51:28 PM' 637220)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('parser preprocessing' withoutSlashSlashCommentsAndReplacingDoubleQuotesBySingleQuotes )) !


!String methods !   
withoutSlashSlashCommentsAndReplacingDoubleQuotesBySingleQuotes
    "Preserves // if inside quotes; i.e. matches single and double quotes..."
    | input output character endCharacter |
    input := self asStream. output := WriteStream on: (String new: self size).
    
    [input atEnd] whileFalse: [
        character := input next.
        (character == $') ifTrue: [
            "Leaves interior double quotes unchanged."
            output nextPut: $'; nextPutAll: (input upTo: character); nextPut: $'] ifFalse: [
        (character == $") ifTrue: [
            "Replaces each interior single quote by two single quotes..."
            output nextPut: $'; nextPutAll: ((input upTo: character) copyReplacingAll: #('''') by: #('''''')); nextPut: $'] ifFalse: [
        (character == $/ and: [input peek == $/]) ifTrue: [
            [input atEnd not and: [input peek isTerminator not]] whileTrue: [input next].
            [input atEnd not and: [input peek isTerminator]] whileTrue: [input next]] ifFalse: [
        "otherwise"
            output nextPut: character]]]].
            
    ^output contents! ! 
#('June 4, 2007' '04:11:46 PM' 638816)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('parser preprocessing' withoutSlashSlashCommentsAndReplacingDoubleQuotesBySingleQuotes )) !


!String methods !   
exportString
    | input output character |
    "   'c:\3d\test.bmp' exportString   "
    input := self asStream. output := WriteStream on: (String new: self size * 2).
    output nextPut: $".
    [input atEnd] whileFalse: [
        character := input next.
        (character == $/ or: [character == $\])
            ifTrue: [output nextPutAll: '\\']
            ifFalse: [output nextPut: character]].
    output nextPut: $".
    ^output contents! ! 
#('October 1, 2001' '04:59:56 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' exportString )) !


!String methods !
convertUnderscoreToColonEquals

    ^self replaceAll: '_' with: ':='! ! 
#('November 14, 2001' '01:57:14 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('hyperdrive extensions' convertUnderscoreToColonEquals )) !


!String methods ! 
matches: aString at: start
    "Returns a boolean indicating success..."
    
    aString isEmpty ifTrue: [^true].
    start + aString size > self size ifTrue: [^false].
    0 to: aString size - 1 do: [:offset |
        (self at: start + offset) == (aString at: 1 + offset) ifFalse: [^false]].
    ^true! ! 
#('September 23, 2005' '08:07:23 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' matches:at: )) !


!String methods !  
fileNamePath
        "Answer the directory path of the receiver path name
        (without the file name and extension)."
    ^self
        copyFrom: 1
        to: ( ( self  findLast: [ :i | i = $\ ] ifAbsent: [^''] ) - 1 )!   ! 
#('November 5, 2010' '07:47:50 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('file names' fileNamePath )) !


!String methods !   
fileNamePath
    "Returns 'C:\3D\Helpme\textures\Atlases' given 'C:\3D\Helpme\textures\Atlases\test.bmp'..."
    ^self copyFrom: 1 to: ((self  findLast: [:i | i = $\] ifAbsent: [^'']) - 1)! ! 
#('November 5, 2010' '07:47:50 PM' 643088)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('file names' fileNamePath )) !


!String methods !
convertTabsToSpaces

    self replaceAll: (String with: Tab) with: '    '!    ! 
#('November 14, 2001' '01:50:55 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('hyperdrive extensions' convertTabsToSpaces )) !


!String methods !
readStream
    ^ReadStream on: self!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' readStream )) !


!String methods !  
stringAfterIncluding: substring
    | index |
    index := self indexOfString: substring.
    index = 0 ifTrue: [^''].
    ^self copyFrom: index to: self size! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' stringAfterIncluding: )) !


!String methods !   
fileNamePrefix
        "Returns 'test' given 'a:\data\special\test.bmp'."
    | prefix suffix index1 index2 index reverse |
    prefix := (self size > 3 and: [(self at: self size - 3) == $.])
        ifTrue: [self prefix: self size - 4] ifFalse: [self].
    suffix := (prefix size > 1 and: [(prefix at: 2) == $:])
        ifTrue: [prefix suffix: prefix size - 2] ifFalse: [prefix].
    reverse := suffix reversed.
    index1 := reverse indexOf: $\.
    index := index1 = 0
        ifTrue: [reverse indexOf: $/]
        ifFalse: [index2 := reverse indexOf: $/. index2 = 0 ifTrue: [index1] ifFalse: [index1 min: index2]].
    index = 0 ifTrue: [^suffix].
    ^suffix suffix: index - 1!    ! 
#('September 19, 2001' '12:29:17 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('file names' fileNamePrefix )) !


!String methods !   
fileNamePrefix
    "Returns 'test' given 'a:\data\special\test.bmp'."
    | suffix |
    suffix := self fileNameSuffix.
    suffix size = 0 ifTrue: [^self].
    ^self copyFrom: 1 to: (self size - suffix size - 1)!  ! 
#('June 24, 2004' '10:59:52 AM' 644616)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('file names' fileNamePrefix )) !


!String methods ! 
fileNamePrefix
    "Returns 'test' given 'a:\data\special\test.bmp'."
    | suffix filename |
    filename := self fileNameComplete.
    suffix := filename fileNameSuffix.
    suffix size = 0 ifTrue: [^filename].
    ^filename copyFrom: 1 to: (filename size - suffix size - 1)! ! 
#('June 24, 2004' '11:04:19 AM' 645480)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('file names' fileNamePrefix )) !


!String methods ! 
fileNameSuffix
        "Returns 'bmp' given 'a:\data\special\test.bmp'. or 'foobar' given 'c:\blah\baz.foobar' or '' given 'a:\more\extra'."

    | indexOfDot substring |
    substring := self copy.
    indexOfDot := self indexOf: $..
    indexOfDot = 0 ifTrue: [^''].
    [true] whileTrue: [
        substring := substring copyFrom: indexOfDot + 1 to: substring size.
        indexOfDot := substring indexOf: $..
        indexOfDot = 0 ifTrue: [^substring].
    ].

    "^(self size > 3 and: [(self at: self size - 3) == $.])
        ifTrue: [self suffix: 3] ifFalse: ['']
        "! ! 
#('May 15, 2003' '10:31:59 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('file names' fileNameSuffix )) !


!String methods ! 
fileNameSuffix
        "Returns 'bmp' given 'a:\data\special\test.bmp'. or 'foobar' given 'c:\blah\baz.foobar' or '' given 'a:\more\extra'."

    | indexOfDot substring |
    substring := self copy.
    indexOfDot := self indexOf: $..
    indexOfDot = 0 ifTrue: [^''].
    [true] whileTrue: [
        substring := substring copyFrom: indexOfDot + 1 to: substring size.
        indexOfDot := substring indexOf: $..
        indexOfDot = 0 ifTrue: [^substring].
    ].!   ! 
#('June 24, 2004' '11:00:17 AM' 646304)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('file names' fileNameSuffix )) !


!String methods ! 
isFloatString
    "Return whether or not the string represents an integer."

    | dotAlreadyFound |

    dotAlreadyFound := false.

    self do: [:each | each isDigit ifFalse: [
        each = $.
            ifTrue:[dotAlreadyFound ifTrue:[^false] ifFalse:[dotAlreadyFound := true]]
            ifFalse: [^false]]].
    ^true!  ! 
#('May 2, 2009' '11:03:18 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' isFloatString )) !


!String methods !   
stringAfter: substring
    | index |
    index := self indexOfString: substring.
    index = 0 ifTrue: [^''].
    ^self copyFrom: index + substring size to: self size! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' stringAfter: )) !


!String methods !
equalsIgnoreCase: aString upTo: length
    "Somewhat optimized for speed....
    Restrictions: aString must be lowercase already, and it's length must not exceed length."

    self size < length ifTrue: [^false].
    1 to: length do: [:index | (self at: index) asLowercase == (aString at: index) ifFalse: [^false]].
    ^true!    ! 
#('May 6, 2002' '02:46:18 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' equalsIgnoreCase:upTo: )) !


!String methods !  
equalsIgnoreCase: lowercaseString upTo: length

    self size < length ifTrue: [^false].
    lowercaseString size < length ifTrue: [^false].
    
    1 to: length do: [:index | (self at: index) asLowercase == (lowercaseString at: index) ifFalse: [^false]].
    ^true!   ! 
#('August 10, 2005' '02:23:39 PM' 648524)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' equalsIgnoreCase:upTo: )) !


!String methods !   
withoutSlashSlashCommentsAndReplacingDoubleQuotesBySingleQuotesAndCExponentsToSmalltalkExponents
    ^(self copyReplacingAll: #('e+') by: #('e')) withoutSlashSlashCommentsAndReplacingDoubleQuotesBySingleQuotes! ! 
#('May 25, 2007' '10:12:46 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('parser preprocessing' withoutSlashSlashCommentsAndReplacingDoubleQuotesBySingleQuotesAndCExponentsToSmalltalkExponents )) !


!String methods ! 
fileNameComplete
        "Returns 'test.bmp' given 'a:\data\special\test.bmp'."
    | suffix index |
    suffix := (self size > 1 and: [(self at: 2) == $:])
        ifTrue: [self suffix: self size - 2] ifFalse: [self].
    index := suffix reversed indexOf: $\.
    index = 0 ifTrue: [^suffix].
    ^suffix suffix: index - 1! ! 
#('January 15, 2002' '01:45:26 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('file names' fileNameComplete )) !


!String methods !   
fileNameComplete
        "Returns 'test.bmp' given 'a:\data\special\test.bmp'."
    | suffix index |
    
    self replaceAll: '/' with: '\'. "Make sure all our slashes are going the expected way."
    
    suffix := (self size > 1 and: [(self at: 2) == $:])
        ifTrue: [self suffix: self size - 2] ifFalse: [self].
    index := suffix reversed indexOf: $\.
    index = 0 ifTrue: [^suffix].
    ^suffix suffix: index - 1!    ! 
#('June 30, 2004' '09:10:32 AM' 649932)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('file names' fileNameComplete )) !


!String methods !   
fileNameComplete
        "Returns 'test.bmp' given 'a:\data\special\test.bmp'."
    | string suffix index |
    
    string := self replaceAll: '/' with: '\'. "Make sure all our slashes are going the expected way."
    
    suffix := (string size > 1 and: [(string at: 2) == $:])
        ifTrue: [string suffix: string size - 2] ifFalse: [string].
    index := suffix reversed indexOf: $\.
    index = 0 ifTrue: [^suffix].
    ^suffix suffix: index - 1! ! 
#('June 30, 2004' '09:12:23 AM' 650428)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('file names' fileNameComplete )) !


!String methods !   
stringBefore: substring
    | index |
    index := self indexOfString: substring.
    index = 0 ifTrue: [^self].
    ^self copyFrom: 1 to: index - 1!   ! 
#('May 12, 2006' '03:24:08 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' stringBefore: )) !


!String methods !  
extractStringPrefix
    "Given a string that has something quoted; i.e., surrounded by single quote character $', ignores leading characters 
    and returns the contents of the leading quoted string if one exists; otherwise, returns the empty string..
        '       ''It''''s a life'' for sure' extractStringPrefix returns the string with characters $I$t$'$s$ $a$ $l$i$f$e   "
        
    | input output character endCharacter |
    input := self asStream. output := WriteStream on: (String new: self size).
    [input atEnd not and: [input peek isSeparator]] whileTrue: [input next].
    
    input next == $' ifFalse: [^''].
    
    [input atEnd] whileFalse: [
        character := input next.
        (character == $') ifTrue: [
            (input atEnd or: [input peek ~~ $']) ifTrue: [^output contents]. "The prefix is ended..."
            output nextPut: input next] ifFalse: [
        "otherwise"
            output nextPut: character]].
            
    ^output contents "If we get here, the string is missing a terminating quote (but we'll return it as if it were there)..."!   ! 
#('November 15, 2006' '09:30:43 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('parser preprocessing' extractStringPrefix )) !


!String methods ! 
reallyStripSpecialHelpmeCharacters
    ^self reject: [:character | character == $@ or: [character == $!!]]!    ! 
#('February 16, 2010' '12:32:44 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' reallyStripSpecialHelpmeCharacters )) !


!String methods !
asCapitalizedString
    self isEmpty ifTrue: [^self].
    ^(String with: self first asUppercase), (self copyFrom: 2 to: self size)!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' asCapitalizedString )) !


!String methods ! 
null
    ^String with: Character null! ! 
#('January 20, 2003' '10:53:25 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('single character versions' null )) !


!String methods !
asNameCollection
    "Return a collection of names."
    
    (self indexOf: $,) = 0 ifTrue: [^Array with: self].
    ^(self copyReplacingAll: #('[' ']' ',') by: #(' ' ' ' ' ')) asArrayOfSubstrings!  ! 
#('January 7, 2010' '04:25:31 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' asNameCollection )) !


!String methods !
asNameCollection
    "Return a collection of names."
    
    (self indexOf: $,) = 0 ifTrue: [^Array with: self].
    ^(self copyReplacingAll: #('[' ']' ',') by: #(' ' ' ' ' ')) asArrayOfSubstrings!  ! 
#('January 7, 2010' '04:27:07 PM' 654056)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' asNameCollection )) !


!String methods ! 
asNameCollection
    "Return a collection of names."
    
    (self indexOf: $,) = 0 ifTrue: [^self isEmpty ifTrue: [#()] ifFalse: [Array with: self]].
    ^(self copyReplacingAll: #('[' ']' ',') by: #(' ' ' ' ' ')) asArrayOfSubstrings!    ! 
#('January 7, 2010' '04:33:31 PM' 654420)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' asNameCollection )) !


!String methods ! 
groupByMarkers: stringMarkers
    "Example usage:
        'test start {ok} long start {fine}' groupByMarkers: #('start {' 'long start {')  "
    
    | markers positions position match result start end |
    
    "Sort the markers by length so that longest strings match first."
    markers := (stringMarkers asSortedCollection: [:string1 :string2 | string1 size >= string2 size]) asArray
        reject: [:string | string isEmpty].
    
    "Walk over the characters noting where the markers match. On a match, jump over the matched portion..."
    positions := OrderedCollection new.
    position := 1.
    [position <= self size] whileTrue: [
        match := self matchesOneOf: markers at: position.
        position := match notNil 
            ifTrue: [positions add: position. position + match size]
            ifFalse: [position + 1]].
            
    "Extract the substrings that each one starts ensuring that the initial unmatched substring (if any) is included..."
    (positions isEmpty or: [positions first ~~ 1]) ifTrue: [positions addFirst: 1].
    positions add: self size.
    result := OrderedCollection new.
    
    1 to: positions size - 1 do: [:index | 
        start := (positions at: index).
        end := (positions at: index + 1) - 1.
        result add: (self copyFrom: start to: end)].
        
    ^result! ! 
#('September 23, 2005' '08:21:40 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' groupByMarkers: )) !


!String methods !  
groupByMarkers: stringMarkers
    "Example usage:
        'test start {ok} long start {fine}' groupByMarkers: #('start {' 'long start {')  
    "
    
    | markers positions position match result start end |
    
    "Sort the markers by length so that longest strings match first."
    markers := (stringMarkers asSortedCollection: [:string1 :string2 | string1 size >= string2 size]) asArray
        reject: [:string | string isEmpty].
    
    "Walk over the characters noting where the markers match. On a match, jump over the matched portion..."
    positions := OrderedCollection new.
    position := 1.
    [position <= self size] whileTrue: [
        match := self matchesOneOf: markers at: position.
        position := match notNil 
            ifTrue: [positions add: position. position + match size]
            ifFalse: [position + 1]].
            
    "Extract the substrings that each one starts ensuring that the initial unmatched substring (if any) is included..."
    (positions isEmpty or: [positions first ~~ 1]) ifTrue: [positions addFirst: 1].
    positions add: self size + 1.
    result := OrderedCollection new.
    
    1 to: positions size - 1 do: [:index | 
        start := (positions at: index).
        end := (positions at: index + 1) - 1.
        result add: (self copyFrom: start to: end)].
        
    ^result!   ! 
#('September 23, 2005' '08:23:18 AM' 655196)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' groupByMarkers: )) !


!String methods !   
groupByMarkers: stringMarkers
    "Example usage:
        'test start {ok more} long start {fine again} ' groupByMarkers: #('start {' 'long start {')  
    "
    
    | markers positions position match result start end |
    
    "Sort the markers by length so that longest strings match first."
    markers := (stringMarkers asSortedCollection: [:string1 :string2 | string1 size >= string2 size]) asArray
        reject: [:string | string isEmpty].
    
    "Walk over the characters noting where the markers match. On a match, jump over the matched portion..."
    positions := OrderedCollection new.
    position := 1.
    [position <= self size] whileTrue: [
        match := self matchesOneOf: markers at: position.
        position := match notNil 
            ifTrue: [positions add: position. position + match size]
            ifFalse: [position + 1]].
            
    "Extract the substrings that each one starts ensuring that the initial unmatched substring (if any) is included..."
    (positions isEmpty or: [positions first ~~ 1]) ifTrue: [positions addFirst: 1].
    positions add: self size + 1.
    result := OrderedCollection new.
    
    1 to: positions size - 1 do: [:index | 
        start := (positions at: index).
        end := (positions at: index + 1) - 1.
        result add: (self copyFrom: start to: end)].
        
    ^result!   ! 
#('September 23, 2005' '08:37:44 AM' 656728)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' groupByMarkers: )) !


!String methods !   
integerAfter: substring ifAbsent: aBlock

    | index |
    index := self indexOfString: substring.
    index = 0 ifTrue: [^aBlock value].
    ^(self copyFrom: index + substring size to: self size) asInteger!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' integerAfter:ifAbsent: )) !


!String methods !  
upToWhitespace
        "Answer a String which is a copy of the receiver up
         to the next white space."
    ^(ReadStream on: self) upToWhitespace! ! 
#('April 10, 2007' '04:35:35 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('no category methods' upToWhitespace )) !


!String methods !  
keywords
    "Answer an array of the keywords that compose the receiver."
    | result aStream char |
    result := WriteStream on: (Array new: 10).
    aStream := WriteStream on: (String new: 16).
    1 to: self size do: [:i |
        aStream nextPut: (char := self at: i).
        char = $: ifTrue: [result nextPut: aStream contents. aStream reset]].
    aStream isEmpty ifFalse: [result nextPut: aStream contents].
    ^result contents!    ! 
#('November 21, 2001' '05:19:45 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('hyperdrive extensions' keywords )) !


!String methods !   
asHelpmeTextureName

    "Standardize by converting everything to lowercase and converting '/' to '\'. Helpme texture names
    MUST BE PATH NAMES beginning with 'textures\' with one of 4 possible suffixes: dds tga bmp or lum.."
    
    | string texturesDirectory index |
    string := self replaceAll: '/' with: '\'. "Make sure all our slashes are going the expected way."
    string := string asLowercase.
true ifTrue: [^string fileNamePrefix].

    texturesDirectory := '\textures\'.
    index := string indexOfString: texturesDirectory.
    index > 1 ifTrue: [string := string copyFrom: index + texturesDirectory size to: string size].
        
    (#('dds' 'tga' 'bmp' 'lum') includes: (string suffix: 3)) ifFalse: [
        self halt: 'asHelpmeTextureName found a texture without a suffix; i.e. ', self printString].
        
    ^string!  ! 
#('February 1, 2007' '02:02:26 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' asHelpmeTextureName )) !


!String methods !
asHelpmeTextureName

    "Standardize by converting everything to lowercase and converting '/' to '\'. Helpme texture names
    MUST BE PATH NAMES beginning with 'textures\' with one of 4 possible suffixes: dds tga bmp or lum.."
    
    | string texturesDirectory index |
    string := self replaceAll: '/' with: '\'. "Make sure all our slashes are going the expected way."
    string := string asLowercase.
true ifTrue: [^string fileNameComplete].

    texturesDirectory := '\textures\'.
    index := string indexOfString: texturesDirectory.
    index > 1 ifTrue: [string := string copyFrom: index + texturesDirectory size to: string size].
        
    (#('dds' 'tga' 'bmp' 'lum') includes: (string suffix: 3)) ifFalse: [
        self halt: 'asHelpmeTextureName found a texture without a suffix; i.e. ', self printString].
        
    ^string!    ! 
#('February 1, 2007' '03:00:57 PM' 661164)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' asHelpmeTextureName )) !


!String methods ! 
asHelpmeTextureName

    "Standardize by converting everything to lowercase and converting '/' to '\'. Helpme texture names
    MUST BE PATH NAMES beginning with 'textures\' with one of 4 possible suffixes: dds tga bmp or lum.."
    
    | string texturesDirectory index |
    string := self replaceAll: '/' with: '\'. "Make sure all our slashes are going the expected way."
    string := string asLowercase.
"true ifTrue: [^string fileNameComplete]."
true ifTrue: [^string fileNamePrefix].

    texturesDirectory := '\textures\'.
    index := string indexOfString: texturesDirectory.
    index > 1 ifTrue: [string := string copyFrom: index + texturesDirectory size to: string size].
        
    (#('dds' 'tga' 'bmp' 'lum') includes: (string suffix: 3)) ifFalse: [
        self halt: 'asHelpmeTextureName found a texture without a suffix; i.e. ', self printString].
        
    ^string!  ! 
#('February 2, 2007' '08:57:02 AM' 662192)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' asHelpmeTextureName )) !


!String methods ! 
asAlphaNumeric
    | string |
    string := self select: [:character | character isAlphaNumeric].
    (string notEmpty and: [string first isLetter not]) ifTrue: [string := string rest].
    ^string!  ! 
#('March 30, 2003' '10:25:14 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('hyperdrive extensions' asAlphaNumeric )) !


!String methods !
isName
    self isEmpty ifTrue: [^false].
    self do: [:character | character isAlphaNumeric ifFalse: [^false]].
    ^self first isLetter!  ! 
#('February 25, 2003' '10:09:22 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' isName )) !


!String methods !
asBoolean

    ^self asInteger asBoolean! ! 
#('July 11, 2001' '01:30:00 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' asBoolean )) !


!String methods ! 
asPath
    "Return a collection of points."

    | substrings start |
    substrings := (self copyReplacingAll: #('[' ']' ',') by: #(' ' ' ' ' ')) asArrayOfSubstrings.
    substrings size \\ 3 = 0 ifFalse: [^self error: 'Cannot convert path since the number of values is not a multiple of 3...'].
    ^(1 to: substrings size \\ 3) collect: [:index |
        start := (index - 1) * 3.
        Point3D 
            x: (substrings at: start + 1) asNumber asFloat 
            y: (substrings at: start + 2) asNumber asFloat 
            z: (substrings at: start + 3) asNumber asFloat]!    ! 
#('July 12, 2006' '10:29:59 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' asPath )) !


!String methods !
asPath
    "Return a collection of points."

    | substrings start |
    substrings := (self copyReplacingAll: #('[' ']' ',') by: #(' ' ' ' ' ')) asArrayOfSubstrings.
    substrings size \\ 3 = 0 ifFalse: [^self error: 'Cannot convert path since the number of values is not a multiple of 3...'].
    ^(1 to: substrings size // 3) collect: [:index |
        start := (index - 1) * 3.
        Point3D 
            x: (substrings at: start + 1) asNumber asFloat 
            y: (substrings at: start + 2) asNumber asFloat 
            z: (substrings at: start + 3) asNumber asFloat]!    ! 
#('July 14, 2006' '01:56:47 PM' 665168)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' asPath )) !


!String methods ! 
withoutSlashSlashCommentsAndReplacingDoubleQuotesBySingleQuotesAlongWithSemicolonsAndColonsByCharacters
    "Preserves // if inside quotes; i.e. matches single and double quotes..."
    | input output character endCharacter |
    input := self asStream. output := WriteStream on: (String new: self size).
    
    [input atEnd] whileFalse: [
        character := input next.
        (character == $;) | (character == $:) ifTrue: [
            output nextPut: $$; nextPut: character] ifFalse: [
        (character == $') ifTrue: [
            "Leaves interior double quotes unchanged."
            output nextPut: $'; nextPutAll: (input upTo: character); nextPut: $'] ifFalse: [
        (character == $") ifTrue: [
            "Replaces each interior single quote by two single quotes..."
            output nextPut: $'; nextPutAll: ((input upTo: character) copyReplacingAll: #('''') by: #('''''')); nextPut: $'] ifFalse: [
        (character == $/ and: [input peek == $/]) ifTrue: [
            [input atEnd not and: [input peek isTerminator not]] whileTrue: [input next].
            [input atEnd not and: [input peek isTerminator]] whileTrue: [input next]] ifFalse: [
        "otherwise"
            output nextPut: character]]]]].
            
    ^output contents!   ! 
#('January 20, 2014' '04:09:20 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('parser preprocessing' withoutSlashSlashCommentsAndReplacingDoubleQuotesBySingleQuotesAlongWithSemicolonsAndColonsByCharacters )) !


!String methods !  
cr
    ^String with: Character cr! ! 
#('January 20, 2003' '10:53:25 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('single character versions' cr )) !


!String methods !  
withoutSlashSlashCommentsAndReplacingDoubleQuotesBySingleQuotesAndSemicolonsByCharacters
    "Preserves // if inside quotes; i.e. matches single and double quotes..."
    | input output character endCharacter |
    input := self asStream. output := WriteStream on: (String new: self size).
    
    [input atEnd] whileFalse: [
        character := input next.
        (character == $;) ifTrue: [
            output nextPut: $$; nextPut: character] ifFalse: [
        (character == $') ifTrue: [
            "Leaves interior double quotes unchanged."
            output nextPut: $'; nextPutAll: (input upTo: character); nextPut: $'] ifFalse: [
        (character == $") ifTrue: [
            "Replaces each interior single quote by two single quotes..."
            output nextPut: $'; nextPutAll: ((input upTo: character) copyReplacingAll: #('''') by: #('''''')); nextPut: $'] ifFalse: [
        (character == $/ and: [input peek == $/]) ifTrue: [
            [input atEnd not and: [input peek isTerminator not]] whileTrue: [input next].
            [input atEnd not and: [input peek isTerminator]] whileTrue: [input next]] ifFalse: [
        "otherwise"
            output nextPut: character]]]]].
            
    ^output contents!  ! 
#('December 28, 2013' '10:42:00 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('parser preprocessing' withoutSlashSlashCommentsAndReplacingDoubleQuotesBySingleQuotesAndSemicolonsByCharacters )) !


!String methods !
stripSpecialHelpmeCharacters
    ^self reject: [:character | character == $@ or: [character == $!!]]!  ! 
#('February 16, 2010' '09:56:32 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' stripSpecialHelpmeCharacters )) !


!String methods !  
stripSpecialHelpmeCharacters
true ifTrue: [^self].
    ^self reject: [:character | character == $? or: [character == $!!]]!   ! 
#('February 16, 2010' '11:55:06 AM' 669912)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' stripSpecialHelpmeCharacters )) !


!String methods !   
stripSpecialHelpmeCharacters
true ifTrue: [^self].
    ^self reject: [:character | character == $@ or: [character == $!!]]!   ! 
#('February 16, 2010' '11:55:24 AM' 670192)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' stripSpecialHelpmeCharacters )) !


!String methods !   
fileDrive
    "Returns 'a:' given 'a:\data\special\test.bmp'. or '' given 'flower.bmp'."

    (self size < 2 or: [self at2 ~= ':']) ifTrue: [^''].
    ^self prefix: 2! ! 
#('November 13, 2008' '05:38:18 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('file names' fileDrive )) !


!String methods ! 
fileDrive
    "Returns 'a:' given 'a:\data\special\test.bmp'. or '' given 'flower.bmp'."

    (self size < 2 or: [self at2 ~= $:]) ifTrue: [^''].
    ^self prefix: 2!  ! 
#('November 13, 2008' '05:55:56 PM' 670808)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('file names' fileDrive )) !


!String methods !  
directoryNamePath
        "Returns 'a:\data\special\' given 'a:\data\special\test.bmp'."
    | position directoryName |
    directoryName := self fileNamePath.
    directoryName isEmpty ifTrue: [^'.\'].
    directoryName last = $\ ifFalse: [directoryName := directoryName, '\'].
    ^directoryName!    ! 
#('January 14, 2002' '01:53:53 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' directoryNamePath )) !


!String methods !  
withoutSlashSlashCommentsAndReplacingDoubleQuotesBySingleQuotesAlongWithSemicolonsAndColonsByCharactersAndRemovingCommas
    "Preserves // if inside quotes; i.e. matches single and double quotes..."
    | input output character endCharacter |
    input := self asStream. output := WriteStream on: (String new: self size).
    
    [input atEnd] whileFalse: [
        character := input next.
        (character == $,) ifTrue: [
            output space] ifFalse: [
        (character == $;) | (character == $:) ifTrue: [
            output nextPut: $$; nextPut: character] ifFalse: [
        (character == $') ifTrue: [
            "Leaves interior double quotes unchanged."
            output nextPut: $'; nextPutAll: (input upTo: character); nextPut: $'] ifFalse: [
        (character == $") ifTrue: [
            "Replaces each interior single quote by two single quotes..."
            output nextPut: $'; nextPutAll: ((input upTo: character) copyReplacingAll: #('''') by: #('''''')); nextPut: $'] ifFalse: [
        (character == $/ and: [input peek == $/]) ifTrue: [
            [input atEnd not and: [input peek isTerminator not]] whileTrue: [input next].
            [input atEnd not and: [input peek isTerminator]] whileTrue: [input next]] ifFalse: [
        "otherwise"
            output nextPut: character]]]]]].
            
    ^output contents!  ! 
#('May 8, 2014' '08:54:06 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('parser preprocessing' withoutSlashSlashCommentsAndReplacingDoubleQuotesBySingleQuotesAlongWithSemicolonsAndColonsByCharactersAndRemovingCommas )) !


!String methods !  
tab
    ^String with: Character tab!   ! 
#('January 20, 2003' '10:53:26 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('single character versions' tab )) !


!String methods ! 
containsString: substring
    ^(self indexOfString: substring) ~= 0.!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' containsString: )) !


!String methods ! 
floatAfter: substring ifAbsent: aBlock

    | index |
    index := self indexOfString: substring.
    index = 0 ifTrue: [^aBlock value].
    ^(self copyFrom: index + substring size to: self size) asFloat!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' floatAfter:ifAbsent: )) !


!String methods !
pathNamePrefix
        "Returns 'a:\data\special\test' given 'a:\data\special\test.bmp'."
    (self size > 3 and: [(self at: self size - 3) == $.])
        ifTrue: [^self prefix: self size - 4]
        ifFalse: [^self].!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('file names' pathNamePrefix )) !


!String methods !  
pathNamePrefix
    "Returns 'a:\data\special\test' given 'a:\data\special\test.bmp'."
    (self size > 3 and: [(self at: self size - 3) == $.])
        ifTrue: [^self prefix: self size - 4]
        ifFalse: [^self].!    ! 
#('July 16, 2008' '12:22:37 PM' 674408)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('file names' pathNamePrefix )) !


!String methods ! 
pathNamePrefix
    "Returns 'a:\data\special\test' given 'a:\data\special\test.bmp'."
"
    'a:\data\special\test.bmp' pathNamePrefix
    'a:\data\special\test.pvrBad' pathNamePrefix
    '.\data\special\test' pathNamePrefix
    '..\data\special\test' pathNamePrefix
"
    | indexOfDot |
    indexOfDot := self reversed indexOf: $..
    ((indexOfDot = 0) or: [indexOfDot >= (self size - 1)]) ifTrue: [^self]. "No dot or of the form '.\name' or '..\name'."
    ^self prefix: self size - indexOfDot! ! 
#('March 3, 2010' '10:03:15 AM' 674796)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('file names' pathNamePrefix )) !


!String methods ! 
padRight: size
    self size >= size ifTrue: [^self].
    ^self, ((String new: size - self size) atAllPut: $ )!   ! 
#('April 22, 2009' '11:35:59 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' padRight: )) !


!String methods !
writeStream

    ^WriteStream on: self!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' writeStream )) !


!String methods ! 
asInitializationFileData
    "Creates a dictionary keyed by names whose values are ordered collections of name/value pairs. The names are concatenated alphabetic names separated by
    spaces as in 'maximum damage'; the values are either basic entities likes numbers, boolean, an array of basic entities, etc."

    | input dictionary line pairs name value index character output tracing |
    "Pass 1 eliminates comments..."
tracing := false.
    input := self asStream. output := WriteStream on: (String new: self size).
    [input atEnd] whileFalse: [
        character := input next.
        (character == $/ and: [input peek == $/]) ifTrue: [
            [input atEnd not and: [input peek isTerminator not]] whileTrue: [input next].
            [input atEnd not and: [input peek isTerminator]] whileTrue: [input next].
            output nextPut: Character cr; nextPut: Character lf] ifFalse: [
        "otherwise"
            output nextPut: character]].
    input := output contents asStream.

    "Pass 2 creates the dictionary of keyed items where each value is the entire string after the key..."
    dictionary := Dictionary new.
    [input atEnd] whileFalse: [
        "Allow lines to be continued if '\' is the last character...."
        line := input nextLine trimBlanks.
        [line notEmpty and: [line last = $\ and: [input atEnd not]]] whileTrue: [
            line := (line copyFrom: 1 to: line size - 1), input nextLine trimBlanks].
        (line isEmpty) ifTrue: ["Ignore"] ifFalse: [
        (line first = $[) ifTrue: [
            "Creates a new entry in the dictionary..."
            index := line indexOf: $].
            index == 0 ifTrue: [self halt: 'Syntax error in .INI file, problem line is "', line, '"...'].
            name := line copyFrom: 2 to: index - 1.
tracing := name = 'Flare Projectile'.
            pairs := OrderedCollection new.
            dictionary at: name put: pairs] ifFalse: [
        "otherwise processing name/value pair."
tracing ifTrue: [self halt: 'Consider "', line, '"'].
            index := line indexOf: $=.
            index == 0 ifTrue: [self halt: 'Syntax error in .INI file, problem line is "', line, '"...'].
            name := (line copyFrom: 1 to: index - 1) trimBlanks.
            name at1 == $/ ifTrue: [self halt: 'Found name with /...'].
            value := (line copyFrom: index + 1 to: line size) trimBlanks.
            (value notEmpty and: [value at1 isLetter not and: [value at1 ~~ $$]])
                ifTrue: [
                    value := Compiler evaluate: '#(', value, ')'.
                    value size = 1 ifTrue: [value := value at1]]
                ifFalse: [(#('true' 'false') includes: value) ifTrue: [value := Compiler evaluate: value]].
            pairs add: (Array with: name with: value)]]].

    ^dictionary!   ! 
#('September 25, 2008' '10:03:05 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('parser preprocessing' asInitializationFileData )) !


!String methods !   
asInitializationFileData
    "Creates a dictionary keyed by names whose values are ordered collections of name/value pairs. The names are concatenated alphabetic names separated by
    spaces as in 'maximum damage'; the values are either basic entities likes numbers, boolean, an array of basic entities, etc."

    | input dictionary line pairs name value index character output tracing |
    "Pass 1 eliminates comments..."
tracing := false.
    input := self asStream. output := WriteStream on: (String new: self size).
    [input atEnd] whileFalse: [
        character := input next.
        (character == $/ and: [input peek == $/]) ifTrue: [
            [input atEnd not and: [input peek isTerminator not]] whileTrue: [input next].
            [input atEnd not and: [input peek isTerminator]] whileTrue: [input next].
            output nextPut: Character cr; nextPut: Character lf] ifFalse: [
        "otherwise"
            output nextPut: character]].
    input := output contents asStream.

    "Pass 2 creates the dictionary of keyed items where each value is the entire string after the key..."
    dictionary := Dictionary new.
    [input atEnd] whileFalse: [
        "Allow lines to be continued if '\' is the last character...."
        line := input nextLine trimBlanks.
        [line notEmpty and: [line last = $\ and: [input atEnd not]]] whileTrue: [
            line := (line copyFrom: 1 to: line size - 1), input nextLine trimBlanks].
        (line isEmpty) ifTrue: ["Ignore"] ifFalse: [
        (line first = $[) ifTrue: [
            "Creates a new entry in the dictionary..."
            index := line indexOf: $].
            index == 0 ifTrue: [self halt: 'Syntax error in .INI file, problem line is "', line, '"...'].
            name := line copyFrom: 2 to: index - 1.
tracing := name = 'Projectile::Flare Projectile'.
            pairs := OrderedCollection new.
            dictionary at: name put: pairs] ifFalse: [
        "otherwise processing name/value pair."
tracing ifTrue: [self halt: 'Consider "', line, '"'].
            index := line indexOf: $=.
            index == 0 ifTrue: [self halt: 'Syntax error in .INI file, problem line is "', line, '"...'].
            name := (line copyFrom: 1 to: index - 1) trimBlanks.
            name at1 == $/ ifTrue: [self halt: 'Found name with /...'].
            value := (line copyFrom: index + 1 to: line size) trimBlanks.
            (value notEmpty and: [value at1 isLetter not and: [value at1 ~~ $$]])
                ifTrue: [
                    value := Compiler evaluate: '#(', value, ')'.
                    value size = 1 ifTrue: [value := value at1]]
                ifFalse: [(#('true' 'false') includes: value) ifTrue: [value := Compiler evaluate: value]].
            pairs add: (Array with: name with: value)]]].

    ^dictionary!   ! 
#('September 25, 2008' '10:05:04 AM' 676316)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('parser preprocessing' asInitializationFileData )) !


!String methods !
asInitializationFileData
    "Creates a dictionary keyed by names whose values are ordered collections of name/value pairs. The names are concatenated alphabetic names separated by
    spaces as in 'maximum damage'; the values are either basic entities likes numbers, boolean, an array of basic entities, etc."

    | input dictionary line pairs name value index character output |
    "Pass 1 eliminates comments..."
    input := self asStream. output := WriteStream on: (String new: self size).
    [input atEnd] whileFalse: [
        character := input next.
        (character == $/ and: [input peek == $/]) ifTrue: [
            [input atEnd not and: [input peek isTerminator not]] whileTrue: [input next].
            [input atEnd not and: [input peek isTerminator]] whileTrue: [input next].
            output nextPut: Character cr; nextPut: Character lf] ifFalse: [
        "otherwise"
            output nextPut: character]].
    input := output contents asStream.

    "Pass 2 creates the dictionary of keyed items where each value is the entire string after the key..."
    dictionary := Dictionary new.
    [input atEnd] whileFalse: [
        "Allow lines to be continued if '\' is the last character...."
        line := input nextLine trimBlanks.
        [line notEmpty and: [line last = $\ and: [input atEnd not]]] whileTrue: [
            line := (line copyFrom: 1 to: line size - 1), input nextLine trimBlanks].
        (line isEmpty) ifTrue: ["Ignore"] ifFalse: [
        (line first = $[) ifTrue: [
            "Creates a new entry in the dictionary..."
            index := line indexOf: $].
            index == 0 ifTrue: [self halt: 'Syntax error in .INI file, problem line is "', line, '"...'].
            name := line copyFrom: 2 to: index - 1.
            pairs := OrderedCollection new.
            dictionary at: name put: pairs] ifFalse: [
        "otherwise processing name/value pair."
            index := line indexOf: $=.
            index == 0 ifTrue: [self halt: 'Syntax error in .INI file, problem line is "', line, '"...'].
            name := (line copyFrom: 1 to: index - 1) trimBlanks.
            name at1 == $/ ifTrue: [self halt: 'Found name with /...'].
            value := (line copyFrom: index + 1 to: line size) trimBlanks.
            (value notEmpty and: [value at1 isLetter not and: [value at1 ~~ $$]])
                ifTrue: [
                    value := Compiler evaluate: '#(', value, ')'.
                    value size = 1 ifTrue: [value := value at1]]
                ifFalse: [(#('true' 'false') includes: value) ifTrue: [value := Compiler evaluate: value]].
            pairs add: (Array with: name with: value)]]].

    ^dictionary!    ! 
#('September 25, 2008' '10:10:33 AM' 679364)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('parser preprocessing' asInitializationFileData )) !


!String methods !
flattened
    ^self!   ! 
#('April 18, 2002' '04:48:08 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' flattened )) !


!String methods !
sequencePrefix
        "Returns 'test' given 'test29' or nil if there is no digit trailing the name."
    | number result |
    (number := self sequenceNumberSuffix) isNil ifTrue: [^nil].
    "If there are additional zeros, we need to get rid of them too..."
    result := self prefix: (self size - number printString size).
    result sequenceNumberSuffix isNil ifFalse: [^result sequencePrefix].
    ^result
! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' sequencePrefix )) !


!String methods !  
isIntegerString
    "Return whether or not the string represents an integer."
    self do: [:each | each isDigit ifFalse: [^false]].
    ^true!  ! 
#('May 2, 2003' '08:45:29 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' isIntegerString )) !


!String methods ! 
extractSelectorFromMethodSource
    | inputStream outputStream aCharacter |
    inputStream := ReadStream on: self.
    outputStream := WriteStream on: (String new: 256).

    [inputStream atEnd] whileFalse: [
        aCharacter := inputStream next.
        aCharacter isTerminator ifTrue: [^outputStream contents asSymbol] ifFalse: [
        aCharacter isOperator ifTrue: [
            outputStream nextPut: aCharacter.
            [inputStream atEnd not and: [inputStream peek isOperator]] whileTrue: [
                outputStream nextPut: inputStream next].
            ^outputStream contents asSymbol] ifFalse: [
        aCharacter == $: ifTrue: [
            outputStream nextPut: $:.
            "Remove leading spaces if any."
            [inputStream atEnd not and: [inputStream peek isSeparator]] whileTrue: [
                inputStream next].
            "Remove alphanumeric parameter name."
            [inputStream atEnd not and: [inputStream peek isAlphaNumeric]] whileTrue: [
                inputStream next]] ifFalse: [
        aCharacter isSeparator ifFalse: [outputStream nextPut: aCharacter]]]]].

    ^outputStream contents asSymbol! ! 
#('May 19, 2003' '02:21:45 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('hyperdrive extensions' extractSelectorFromMethodSource )) !


!String methods ! 
asUncapitalizedString
    self isEmpty ifTrue: [^self].
    ^(String with: self first asLowercase), (self copyFrom: 2 to: self size)! ! 
#('October 7, 2001' '11:09:11 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' asUncapitalizedString )) !


!String methods !   
convertLfsToCrLfPairs

    | remainingString newString index |

    newString := String new.
    remainingString := self copy.
    index := remainingString indexOf: Lf.

    [index = 0] whileFalse: [
        newString := newString, (remainingString upTo: Lf), String crlf.
        remainingString := remainingString copyFrom: index + 1.
        index := remainingString indexOf: Lf].

    newString := newString, remainingString.

    ^newString!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' convertLfsToCrLfPairs )) !


!String methods !   
strippedFileName
    ^self reject: [:character | character == $? or: [character == $!!]]!  ! 
#('November 10, 2009' '12:39:14 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' strippedFileName )) !


!String methods !  
strippedFileName
    ^self reject: [:character | character == $@ or: [character == $!!]]!  ! 
#('February 16, 2010' '09:54:06 AM' 688712)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' strippedFileName )) !


!String methods !   
strippedFileName
true ifTrue: [^self].
    ^self reject: [:character | character == $@ or: [character == $!!]]!   ! 
#('February 16, 2010' '11:55:30 AM' 688968)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' strippedFileName )) !


!String methods !   
padLeft: size
    self size >= size ifTrue: [^self].
    ^((String new: size - self size) atAllPut: $ ), self!    ! 
#('April 22, 2009' '11:35:34 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' padLeft: )) !


!String methods ! 
convertCrsToLfs

    ^self replaceAll: (String with: Cr) with: (String with: Lf)! ! 
#('November 14, 2001' '01:55:54 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('hyperdrive extensions' convertCrsToLfs )) !


!String methods !
beginsWithString: start remainderSatisfies: aBlock

    (self indexOfString: start) == 1 ifFalse: [^false].
    ^aBlock value: (self copyFrom: (start size + 1))!    ! 
#('May 2, 2003' '08:45:29 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' beginsWithString:remainderSatisfies: )) !


!String methods !
beginsWithString: start remainderSatisfies: aBlock
    "Example:
        'abc123' beginsWithString: 'abc' remainderSatisfies: [:string | string isIntegerString]
    "
    (self indexOfString: start) == 1 ifFalse: [^false].
    ^aBlock value: (self copyFrom: (start size + 1))!   ! 
#('May 2, 2003' '08:45:29 AM' 690036)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' beginsWithString:remainderSatisfies: )) !


!String methods ! 
beginsWithString: start remainderSatisfies: aBlock
    "Example:
        'abc123' beginsWithString: 'abc' remainderSatisfies: [:string | string isIntegerString].
        'abcdef' beginsWithString: 'abc' remainderSatisfies: [:string | string isEmpty].
    "
    (self indexOfString: start) == 1 ifFalse: [^false].
    ^aBlock value: (self copyFrom: (start size + 1))!    ! 
#('May 2, 2003' '08:45:29 AM' 690380)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' beginsWithString:remainderSatisfies: )) !


!String methods ! 
beginsWith: aString

    ^(self indexOfString: aString) == 1! ! 
#('August 28, 2001' '10:17:20 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' beginsWith: )) !


!String methods ! 
asExclamationDoubledString
    | stream |
    (self indexOf: $!!) = 0 ifTrue: [^self].
    stream := WriteStream on: (String new: self size * 2).
    self do: [:character | stream nextPut: character. character == $!! ifTrue: [stream nextPut: character]].
    ^stream contents!   ! 
#('March 8, 2003' '08:43:38 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('hyperdrive extensions' asExclamationDoubledString )) !


!String methods ! 
asPoint3D
    "Return a Point3D with the x, y, and z value contained in this string."

    | substrings |
    substrings := (self replaceAll: ',' with: ' ') asArrayOfSubstrings.
    substrings size ~= 3 ifTrue: [^self error: 'Cannot convert string to Point3D'].
    ^Point3D x: substrings first asNumber asFloat y: (substrings at: 2) asNumber asFloat z: substrings last asNumber asFloat!   ! 
#('December 21, 2001' '05:07:58 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' asPoint3D )) !


!String methods ! 
fromStoreString
        "Given a store string, discard leading and trailing quote and remove doubled quotes..."
        "    'It''s me' storeString fromStoreString   "
        | odd character stream |
        (self size < 2 or: [self first ~~ $' or: [self last ~~ $']]) ifTrue: [self halt: 'Improper store string'].
        odd := true. "Keep only the odd quotes."
        stream := WriteStream on: (String new: self size).
        2 to: self size - 1 do: [:index |
            (character := self at: index) ~~ $' 
                ifTrue: [stream nextPut: character] 
                ifFalse: [odd ifTrue: [stream nextPut: character]. odd := odd not]].
        ^stream contents!   ! 
#('March 9, 2003' '03:07:08 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('hyperdrive extensions' fromStoreString )) !


!String methods !
replaceAllIgnoringCase: aString with: newString
    | start index lowercaseSelf lowercaseString result |
    "('This IS an interesting story, iSN''t it.' replaceAllIgnoringCase: 'is' with: 'XX')"
    lowercaseSelf := self asLowercase.
    lowercaseString := aString asLowercase.
    start := 1. result := WriteStream on: ''.
    [(index := lowercaseSelf indexOfString: lowercaseString startingAt: start) > 0] whileTrue: [
        result nextPutAll: (self copyFrom: start to: index - 1); nextPutAll: newString.
        start := index + lowercaseString size].
    result nextPutAll: (self copyFrom: start to: self size).
    ^result contents!  ! 
#('May 5, 2013' '10:33:41 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('no category methods' replaceAllIgnoringCase:with: )) !


!String methods !   
asSuggestedFileName
    | string |
    string := self asAlphaNumeric.
    ^string isEmpty ifTrue: ['unnamed'] ifFalse: [string]! ! 
#('March 23, 2003' '12:59:32 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('hyperdrive extensions' asSuggestedFileName )) !


!String methods !   
asZeroPaddedPoint3D
    "Return a Point3D with the x, y, and z value contained in this string."

    | substrings |
    substrings := (self replaceAll: ',' with: ' ') asArrayOfSubstrings, (Array with: 0.0 with: 0.0).
    ^Point3D x: substrings first asNumber asFloat y: substrings second asNumber asFloat z: substrings third asNumber asFloat! ! 
#('November 11, 2002' '03:03:32 PM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('no category methods' asZeroPaddedPoint3D )) !


!String methods !  
sequenceNumberSuffix
        "Returns '29' given 'test29' or nil if there is no digit."
    | number multiplier|
    self last isDigit ifFalse: [^nil].
    number := 0.
    multiplier := 1.
    self reverseDo: [:character |
        character isDigit ifFalse: [^number].
        number := number + (multiplier * character digitValue).
        multiplier := multiplier * 10].
    ^number
!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' sequenceNumberSuffix )) !


!String methods !
sequenceNumberSuffix
    "Returns '29' given 'test29' or nil if there is no digit."
    | number multiplier|
    self last isDigit ifFalse: [^nil].
    number := 0.
    multiplier := 1.
    self reverseDo: [:character |
        character isDigit ifFalse: [^number].
        number := number + (multiplier * character digitValue).
        multiplier := multiplier * 10].
    ^number!    ! 
#('July 16, 2008' '12:22:02 PM' 695160)!

(CodeFiler organizerFor: String) reorganizeFrom: #(
('extensions' sequenceNumberSuffix )) !


!String class methods ! 
lf
    ^Lf!    ! 
#('January 20, 2003' '10:53:25 AM' nil)!

(CodeFiler organizerFor: String class) reorganizeFrom: #(
('extensions' lf )) !


!String class methods ! 
lf
    ^String with: Lf!   ! 
#('October 10, 2006' '10:27:36 AM' 696292)!

(CodeFiler organizerFor: String class) reorganizeFrom: #(
('extensions' lf )) !


!String class methods !  
tab
    ^Tab!  ! 
#('January 20, 2003' '10:53:25 AM' nil)!

(CodeFiler organizerFor: String class) reorganizeFrom: #(
('extensions' tab )) !


!String class methods !
tab
    ^String with: Tab! ! 
#('October 10, 2006' '10:28:01 AM' 696660)!

(CodeFiler organizerFor: String class) reorganizeFrom: #(
('extensions' tab )) !


!String class methods ! 
crlf
    ^String with: Cr with: Lf!    ! 
#('December 5, 2007' '09:38:14 AM' nil)!

(CodeFiler organizerFor: String class) reorganizeFrom: #(
('extensions' crlf )) !


!String class methods !   
cr
    ^Cr!    ! 
#('January 20, 2003' '10:53:25 AM' nil)!

(CodeFiler organizerFor: String class) reorganizeFrom: #(
('extensions' cr )) !


!String class methods ! 
cr
    ^String with: Cr!   ! 
#('October 10, 2006' '10:27:31 AM' 697232)!

(CodeFiler organizerFor: String class) reorganizeFrom: #(
('extensions' cr )) !


!String class methods !  
space
    ^Space!  ! 
#('January 20, 2003' '10:53:25 AM' nil)!

(CodeFiler organizerFor: String class) reorganizeFrom: #(
('extensions' space )) !


!String class methods !  
space
    ^String with: Space! ! 
#('October 10, 2006' '10:27:54 AM' 697600)!

(CodeFiler organizerFor: String class) reorganizeFrom: #(
('extensions' space )) !


!String class methods !   
null
    ^Character value: 0!  ! 
#('January 20, 2003' '10:53:25 AM' nil)!

(CodeFiler organizerFor: String class) reorganizeFrom: #(
('extensions' null )) !


!String class methods !   
null
    ^String with: (Character value: 0)!   ! 
#('October 10, 2006' '10:27:48 AM' 697984)!

(CodeFiler organizerFor: String class) reorganizeFrom: #(
('extensions' null )) !


   

String variableByteSubclass: #DoubleByteString
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Collections' )
  comment: ''!

 

DoubleByteString variableByteSubclass: #DoubleByteSymbol
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Collections' )
  comment: ''!

   

Object subclass: #StringModel
  instanceVariableNames: 
    ' lines extent lastChild frame topCorner charScanner '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'Base-Text' )
  comment: ''!

!StringModel methods !  
display: aRectangle
        "Display the text contained in aRectangle."

    | sourceY dest lastY sourceX minY font |
    charScanner := lastChild pen.
    font := charScanner font.
    sourceX := aRectangle origin x.
    sourceY := aRectangle origin y.
    lastY := aRectangle corner y.
    dest := (frame leftTop x
        left: (lastChild topCorner x - 1 * font width)) @ ((frame leftTop y down: font basePoint y)
        down:  (sourceY - lastChild  topCorner y * font height)).

    lines size >= sourceY ifTrue: [
        (sourceY = lastY) ifTrue: [ "single line"
            lastChild doGraphics: [charScanner
                align: (lines at: sourceY)
                at: dest
                showFrom: sourceX].
            ^self].
        "display first line for multi lines"
            lastChild doGraphics: [charScanner
                align: (lines at: sourceY)
                at: dest
                showFrom: 1 "sourceX"]].
    lastChild doGraphics: [
    minY := lastY min: lines size.
    sourceY + 1 to: minY do: [ :i |
        dest y: (dest y down: font height).
        charScanner
            lineDisplay: (lines at: i)
            at: dest].
    minY < lastY
        ifTrue: [
            minY := minY max: sourceY - 1. "for case sourceY > minY"
            charScanner
                blankRestFrom:
                    (frame leftTop y
                        down:
                            (minY - lastChild topCorner y + 1 * font height))]]!    ! 
#('April 12, 2002' '10:30:04 AM' nil)!

(CodeFiler organizerFor: StringModel) reorganizeFrom: #(
('no category methods' display: )) !




Object subclass: #StringReference
  instanceVariableNames: ''
  classVariableNames: 
    ' DefaultSubclass '
  poolDictionaries: ''
  categories: #( 'Kernel-Source Management' )
  comment: ''!

  

StringReference subclass: #SourceChunkReference
  instanceVariableNames: 
    ' position streamReference '
  classVariableNames: 
    ' InAssociatedFileIndex StreamIndexBits WithMethodIndex '
  poolDictionaries: ''
  categories: #( 'Kernel-Source Management' )
  comment: ''!

  

PropertyAccessor subclass: #StylePropertyAccessor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

StylePropertyAccessor subclass: #MaskedStylePropertyAccessor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

String variableByteSubclass: #Symbol
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Collections' )
  comment: ''!

!Symbol methods !  
storeOn: aStream
    "Append the text representation of the receiver to aStream from which the receiver can be reconstructed."
    self isSelectorName ifTrue: [aStream nextPut: $#; nextPutAll: self. ^self].
    aStream nextPut: $#. super printOn: aStream.! ! 
#('March 30, 2003' '07:14:13 PM' nil)!

(CodeFiler organizerFor: Symbol) reorganizeFrom: #(
('no category methods' storeOn: )) !


!Symbol class methods !  
privateSymbolTable
    "CAUTION: Really private"

    ^SymbolTable!  ! 
#('May 6, 2002' '02:12:50 PM' nil)!

(CodeFiler organizerFor: Symbol class) reorganizeFrom: #(
('extensions' privateSymbolTable )) !


 

HashedCollection subclass: #SymbolSet
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Collections' )
  comment: ''!

 

Dictionary subclass: #SystemDictionary
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants '
  categories: #( 'Kernel-Special Objects' )
  comment: ''!

!SystemDictionary methods !
logMemory: aString
    true ifTrue: [^self].
    Transcript cr; << aString; << ' Mem = '; << self freePhysicalSpacePercentage
!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SystemDictionary) reorganizeFrom: #(
('extensions' logMemory: )) !


!SystemDictionary methods !  
freePhysicalSpace
        "Answer an integer which is the number of bytes of unused physical
        memory available."
    | status |
    status := WinMemorystatus new.
    KernelLibrary globalMemoryStatus: status asParameter.
    ^status dwAvailPhys!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SystemDictionary) reorganizeFrom: #(
('extensions' freePhysicalSpace )) !


!SystemDictionary methods !   
freePhysicalSpacePercentage
        "Answer a percentage which is the fraction of total physical memory which is still unused."

    | status total|
    status := WinMemorystatus new.
    KernelLibrary globalMemoryStatus: status asParameter.
    ^(status dwAvailPhys / status dwTotalPhys) asFloat! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SystemDictionary) reorganizeFrom: #(
('extensions' freePhysicalSpacePercentage )) !




StreamReference subclass: #SystemStreamReference
  instanceVariableNames: 
    ' fileIndex '
  classVariableNames: 
    ' StreamReferenceArray '
  poolDictionaries: ''
  categories: #( 'Kernel-Source Management' )
  comment: ''!

 

Object subclass: #TabControlItem
  instanceVariableNames: 
    ' eventTable label image tip parent titleForParent '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

TabControlItem subclass: #TabControlPage
  instanceVariableNames: 
    ' controls cachedState orderedChildren '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

Object subclass: #TersecriptWindow
  instanceVariableNames: 
    ' terse promptForErrors '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Windows-Views' )
  comment: ''!

!TersecriptWindow methods !   
print: anObject
    terse ifTrue: [^self].
    Transcript print: anObject!    ! 
#('May 15, 2003' '05:03:35 PM' nil)!

(CodeFiler organizerFor: TersecriptWindow) reorganizeFrom: #(
('delegation' print: )) !


!TersecriptWindow methods ! 
terse: aBoolean
    terse := aBoolean! ! 
#('May 15, 2003' '05:03:35 PM' nil)!

(CodeFiler organizerFor: TersecriptWindow) reorganizeFrom: #(
('get/set' terse: )) !


!TersecriptWindow methods !
<< anObject
    terse ifTrue: [^self].
    Transcript << anObject!    ! 
#('May 15, 2003' '05:03:35 PM' nil)!

(CodeFiler organizerFor: TersecriptWindow) reorganizeFrom: #(
('delegation' << )) !


!TersecriptWindow methods ! 
promptForErrors: aBoolean
    promptForErrors := aBoolean! ! 
#('September 22, 2003' '09:10:43 AM' nil)!

(CodeFiler organizerFor: TersecriptWindow) reorganizeFrom: #(
('get/set' promptForErrors: )) !


!TersecriptWindow methods !
space
    terse ifTrue: [^self].
    Transcript space!    ! 
#('May 15, 2003' '05:03:35 PM' nil)!

(CodeFiler organizerFor: TersecriptWindow) reorganizeFrom: #(
('delegation' space )) !


!TersecriptWindow methods !  
tab
    terse ifTrue: [^self].
    Transcript tab!    ! 
#('May 15, 2003' '05:03:35 PM' nil)!

(CodeFiler organizerFor: TersecriptWindow) reorganizeFrom: #(
('delegation' tab )) !


!TersecriptWindow methods !
nextPut: aCharacter
    terse ifTrue: [^self].
    Transcript nextPut: aCharacter!    ! 
#('May 15, 2003' '05:03:35 PM' nil)!

(CodeFiler organizerFor: TersecriptWindow) reorganizeFrom: #(
('delegation' nextPut: )) !


!TersecriptWindow methods !   
nextPutAll: aString
    terse ifTrue: [^self].
    Transcript nextPutAll: aString!    ! 
#('May 15, 2003' '05:03:35 PM' nil)!

(CodeFiler organizerFor: TersecriptWindow) reorganizeFrom: #(
('delegation' nextPutAll: )) !


!TersecriptWindow methods !
space: number
    terse ifTrue: [^self].
    Transcript space: number!    ! 
#('May 15, 2003' '05:03:35 PM' nil)!

(CodeFiler organizerFor: TersecriptWindow) reorganizeFrom: #(
('delegation' space: )) !


!TersecriptWindow methods ! 
error: message
    self promptForErrors ifTrue: [MessageBox message: message. ^self].
    self cr; << '*** Error, '; << message!  ! 
#('September 22, 2003' '09:10:43 AM' nil)!

(CodeFiler organizerFor: TersecriptWindow) reorganizeFrom: #(
('delegation' error: )) !


!TersecriptWindow methods !   
error: message
    self promptForErrors ifTrue: [MessageBox confirmContinue: message. ^self].
    self cr; << '*** Error, '; << message!  ! 
#('September 22, 2003' '09:10:47 AM' 707124)!

(CodeFiler organizerFor: TersecriptWindow) reorganizeFrom: #(
('delegation' error: )) !


!TersecriptWindow methods !
next: anInteger put: aCharacter
    terse ifTrue: [^self].
    Transcript next: anInteger put: aCharacter!    ! 
#('May 15, 2003' '05:03:35 PM' nil)!

(CodeFiler organizerFor: TersecriptWindow) reorganizeFrom: #(
('delegation' next:put: )) !


!TersecriptWindow methods !  
cr
    terse ifTrue: [^self].
    Transcript cr!  ! 
#('May 15, 2003' '05:03:35 PM' nil)!

(CodeFiler organizerFor: TersecriptWindow) reorganizeFrom: #(
('delegation' cr )) !


!TersecriptWindow methods ! 
terse
    ^terse!  ! 
#('May 15, 2003' '05:03:35 PM' nil)!

(CodeFiler organizerFor: TersecriptWindow) reorganizeFrom: #(
('get/set' terse )) !


!TersecriptWindow methods ! 
promptForErrors
    ^promptForErrors!  ! 
#('September 22, 2003' '09:10:43 AM' nil)!

(CodeFiler organizerFor: TersecriptWindow) reorganizeFrom: #(
('get/set' promptForErrors )) !


!TersecriptWindow class methods !   
initializeTersecript
    Tersecript := self new terse: false.! ! 
#('May 15, 2003' '10:33:03 PM' nil)!

(CodeFiler organizerFor: TersecriptWindow class) reorganizeFrom: #(
('initializing' initializeTersecript )) !


!TersecriptWindow class methods ! 
initializeTersecript
    "TersecriptWindow initializeTersecript"
    Tersecript := self new terse: false.!    ! 
#('May 15, 2003' '10:33:04 PM' 708660)!

(CodeFiler organizerFor: TersecriptWindow class) reorganizeFrom: #(
('initializing' initializeTersecript )) !


!TersecriptWindow class methods !  
initializeTersecript
    "TersecriptWindow initializeTersecript"
    Tersecript := self new terse: false; promptForErrors: true!  ! 
#('September 22, 2003' '09:10:43 AM' 708920)!

(CodeFiler organizerFor: TersecriptWindow class) reorganizeFrom: #(
('initializing' initializeTersecript )) !


 

CompilerErrorHandler subclass: #TextPaneErrorHandler
  instanceVariableNames: 
    ' pane compiler '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Compiler Support' )
  comment: ''!

!TextPaneErrorHandler methods !   
reportWarning: error
    "Private - report warnings and let the user decide whether to continue."

    ( MessageBox confirm: 'compilation warning: ',  error errorMessage, ' - continue?' )
        ifFalse: [ error retry. self reportFatal: error ].
    ^self!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: TextPaneErrorHandler) reorganizeFrom: #(
('no category methods' reportWarning: )) !




TextPaneErrorHandler subclass: #PARTSTextPaneErrorHandler
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

Object subclass: #TextSelection
  instanceVariableNames: 
    ' begin end pane extendOrigin selectFlag '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Text' )
  comment: ''!

!TextSelection methods !
origin: beginPoint corner: endPoint
        "Change the origin and corner of the receiver
         to beginPoint and endPoint respectively."
    self hide.
    begin := extendOrigin := beginPoint.
    end := endPoint!  ! 
#('April 18, 2002' '11:38:14 AM' nil)!

(CodeFiler organizerFor: TextSelection) reorganizeFrom: #(
('no category methods' origin:corner: )) !




GraphicsTool subclass: #TextTool
  instanceVariableNames: 
    ' font fontsLoaded '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants GraphicsConstants OperatingSystemConstants '
  categories: #( 'Base-Graphics' )
  comment: ''!

!TextTool methods ! 
bellThatWorks
    "Added because 'bell' doesn't work.  The parameters for beep are ignored on Win9x, so I'm just passing in zeros.
    This results in the 'Default sound' being played.  You can set this in the Sound control panel in Windows."
    ^OperatingSystem dingle!  ! 
#('March 5, 2004' '09:54:58 AM' nil)!

(CodeFiler organizerFor: TextTool) reorganizeFrom: #(
('extensions' bellThatWorks )) !


!TextTool methods ! 
bellThatWorks
    "Added because 'bell' doesn't work.  The parameters for beep are ignored on Win9x, so I'm just passing in zeros.
    This results in the 'Default sound' being played.  You can set this in the Sound control panel in Windows."
    ^UserLibrary messageBeep:  MbIconexclamation! ! 
#('March 5, 2004' '09:58:32 AM' 711320)!

(CodeFiler organizerFor: TextTool) reorganizeFrom: #(
('extensions' bellThatWorks )) !


!TextTool methods !  
bellThatWorks
    "Added because 'bell' doesn't work.  Currently plays the 'exclamation' sound -- you can set this
    (or disable it) in the Windows 'Sounds' control panel."

    ^UserLibrary messageBeep:  MbIconexclamation!   ! 
#('March 11, 2004' '09:09:47 AM' 711756)!

(CodeFiler organizerFor: TextTool) reorganizeFrom: #(
('extensions' bellThatWorks )) !




TextTool subclass: #Pen
  instanceVariableNames: 
    ' direction downState logicalBrush lineType compatibleDirection '
  classVariableNames: 
    ' ColorCount '
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Base-Graphics' )
  comment: ''!

!Pen methods ! 
ellipseUnfilled: boundingBox rotation: angle
    "Simulate ellipse drawing."
    "(x-cx)^2/a^2 + (y-cy)^2/b^2 = 1"

    | a b h k y c s lastPoint1 lastPoint2 newPoint1 newPoint2 rotate |
    a := boundingBox width // 2. b := boundingBox height // 2. h := boundingBox center x. k := boundingBox center y.
    h isInteger & k isInteger ifFalse: [self halt: 'Not integer'].

    c := angle negated degreesToRadians cos. s := angle negated degreesToRadians sin.
    rotate := [:p | ((p x * c) - (p y * s)) truncated @ ((p y  * c) + (p x * s)) truncated].

    lastPoint1 := lastPoint2 := (rotate value: (a negated @ 0)) + (h@k).
    a negated to: a do: [:x |
        y := ((b squared * (1 - (x squared / a squared))) asFloat) sqrt.
        newPoint1 := (rotate value: x@y) + (h@k). newPoint2 := (rotate value: x@(y negated)) + (h@k).
        "newPoint1 := rotate value: ((x+h) @ (y+k)). newPoint2 := rotate value: ((x+h) @ (y negated + k))."
        newPoint1 = lastPoint1 ifFalse: [self place: lastPoint1; goto: newPoint1. lastPoint1 := newPoint1].
        newPoint2 = lastPoint2 ifFalse: [self place: lastPoint2; goto: newPoint2. lastPoint2 := newPoint2]]! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Pen) reorganizeFrom: #(
('ellipse extension' ellipseUnfilled:rotation: )) !




Pen subclass: #RecordingPen
  instanceVariableNames: 
    ' currentId segments segmentIsOpen drawingMode archive '
  classVariableNames: ''
  poolDictionaries: 
    ' GraphicsConstants OperatingSystemConstants '
  categories: #( 'Base-Graphics' )
  comment: ''!



Magnitude subclass: #Time
  instanceVariableNames: 
    ' seconds '
  classVariableNames: 
    ' ValueArray '
  poolDictionaries: ''
  categories: #( 'Base-Magnitudes' )
  comment: ''!

!Time class methods !
waitForSeconds: seconds
    self delayFor: (seconds * 1000.0) asInteger!   ! 
#('August 4, 2008' '09:44:30 AM' nil)!

(CodeFiler organizerFor: Time class) reorganizeFrom: #(
('extensions' waitForSeconds: )) !


!Time class methods !  
delayFor: milliseconds

    | end |
    end := Time millisecondClockValue + milliseconds.
    [Time millisecondClockValue < end] whileTrue: [Processor yield].
    ^self!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Time class) reorganizeFrom: #(
('extensions' delayFor: )) !




EventManager subclass: #Timer
  instanceVariableNames: 
    ' period id '
  classVariableNames: 
    ' Timers '
  poolDictionaries: ''
  categories: #( 'Kernel-Processes and Events' )
  comment: ''!

   

TimeStamp subclass: #PARTSTimeStamp
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

Object subclass: #Tool
  instanceVariableNames: 
    ' selector owner rectangle space extent bitmap name '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants SystemColorConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

Object subclass: #ToolbarItem
  instanceVariableNames: 
    ' parent id bitmap tipText style state eventTable label bitmapIndex labelIndex index detached '
  classVariableNames: ''
  poolDictionaries: 
    ' WinCommonControlConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

ToolbarItem subclass: #ToolbarButton
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' WinCommonControlConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

ToolbarItem subclass: #ToolbarSeparator
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' WinCommonControlConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

ToolbarButton subclass: #ToolbarToggleButton
  instanceVariableNames: 
    ' value '
  classVariableNames: ''
  poolDictionaries: 
    ' WinCommonControlConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!


TooManyOpenFiles class instanceVariableNames: ''
  categories: #( )
  comment: ''!

  

SilentErrorHandler subclass: #TraditionalCompilerErrorHandler
  instanceVariableNames: 
    ' compiler '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Compiler Support' )
  comment: ''!

!TraditionalCompilerErrorHandler methods !
reportWarning: error
    "Private - report warnings and let the user decide whether to continue."
    ( MessageBox confirm: 'compilation warning: ',  error errorMessage, ' - continue?' )
        ifFalse: [ error retry ].
    ^self! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: TraditionalCompilerErrorHandler) reorganizeFrom: #(
('no category methods' reportWarning: )) !


 

ListItem subclass: #TreeViewItem
  instanceVariableNames: 
    ' image selectedImage hasChildren children childrenExpanded '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

Boolean subclass: #True
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Objects' )
  comment: ''!

!True methods !  
asInteger
    ^1!  ! 
#('September 26, 2006' '07:56:45 AM' nil)!

(CodeFiler organizerFor: True) reorganizeFrom: #(
('extensions' asInteger )) !


   

Object subclass: #UndefinedObject
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Special Objects' )
  comment: ''!

!UndefinedObject methods ! 
closeEditor: s! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: UndefinedObject) reorganizeFrom: #(
('extensions' closeEditor: )) !




Error subclass: #UnknownImport
  instanceVariableNames: 
    ' object '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

Object subclass: #UpgraderForDirectory
  instanceVariableNames: 
    ' drive pathName '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

Object subclass: #UpgraderForFile
  instanceVariableNames: 
    ' name directory '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

DynamicLinkLibrary variableByteSubclass: #UserDLL
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-DLLs' )
  comment: ''!

!UserDLL methods ! 
validateRect: aWindowHandle rectangle: aWinRectangle
    <api: ValidateRect ulong struct boolean>
    ^self invalidArgument!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: UserDLL) reorganizeFrom: #(
('extensions' validateRect:rectangle: )) !


!UserDLL methods !   
validateRect: aWindowHandle
    self validateRect: aWindowHandle rectangle: nil!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: UserDLL) reorganizeFrom: #(
('extensions' validateRect: )) !


!UserDLL methods ! 
getAsyncKeyState: nVirtKey
    <api: GetAsyncKeyState long short>
    ^self invalidArgument!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: UserDLL) reorganizeFrom: #(
('extensions' getAsyncKeyState: )) !


   

Object subclass: #VariableLocator
  instanceVariableNames: 
    ' binding '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Compiler Support' )
  comment: ''!

   

VariableLocator subclass: #VariableLocatorNoSource
  instanceVariableNames: 
    ' name stack argument '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Compiler Support' )
  comment: ''!

  

Object subclass: #ViewManager
  instanceVariableNames: 
    ' views '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Windows-Views' )
  comment: ''!

!ViewManager methods ! 
isOpen
    ^self mainView isOpen!  ! 
#('April 11, 2005' '08:23:06 AM' nil)!

(CodeFiler organizerFor: ViewManager) reorganizeFrom: #(
('extensions' isOpen )) !


   

ViewManager subclass: #AddressPaneTester
  instanceVariableNames: 
    ' address '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



ViewManager subclass: #Browser
  instanceVariableNames: ''
  classVariableNames: 
    ' DragDropEnabled '
  poolDictionaries: ''
  categories: #( 'Tools-Browsers' )
  comment: ''!

!Browser methods ! 
classFor: anObject
    ^anObject class!    ! 
#('March 30, 2003' '05:32:48 PM' nil)!

(CodeFiler organizerFor: Browser) reorganizeFrom: #(
('extensions' classFor: )) !




Browser subclass: #BrowserView
  instanceVariableNames: 
    ' codeBrowser textViewState savedStates updatesInProgress changeSet currentItems '
  classVariableNames: 
    ' Defaults '
  poolDictionaries: 
    ' CharacterConstants ColorConstants VirtualKeyConstants '
  categories: #( 'Tools-Navigator' )
  comment: ''!

!BrowserView methods !
systemDictionary
    ^codeBrowser systemDictionary!    ! 
#('November 13, 2001' '11:21:00 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('queries' systemDictionary )) !


!BrowserView methods !   
mputed by averaging the normals of all face planes
    that share the point."

    | faceData index facePointCopy facePointNormal facesContainingEqualPoint summation breakAngle |
    breakAngle := 60.0.
    
Transcript cr; << 'Recomputing '; << givenFaces size; << ' faces'' normals for object: '; << self name.

    "Gather each unique point and determine which faces contain it."
    faceData := OrderedCollection new.
    givenFaces do: [:face |
        face points do: [:point |
            index := self indexOf: point in: faceData.
            index = 0
                ifTrue: [
                    facesContainingEqualPoint := OrderedCollection with: face.
                    faceData add: (Array with: point shallowCopy with: facesContainingEqualPoint)]
                ifFalse: [
                    facesContainingEqualPoint := (faceData at: index) last.
                    facesContainingEqualPoint addIfIdenticalAbsent: face]]].

    "Average all the face normals and associate this average normal with the point (note we used a copy)."
    faceData groupsDo: [:point :faces |
        summation := faces inject: Point3D zero into: [:sum :face |
            sum + face plane normal].
        summation isZero
            ifTrue: [point normal: summation]
            ifFalse: [point normal: summation normalized]].

    "Destructively store into existing points (we have to search again but oh well)."
    givenFaces do: [:face |
        face points do: [:point |
            index := self indexOf: point in: faceData.
            facePointCopy := (faceData at: index) first.
            facePointNormal := facePointCopy normal.
            facePointNormal isZero ifTrue: [facePointNormal := face normal].
            "Only set new normal if it's lets than breakAngle degrees from the original normal."
            (point normal angleInDegreesTo: face normal) < breakAngle 
                ifTrue: [point normal: facePointNormal] 
                ifFalse: [point normal: face normal]]]! ! 
#('November 27, 2002' '11:39:28 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('class operations' referencesToInstanceVariables )) !


!BrowserView methods ! 
referencesToInstanceVariables

    | theClass instanceVariables answer selectors |

    theClass := self deepestCommonSuperclassOf: codeBrowser selectedSmalltalkClasses.
    instanceVariables := theClass allInstVarNamesGrouped.
    answer := ChooseManyDialog new
        openOn: instanceVariables
        label: 'Instance Variables of ', theClass name.

    answer notNil
        ifTrue: [
            selectors := answer inject: Set new into: [:sum :each |
                codeBrowser selectedSmalltalkClasses do: [:eachClass |
                    sum addAll: (eachClass allMethodsReferencingInstVar: each)].
                sum].
            MethodBrowser new
                label: 'References to ', (answer inject: '' into: [:sum :each | sum, each, ' ']);
                openOn: selectors].!  ! 
#('April 22, 2005' '09:45:10 AM' 722240)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('class operations' referencesToInstanceVariables )) !


!BrowserView methods ! 
updateMethods
    "Update my list of methods"

    (self paneNamed: 'methods') update: #restoreSelected: with: (codeBrowser selectedMethods collect: [:each | each asString]).
    self updateMethodMenu!   ! 
#('March 7, 2003' '06:25:55 PM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('updating' updateMethods )) !


!BrowserView methods ! 
findWildcardName: className
    "Return the name of the class specified by className, which is '<whatever>*'."

    | classes partialName name names pattern theClass |
    pattern := WildPattern new: className asLowercase.
    classes := self systemDictionary select: [:aClass |
        (aClass isBehavior)
            ifTrue: [(pattern matches: aClass name asLowercase)]
            ifFalse: [false]].
    names := classes keys asSortedCollection asArray.
    names size = 0 ifTrue: [MessageBox message: 'Class does not exist.'. ^nil].
    names size = 1 ifTrue: [^names first].

    theClass := (ChooseOneDialog new openOn: names label: 'Choose a Class').
    theClass isNil ifTrue: [^theClass].
    theClass notEmpty ifTrue: [theClass := theClass asString].
    ^theClass! ! 
#('March 30, 2003' '07:14:40 PM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('private' findWildcardName: )) !


!BrowserView methods ! 
exportChangeSetWith: aCodeWriterClass
    "Export the current change set with the current code writer"

    | fileName file |
    fileName := (changeSet name copyWithout: Space), '.st'.
    fileName := (FileDialog new saveFile: fileName) file.
    fileName isNil ifTrue: [^self].
    file := File newFile: fileName.
    [changeSet exportOn: file with: aCodeWriterClass] ensure: [file close]! ! 
#('January 15, 2002' '10:32:10 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('filing out' exportChangeSetWith: )) !


!BrowserView methods ! 
codeFilerClass
    ^CodeFiler! ! 
#('October 26, 2002' '11:02:26 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('queries' codeFilerClass )) !


!BrowserView methods !  
updateProtocolMenu
    "Update the protocol menu to reflect the current state of the selection"

    | menu items |

    (menu := self menuTitled: 'Protocol') isNil
        ifTrue: [^self].

    codeBrowser selectedClasses size = 1
        ifTrue: [self enable: #(addProtocol findMethod) inMenu: menu]
        ifFalse: [self disable: #(addProtocol findMethod) inMenu: menu].

    items := #(copyProtocolsToNewClass renameProtocols updateClassOrganizer removeProtocols 'File Out...').
    codeBrowser selectedProtocols isEmpty
         ifTrue: [self disable: items inMenu: menu]
        ifFalse: [self enable: items inMenu: menu].

    items :=  #(removeProtocols).
    (codeBrowser selectedProtocols size = 1 and: [codeBrowser selectedProtocol = codeBrowser selectedMethodOrganizer defaultCategory])
         ifTrue: [self disable: items inMenu: menu]! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('updating' updateProtocolMenu )) !


!BrowserView methods !  
copyMethodsToNewClass
    "Copy all the selected methods to a new class specified by the user"

    | theClass newClass stream methodOrganizer protocol |

    newClass := PrompterDialog
        title: 'Navigator Browser'
        prompt: 'Copy the selected protocols to which class?'
        default: codeBrowser selectedClass
        history: codeBrowser classes.

    (newClass isNil or: [newClass isEmpty])
        ifTrue: [^self].
    newClass := newClass trimBlanks.
    (self systemDictionary includesKey: newClass asSymbol)
        ifFalse: [^MessageBox message: 'No such class'].
    self class rememberClass: newClass.
    newClass := self classForClassName: newClass.

    CursorManager execute changeFor: [
        codeBrowser copySelectedMethodsTo: newClass.
        methodOrganizer := self codeFilerClass organizerFor: newClass.
        codeBrowser selectedMethods do: [:eachSelector |
            protocol := methodOrganizer categoryOfElement: eachSelector.
            changeSet logChangeForSelector: eachSelector inProtocol: protocol inClass: newClass]].

    self updatePanesFrom: 'categories'!    ! 
#('March 29, 2003' '09:13:13 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('reorganizing' copyMethodsToNewClass )) !


!BrowserView methods !
createTextInFrame: frame
    "Add a pane to myself that will display an appropriate piece of text."

    | thisPane |

    ((thisPane := self toolTextPaneClass new)
        owner: self;
        paneName: 'textPane';
        when: #needsContents send: #textForPane: to: self with: thisPane;
        when: #aboutToSave send: #acceptFromPane: to: self with: thisPane;
        when: #controlTabbed send: #cycleCurrentState to: self;
        framingRatio: frame).
    (thisPane canTriggerEvent: #needsAutoCompleteList) ifTrue: [
        thisPane when: #needsAutoCompleteList send: #autoCompleteListForPane: to: self with: thisPane].

    self addSubpane: thisPane.
    "self icon: (Icon fromModule: Icon defaultDLLFileName id:'ClassHierarchyBrowser')."!    ! 
#('July 29, 2002' '02:30:06 PM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('private-scheduling' createTextInFrame: )) !


!BrowserView methods !  
moveMethods
    "Move the selected methods from the selected protocol to another one"

    | destinationProtocol |

    self textModified
        ifTrue: [^self].
    destinationProtocol := PrompterDialog
        title: 'Navigator Browser'
        prompt: 'Move selected methods where?'
        default: codeBrowser selectedProtocol
        history: codeBrowser protocols.
    destinationProtocol isNil ifTrue: [^self].
    codeBrowser selectedMethods do: [:each |
        changeSet logChangeForSelector: each inProtocol: destinationProtocol inClass: codeBrowser selectedSmalltalkClassOrMetaclass].
        currentItems := changeSet
            itemsForMethods: codeBrowser selectedMethods
            inClasses: (self realClassNamesFrom: codeBrowser selectedClasses).
    codeBrowser moveSelectedMethodsTo: destinationProtocol.
    self updatePanesFrom: 'categories'.!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('reorganizing' moveMethods )) !


!BrowserView methods ! 
state
    "   ^   <ContainerObject>
    Answer a browserViewState which entirely captures my current state"

    | answer stateName textSelection cursorPosition anchorPosition textPane |

    stateName := WriteStream on: (String new).
    codeBrowser selectedClass notNil
        ifTrue: [stateName nextPutAll: codeBrowser selectedClassOrMetaclass].
    codeBrowser selectedMethod notNil
        ifTrue: [stateName nextPutAll: '>>', codeBrowser selectedMethod].

    textPane := self paneNamed: 'textPane'.
    textSelection := textPane selection.
    textSelection isString
        ifTrue: [cursorPosition := textPane cursorPosition. anchorPosition := textPane anchorPosition]
        ifFalse: [cursorPosition := textSelection corner. anchorPosition := textSelection origin].
    answer := ContainerObject new.
    answer
        changeSet: changeSet;
        selection: codeBrowser selection deepCopy;
        textViewState: self textViewState;
        text: textPane contents;
        isModified: textPane modified;
        name: stateName contents;
        classOrInstanceMode: codeBrowser classOrInstanceMode;
        selectedTextOrigin:  anchorPosition;
        selectedTextCorner: cursorPosition;
        zoomed: self mainView zoomed.
    ^answer! ! 
#('May 3, 2002' '03:51:42 PM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('browser state operations' state )) !


!BrowserView methods !   
buildCategoryBrowser
    "private - build the panes for a category browser"

    | midY aRectangle buttonHeight categoryBox classBox protocolBox methodBox |

    midY := 4/9.
    buttonHeight := 1/9.
    categoryBox := 0 @ 0 corner: 1/4 @ midY.
    classBox := (1/4) @ 0 corner: 1/2 @ midY.
    protocolBox := (1/2) @ 0 corner: (3/4) @ midY.
    methodBox := (3/4) @ 0 corner: 1 @ midY.

    self
        createChangeSetListInFrame: [:rect | rect scaleTo: categoryBox];
        createChangeSetAnnotationInFrame: [:rect |
            aRectangle := rect scaleTo: (categoryBox merge: classBox).
            aRectangle origin + (4 @ (aRectangle height - ListFont height - 5)) corner: aRectangle corner - (4@0)];
        createCategoryListInFrame: [:rect |
            (rect scaleTo: categoryBox) insetBy: (0@(ListFont height + 7) corner: 0@(ListFont height + 5))];
        createClassListInFrame: [:rect |
            (rect scaleTo: classBox) insetBy: (0@0 corner: 0@(ListFont height + 5))];
        createProtocolListInFrame: [:rect |
            (rect scaleTo: protocolBox) insetBy: (0 @ 0 corner: 0 @ (ListFont height + 6))];
        createProtocolButtonInFrame: [:rect |
            aRectangle := rect scaleTo: protocolBox.
            aRectangle origin + (0 @ (aRectangle height - ListFont height - 6)) corner: aRectangle corner];
        createMethodListInFrame: [:rect |
            (rect scaleTo: methodBox) insetBy: (0 @ 0 corner: 0 @ (ListFont height + 5))];
        createAnnotationPaneInFrame: [:rect |
            aRectangle := rect scaleTo: methodBox.
            aRectangle origin + (4 @ (aRectangle height - ListFont height - 5)) corner: aRectangle corner - (4@0)];
        createTextInFrame: (0 @ midY corner: 1 @ 1)!   ! 
#('April 26, 2002' '12:31:29 PM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('private-scheduling' buildCategoryBrowser )) !


!BrowserView methods !   
createClassDefinitionButtonInFrame: frame
    "Add a pane to myself that will show annotations for the current change set"

    | thisPane |
    self addSubpane: ((thisPane := Button new)
        owner: self;
        paneName: 'classDefinitionButton';
        when: #clicked send: #instanceOrClassClicked: to: self with: thisPane;
        when: #needsContents send: #labelForProtocolButton: to: self with: thisPane;
        pushButton;
        framingBlock: frame).!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('private-scheduling' createClassDefinitionButtonInFrame: )) !


!BrowserView methods !   
open

    self
        labelWithoutPrefix: 'Navigator Browser';
        buildCategoryBrowser"WithoutChangeSets";
        openWindow;
        addBrowserMenu;
        updateMenus!    ! 
#('April 26, 2002' '12:33:47 PM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('scheduling' open )) !


!BrowserView methods !   
classForClassName: className
    ^codeBrowser isBrowsingClassMethods
        ifTrue: [(self systemDictionary at:  className asSymbol) class]
        ifFalse: [self systemDictionary at: className asSymbol].!   ! 
#('March 29, 2003' '09:12:28 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('queries' classForClassName: )) !


!BrowserView methods !
classForClassName: className
    ^codeBrowser isBrowsingClassMethods
        ifTrue: [self classFor: (self systemDictionary at:  className asSymbol)]
        ifFalse: [self systemDictionary at: className asSymbol].!  ! 
#('March 30, 2003' '05:40:25 PM' 736388)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('queries' classForClassName: )) !


!BrowserView methods ! 
privateUpdatePanesFrom: startPaneName to: endPaneName
    "Update the panes from startPaneName to endPaneName in my pane ordering"

    | panes methodName|

    ((panes := self class paneUpdateOrder)
        copyFrom: (panes indexOf: startPaneName) to: (panes indexOf: endPaneName)) do:  [:paneName |
                methodName := ('update', (String with: paneName first asUpperCase), paneName rest) asSymbol.
                self perform: methodName]!    ! 
#('March 7, 2003' '06:24:20 PM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('updating' privateUpdatePanesFrom:to: )) !


!BrowserView methods !
disable: items inMenu: menu
    "items      <collection of symbols>
     Disable all of the named items in menu"

    items do: [:each | menu disableItem: each]!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('private-menu support' disable:inMenu: )) !


!BrowserView methods ! 
protocolMenuForPane: aPane
    "Answer the menu for the protocols pane"

    | menu fileOutMenu tab |
    tab := String with: Tab.
    fileOutMenu := self codeWriterClass codeWriterMenuWith: [:aCodeWriterClass | self fileOutProtocolsWith: aCodeWriterClass].
    fileOutMenu
        owner: self;
        title: 'File Out...'.

    menu := Menu new
        title: 'Protocol';
        owner: self;
        appendItem: 'Add...' selector: #addProtocol;
        appendItem: 'Add To Changes' action: [:owner | self logChangeForSelectedProtocols; update];
        appendSeparator;
        appendSubMenu: fileOutMenu;
        appendItem: 'Find Method...', tab, 'Ctrl-Shift-F' selector: #findMethod accelKey: $F accelBits: AfControl | AfShift;
        appendItem: 'Copy...' selector: #copyProtocolsToNewClass;
        appendItem: 'Rename...' selector: #renameProtocols;
        appendSeparator;
        appendItem: 'Remove...' selector: #removeProtocols;
        yourself.
    aPane notNil ifTrue: [aPane setMenu: menu].
    ^menu!   ! 
#('March 8, 2003' '09:47:11 PM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('menus' protocolMenuForPane: )) !


!BrowserView methods ! 
createProtocolListInFrame: frame
    "Add a pane to myself that will list protocols"

    | thisPane |

    self addSubpane: ((thisPane := ColorMultipleSelectListBox new)
        owner: self;
        paneName: 'protocols';
        extendedSelect;
        ownerDrawFixed;
        when: #needsContents send: #protocolsForPane: to: self with: thisPane;
        when: #changed: send: #selectProtocolsForPane: to: self with: thisPane;
        when: #needsMenu send: #protocolMenuForPane: to: self with: thisPane;
        when: #tabbed send: #cycleCurrentState to: self;
        when: #backTabbed send: #cycleCurrentState to: self;
        framingBlock: frame).! ! 
#('April 19, 2002' '11:21:55 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('private-scheduling' createProtocolListInFrame: )) !


!BrowserView methods ! 
acceptForViewingClassDefinition: pane
    "Accept a class definition for the currently selected class"

    | result |
    CursorManager execute changeFor: [
        result := Compiler
         evaluate: pane contents
            in: nil class
            to: nil
            notifying: pane
           ifFail: [nil]].
    pane modified: (result isKindOf: Class) not.
    result isNil ifTrue: [^self].
    self sourceManager logEvaluate: pane contents.
    codeBrowser selectedClasses: (Array with: result symbol trimBlanks asString).
    changeSet logChangeForClass: result.
    currentItems := changeSet itemsForCategories: codeBrowser selectedCategories.
    changeSet isNonRecordingChangeSet
        ifTrue: [self updatePanesFrom: 'classes']
        ifFalse: [self update]!    ! 
#('March 3, 2003' '10:13:24 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('private-text pane support' acceptForViewingClassDefinition: )) !


!BrowserView methods ! 
removeCategories
    "Prompt the user, then remove the selected categories, and all of the classes that they contain."

   | question classes |
    self textModified
        ifTrue: [^self].
    classes := codeBrowser selectedCategories inject: Set new into: [:sum :each |
        sum addAll: (codeBrowser selectedClassOrganizer elementsOfCategory: each); yourself].

    codeBrowser selectedCategories size > 1
        ifTrue: [question := 'Remove the selected categories?']
        ifFalse: [question := 'Remove category ', codeBrowser selectedCategory, '?'].

    (classes isEmpty or: [MessageBox confirm: question])
        ifTrue: [
            codeBrowser removeSelectedCategories.
            self updatePanesFrom: 'categories']!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('reorganizing' removeCategories )) !


!BrowserView methods !
renameCategories
    "Prompt the user to rename each of the selected categories, and then rename them"

    | answer newCategories |
    self textModified
        ifTrue: [^self].

    newCategories := OrderedCollection new.
    codeBrowser selectedCategories do: [:each |
        answer := PrompterDialog
            title: 'Navigator Browser'
            prompt: 'rename ', each, ' as:'
            default: each
            history: self class previousCategories.
        (answer isNil or: [answer isEmpty])
            ifTrue: [^self]
            ifFalse: [
                newCategories add: answer.
                self class rememberCategory: answer]].
    codeBrowser
        renameSelectedCategoriesTo: newCategories;
        selectedCategories: newCategories.
    self updatePanesFrom: 'categories'.!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('reorganizing' renameCategories )) !


!BrowserView methods !
initializeWithCodeBrowser: aCodeBrowser

    self initialize.
    updatesInProgress := false.
    codeBrowser := aCodeBrowser.
    changeSet := self codeFilerClass changeSetManager changeSets first.
    self
        viewNothing;
        savedStates: OrderedCollection new.!   ! 
#('October 26, 2002' '11:05:46 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('initializing' initializeWithCodeBrowser: )) !


!BrowserView methods ! 
fileOutClassesWith: aCodeWriterClass
    "file out  the selected classes"

    | fileName file |
    codeBrowser selectedClasses size > 1
        ifTrue: [fileName := 'classes.st']
        ifFalse: [fileName := (codeBrowser selectedClass copyWithout: Space), '.st'].
    fileName := (FileDialog new saveFile: fileName) file.
    fileName isNil ifTrue: [^self].
    file := File newFile: fileName.
    [codeBrowser fileOutSelectedClassesOn: file with: aCodeWriterClass] ensure: [file close].!   ! 
#('January 15, 2002' '10:34:40 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('filing out' fileOutClassesWith: )) !


!BrowserView methods !  
sourceManager
    ^SourceManager current!  ! 
#('March 3, 2003' '10:13:24 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('queries' sourceManager )) !


!BrowserView methods !  
createClassListInFrame: frame
    "Add a pane to myself that will list classes"

    | thisPane |

    self addSubpane: ((thisPane := ColorMultipleSelectListBox new)
        owner: self;
        paneName: 'classes';
        extendedSelect;
        ownerDrawFixed;
        when: #needsContents send: #classesForPane: to: self with: thisPane;
        when: #changed: send: #selectClassesForPane: to: self with: thisPane;
        when: #needsMenu send: #classMenuForPane: to: self with: thisPane;
        when: #tabbed send: #cycleCurrentState to: self;
        when: #backTabbed send: #cycleCurrentState to: self;
        framingBlock: frame).!   ! 
#('April 19, 2002' '11:21:46 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('private-scheduling' createClassListInFrame: )) !


!BrowserView methods !
restoreStateFrom: state
    "   state:  <ContainerObject>
    Restore my state from state"

    | textPane |

    textPane := self paneNamed: 'textPane'.
    codeBrowser
        selection: state selection deepCopy;
        classOrInstanceMode: state classOrInstanceMode.
    self textViewState: state textViewState.
    changeSet := state changeSet.
    textPane modified: false.
    self update.
    self mainView zoomed == state zoomed ifFalse: [self zoom].
    textPane
        contents: state text;
        modified: state isModified;
        selectFrom: state selectedTextOrigin to: state selectedTextCorner;
        invalidateRect: nil;
        forceSelectionOntoDisplay;
        setFocus.
! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('browser state operations' restoreStateFrom: )) !


!BrowserView methods !   
referencesToSelectedClasses
    "open a methodBrowser on all methods in Smalltalk which reference the selected classes"

    | methods allClasses label |

    allClasses := (self systemDictionary rootClasses inject: OrderedCollection new into: [:sum :each |
            sum, each withAllSubclasses]).
    methods := codeBrowser selectedClasses inject: OrderedCollection new into: [:sum :each |
        sum, (self sendersOf: (Array with: (self systemDictionary associationAt: each asSymbol)) in: allClasses)].

    methods isEmpty ifTrue: [^MessageBox message: 'No references'].

    label := WriteStream on: (String new: 80).
    codeBrowser selectedClasses do: [:each |
        label nextPutAll: each.
        label space; space].

    ^MethodBrowser new
        literal: codeBrowser selectedClass;
        label: 'References to ' , label contents;
        openOn: methods asSet asArray.!   ! 
#('November 13, 2001' '11:21:42 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('class operations' referencesToSelectedClasses )) !


!BrowserView methods !   
referencesToSelectedClasses
    "open a methodBrowser on all methods in Smalltalk which reference the selected classes"
    
    ^self referencesToSelectedClassesIfNone: [^MessageBox message: 'No references']!    ! 
#('April 21, 2005' '10:16:21 AM' 746268)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('class operations' referencesToSelectedClasses )) !


!BrowserView methods !   
fileOutChangeSetWith: aCodeWriterClass
    "File out the current change set with the current code writer"

    | fileName file |
    fileName := (changeSet name copyWithout: Space), '.st'.
    fileName := (FileDialog new saveFile: fileName) file.
    fileName isNil ifTrue: [^self].
    file := File newFile: fileName.
    [changeSet fileOutOn: file with: aCodeWriterClass] ensure: [file close]! ! 
#('January 15, 2002' '10:31:58 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('filing out' fileOutChangeSetWith: )) !


!BrowserView methods !
methodMessages
    "Open a messages selector browser for the selected method."

    | method |
    method := codeBrowser selectedMethod.
    CursorManager execute changeFor: [
        self sourceManager messagesIn: (codeBrowser selectedSmalltalkClassOrMetaclass compiledMethodAt: method)]! ! 
#('March 3, 2003' '10:13:24 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('method operations' methodMessages )) !


!BrowserView methods !   
highlightChangeSet

    changeSet := changeSet highlightsCopy.
    self codeFilerClass changeSetManager add: changeSet.
    self
        updateChangeSet;
        updatePanesFrom: 'categories'!  ! 
#('October 26, 2002' '11:05:25 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('change set operations' highlightChangeSet )) !


!BrowserView methods !
findMethod
    "Ask the user which method to find, and select it"

    | method |
    self textModifiedWithAutomaticPush ifTrue: [^self].
    method := PrompterDialog
        title: 'Navigator Browser'
        prompt: 'Find which method?'
        default: ''
        history: codeBrowser selectedMethodOrganizer elements asSortedCollection.
    (method isNil or: [method isEmpty]) ifTrue: [BrowserView automaticPush ifTrue: [self popLastState]. ^self].
    method := method asSymbol.
    codeBrowser
        selectedProtocols: (codeBrowser selectedMethodOrganizer categoriesOfElement: method);
        selectedMethods: (Array with: method).
    self updatePanesFrom: 'protocols'!  ! 
#('November 19, 2001' '09:25:42 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('method operations' findMethod )) !


!BrowserView methods !   
categoryMenuForPane: aPane
    "Answer the menu for the categories pane"

    | menu fileOutMenu tab |
    tab := String with: Tab.
    fileOutMenu := self codeWriterClass codeWriterMenuWith: [:aCodeWriterClass | self fileOutCategoriesWith: aCodeWriterClass].
    fileOutMenu
        owner: self;
        title: 'File Out...'.

    menu := Menu new
        title: 'Category';
        owner: self;
        appendItem: 'Add...' selector: #addCategory;
        appendSeparator;
        appendSubMenu: fileOutMenu;
        appendItem: 'Rename...' selector: #renameCategories;
        appendItem: 'Find Class...', tab, 'Alt+F' selector: #findClass acceleratorString: 'Alt+F';
        appendSeparator;
        appendItem: 'Remove...' selector: #removeCategories;
        yourself.
    aPane notNil
        ifTrue: [aPane setMenu: menu].
    ^menu!    ! 
#('March 8, 2003' '09:45:46 PM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('menus' categoryMenuForPane: )) !


!BrowserView methods ! 
referencesToSelectedClassesIfNone: ifNoneBlock
    "open a methodBrowser on all methods in Smalltalk which reference the selected classes"

    | methods allClasses label |

    allClasses := (self systemDictionary rootClasses inject: OrderedCollection new into: [:sum :each |
            sum, each withAllSubclasses]).
    methods := codeBrowser selectedClasses inject: OrderedCollection new into: [:sum :each |
        sum, (self sendersOf: (Array with: (self systemDictionary associationAt: each asSymbol)) in: allClasses)].

    methods isEmpty ifTrue: [^ifNoneBlock value].

    label := WriteStream on: (String new: 80).
    codeBrowser selectedClasses do: [:each |
        label nextPutAll: each.
        label space; space].

    ^MethodBrowser new
        literal: codeBrowser selectedClass;
        label: 'References to ' , label contents;
        openOn: methods asSet asArray.!  ! 
#('April 21, 2005' '10:15:48 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('class operations' referencesToSelectedClassesIfNone: )) !


!BrowserView methods !   
commitSelection: aPane

    ^self textModifiedWithAutomaticPush not!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('text pane event handling' commitSelection: )) !


!BrowserView methods !
acceptForViewingClassComment: pane
    "Accept a class comment for the currently selected class"

    self codeFilerClass setCommentFor: codeBrowser selectedClass to: pane contents.
    changeSet logChangeForClassComment: codeBrowser selectedClass.
    pane modified: false.
    self updateChangeSet!  ! 
#('October 26, 2002' '11:07:14 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('private-text pane support' acceptForViewingClassComment: )) !


!BrowserView methods ! 
acceptForViewingMethodSource: aPane
    "Accept source code for the currently selected method"

    | result codeFiler oldMethod theClass protocol previousSourcePosition selector defaultProtocol sourceString |
    theClass := codeBrowser selectedSmalltalkClassOrMetaclass.
    codeFiler := self codeFilerClass forClass: theClass.
    CursorManager execute changeFor: [
        result := codeFiler compile: aPane contents notifying: aPane].
    result isNil
        ifTrue: [aPane modified: true]
        ifFalse: [
            aPane modified: false.
            protocol := self protocolForSelector: result key.
            (self codeFilerClass organizerFor: theClass) reorganize: (Array with: result key) into: (Array with: protocol).
            changeSet logChangeForSelector: result key inProtocol: protocol inClass: theClass.
            currentItems := changeSet
                itemsForMethods: (Array with: result key asString)
                inClasses: (self realClassNamesFrom: codeBrowser selectedClasses).
            changeSet isNonRecordingChangeSet
                ifTrue: [self updatePanesFrom: 'methods']
                ifFalse: [self update]].
    ^result!   ! 
#('October 26, 2002' '11:07:52 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('private-text pane support' acceptForViewingMethodSource: )) !


!BrowserView methods ! 
acceptForViewingMethodSource: aPane
    "Accept source code for the currently selected method"

    | result codeFiler oldMethod theClass protocol previousSourcePosition selector defaultProtocol sourceString |
    theClass := codeBrowser selectedSmalltalkClassOrMetaclass.
    codeFiler := self codeFilerClass forClass: theClass.
    CursorManager execute changeFor: [
        result := codeFiler compile: aPane contents notifying: aPane].
    result isNil
        ifTrue: [aPane modified: true]
        ifFalse: [
            aPane modified: false.
            protocol := self protocolForSelector: result key.
            (self codeFilerClass organizerFor: theClass) reorganize: (Array with: result key) into: (Array with: protocol).
            changeSet logChangeForSelector: result key inProtocol: protocol inClass: theClass.
            currentItems := changeSet
                itemsForMethods: (Array with: result key asString)
                inClasses: (self realClassNamesFrom: codeBrowser selectedClasses).
            changeSet isNonRecordingChangeSet
                ifTrue: [self updatePanesFrom: 'methods']
                ifFalse: [self update].
            self updateExternalBrowsers].
    ^result! ! 
#('January 26, 2008' '11:11:37 AM' 752996)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('private-text pane support' acceptForViewingMethodSource: )) !


!BrowserView methods !  
findClass
    "Prompt the user for a class to find, and select it in the browser"

    | className theClass |
    self textModifiedWithAutomaticPush ifTrue: [^self].

    className := PrompterDialog
        title: 'Navigator Browser'
        prompt: 'Find which class (* allowed)'
        default: self class previousClass
        history: self class previousClasses.
    (className isNil or: [className isEmpty])
        ifTrue: [BrowserView automaticPush ifTrue: [self popLastState].^self].

    (className includes: $*) ifFalse: [className := className, '*'].
    className := self findWildcardName: className.
    (className isNil or: [className isEmpty]) ifTrue: [BrowserView automaticPush ifTrue: [self popLastState]. ^self].

    theClass := self systemDictionary
        at: className trimBlanks asSymbol
        ifAbsent: [BrowserView automaticPush ifTrue: [self popLastState]. ^MessageBox message: 'Class does not exist.'].

    self update.
    (theClass isBehavior) ifFalse: [theClass := theClass class].
    BrowserView rememberClass: className.
    codeBrowser findClass: theClass name.
    self updatePanesAndMakeVisibleSelectionFrom: 'categories'!   ! 
#('March 30, 2003' '07:14:55 PM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('class operations' findClass )) !


!BrowserView methods !
fileOutCategoriesWith: aCodeWriterClass
    "file out  the selected categories"

    | fileName file |
    codeBrowser selectedCategories size > 1
        ifTrue: [fileName := 'classes.st']
        ifFalse: [fileName := (codeBrowser selectedCategory copyWithout: Space), '.st'].
    fileName := (FileDialog new saveFile: fileName) file.
    fileName isNil ifTrue: [^self].
    file := File newFile: fileName.
    [codeBrowser fileOutSelectedCategoriesOn: file with: aCodeWriterClass] ensure: [file close].!    ! 
#('January 15, 2002' '10:32:03 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('filing out' fileOutCategoriesWith: )) !


!BrowserView methods !   
updateBrowserMenu
    "Update the browser menu"

    | menu statesMenu items |
    (menu := self menuTitled: 'Browser') isNil
        ifTrue: [^self].

    items := #(popLastState exchangeCurrentState clearSavedStates).
    self savedStates isEmpty
         ifTrue: [self disable: items inMenu: menu]
        ifFalse: [self enable: items inMenu: menu].

    menu item: #toggleAutomaticPush checked: BrowserView automaticPush!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('updating' updateBrowserMenu )) !


!BrowserView methods !   
browseMethodVersions
    "Open a browser on all the versions of the currently selected method"

    | loadedVersion |

    loadedVersion := (self codeFilerClass forClass: codeBrowser selectedSmalltalkClassOrMetaclass)
        loadedVersionOf: codeBrowser selectedMethod.

    MethodVersionBrowser openOn: loadedVersion withAllPreviousVersions! ! 
#('October 26, 2002' '11:09:21 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('method operations' browseMethodVersions )) !


!BrowserView methods !  
codeWriterClass
    ^CodeWriter!   ! 
#('March 8, 2003' '09:24:09 PM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('queries' codeWriterClass )) !


!BrowserView methods !
changeSetMenuForPane: aPane
    "Answer the menu for the change set combo box."

    | menu fileOutMenu exportMenu |

    fileOutMenu := self codeWriterClass codeWriterMenuWith: [:aCodeWriterClass | self fileOutChangeSetWith: aCodeWriterClass].
    fileOutMenu
        owner: self;
        title: 'File Out...'.

    exportMenu := self codeWriterClass codeWriterMenuWith: [:aCodeWriterClass | self exportChangeSetWith: aCodeWriterClass].
    exportMenu
        owner: self;
        title: 'Export...'.

    menu := Menu new
        title: 'Changes';
        owner: self;

        appendItem: 'Add...' selector: #addChangeSet;
        appendSeparator;
        appendSubMenu: fileOutMenu;
        appendSubMenu: exportMenu;
        appendSeparator;
        appendItem: 'Browse...' action: [:owner | ChangeSetBrowser openOn: changeSet];
        appendSeparator;
        appendItem: 'Open' action: [:owner | changeSet allowChanges. self updateChangeSet];
        appendItem: 'Close' action: [:owner | changeSet disallowChanges. self updateChangeSet];
        appendItem: 'Comment' selector: #editChangeSetComment;
        appendItem: 'Rename...' selector: #renameChangeSet;
        appendItem: 'Highlights' selector: #highlightChangeSet;
        appendSeparator;
        appendItem: 'Remove...' selector: #removeChangeSet;
        yourself.

    aPane notNil
        ifTrue: [aPane setMenu: menu].
    ^menu!   ! 
#('March 8, 2003' '09:46:37 PM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('menus' changeSetMenuForPane: )) !


!BrowserView methods !
realClassNamesFrom: aCollection
    "Return a collection of the given class names, with a ' class' suffix if we're viewing metaclasses."

    | classMethods |
    classMethods := codeBrowser isBrowsingClassMethods.
    ^aCollection collect: [:each |
        classMethods
            ifTrue: [each trimBlanks, ' class']
            ifFalse: [each trimBlanks]]
!   ! 
#('March 29, 2003' '09:14:50 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('private' realClassNamesFrom: )) !


!BrowserView methods !   
realClassNamesFrom: aCollection
    "Return a collection of the given class names, with a ' class' suffix if we're viewing metaclasses."

    | classMethods |
    classMethods := codeBrowser isBrowsingClassMethods.
    ^aCollection collect: [:each | classMethods ifTrue: [each trimBlanks, ' class'] ifFalse: [each trimBlanks]]!    ! 
#('March 29, 2003' '09:14:50 AM' 760860)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('private' realClassNamesFrom: )) !


!BrowserView methods !
removeClasses
    "Remove the selected classes from Smalltalk. If there are methods in the system referencing
    the classes I'm deleting, then pop up a method browser on those methods"

    | question classes allClasses methods |

    self textModified
        ifTrue: [^self].
    codeBrowser selectedClasses size > 1
        ifTrue: [question := 'Remove the selected classes?']
        ifFalse: [question := 'Remove class ', codeBrowser selectedClass, '?'].
    (MessageBox confirm: question)
        ifFalse: [^self].

    classes := codeBrowser selectedSmalltalkClasses.
    allClasses := (self systemDictionary rootClasses inject: OrderedCollection new into: [:sum :each |
            sum, each withAllSubclasses]).
    allClasses removeAll: classes.
    methods := classes inject: OrderedCollection new into: [:sum :each |
        sum, (self sendersOf: (Array with: (self systemDictionary associationAt: each symbol)) in: allClasses)].

    methods notEmpty ifTrue: [
        MethodBrowser new
            label: 'References to deleted classes';
            openOn: methods asSet asArray].

    classes do: [:each |
        changeSet logChangeForRemoveClass: each].
    currentItems := changeSet itemsForCategories: codeBrowser selectedCategories.
    codeBrowser removeSelectedClasses.
    self updatePanesFrom: 'categories'!    ! 
#('November 13, 2001' '11:23:31 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('reorganizing' removeClasses )) !


!BrowserView methods ! 
renameClasses
    "Prompt the user to rename each of the selected classes, and then rename them"

    | answer oldClassNames newClassNames oldClass |

    self textModified ifTrue: [^self].
    oldClassNames := codeBrowser selectedClasses.
    newClassNames := OrderedCollection new.

    oldClassNames do: [:each |
        answer := PrompterDialog
            title: 'Navigator Browser'
            prompt: 'rename ', each, ' as:'
            default: each
            history: #().
        (answer isNil or: [answer isEmpty])
            ifTrue: [^self]
            ifFalse: [
                oldClass := Smalltalk at: each asSymbol ifAbsent: [nil].
                oldClass isMetaClass ifTrue: [MessageBox message: 'Cannot rename metaclasses such as ', each printString. ^self].
                oldClass isClass ifFalse: [MessageBox message: each printString, ' is not a class'. ^self].
                (Smalltalk includesKey: answer asSymbol) ifTrue: [MessageBox message: 'Name ', answer printString, ' is already in the dictionary...'. ^self].
                newClassNames add: answer]].

    self referencesToSelectedClassesIfNone: [].
    oldClassNames with: newClassNames do: [:oldName :newName |
        changeSet logChangeForRenameClass: oldName to: newName].
    codeBrowser
        renameSelectedClassesTo: newClassNames;
        replaceCategoryClassNames: oldClassNames asSymbols by: newClassNames asSymbols;
        selectedClasses: newClassNames.
    "self updateClassOrganizer."
    self updatePanesFrom: 'categories'.!    ! 
#('April 23, 2005' '12:53:02 PM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('reorganizing' renameClasses )) !


!BrowserView methods !
renameClasses
    "Prompt the user to rename each of the selected classes, and then rename them"

    | answer oldClassNames newClassNames oldClass |

    self textModified ifTrue: [^self].
    oldClassNames := codeBrowser selectedClasses.
    newClassNames := OrderedCollection new.

    oldClassNames do: [:each |
        answer := PrompterDialog
            title: 'Navigator Browser'
            prompt: 'rename ', each, ' as:'
            default: each
            history: #().
        (answer isNil or: [answer isEmpty])
            ifTrue: [^self]
            ifFalse: [
                oldClass := Smalltalk at: each asSymbol ifAbsent: [nil].
                oldClass isMetaClass ifTrue: [MessageBox message: 'Cannot rename metaclasses such as ', each printString. ^self].
                oldClass isClass ifFalse: [MessageBox message: each printString, ' is not a class'. ^self].
                (Smalltalk includesKey: answer asSymbol) ifTrue: [MessageBox message: 'Name ', answer printString, ' is already in the dictionary...'. ^self].
                newClassNames add: answer]].

    self referencesToSelectedClassesIfNone: [].
    
    oldClassNames with: newClassNames do: [:oldName :newName |
        changeSet logChangeForRenameClass: oldName to: newName].
        
    self replaceAllClassNames: oldClassNames by: newClassNames.
    
    self updatePanesFrom: 'categories'.!   ! 
#('April 26, 2005' '09:17:19 AM' 763452)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('reorganizing' renameClasses )) !


!BrowserView methods ! 
renameClasses
    "Prompt the user to rename each of the selected classes, and then rename them"

    | answer oldClassNames newClassNames oldClass |

    self textModified ifTrue: [^self].
    oldClassNames := codeBrowser selectedClasses.
    newClassNames := OrderedCollection new.

    oldClassNames do: [:each |
        answer := PrompterDialog
            title: 'Navigator Browser'
            prompt: 'rename ', each, ' as:'
            default: each
            history: #().
        (answer isNil or: [answer isEmpty])
            ifTrue: [^self]
            ifFalse: [
                oldClass := Smalltalk at: each asSymbol ifAbsent: [nil].
                oldClass isMetaClass ifTrue: [MessageBox message: 'Cannot rename metaclasses such as ', each printString. ^self].
                oldClass isClass ifFalse: [MessageBox message: each printString, ' is not a class'. ^self].
                (Smalltalk includesKey: answer asSymbol) ifTrue: [MessageBox message: 'Name ', answer printString, ' is already in the dictionary...'. ^self].
                newClassNames add: answer]].

    self referencesToSelectedClassesIfNone: [].
    
    oldClassNames with: newClassNames do: [:oldName :newName |
        changeSet logChangeForRenameClass: oldName to: newName].
        
    self replaceAllClassNames: oldClassNames by: newClassNames!   ! 
#('April 27, 2005' '08:51:29 AM' 765192)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('reorganizing' renameClasses )) !


!BrowserView methods ! 
enable: items inMenu: menu
    "items      <collection of symbols>
     Enable all of the named items in menu"

    items do: [:each | menu enableItem: each]!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('private-menu support' enable:inMenu: )) !


!BrowserView methods !  
autoCompleteListForPane: aPane
    
    aPane buildAutoCompleteListForClass: codeBrowser selectedSmalltalkClassOrMetaclass.!  ! 
#('May 3, 2002' '02:34:37 PM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('text pane event handling' autoCompleteListForPane: )) !


!BrowserView methods !
replaceAllClassNames: oldNames by: newNames
    "Change the names of the class objects once (in this code browser) since it is a global change and then in all browsers,
    change the selected class names and the class names in the categories that are affected..."
    "oldNames/newNames <collection of strings>"
    
    codeBrowser renameAllClassesIn: oldNames asSymbols to: newNames asSymbols.
    
    NavigatorBrowser allInstances do: [:aCodeBrowser |
        aCodeBrowser replaceSelectionsAndCategoryClassNames: oldNames by: newNames]!   ! 
#('April 27, 2005' '08:02:05 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('private' replaceAllClassNames:by: )) !


!BrowserView methods !  
replaceAllClassNames: oldNames by: newNames
    "oldNames/newNames <collection of strings>"
    "Change the names of the class objects once (in this code browser) and the names held by the global organizers
    (referenced by the codeBrowser) JUST ONCE since these are global change and then in all browsers,
    change the selected class names and force an update of from it's categories to ensure the class names associated
    with those categories get revised..."
    
    | oldNameSymbols newNameSymbols |
    oldNameSymbols := oldNames asSymbols. newNameSymbols := newNames asSymbols.
    
    "The DO ONCE changes..."
    codeBrowser renameAllClassesIn: oldNameSymbols to: newNameSymbols
    codeBrowser categories do: [:category |
        codeBrowser organizer renameElementsOfCategory: category from: oldNameSymbols to: newNameSymbols].
    
    "The DO FOR EACH code browser changes..."
    NavigatorBrowser allInstances do: [:aCodeBrowser |
         aCodeBrowser selectedClasses: (aCodeBrowser selectedClasses substituteAllIn: oldNames by: newNames)].
         
    "The DO FOR EACH browser view changes..."
    BrowserView allInstances do: [:aBrowserView |
        aBrowserView updatePanesFrom: 'categories']!  ! 
#('April 27, 2005' '08:47:21 AM' 769004)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('private' replaceAllClassNames:by: )) !


!BrowserView methods !   
replaceAllClassNames: oldNames by: newNames
    "oldNames/newNames <collection of strings>"
    "Change the names of the class objects once (in this code browser) and the names held by the global organizers
    (referenced by the codeBrowser) JUST ONCE since these are global change and then in all browsers,
    change the selected class names and force an update of from it's categories to ensure the class names associated
    with those categories get revised..."
    
    | oldNameSymbols newNameSymbols |
    oldNameSymbols := oldNames asSymbols. newNameSymbols := newNames asSymbols.
    
    "The DO ONCE changes..."
    codeBrowser renameAllClassesIn: oldNameSymbols to: newNameSymbols.
    codeBrowser categories do: [:category |
        codeBrowser organizer renameElementsOfCategory: category from: oldNameSymbols to: newNameSymbols].
    
    "The DO FOR EACH code browser changes..."
    NavigatorBrowser allInstances do: [:aCodeBrowser |
         aCodeBrowser selectedClasses: (aCodeBrowser selectedClasses substituteAllIn: oldNames by: newNames)].
         
    "The DO FOR EACH browser view changes..."
    BrowserView allInstances do: [:aBrowserView |
        aBrowserView updatePanesFrom: 'categories']! ! 
#('April 27, 2005' '08:48:37 AM' 769732)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('private' replaceAllClassNames:by: )) !


!BrowserView methods !   
removeChangeSet

    (MessageBox confirm: 'Are you sure you want to delete the change set ', changeSet name printString, ' ?')
        ifFalse: [^self].

    self codeFilerClass changeSetManager remove: changeSet.
    changeSet := self codeFilerClass changeSetManager nonRecordingChangeSet.
    self
        updateChangeSet;
        updatePanesFrom: 'categories'!    ! 
#('October 26, 2002' '11:10:31 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('change set operations' removeChangeSet )) !


!BrowserView methods !   
resynchronizeSystem
    "Ok...it's all fubared. Recache all the organizational information in the system."

    self codeFilerClass resynchronizeClassOrganizers.
    self resynchronizeBrowser.!   ! 
#('October 26, 2002' '11:06:54 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('updating' resynchronizeSystem )) !


!BrowserView methods !
updateChangeSetAnnotation
    "Update my change set annotation pane"

    | changeSetPane |
    changeSetPane := self paneNamed: 'changeSetAnnotation'.
    changeSetPane notNil ifTrue: [changeSetPane update]!   ! 
#('April 26, 2002' '12:32:47 PM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('updating' updateChangeSetAnnotation )) !


!BrowserView methods !
spawn
    "Spawn a new browser identical to myself"

    | browserView currentState |

    currentState := self state.
    currentState isModified: false; zoomed: false.
    browserView := self class new: codeBrowser deepCopy.
    browserView
        open;
        restoreStateFrom: currentState!  ! 
#('March 30, 2003' '05:01:27 PM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('scheduling' spawn )) !


!BrowserView methods !  
isViewingMethod: aMethod

    ^textViewState = #viewingMethodSource: and: [codeBrowser selectedMethod == aMethod]!    ! 
#('January 26, 2008' '11:06:48 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('text pane support' isViewingMethod: )) !


!BrowserView methods !  
resynchronizeBrowser
    "Usually called because something got whacked out of sync.
    Fix everything that seems reasonable to fix and try to continue."

    CursorManager execute changeFor: [
        self codeFilerClass updateClassOrganizers.
        codeBrowser selectedMethodOrganizers do: [:each | each makeDirty; update]].
    self update.!   ! 
#('October 26, 2002' '11:08:07 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('updating' resynchronizeBrowser )) !


!BrowserView methods !   
instanceOrClassClicked: aButton
    "Switch from instance to class mode, and vs"

    self textModifiedWithAutomaticPush ifTrue: [^self].
    self viewMethodOrganization.
    codeBrowser isBrowsingInstanceMethods
        ifTrue: [codeBrowser browseClassMethods]
        ifFalse: [codeBrowser browseInstanceMethods].

    currentItems := changeSet itemsForClasses: (self realClassNamesFrom: codeBrowser selectedClasses).
    self
        updateProtocolButton;
        updatePanesFrom: 'protocols'!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('list pane event handling' instanceOrClassClicked: )) !


!BrowserView methods ! 
fileOutMethodsWith: aCodeWriterClass
    "file out  the selected methods"

    | fileName file |
    codeBrowser selectedMethods size > 1
        ifTrue: [fileName := 'methods.st']
        ifFalse: [fileName := (codeBrowser selectedMethod asSuggestedFileName), '.st'].
    fileName := (FileDialog new saveFile: fileName) file.
    fileName isNil ifTrue: [^self].
    file := File newFile: fileName.
    [codeBrowser fileOutSelectedMethodsOn: file with: aCodeWriterClass] ensure: [file close].! ! 
#('March 23, 2003' '01:00:19 PM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('filing out' fileOutMethodsWith: )) !


!BrowserView methods !
classMenuForPane: aPane
    "Answer the menu for the classes pane"

    | menu fileOutMenu fileOutAllMenu tab |
    tab := String with: Tab.
    fileOutMenu := self codeWriterClass codeWriterMenuWith: [:aCodeWriterClass | self fileOutClassesWith: aCodeWriterClass].
    fileOutMenu
        owner: self;
        title: 'File Out...'.

    fileOutAllMenu := self codeWriterClass codeWriterMenuWith: [:aCodeWriterClass | self fileOutClassesWithAllSubclassesWith: aCodeWriterClass].
    fileOutAllMenu
        owner: self;
        title: 'File Out All...'.

    menu := Menu new
        title: 'Class';
        owner: self;
        appendItem: 'Add To Changes' action: [:owner | self logChangeForSelectedClasses; update];
        appendSeparator;
        appendSubMenu: fileOutMenu;
        appendSubMenu: fileOutAllMenu;
        appendItem: 'Get and Set...' action: [:owner |
            (Smalltalk at: #GetAndSetBuilder) new sourceManager: self sourceManager; openOn: codeBrowser selectedSmalltalkClass.
            self updatePanesFrom: 'protocols'];
        appendItem: 'Classify Methods' action: [:owner |
            MethodClassifier classifyAll: codeBrowser selectedSmalltalkClasses.
            self updatePanesFrom: 'protocols'];
        appendSeparator;
        appendItem: 'Find Class...', tab, 'Alt+F' selector: #findClass;
        appendItem: 'Move...' selector: #moveClasses;
        appendItem: 'Copy...' selector: #copyClasses;
        appendSeparator;
        appendItem: 'Update' selector: #updateClassOrganizer;
        appendItem: 'Definition' selector: #editClassDefinition;
        appendItem: 'Comment' selector: #editClassComment;
        appendSubMenu: self classReferencesSubMenu;
        appendSeparator;
        appendItem: 'Remove...' selector: #removeClasses;
        yourself.
    aPane notNil
        ifTrue: [aPane setMenu: menu].
    ^menu!    ! 
#('March 30, 2003' '01:01:40 PM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('menus' classMenuForPane: )) !


!BrowserView methods !   
classMenuForPane: aPane
    "Answer the menu for the classes pane"

    | menu fileOutMenu fileOutAllMenu tab |
    tab := String with: Tab.
    fileOutMenu := self codeWriterClass codeWriterMenuWith: [:aCodeWriterClass | self fileOutClassesWith: aCodeWriterClass].
    fileOutMenu
        owner: self;
        title: 'File Out...'.

    fileOutAllMenu := self codeWriterClass codeWriterMenuWith: [:aCodeWriterClass | self fileOutClassesWithAllSubclassesWith: aCodeWriterClass].
    fileOutAllMenu
        owner: self;
        title: 'File Out All...'.

    menu := Menu new
        title: 'Class';
        owner: self;
        appendItem: 'Add To Changes' action: [:owner | self logChangeForSelectedClasses; update];
        appendSeparator;
        appendSubMenu: fileOutMenu;
        appendSubMenu: fileOutAllMenu;
        appendItem: 'Get and Set...' action: [:owner |
            (Smalltalk at: #GetAndSetBuilder) new sourceManager: self sourceManager; openOn: codeBrowser selectedSmalltalkClass.
            self updatePanesFrom: 'protocols'];
        appendItem: 'Classify Methods' action: [:owner |
            (MethodClassifier forCodeFiler: codeBrowser sourceManager: self sourceManager) classifyAll: codeBrowser selectedSmalltalkClasses.
            self updatePanesFrom: 'protocols'];
        appendSeparator;
        appendItem: 'Find Class...', tab, 'Alt+F' selector: #findClass;
        appendItem: 'Move...' selector: #moveClasses;
        appendItem: 'Copy...' selector: #copyClasses;
        appendSeparator;
        appendItem: 'Update' selector: #updateClassOrganizer;
        appendItem: 'Definition' selector: #editClassDefinition;
        appendItem: 'Comment' selector: #editClassComment;
        appendSubMenu: self classReferencesSubMenu;
        appendSeparator;
        appendItem: 'Remove...' selector: #removeClasses;
        yourself.
    aPane notNil
        ifTrue: [aPane setMenu: menu].
    ^menu!  ! 
#('March 30, 2003' '06:05:14 PM' 776584)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('menus' classMenuForPane: )) !


!BrowserView methods !
classMenuForPane: aPane
    "Answer the menu for the classes pane"

    | menu fileOutMenu fileOutAllMenu tab |
    tab := String with: Tab.
    fileOutMenu := self codeWriterClass codeWriterMenuWith: [:aCodeWriterClass | self fileOutClassesWith: aCodeWriterClass].
    fileOutMenu
        owner: self;
        title: 'File Out...'.

    fileOutAllMenu := self codeWriterClass codeWriterMenuWith: [:aCodeWriterClass | self fileOutClassesWithAllSubclassesWith: aCodeWriterClass].
    fileOutAllMenu
        owner: self;
        title: 'File Out All...'.

    menu := Menu new
        title: 'Class';
        owner: self;
        appendItem: 'Add To Changes' action: [:owner | self logChangeForSelectedClasses; update];
        appendSeparator;
        appendSubMenu: fileOutMenu;
        appendSubMenu: fileOutAllMenu;
        appendItem: 'Get and Set...' action: [:owner |
            (Smalltalk at: #GetAndSetBuilder) new sourceManager: self sourceManager; openOn: codeBrowser selectedSmalltalkClass.
            self updatePanesFrom: 'protocols'];
        appendItem: 'Classify Methods' action: [:owner |
            (MethodClassifier forCodeFiler: codeBrowser sourceManager: self sourceManager) classifyAll: codeBrowser selectedSmalltalkClasses.
            self updatePanesFrom: 'protocols'];
        appendSeparator;
        appendItem: 'Find Class...', tab, 'Alt+F' selector: #findClass;
        appendItem: 'Move...' selector: #moveClasses;
        appendItem: 'Copy...' selector: #copyClasses;
        appendSeparator;
        appendItem: 'Update' selector: #updateClassOrganizer;
        appendItem: 'Definition' selector: #editClassDefinition;
        appendItem: 'Comment' selector: #editClassComment;
        appendSubMenu: self classReferencesSubMenu;
        appendSeparator;
        appendItem: 'Remove...' selector: #removeClasses;
        appendItem: 'Rename...' selector: #renameClasses;
        yourself.
    aPane notNil
        ifTrue: [aPane setMenu: menu].
    ^menu!   ! 
#('April 21, 2005' '09:50:54 AM' 778668)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('menus' classMenuForPane: )) !


!BrowserView methods !
textModifiedWithAutomaticPush

    self mainView isTextModified ifFalse: [^false].
    BrowserView automaticPush ifTrue: [self pushCurrentState].
    ^super textModified!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('text pane event handling' textModifiedWithAutomaticPush )) !


!BrowserView methods !   
removeProtocols
    "Remove the selected protocols"

    | selectors protocols |
    self textModified
        ifTrue: [^self].
    selectors := codeBrowser selectedProtocols inject: Set new into: [:sum :each |
        sum addAll: (codeBrowser selectedMethodOrganizer elementsOfCategory: each); yourself].

    (selectors isEmpty or: [MessageBox confirm: 'Really remove all methods in the selected protocols?'])
        ifTrue: [
            protocols := codeBrowser selectedProtocols.
            codeBrowser removeSelectedProtocols.
            changeSet logChangeForRemoveProtocols: protocols inClass: codeBrowser selectedSmalltalkClassOrMetaclass.
            currentItems := changeSet itemsForClasses: (self realClassNamesFrom: codeBrowser selectedClasses).
            ^self updatePanesFrom: 'categories']
        ifFalse: [^self]!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('reorganizing' removeProtocols )) !


!BrowserView methods ! 
addChangeSet
    "Add a new change set to the set of change sets"

    | newName new |
    newName := Prompter
        title: 'Navigator Browser'
        prompt: 'Name for new change set?'
        default: 'Unnamed'.
    (newName isNil or: [newName isEmpty])
        ifTrue: [^self].

    self codeFilerClass changeSetManager add: (new := ChangeSet new name: newName).
    changeSet := new.

    self
        updateChangeSet;
        updatePanesFrom: 'categories'!    ! 
#('October 26, 2002' '11:08:21 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('change set operations' addChangeSet )) !


!BrowserView methods !  
implementorsOfMethods
    "Open a methodBrowser on all of the implementors of the selected methods
    in all Smalltalk classes"

    | methods label |

    methods := self implementorsOf: codeBrowser selectedMethods in:
        (self systemDictionary rootClasses inject: OrderedCollection new into: [:sum :each |
            sum, each withAllSubclasses]).
    methods isEmpty
        ifTrue: [^MessageBox message: 'No implementors']
        ifFalse: [
            label := WriteStream on: (String new: 80).
            codeBrowser selectedMethods do: [:each |
                each printOn: label.
                label space; space].
            ^MethodBrowser new
                label: 'Implementors of ' , label contents;
                openOn: methods].!  ! 
#('November 13, 2001' '11:22:36 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('method operations' implementorsOfMethods )) !


!BrowserView methods !
editClassComment
    "Edit the class comment"

    self textModified ifTrue: [^self].
    codeBrowser selectedProtocols: Array new.
    self
        privateUpdatePanesFrom: 'protocols';
        viewClassComment;
        updateText! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('class operations' editClassComment )) !


!BrowserView methods !
fileOutProtocolsWith: aCodeWriterClass
    "file out  the selected protocls"

    | fileName file |
    codeBrowser selectedProtocols size > 1
        ifTrue: [fileName := 'methods.st']
        ifFalse: [fileName := (codeBrowser selectedProtocol copyWithout: Space), '.st'].
    fileName := (FileDialog new saveFile: fileName) file.
    fileName isNil ifTrue: [^self].
    file := File newFile: fileName.
    [codeBrowser fileOutSelectedProtocolsOn: file  with: aCodeWriterClass] ensure: [file close].!    ! 
#('January 15, 2002' '10:34:17 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('filing out' fileOutProtocolsWith: )) !


!BrowserView methods !
sendersOfMethods
    "Open a methodBrowser on all of the senders of the selected methods
    in all Smalltalk classes"

    | methods label browser |

    methods := self sendersOf: codeBrowser selectedMethods in:
        (self systemDictionary rootClasses inject: OrderedCollection new into: [:sum :each |
            sum, each withAllSubclasses]).
    methods isEmpty
        ifTrue: [^MessageBox message: 'No senders']
        ifFalse: [
            label := WriteStream on: (String new: 80).
            codeBrowser selectedMethods do: [:each |
                each printOn: label.
                label space;space].
            browser := MethodBrowser new.
            codeBrowser selectedMethods size = 1
                ifTrue: [browser literal: codeBrowser selectedMethod].
            ^browser
                label: 'Senders of ' , label contents;
                openOn: methods].! ! 
#('November 13, 2001' '11:24:25 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('method operations' sendersOfMethods )) !


!BrowserView methods ! 
buildCategoryBrowserWithoutChangeSets
    "private - build the panes for a category browser"

    | midY aRectangle buttonHeight categoryBox classBox protocolBox methodBox |

    midY := 4/9.
    buttonHeight := 1/9.
    categoryBox := 0 @ 0 corner: 1/4 @ midY.
    classBox := (1/4) @ 0 corner: 1/2 @ midY.
    protocolBox := (1/2) @ 0 corner: (3/4) @ midY.
    methodBox := (3/4) @ 0 corner: 1 @ midY.

    self
        createCategoryListInFrame: [:rect | rect scaleTo: categoryBox];
        createClassListInFrame: [:rect | rect scaleTo: classBox];
        createProtocolListInFrame: [:rect |
            (rect scaleTo: protocolBox) insetBy: (0 @ 0 corner: 0 @ (ListFont height + 6))];
        createProtocolButtonInFrame: [:rect |
            aRectangle := rect scaleTo: protocolBox.
            aRectangle origin + (0 @ (aRectangle height - ListFont height - 6)) corner: aRectangle corner];
        createMethodListInFrame: [:rect |
            (rect scaleTo: methodBox) insetBy: (0 @ 0 corner: 0 @ (ListFont height + 5))];
        createAnnotationPaneInFrame: [:rect |
            aRectangle := rect scaleTo: methodBox.
            aRectangle origin + (4 @ (aRectangle height - ListFont height - 5)) corner: aRectangle corner - (4@0)];
        createTextInFrame: (0 @ midY corner: 1 @ 1)! ! 
#('April 26, 2002' '12:31:55 PM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('private-scheduling' buildCategoryBrowserWithoutChangeSets )) !


!BrowserView methods !  
viewingMethodSource: aPane
    "Set the contents of the textPane to the source code of the selected method"

    aPane contents: codeBrowser selectedMethodSource!   ! 
#('May 3, 2002' '10:18:18 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('private-text pane support' viewingMethodSource: )) !


!BrowserView methods !   
addBrowserMenu
    "Add a menu with options which apply to the entire browser"

    | theMenu tab |

    tab := String with: Tab.
    (theMenu := Menu new)
        owner: self;
        title: 'Browser';
        appendItem: 'Exchange State', tab, 'Alt+X' selector: #exchangeCurrentState accelKey: $X accelBits: AfAlt;
        appendItem: 'Push State', tab, 'Alt+C' selector: #pushCurrentState accelKey: $C accelBits: AfAlt;
        appendItem: 'Pop State', tab, 'Alt+V' selector: #popLastState accelKey: $V accelBits: AfAlt;
        appendItem: 'Clear States' selector: #clearSavedStates;
        appendItem: 'Automatic Push' selector: #toggleAutomaticPush;
        appendSeparator;
        appendItem: 'Update', tab, 'Alt+U' selector: #resynchronizeBrowser accelKey: $U accelBits: AfAlt;
        appendItem: 'System-Wide Update', tab, 'Ctrl+Alt+U' selector: #resynchronizeSystem accelKey: $U accelBits: AfAlt | AfControl;
        appendSeparator;
        appendItem: 'Spawn', tab, 'Ctrl+B' selector: #spawn accelKey: $B accelBits: AfControl;
        appendSeparator;
        appendItem: 'Delete Selection', tab, 'Ctrl+Del' selector: #deleteSelection accelKey: DeleteKey accelBits: AfControl;

        yourself.
    self mainView menuWindow insertMenu: theMenu after: 3.!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('menus' addBrowserMenu )) !


!BrowserView methods ! 
createMethodListInFrame: frame
    "Add a pane to myself that will list methods"

    | thisPane theFont |

    self addSubpane: ((thisPane := ColorMultipleSelectListBox new)
        owner: self;
        paneName: 'methods';
        extendedSelect;
        ownerDrawFixed;
        when: #needsContents send: #methodsForPane: to: self with: thisPane;
        when: #changed: send: #selectMethodsForPane: to: self with: thisPane;
        when: #needsMenu send: #methodMenuForPane: to: self with: thisPane;
        when: #tabbed send: #cycleCurrentState to: self;
        when: #backTabbed send: #cycleCurrentState to: self;
        framingBlock: frame).! ! 
#('April 19, 2002' '11:21:50 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('private-scheduling' createMethodListInFrame: )) !


!BrowserView methods !   
copyProtocolsToNewClass
    "Copy all methods in the given protocols to a class specified by the user."

    | theClass newClass stream |

    newClass := PrompterDialog
        title: 'Navigator Browser'
        prompt: 'Copy the selected protocols to which class?'
        default: codeBrowser selectedClass
        history: codeBrowser classes.
    (newClass isNil or: [newClass isEmpty])
        ifTrue: [^self].
    newClass := newClass trimBlanks.
    (self systemDictionary includesKey: newClass asSymbol)
        ifFalse: [^MessageBox message: 'No such class'].
    self class rememberClass: newClass.
    newClass := self classForClassName: newClass.

    CursorManager execute changeFor: [
        codeBrowser copySelectedProtocolsTo: newClass.
        codeBrowser selectedProtocols do: [:eachProtocol |
            (codeBrowser selectedMethodOrganizer elementsOfCategory: eachProtocol) do: [:eachSelector |
                changeSet logChangeForSelector: eachSelector inProtocol: eachProtocol inClass: newClass]]].

    self updatePanesFrom: 'categories'!  ! 
#('March 29, 2003' '09:13:13 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('reorganizing' copyProtocolsToNewClass )) !


!BrowserView methods !  
methodMenuForPane: aPane
    "Answer the menu for the methods pane"

    | menu fileOutMenu |

    fileOutMenu := self codeWriterClass codeWriterMenuWith: [:aCodeWriterClass | self fileOutMethodsWith: aCodeWriterClass].
    fileOutMenu
        owner: self;
        title: 'File Out...'.

    menu := Menu new
        title: 'Method';
        owner: self;
        appendItem: 'Add To Changes' action: [:owner | self logChangeForSelectedMethods; update];
        appendSeparator;
        appendSubMenu: fileOutMenu;
        appendItem: 'Find Method...' selector: #findMethod;
        appendItem: 'Move...' selector: #moveMethods;
        appendItem: 'Copy...' selector: #copyMethodsToNewClass;
        appendSeparator;
        appendSubMenu: self sendersSubMenu;
        appendSubMenu: self implementorsSubMenu;
        appendItem: 'Messages' selector: #methodMessages;
        appendItem: 'Browse Versions' selector: #browseMethodVersions;
        appendSeparator;
        appendItem: 'Remove...' selector: #removeMethods;
        yourself.
    aPane notNil
        ifTrue: [aPane setMenu: menu].
    ^menu! ! 
#('March 8, 2003' '09:47:16 PM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('menus' methodMenuForPane: )) !


!BrowserView methods !   
fileOutClassesWithAllSubclassesWith: aCodeWriterClass
    "file out  the selected classes"

    | fileName file |

    codeBrowser selectedClasses size > 1
        ifTrue: [fileName := 'classes.st']
        ifFalse: [fileName := (codeBrowser selectedClass copyWithout: Space), '.st'].
    fileName := (FileDialog new saveFile: fileName) file.
    fileName isNil ifTrue: [^self].
    file := File newFile: fileName.
    [codeBrowser
        fileOutSelectedClassesWithAllSubclassesOn: file
        with: aCodeWriterClass] ensure: [file close]!  ! 
#('January 15, 2002' '10:33:07 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('filing out' fileOutClassesWithAllSubclassesWith: )) !


!BrowserView methods ! 
acceptFromPane: aPane
    "Accept the text in aPane, and save it.  Call the appropriate save method depending upon
    the current textViewState."

    | acceptSelector |
    acceptSelector := 'acceptFor',
        (String with: self textViewState first asUpperCase), (self textViewState copyFrom: 2 to: self textViewState size).
    acceptSelector := acceptSelector asSymbol.

    (self respondsTo: acceptSelector)
        ifTrue: [self perform: acceptSelector with: aPane]
        ifFalse: [self privateUnknownAcceptForPane: aPane]!    ! 
#('May 3, 2002' '10:17:12 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('text pane event handling' acceptFromPane: )) !


!BrowserView methods ! 
updateLabel
    "Update my label to say something useful about what I am browsing"

    | label |

    label := WriteStream on: (String new: 80).
    self savedStates notEmpty ifTrue: [
        label nextPut: $(; print: self savedStates size; nextPutAll: ') '].

    codeBrowser selectedClasses notEmpty
        ifTrue: [
            label
                "nextPutAll: 'Browsing ';"
                nextPutAll: codeBrowser selectedClass.
            codeBrowser selectedClasses size > 1
                ifTrue: [label nextPutAll: ' . . .'].
            ^self labelWithoutPrefix: label contents].
    codeBrowser selectedCategories notEmpty
        ifTrue: [
             label
                nextPutAll: 'Browsing in ';
                nextPutAll: codeBrowser selectedCategory.
            codeBrowser selectedCategories size > 1
                ifTrue: [label nextPutAll: '. . .'].
            ^self labelWithoutPrefix: label contents].
    self labelWithoutPrefix: label contents, 'Navigator Browser'
! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('updating' updateLabel )) !


!BrowserView methods ! 
editClassDefinition
    "Make sure that I am showing a class definition, or a class
    definition template"

    self textModifiedWithAutomaticPush ifTrue: [^self].
    codeBrowser selectedProtocols: Array new.
    self
        privateUpdatePanesFrom: 'protocols';
        viewClassDefinition;
        updateText! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('class operations' editClassDefinition )) !


!BrowserView methods ! 
updateClassOrganizer
    "Update my selected classes' organizers"

    self textModified
        ifTrue: [^self].
    codeBrowser selectedSmalltalkClasses do: [:each |
        (self codeFilerClass organizerFor: each) makeDirty; update.
         (self codeFilerClass organizerFor: each class) makeDirty; update].
    self updatePanesFrom: 'classes'.!   ! 
#('March 30, 2003' '05:23:30 PM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('updating' updateClassOrganizer )) !


!BrowserView methods ! 
updateClassOrganizer
    "Update my selected classes' organizers"

    self textModified
        ifTrue: [^self].
    codeBrowser selectedSmalltalkClasses do: [:each |
        (self codeFilerClass organizerFor: each) makeDirty; update.
         (self codeFilerClass organizerFor: (self classFor: each)) makeDirty; update].
    self updatePanesFrom: 'classes'.!    ! 
#('March 30, 2003' '05:36:02 PM' 798196)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('updating' updateClassOrganizer )) !


!BrowserView methods !  
updateClassOrganizer
    "Update my selected classes' organizers"

    (self textModified or: [codeBrowser selectedSmalltalkClasses isNil])
        ifTrue: [^self].
    codeBrowser selectedSmalltalkClasses do: [:each |
        (self codeFilerClass organizerFor: each) makeDirty; update.
         (self codeFilerClass organizerFor: (self classFor: each)) makeDirty; update].
    self updatePanesFrom: 'classes'.! ! 
#('April 22, 2005' '09:54:36 AM' 798728)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('updating' updateClassOrganizer )) !


!BrowserView methods !  
viewingClassComment: aPane
    "Set the contents of aPane to be the class comment of the selected class"

    | comment |

    comment := self codeFilerClass commentFor: codeBrowser selectedClass asSymbol.
    comment isEmpty
        ifTrue: [comment := 'No comment for this class.'].

    aPane contents: comment.!    ! 
#('October 26, 2002' '11:09:36 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('private-text pane support' viewingClassComment: )) !


!BrowserView methods !  
exchangeCurrentState
    "Exchange the current browser state with the top state on the browser stack"

    | topmostState |
    self savedStates isEmpty ifTrue: [^self].

    topmostState := self savedStates removeLast.
    self savedStates addLast: self state.
    self
        restoreStateFrom: topmostState;
        updateBrowserMenu! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('browser state operations' exchangeCurrentState )) !


!BrowserView methods !
showMethodSourceAnnotationFor: aPane
    "Show the timeStamp for the current method, if I can find it in the change log"

    | method sourceIndex version stream |
    method := codeBrowser selectedSmalltalkClassOrMetaclass compiledMethodAt: codeBrowser selectedMethod.
    sourceIndex := method sourceIndex.
    sourceIndex = 0
        ifTrue: [^aPane contents: 'no source'].
    sourceIndex = 1
        ifTrue: [^aPane contents: 'sources.sml'].
    method sourceLibrary notNil
        ifTrue: [^aPane contents: 'library ', method sourceLibrary name].
    sourceIndex = 3
        ifTrue: [^aPane contents: 'sources sll'].
    sourceIndex ~= 2
        ifTrue: [^aPane contents: 'library ', sourceIndex printString].

    version := (self codeFilerClass forClass: codeBrowser selectedSmalltalkClassOrMetaclass)
        loadedVersionOf: codeBrowser selectedMethod.

    stream := WriteStream on: (String new: 50).
    stream
        nextPutAll: version stampPrintString.
    version hasPreviousVersions
        ifTrue: [stream nextPutAll: ' ...'].

    aPane contents: stream contents!   ! 
#('October 26, 2002' '11:09:06 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('annotation pane event handling' showMethodSourceAnnotationFor: )) !


!BrowserView methods !   
deleteSelection

    codeBrowser selectedMethods notEmpty ifTrue: [^self removeMethods].
    codeBrowser selectedProtocols notEmpty ifTrue: [^self removeProtocols].!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('reorganizing' deleteSelection )) !


!BrowserView methods ! 
cycleCurrentState

    | nextVisibleState |
    self savedStates isEmpty ifTrue: [^self].
    Notifier isShiftKeyDown
        ifTrue: [
            nextVisibleState := self savedStates removeLast.
            self savedStates addFirst: self state]
        ifFalse: [
            nextVisibleState := self savedStates removeFirst.
            self savedStates addLast: self state].

    self restoreStateFrom: nextVisibleState.
    self updateBrowserMenu!  ! 
#('April 15, 2002' '11:27:36 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('browser state operations' cycleCurrentState )) !


!BrowserView methods !
createCategoryListInFrame: frame
    " Add a pane to myself that will handle the category selection."

    | thisPane theFont |

    self addSubpane: ((thisPane := ColorMultipleSelectListBox new)
        owner: self;
        paneName: 'categories';
        extendedSelect;
        ownerDrawFixed;
        when: #needsContents send: #categoriesForPane: to: self with: thisPane;
        when: #changed: send: #selectCategoriesForPane: to: self with: thisPane;
        when: #needsMenu send:  #categoryMenuForPane: to: self with: thisPane;
        when: #tabbed send: #cycleCurrentState to: self;
        when: #backTabbed send: #cycleCurrentState to: self;
        framingBlock: frame).!    ! 
#('April 19, 2002' '11:21:18 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('private-scheduling' createCategoryListInFrame: )) !


!BrowserView methods ! 
toggleAutomaticPush

    BrowserView automaticPush: BrowserView automaticPush not.
    self updateBrowserMenu.!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('browser state operations' toggleAutomaticPush )) !


!BrowserView methods ! 
referencesToClassVariables

    | theClass instanceVariables answer selectors |

    theClass := self deepestCommonSuperclassOf: codeBrowser selectedSmalltalkClasses.
    instanceVariables := theClass allClassVarNamesGrouped.
    answer := ChooseManyDialog new
        openOn: instanceVariables
        label: 'Class Variables of ', theClass name.
    (answer isNil or: [answer isEmpty]) ifTrue: [^self].

    selectors := answer inject: Set new into: [:sum :each |
        codeBrowser selectedSmalltalkClasses do: [:eachClass |
            sum addAll: (eachClass allMethodsUsingClassVar: each); addAll: ((self classFor: eachClass) allMethodsUsingClassVar: each)].
        sum].

    MethodBrowser new
        literal: answer first;
        label: 'References to ', (answer inject: '' into: [:sum :each | sum, each, ' ']);
        openOn: selectors.!   ! 
#('March 30, 2003' '05:33:55 PM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('class operations' referencesToClassVariables )) !


!BrowserView methods !   
updateExternalBrowsers
    | textPane |
    BrowserView allInstances do: [:browserView |
        (browserView ~~ self and: [browserView isViewingMethodSource]) ifTrue: [
            textPane := browserView paneNamed: 'textPane'.
            textPane modified ifTrue: [textPane foregroundColor: 200@200@0]]] "muddy yellow"! ! 
#('January 26, 2008' '10:57:50 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('updating' updateExternalBrowsers )) !


!BrowserView methods ! 
updateExternalBrowsers
    | textPane |
    BrowserView allInstances do: [:browserView |
        (browserView ~~ self and: [browserView isViewingMethod: codeBrowser selectedMethod]) ifTrue: [
            textPane := browserView paneNamed: 'textPane'.
            textPane modified ifTrue: [textPane foregroundColor: 200@200@0]]] "muddy yellow"!   ! 
#('January 26, 2008' '11:07:34 AM' 805500)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('updating' updateExternalBrowsers )) !


!BrowserView methods !  
updateExternalBrowsers
    | textPane |
    BrowserView allInstances do: [:browserView |
        (browserView ~~ self and: [browserView isViewingMethod: codeBrowser selectedMethod]) ifTrue: [
            textPane := browserView paneNamed: 'textPane'.
            textPane foregroundColor: 200@200@0]] "muddy yellow"!   ! 
#('January 26, 2008' '11:21:59 AM' 806004)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('updating' updateExternalBrowsers )) !


!BrowserView methods !  
changeSetsForPane: aPane
    "Set the contents of the change set pane"

    aPane
        contents: self codeFilerClass changeSetManager changeSets;
        selection: changeSet! ! 
#('October 26, 2002' '11:08:36 AM' nil)!

(CodeFiler organizerFor: BrowserView) reorganizeFrom: #(
('list pane event handling' changeSetsForPane: )) !


!BrowserView class methods !   
initializeDefaults
    "(self initializeDefaults)
    Initialize my defaults dictionary"

    Defaults := Dictionary new

        "This is updated when you select a protocol"
        at: #previousProtocol put: String new;

        "These are a history of the last things you typed into various dialog boxes"
        at: #previousCategories put: OrderedCollection new;
        at: #previousClasses put: OrderedCollection new;
        at: #previousProtocols put: OrderedCollection new;

        "This is how many of previous things to remember"
        at: #numberOfHistoryItems put: 10;

        "This is the color for change set items"
        at: #changeSetItemColor put: ClrBlue;

        at: #automaticPush put: true;

        yourself!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BrowserView class) reorganizeFrom: #(
('defaults' initializeDefaults )) !


!BrowserView class methods !  
automaticPush
    ^Defaults at: #automaticPush ifAbsentPut: [true]!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BrowserView class) reorganizeFrom: #(
('defaults' automaticPush )) !


!BrowserView class methods !   
new: aCodeBrowser
    ^super new initializeWithCodeBrowser: aCodeBrowser
!    ! 
#('March 29, 2003' '03:59:07 PM' nil)!

(CodeFiler organizerFor: BrowserView class) reorganizeFrom: #(
('instance creation' new: )) !


!BrowserView class methods !
new: aCodeBrowser
    ^self basicNew initializeWithCodeBrowser: aCodeBrowser "new and initializeWithCodeBrowser: BOTH execute initialize..."!  ! 
#('March 29, 2003' '03:59:07 PM' 808620)!

(CodeFiler organizerFor: BrowserView class) reorganizeFrom: #(
('instance creation' new: )) !


!BrowserView class methods ! 
automaticPush: trueOrFalse
    ^Defaults at: #automaticPush put: trueOrFalse!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: BrowserView class) reorganizeFrom: #(
('defaults' automaticPush: )) !


!BrowserView class methods !  
codeFilerClass
    ^CodeFiler! ! 
#('January 20, 2003' '10:53:20 AM' nil)!

(CodeFiler organizerFor: BrowserView class) reorganizeFrom: #(
('private' codeFilerClass )) !


!BrowserView class methods !  
openOnSystem
    "Open a BrowserView on a codeBrowser browsing the system classes"

    ^self openOn: (NavigatorBrowser new organizer: self codeFilerClass systemOrganizer update)!  ! 
#('January 20, 2003' '10:53:18 AM' nil)!

(CodeFiler organizerFor: BrowserView class) reorganizeFrom: #(
('instance creation' openOnSystem )) !


  

Browser subclass: #CodeBrowser
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Browsers' )
  comment: ''!

!CodeBrowser methods !
compile: aString notifying: aDispatcher in: aClass
        "Private - Accept aString as an updated
        method and compile it, logging source to
        the change log if successful.  Notify aDispatcher
        if the compiler detects errors."

    ^(CodeFiler forClass: aClass) compile: aString notifying: aDispatcher!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: CodeBrowser) reorganizeFrom: #(
('no category methods' compile:notifying:in: )) !


!CodeBrowser methods !
compile: aString in: aClass
        "Private - Accept aString as an updated
        method and compile it, logging source to
        the change log if successful."

    ^(CodeFiler forClass: aClass) compile: aString!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: CodeBrowser) reorganizeFrom: #(
('no category methods' compile:in: )) !




CodeBrowser subclass: #ChangeSetBrowser
  instanceVariableNames: 
    ' changeSets items textViewState itemSortState '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Browsers' )
  comment: ''!

!ChangeSetBrowser methods !  
changeSetsMenuForPane: aPane

    | menu fileOutMenu exportMenu |

    fileOutMenu := CodeWriter codeWriterMenuWith: [:aCodeWriterClass | self fileOutChangeSetsWith: aCodeWriterClass].
    fileOutMenu
        owner: self;
        title: 'File Out...'.

    exportMenu := CodeWriter codeWriterMenuWith: [:aCodeWriterClass | self exportChangeSetsWith: aCodeWriterClass].
    exportMenu
        owner: self;
        title: 'Export...'.

    menu := Menu new
        title: 'Change Set';
        owner: self;
        appendItem: 'Add...' selector: #addChangeSet;
        appendSeparator;
        appendSubMenu: fileOutMenu;
        appendSubMenu: exportMenu;
        appendSeparator;
        appendItem: 'Open' action: [:owner | changeSets do: [:each | each allowChanges]. self update];
        appendItem: 'Close' action: [:owner |changeSets do: [:each | each disallowChanges]. self update];
        appendSeparator;
        appendItem: 'Copy...' selector: #copyChangeSets;
        appendItem: 'Merge' selector: #mergeChangeSets;
        appendItem: 'Update' selector: #update;
        appendItem: 'Rename...' selector: #renameChangeSets;
        appendItem: 'Highlights' selector: #highlightChangeSets;
        appendSeparator;
        appendItem: 'Remove...' selector: #removeChangeSets;
        yourself.

    aPane setMenu: menu.
    ^menu!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: ChangeSetBrowser) reorganizeFrom: #(
('menus' changeSetsMenuForPane: )) !


!ChangeSetBrowser methods !   
highlightChangeSets

    | highlights |
    highlights := changeSets first highlightsCopy.
    2 to: changeSets size do: [:index |
        (changeSets at: index) highlightsCopy items do: [:each | highlights addItem: each]].

    CodeFiler changeSetManager add: highlights.
    self
        selectedChangeSets: (Array with: highlights);
        update!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: ChangeSetBrowser) reorganizeFrom: #(
('reorganizing' highlightChangeSets )) !


!ChangeSetBrowser methods !   
mergeChangeSets

    | merged |
    merged := changeSets first copy.
    merged name: 'Merged change sets'.
    2 to: changeSets size do: [:index |
        (changeSets at: index) items do: [:each | merged addItem: each]].

    CodeFiler changeSetManager add: merged.
    self
        selectedChangeSets: (Array with: merged);
        update!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: ChangeSetBrowser) reorganizeFrom: #(
('reorganizing' mergeChangeSets )) !


  

CodeBrowser subclass: #ClassBrowser
  instanceVariableNames: 
    ' browsedClass selectedDictionary selectedMethod '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Browsers' )
  comment: ''!

!ClassBrowser methods !
text: textPane
        "Private - Fill the text pane with source
         text for the selected method."
    selectedMethod isNil
        ifTrue: [ ^textPane contents: self template ].
    textPane contents: ( selectedDictionary sourceCodeAt: selectedMethod )!   ! 
#('January 26, 2008' '09:07:12 AM' nil)!

(CodeFiler organizerFor: ClassBrowser) reorganizeFrom: #(
('extensions' text: )) !


!ClassBrowser methods !  
text: textPane
    "Private - Fill the text pane with source text for the selected method."
    textPane contents: self initialContent!   ! 
#('January 26, 2008' '09:07:13 AM' 814240)!

(CodeFiler organizerFor: ClassBrowser) reorganizeFrom: #(
('extensions' text: )) !


!ClassBrowser methods !   
accept: aPane
        "Private - Accept the contents of aPane as an updated
         method and compile it.  Notify aDispatcher if
         the compiler detects errors."

    | result |
    result := (CodeFiler forClass: selectedDictionary) compile: aPane contents notifying: aPane.
    aPane modified: result isNil.
    (result notNil and: [result key ~= selectedMethod]) ifTrue: [
        selectedMethod := result key.
        self changed: #selectors: with: #restoreSelected:with: selectedMethod].! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: ClassBrowser) reorganizeFrom: #(
('no category methods' accept: )) !


!ClassBrowser methods !
createView
        "Private - create the SubPanes for the receiver window."
    | twoLineHeight pane group |
    self label: self label.
    twoLineHeight := ListFont height * 2 + 8.
    self addSubpane:
        ( ( group := GroupPane new )
            framingBlock: [ :box |
                box leftTop extentFromLeftTop:
                  box width // 3 @ twoLineHeight ] ).
    group
        addSubpane: ( ( pane := RadioButton new )
            contents: 'instance';
            selection: true;
            when: #clicked: send: #instanceButton: to: self with: pane;
            framingRatio: ( ( Rectangle leftTopUnit rightAndDown: ( 1/15 @ 0 ) )
                extentFromLeftTop: 14/15 @ (1/2) );
            yourself ).
    group
        addSubpane: ( ( pane := RadioButton new )
            contents: 'class';
            when: #clicked: send: #classButton: to: self with: pane;
            framingRatio: ( ( Rectangle leftTopUnit rightAndDown: ( 1/15 @ (1/2) ) )
                extentFromLeftTop: 14/15 @ (1/2) );
            yourself ).
    self addSubpane:
        ( ( pane := ListPane new )
            addHorizontalScrollbarStyle;
            setName: #selectors: ;
            when: #needsContents send: #selectors: to: self with: pane;
            when: #clicked: send: #selector: to: self with: pane;
            when: #needsMenu send: #selectorMenu: to: self with: pane;
            dragSource: self class dragDropEnabled;
            when: #dragSourceNeedsObject: send: #methodListSetDragObject: to: self;
            when: #dragSourceCut: send: #methodListCut: to: self;
            dragTargetForFormats: #( 'compiledMethod' ) operations: #( #move #copy );
            dragTarget: self class dragDropEnabled;
            dragTargetEmphasisPane;
            when: #dragTargetDrop: send: #methodListDrop: to: self;
            framingBlock: [ :box |
                box leftBottom extentFromLeftBottom:
                  box width // 3 @ ( box height - twoLineHeight ) ] ).
    self addSubpane:
        ( ( pane := self toolTextPaneClass new )
            setName: #text: ;
            when: #needsContents send: #text: to: self with: pane;
            when: #aboutToSave send: #accept: to: self with: pane;
            dragTargetForFormats: #( 'string' ) operations: #( #move #copy );
            framingBlock: [ :box |
                ( box leftTop right: ( box width // 3 ) )
                  rightBottom: box rightBottom ] ).!   ! 
#('May 8, 2002' '01:12:04 PM' nil)!

(CodeFiler organizerFor: ClassBrowser) reorganizeFrom: #(
('no category methods' createView )) !


!ClassBrowser methods ! 
initialContent
    "Private - Fill the text pane with source text for the selected method."
    ^selectedMethod isNil ifTrue: [self template] ifFalse: [selectedDictionary sourceCodeAt: selectedMethod]! ! 
#('January 26, 2008' '09:06:41 AM' nil)!

(CodeFiler organizerFor: ClassBrowser) reorganizeFrom: #(
('extensions' initialContent )) !


!ClassBrowser methods ! 
initialContent
    "Private - The initial source text for the selected method."
    ^selectedMethod isNil ifTrue: [self template] ifFalse: [selectedDictionary sourceCodeAt: selectedMethod]! ! 
#('January 26, 2008' '09:07:39 AM' 818340)!

(CodeFiler organizerFor: ClassBrowser) reorganizeFrom: #(
('extensions' initialContent )) !


 

CodeBrowser subclass: #ClassHierarchyBrowser
  instanceVariableNames: 
    ' originalClasses browsedClasses selectedClass instanceSelectedLast selectedMethod methodSelectedLast hiddenClasses selectedInstVar assigned used '
  classVariableNames: ''
  poolDictionaries: 
    ' VirtualKeyConstants '
  categories: #( 'Tools-Browsers' )
  comment: ''!

!ClassHierarchyBrowser methods !  
text: textPane
        "Private - Set the source text for
         the selected method or class definition
         for the selected class."
    | answer aClass |
    selectedClass isNil
        ifTrue: [ ^textPane contents: String new ].
    aClass := instanceSelectedLast
        ifTrue: [ selectedClass ]
        ifFalse: [ selectedClass class ].
    methodSelectedLast ifTrue: [
        selectedMethod isNil
            ifTrue: [ ^textPane contents: self template ]
            ifFalse: [ ^textPane contents: ( aClass sourceCodeAt: selectedMethod ) ] ].
    answer := WriteStream on: ( String new: 100 ).
    aClass fileOutOn: answer.
    textPane contents: answer contents!  ! 
#('January 26, 2008' '09:16:20 AM' nil)!

(CodeFiler organizerFor: ClassHierarchyBrowser) reorganizeFrom: #(
('extensions' text: )) !


!ClassHierarchyBrowser methods !
text: textPane
    "Private - Fill the text pane with source text for the selected method or class definition for the selected class."
    textPane contents: self initialContent!    ! 
#('January 26, 2008' '09:16:21 AM' 819456)!

(CodeFiler organizerFor: ClassHierarchyBrowser) reorganizeFrom: #(
('extensions' text: )) !


!ClassHierarchyBrowser methods ! 
initialContent
    "Private - The source text for  the selected method or class definition for the selected class."
    | answer aClass |
    selectedClass isNil ifTrue: [^String new ].
    aClass := instanceSelectedLast ifTrue: [selectedClass] ifFalse: [selectedClass class].
    methodSelectedLast ifTrue: [
        selectedMethod isNil ifTrue: [^self template] ifFalse: [^aClass sourceCodeAt: selectedMethod]].
    answer := WriteStream on: ( String new: 100 ).
    aClass fileOutOn: answer.
    ^answer contents!   ! 
#('January 26, 2008' '09:14:52 AM' nil)!

(CodeFiler organizerFor: ClassHierarchyBrowser) reorganizeFrom: #(
('extensions' initialContent )) !


!ClassHierarchyBrowser methods !   
createView
        "Private - create the panes for the receiver window."
    | ratio groupPane pane listLineHeight |
    ratio := 2 / 5.
    listLineHeight := ButtonFont height + 4.
    self
        owner: self;
        label: self label.
    self addSubpane:
        ( ( pane := ListPane new )
            addHorizontalScrollbarStyle;
            setName: #hierarchy: ;
            when: #needsContents send: #hierarchy: to: self with: pane;
            when: #clicked: send: #hierarchySelected: to: self with: pane;
            when: #doubleClicked: send: #hideShow: to: self with: pane;
            when: #needsMenu send: #menu: to: self with: pane;
            when: #characterTyped: send: #hierarchyCharInput: to: self with: pane;
            dragSource: self class dragDropEnabled;
            when: #dragSourceNeedsObject: send: #classListSetDragObject: to: self;
            when: #dragSourceCut: send: #classListCut: to: self;
            dragTargetForFormats: #( 'compiledMethod' ) operations: #( #move #copy );
            dragTarget: self class dragDropEnabled;
            dragTargetEmphasisItem;
            when: #dragTargetDrop: send: #classListDrop: to: self;
            framingRatio:
                ( Rectangle leftTopUnit extentFromLeftTop: 3/8 @ ratio ) ).
    self addSubpane: ( groupPane := GroupPane new
        framingBlock: [:box| (box leftTop rightAndDown: ((box width * 3//8) @ 0))
            rightBottom: ((box width * 5//8)@(box top down: (2 *
                    listLineHeight)))]).
    groupPane addSubpane:
        ( ( pane := RadioButton new )
            contents: 'instance';
            when: #clicked: send: #instanceButton: to: self with: pane;
            selection: true;
            framingRatio: ((Rectangle leftTopUnit rightAndDown: (1/15 @ 0))
                extentFromLeftTop: 14/15 @ (1/2))).
    groupPane addSubpane:
        ( ( pane := RadioButton new )
            contents: 'class';
            when: #clicked: send: #classButton: to: self with: pane;
            framingRatio: ((Rectangle leftTopUnit rightAndDown: (1/15 @ (1/2)))
                extentFromLeftTop: 14/15 @ (1/2))).
    self addSubpane:
        ( ( pane := ListPane new )
            addHorizontalScrollbarStyle;
            setName: #instanceVars: ;
            when: #needsContents send: #instanceVars: to: self with: pane;
            when: #clicked: send: #instanceVar: to: self with: pane;
            when: #needsMenu send: #instVarsMenu: to: self with: pane;
            framingBlock: [:box|
                (box leftTop rightAndDown: ((box width * 3/8) truncated @ (2 *
                    listLineHeight)))
                  rightBottom: (box width * 5//8) @ ((box top down: box height * ratio) truncated)]).
    self addSubpane:
        ( ( pane := ListPane new )
            addHorizontalScrollbarStyle;
            setName: #selectors: ;
            when: #needsContents send: #selectors: to: self with: pane;
            when: #clicked: send: #selector: to: self with: pane;
            when: #needsMenu send: #selectorMenu: to: self with: pane;
            dragSource: self class dragDropEnabled;
            when: #dragSourceNeedsObject: send: #methodListSetDragObject: to: self;
            when: #dragTargetOver: send: #methodListDragTargetOver: to: self;
            when: #dragSourceCut: send: #methodListCut: to: self;
            dragTargetForFormats: #( 'compiledMethod' ) operations: #( #move #copy );
            dragTarget: self class dragDropEnabled;
            dragTargetEmphasisPane;
            when: #dragTargetDrop: send: #methodListDrop: to: self;
            framingRatio:
                ( Rectangle leftTopUnit + ( 5/8 @ 0 )
                    extentFromLeftTop: 3/8 @ ratio ) ).
    self addSubpane:
        ( ( pane := self toolTextPaneClass new )
            setName: #text: ;
            when: #needsContents send: #text: to: self with: pane;
            when: #aboutToSave send: #accept: to: self with: pane;
            dragTargetForFormats: #( 'string' ) operations: #( #move #copy );
            dragTarget: self class dragDropEnabled;
            framingRatio: ( Rectangle leftBottomUnit
              extentFromLeftBottom: 1 @ ( 1 - ratio ) ) )!    ! 
#('May 8, 2002' '01:12:04 PM' nil)!

(CodeFiler organizerFor: ClassHierarchyBrowser) reorganizeFrom: #(
('no category methods' createView )) !


   

CodeBrowser subclass: #Debugger
  instanceVariableNames: 
    ' debuggedProcess debuggingProcess object instIndex walkback method walkbackIndex browseWalkback breakpoints breakpointArray maxLevel logger realFrame methodInfoCache filterActivations variables '
  classVariableNames: ''
  poolDictionaries: 
    ' VirtualKeyConstants '
  categories: #( 'Tools-Debuggers' )
  comment: ''!

!Debugger methods !  
walkback: anInteger
        "Private - select the walkback line at index position anInteger."
    | process sourceInterval start end oldMethod oldActivation processIndex |
    process := self debuggedProcess.
    walkbackIndex := anInteger.
    processIndex := self  processWalkbackIndex.
    oldActivation := self activation.
    oldMethod := self method.
    browseWalkback
        ifTrue: [
            ( process isBlockFrame: processIndex )
                ifTrue: [
                    method := process contextFor: processIndex.
                    method isBlockClosure ifFalse: [ method := process methodAt: processIndex ] ]
                ifFalse: [ method := process methodAt: processIndex ] ]
        ifFalse:
            [ oldMethod := nil.
            method := breakpoints at: walkbackIndex.
            method := method classField
                compiledMethodAt: method selector.
            ].
    ((oldActivation == method) and: [(self methodPane modified not)])
        ifFalse: [self updateMethodText].
    instIndex := nil.
    self changed: #tempList:.
    self changed: #instance:.
    start := end := 1.
    browseWalkback ifTrue: [
        object := process receiverAt: processIndex.
        self
            withInfoFor: self method
            do:
                [:info |
                sourceInterval := info sourceIntervalForProcessIC: self ic.
                start := sourceInterval first.
                end :=sourceInterval last]
              ifAbsent: []].
    self methodPane showSelectionFrom: start to: end.
    self checkMenus.!  ! 
#('May 14, 2002' '02:38:09 PM' nil)!

(CodeFiler organizerFor: Debugger) reorganizeFrom: #(
('no category methods' walkback: )) !


!Debugger methods ! 
hopOut

    self walkback: walkbackIndex + 1.
    self skip.!    ! 
#('May 14, 2002' '02:37:00 PM' nil)!

(CodeFiler organizerFor: Debugger) reorganizeFrom: #(
('extensions' hopOut )) !


!Debugger methods ! 
accept: textPane
    "Private - compile and evaluate the code in textPane. Replace
    the selected temporary variable with the result of the evaluation."

    | aString locals bindings compiler compileResult |
    aString := textPane contents.
    locals := self localVariableList.
    bindings := Dictionary new: locals size.
    1 to: locals size do:
        [:idx |
        bindings at: (locals at: idx) put: (self localVariableAt: idx)].
    compiler := CompilerInterface new.
    compiler errorHandler: (TextPaneErrorHandler new pane: textPane).
    compiler nameScope:
        (compiler scopeForReservedSymbolsExcluding: #('super')) ,
        (compiler scopeForClass: self doItInstance class) ,
        (compiler scopeForDictionary: bindings) ,
        compiler scopeForGlobals.
    SourceManager current
        logEvaluate: aString
        for:
            [compileResult := compiler
                evaluate: aString
                withReceiver: self doItInstance.
            compileResult wasSuccessful
                ifFalse: [^textPane modified: true]].
    instIndex = 1    "same as Inspector..."
        ifFalse: [self localVariableAt: instIndex put: compileResult value].
    self changed: #instance:.
    textPane modified: false! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Debugger) reorganizeFrom: #(
('no category methods' accept: )) !


!Debugger methods !
acceptMethod: textPane using: oldExecutable
        "Accept a method definition from the text pane."

    | result |
    result := (CodeFiler forClass: oldExecutable classField) compile: textPane contents.
    result isNil ifTrue: [^nil].
    ^result value! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Debugger) reorganizeFrom: #(
('extensions' acceptMethod:using: )) !


!Debugger methods ! 
take: textPane
        "Private - accept the contents of textPane as an updated method
        and compile it.  Notify textPane if the compiler detects errors."

    | process oldExecutable result |
    walkbackIndex isNil
        ifTrue: [^textPane modified: false].
    CursorManager execute changeFor: [
        process := self debuggedProcess.
        oldExecutable := self selectedExecutable.
        result := self acceptMethod: textPane using: oldExecutable.
        result == nil
            ifTrue: [^textPane modified: true].
         oldExecutable selector = result selector
            ifFalse: [^textPane modified: false].
        self dropMethod: oldExecutable restartingWith: result ].
    self checkMenus.
    ^textPane modified: false!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Debugger) reorganizeFrom: #(
('no category methods' take: )) !


!Debugger methods !  
selectedClass

    self selectedMethod isNil ifTrue: [^nil].
    ^self selectedMethod classField!    ! 
#('May 3, 2002' '02:39:21 PM' nil)!

(CodeFiler organizerFor: Debugger) reorganizeFrom: #(
('no category methods' selectedClass )) !


!Debugger methods !  
goMenu
    "Private - Answer the hop, skip, jump menu."

    ^Menu new
        title: '\uGo' replaceEscapeCharacters;
        owner: self;
        appendItem: '\uHop\tF11' replaceEscapeCharacters selector: #hop accelKey: F11Key accelBits: AfLonekey;
        appendItem: '\uHop Out\tShift + F11' replaceEscapeCharacters selector: #hopOut accelKey: F11Key accelBits: AfShift;
        appendItem: '\uSkip\tF10' replaceEscapeCharacters selector: #skip accelKey: F10Key accelBits: AfLonekey;
        appendItem: '\uJump\tF5' replaceEscapeCharacters selector: #jump accelKey: F5Key accelBits: AfLonekey;
        yourself!   ! 
#('May 14, 2002' '02:36:11 PM' nil)!

(CodeFiler organizerFor: Debugger) reorganizeFrom: #(
('extensions' goMenu )) !


!Debugger methods ! 
autoCompleteListForPane: aPane

    aPane buildAutoCompleteListForClass: self selectedClass!  ! 
#('May 3, 2002' '02:19:43 PM' nil)!

(CodeFiler organizerFor: Debugger) reorganizeFrom: #(
('extensions' autoCompleteListForPane: )) !


!Debugger class methods !  
ddTextPaneTo: aBrowser
        "Private - add the primary TextPane to aBrowser."
    | pane |
    pane := SmalltalkToolInterface current textPaneClass new.
    pane
        "backColor: Color yellow;"
        owner: aBrowser;
        setName: #method: ;
        when: #needsContents send: #method: to: aBrowser with: pane;
        when: #saved send: #take: to: aBrowser with: pane;
        dragTargetForFormats: #( 'string' ) operations: #( #move #copy );
        dragTarget: self dragDropEnabled;
        framingBlock: [ :box | box leftBottom
            extentFromLeftBottom:
                ( box width @ ( box height * ( 1 - self ratio ) - self singleLineHeight ) ) rounded].

    "Only add the 'autoCompleteList' for panes that understand it."
    (pane canTriggerEvent: #needsAutoCompleteList) ifTrue: [
        pane when: #needsAutoCompleteList send: #autoCompleteListForPane: to: aBrowser with: pane].
    aBrowser addSubpane: pane.


"
    aBrowser addSubpane:
        ( ( pane := SmalltalkToolInterface current textPaneClass new )
            backColor: Color yellow;
            owner: aBrowser;
            setName: #method: ;
            when: #needsContents send: #method: to: aBrowser with: pane;
            when: #needsAutoCompleteList send: #autoCompleteListForPane: to: aBrowser with: pane;
            when: #saved send: #take: to: aBrowser with: pane;
            dragTargetForFormats: #( 'string' ) operations: #( #move #copy );
            dragTarget: self dragDropEnabled;
            framingBlock: [ :box | box leftBottom
                extentFromLeftBottom:
                    ( box width @ ( box height * ( 1 - self ratio ) - self singleLineHeight ) ) rounded ] )
"!  ! 
#('July 29, 2002' '02:30:06 PM' nil)!

(CodeFiler organizerFor: Debugger class) reorganizeFrom: #(
('no category methods' ddTextPaneTo: )) !


!Debugger class methods !
addTextPaneTo: aBrowser
        "Private - add the primary TextPane to aBrowser."
    | pane |
    pane := SmalltalkToolInterface current textPaneClass new.
    pane
        "backColor: Color yellow;"
        owner: aBrowser;
        setName: #method: ;
        when: #needsContents send: #method: to: aBrowser with: pane;
        when: #saved send: #take: to: aBrowser with: pane;
        dragTargetForFormats: #( 'string' ) operations: #( #move #copy );
        dragTarget: self dragDropEnabled;
        framingBlock: [ :box | box leftBottom
            extentFromLeftBottom:
                ( box width @ ( box height * ( 1 - self ratio ) - self singleLineHeight ) ) rounded].

    "Only add the 'autoCompleteList' for panes that understand it."
    (pane canTriggerEvent: #needsAutoCompleteList) ifTrue: [
        pane when: #needsAutoCompleteList send: #autoCompleteListForPane: to: aBrowser with: pane].
    aBrowser addSubpane: pane.


"
    aBrowser addSubpane:
        ( ( pane := SmalltalkToolInterface current textPaneClass new )
            backColor: Color yellow;
            owner: aBrowser;
            setName: #method: ;
            when: #needsContents send: #method: to: aBrowser with: pane;
            when: #needsAutoCompleteList send: #autoCompleteListForPane: to: aBrowser with: pane;
            when: #saved send: #take: to: aBrowser with: pane;
            dragTargetForFormats: #( 'string' ) operations: #( #move #copy );
            dragTarget: self dragDropEnabled;
            framingBlock: [ :box | box leftBottom
                extentFromLeftBottom:
                    ( box width @ ( box height * ( 1 - self ratio ) - self singleLineHeight ) ) rounded ] )
"! ! 
#('July 29, 2002' '02:30:06 PM' nil)!

(CodeFiler organizerFor: Debugger class) reorganizeFrom: #(
('no category methods' addTextPaneTo: )) !


!Debugger class methods !   
addInspectorPanesTo: aBrowser
        "Private - add the inst var / temporary list box/ text pane to
        aBrowser."
    | pane |
    aBrowser addSubpane:
        ( ( pane := ListPane new )
            "backColor: Color yellow;"
            owner: aBrowser;
            setName: #tempList: ;
            when: #needsContents send: #tempList: to: aBrowser with: pane;
            when: #clicked: send: #selectInstance: to: aBrowser with: pane;
            when: #doubleClicked: send: #inspectSelection: to: aBrowser with: pane;
            when: #needsMenu send: #inspectMenu: to: aBrowser with: pane;
            framingBlock: [ :box |
                ( box leftTop rightAndDown: ( box width // 2 @ self singleLineHeight ) )
                    extentFromLeftTop: ( box width / 4 @ ( box height * self ratio ) ) rounded ] ).
    aBrowser addSubpane:
        ( ( pane := SmalltalkToolInterface current textPaneClass new )
            "backColor: Color yellow;"
            owner: aBrowser;
            setName: #instance: ;
            when: #needsContents send: #instance: to: aBrowser with: pane;
            when: #saved send: #accept: to: aBrowser with: pane;
                framingBlock: [ :box |
                    ( box leftTop rightAndDown: ( box width * 3 // 4 ) @ self singleLineHeight )
                        extentFromLeftTop: ( box width + 1 / 4 @ ( box height * self ratio ) ) rounded ] )!  ! 
#('April 18, 2002' '04:34:13 PM' nil)!

(CodeFiler organizerFor: Debugger class) reorganizeFrom: #(
('no category methods' addInspectorPanesTo: )) !


!Debugger class methods !
openFor: aBrowser labeled: titleString
        "Create and open a window on <aBrowser>.  The window will be
        labeled with the <titleString>."
    aBrowser owner: aBrowser.
    aBrowser label: titleString.
    self addSubpanesFor: aBrowser.
    aBrowser mainView
        when: #closed
        send: #closed
        to: aBrowser.
    "aBrowser backColor: Color yellow."
    aBrowser addHelpManager.
    aBrowser openWindow.
    self setInitialStateOf: aBrowser! ! 
#('April 18, 2002' '04:33:08 PM' nil)!

(CodeFiler organizerFor: Debugger class) reorganizeFrom: #(
('no category methods' openFor:labeled: )) !


!Debugger class methods !
addWalkbackPaneTo: aBrowser
        "Private - add the walkback list to aBrowser."
    | margin pane |
    margin := self margin.
    aBrowser addSubpane:
        ( ( pane := ListPane new )
            "backColor: Color yellow;"
            owner: aBrowser;
            setName: #walkbackList: ;
            when: #needsContents send: #walkbackList: to: aBrowser with: pane;
            when: #clicked: send: #walkbackSelected: to: aBrowser with: pane;
            when: #needsMenu send: #menu: to: aBrowser with: pane;
            dragSource: self dragDropEnabled;
            when: #dragSourceNeedsObject: send: #methodListSetDragObject: to: aBrowser;
            when: #dragSourceCut: send: #methodListCut: to: aBrowser;
            framingBlock: [ :box |
                ( box leftTop )
                    extentFromLeftTop: box width // 2 @ ( ( box height * self ratio ) rounded + self singleLineHeight ) ] )!    ! 
#('April 18, 2002' '04:34:33 PM' nil)!

(CodeFiler organizerFor: Debugger class) reorganizeFrom: #(
('no category methods' addWalkbackPaneTo: )) !


   

Browser subclass: #Inspector
  instanceVariableNames: 
    ' object originalObject instList instIndex instPane '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Debuggers' )
  comment: ''!

!Inspector methods !  
originalObject
    originalObject isNil ifTrue: [^object] ifFalse: [^originalObject]!  ! 
#('December 1, 2001' '05:11:56 PM' nil)!

(CodeFiler organizerFor: Inspector) reorganizeFrom: #(
('no category methods' originalObject )) !


!Inspector methods !  
originalObject: anObject
    originalObject := anObject!   ! 
#('December 1, 2001' '05:11:20 PM' nil)!

(CodeFiler organizerFor: Inspector) reorganizeFrom: #(
('no category methods' originalObject: )) !


!Inspector methods ! 
createView
        "Private - create the panes for the receiver window."
    | pane |
    ( instPane := self toolTextPaneClass new )
        owner: self;
        setName: #instance: ;
        when: #help send: #help to: self;
        when: #needsContents send: #instance: to: self with: instPane;
        when: #needsAutoCompleteList send: #autoCompleteListForPane: to: self with: instPane;
        when: #saved send: #accept: to: self with: instPane;
        dragTargetForFormats: #( 'string' ) operations: #( #move #copy );
        dragTarget: self class dragDropEnabled;
        framingRatio:
            ( ( Rectangle leftTopUnit rightAndDown: ( 1/3 @ 0 ) )
                extentFromLeftTop: 2/3 @ 1 ).
    self
        label: self label;
        owner: self.
    self addSubpane:
        ( ( pane := ListPane new )
            addHorizontalScrollbarStyle;
            owner: self;
            setName: #instVarList: ;
            when: #needsContents send: #instVarList: to: self with: pane;
            when: #clicked: send: #selectInstance: to: self with: pane;
            when: #doubleClicked: send: #inspectSelection: to: self with: pane;
            when: #needsMenu send: #inspectMenu: to: self with: pane;
            framingRatio: ( Rectangle leftTopUnit extentFromLeftTop: 1/3 @ 1 ) ).

    self addSubpane: instPane!  ! 
#('May 3, 2002' '11:39:56 AM' nil)!

(CodeFiler organizerFor: Inspector) reorganizeFrom: #(
('no category methods' createView )) !


!Inspector methods !   
instance: textPane
        "Private - Set the ASCII representation
         of the selected instance variable."
    | i |
    instIndex isNil ifTrue: [^textPane contents: String new].
    instIndex = 1
        ifTrue: [^textPane contents: object printString].
    object class isPointers
       ifTrue: [(i := self getInstVarIndex) ~= 0
            ifTrue: [^textPane contents: (object instVarAt: i) printString]
            ifFalse: [^textPane contents: String new]]
       ifFalse: [^textPane contents: (object at: instIndex - 1) printString]!    ! 
#('May 3, 2002' '11:14:07 AM' nil)!

(CodeFiler organizerFor: Inspector) reorganizeFrom: #(
('no category methods' instance: )) !


!Inspector methods !
accept: textPane
        "Private - Replace the selected instance
         variable with the result of evaluating
         the contents of textPane."
    | result aString |
    instIndex isNil ifTrue: [ ^self ].
    aString := textPane contents.

    SourceManager current
        logString: aString
        for: [
            result := CompilerInterface
                evaluate: aString
                in: object class
                to: object
                notifying: textPane
                ifFail: [ ^textPane modified: true ] ].

    instIndex = 1
        ifFalse: [
            object class isBytes
                ifTrue: [
                    object
                        at: (instIndex - 1)
                        put: result]
                ifFalse: [
                    object
                        instVarAt: self getInstVarIndex
                        put: result]].
    self changed: #instance:.
    textPane modified: false
!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Inspector) reorganizeFrom: #(
('no category methods' accept: )) !


!Inspector methods !  
doItResult: aTextPane error: aBlock
        "Private - Evaluate the selected text in
         aTextPane in the context of the inspected
         object.  If error, evaluate aBlock."
    | aString selection |
    selection := aTextPane selection.
    aString := aTextPane selectedItem.
    aString  isEmpty
        ifTrue: [
            aTextPane selectLineAtCurrentSelection.
            aString := aTextPane selectedItem ].
    ^CompilerInterface
        evaluate: aString
        in: self originalObject class
        to: self originalObject
        notifying: aTextPane
        ifFail: aBlock!    ! 
#('December 1, 2001' '05:12:29 PM' nil)!

(CodeFiler organizerFor: Inspector) reorganizeFrom: #(
('no category methods' doItResult:error: )) !


!Inspector methods !   
autoCompleteListForPane: aPane

    aPane buildAutoCompleteListForClass: object class!    ! 
#('May 6, 2002' '01:46:08 PM' nil)!

(CodeFiler organizerFor: Inspector) reorganizeFrom: #(
('extensions' autoCompleteListForPane: )) !


  

Inspector subclass: #ByteArrayInspector
  instanceVariableNames: 
    ' radix bytes '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Debuggers' )
  comment: ''!

 

Inspector subclass: #DictionaryInspector
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Debuggers' )
  comment: ''!

!DictionaryInspector methods ! 
inspectMenu: pane
        "Private - Set the dictionary
         inspector list pane menu."
    | menu |
    menu := ( Menu
        labels: '\uInspect\n\uBasic inspect\n\uAdd\n\uRemove' replaceEscapeCharacters
        lines: Array new
        selectors: #(inspectSelection basicInspectSelection add remove))
            title: '\uDictionary' replaceEscapeCharacters;
            owner: self;
            yourself.
    menu disableItem: #inspectSelection.
    menu disableItem: #basicInspectSelection.
    menu disableItem: #remove.
    pane setMenu: menu!   ! 
#('November 10, 2001' '03:20:05 PM' nil)!

(CodeFiler organizerFor: DictionaryInspector) reorganizeFrom: #(
('no category methods' inspectMenu: )) !


!DictionaryInspector methods !   
basicInspectSelection
        "Private - Open an Inspector on the value
         object associated with the selected key."
    instIndex isNil
        ifTrue: [^self].
    (object at: (instList at: instIndex) key)
        basicInspect!   ! 
#('November 10, 2001' '03:20:23 PM' nil)!

(CodeFiler organizerFor: DictionaryInspector) reorganizeFrom: #(
('no category methods' basicInspectSelection )) !


!DictionaryInspector methods !  
disableInspectItem
        "Private - Disable the Inspect and Remove menu items."
    ( self menuTitled: 'Dictionary' )
        disableItem: #inspectSelection;
        disableItem: #basicInspectSelection;
        disableItem: #remove! ! 
#('November 10, 2001' '04:09:19 PM' nil)!

(CodeFiler organizerFor: DictionaryInspector) reorganizeFrom: #(
('no category methods' disableInspectItem )) !


!DictionaryInspector methods ! 
enableInspectItem
        "Private - Enable the Inspect and Remove menu items."
    ( self menuTitled: 'Dictionary' )
        enableItem: #inspectSelection;
        enableItem: #basicInspectSelection;
        enableItem: #remove!  ! 
#('November 10, 2001' '04:09:28 PM' nil)!

(CodeFiler organizerFor: DictionaryInspector) reorganizeFrom: #(
('no category methods' enableInspectItem )) !




Inspector subclass: #DoubleByteStringInspector
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Debuggers' )
  comment: ''!

 

Inspector subclass: #FieldInspector
  instanceVariableNames: 
    ' fieldSelected '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'Tools-Debuggers' )
  comment: ''!

!FieldInspector methods !
instVarList: pane
        "Private - Set an OrderedCollection of
         instance variable names and/or numbers for
         the list pane."
    pane contents: instList.
    instIndex := pane selection.
    "self changed: #instance:."!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: FieldInspector) reorganizeFrom: #(
('no category methods' instVarList: )) !


!FieldInspector methods !   
accept: textPane
        "Private - Replace the selected instance
         variable with the result of evaluating
         the contents of textPane."
    | result aString |
    instIndex isNil ifTrue: [ ^self ].
    aString := textPane contents.

    SourceManager current
        logString: aString
        for: [
            result := CompilerInterface
                evaluate: aString
                in: object class
                to: object
                notifying: textPane
                ifFail: [ ^textPane modified: true ] ].

    fieldSelected notNil ifTrue: [
        object perform: (fieldSelected , ':') asSymbol with: result.
        textPane modified: false.
        ^self].
    instIndex = 1
        ifFalse: [
            object class isBytes
                ifTrue: [
                    object
                        at: (instIndex - 1)
                        put: result]
                ifFalse: [
                    object
                        instVarAt: self getInstVarIndex
                        put: result]].
    self changed: #instance:.
    textPane modified: false.
!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: FieldInspector) reorganizeFrom: #(
('no category methods' accept: )) !


 

Inspector subclass: #GraphicInspector
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Debuggers' )
  comment: ''!

  

CodeBrowser subclass: #MethodBrowser
  instanceVariableNames: 
    ' methods selectedMethod positions highlightLiteral methodPane highlightIndex '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Browsers' )
  comment: ''!

!MethodBrowser methods ! 
text: textPane
        "Private - Compile the selected method source to determine highlight positions."

    | source string debugInfo |
    (selectedMethod notNil and: [
    (source := selectedMethod sourceString) notNil and: [
    highlightLiteral notNil]]) ifTrue: [
        string := highlightLiteral.
        string isAssociation ifTrue: [string := string key].
        (string includes: $:) ifTrue: [string := self keywordPatternFor: string].
        positions := (Pattern new: string) match: source index: 1.
        (self paneAt: #text:) class searchString: string].

    (selectedMethod notNil and: [source isNil]) ifTrue: [ source := '** source code is missing **' ].
    textPane contents: source!  ! 
#('November 19, 2001' '09:18:54 AM' nil)!

(CodeFiler organizerFor: MethodBrowser) reorganizeFrom: #(
('extensions' text: )) !


!MethodBrowser methods !   
text: textPane
    "Private - Compile the selected method source to determine highlight positions."
    | source string |
    source := self initialContent.
    
    (source notNil and: [source ~= '** source code is missing **']) ifTrue: [
        string := highlightLiteral.
        string isAssociation ifTrue: [string := string key].
        (string includes: $:) ifTrue: [string := self keywordPatternFor: string].
        positions := (Pattern new: string) match: source index: 1.
        (self paneAt: #text:) class searchString: string].
        
    textPane contents: source!    ! 
#('January 26, 2008' '09:31:13 AM' 849948)!

(CodeFiler organizerFor: MethodBrowser) reorganizeFrom: #(
('extensions' text: )) !


!MethodBrowser methods ! 
text: textPane
    "Private - Compile the selected method source to determine highlight positions."
    | source string |
    source := self initialContent.
    
    (source notNil and: [highlightLiteral notNil and: [source ~= '** source code is missing **']]) ifTrue: [
        string := highlightLiteral.
        string isAssociation ifTrue: [string := string key].
        (string includes: $:) ifTrue: [string := self keywordPatternFor: string].
        positions := (Pattern new: string) match: source index: 1.
        (self paneAt: #text:) class searchString: string].
        
    textPane contents: source! ! 
#('January 26, 2008' '09:40:59 AM' 850840)!

(CodeFiler organizerFor: MethodBrowser) reorganizeFrom: #(
('extensions' text: )) !


!MethodBrowser methods ! 
createView
        "Private - create the panes for the receiver window."
    | ratio pane |
    ratio := 2 / 5.
    self addSubpane:
        ( ( pane := ListPane new )
            addHorizontalScrollbarStyle;
            setName: #methodList: ;
            when: #needsContents send: #methodList: to: self with: pane;
            when: #needsMenu send: #listMenu: to: self with: pane;
            when: #clicked: send: #method: to: self with: pane;
            dragSource: self class dragDropEnabled;
            when: #dragSourceNeedsObject: send: #methodListSetDragObject: to: self;
            when: #dragSourceCut: send: #methodListCut: to: self;
            framingRatio: ( Rectangle leftTopUnit extentFromLeftTop: ( 1 @ ratio ) ) ).
    self addSubpane:
        ( ( methodPane := self toolTextPaneClass new )
            setName: #text: ;
            when: #needsContents send: #text: to: self with: methodPane;
            when: #needsAutoCompleteList send: #autoCompleteListForPane: to: self with: methodPane;
            when: #aboutToSave send: #accept: to: self with: methodPane;
            dragTargetForFormats: #( 'string' ) operations: #( #move #copy );
            dragTarget: self class dragDropEnabled;
            framingRatio: ( ( Rectangle leftTopUnit rightAndDown:  0 @ ratio )
                extentFromLeftTop: 1 @ ( 1 - ratio ) ) ).!  ! 
#('May 8, 2002' '01:12:04 PM' nil)!

(CodeFiler organizerFor: MethodBrowser) reorganizeFrom: #(
('no category methods' createView )) !


!MethodBrowser methods !   
initialContent
    "Private - The initial source text for the selected method. Note that in this case, nil is a valid result..."
    | source |
    selectedMethod isNil ifTrue: [^nil].
    source := selectedMethod sourceString.
    ^source isNil ifTrue: ['** source code is missing **'] ifFalse: [source]!  ! 
#('January 26, 2008' '09:25:31 AM' nil)!

(CodeFiler organizerFor: MethodBrowser) reorganizeFrom: #(
('extensions' initialContent )) !


!MethodBrowser methods !   
methodList: listPane
        "Private - Set the list of methods."
	methods isNil ifTrue: [ listPane contents: Array new. ^self ].
    listPane contents: ( methods collect: [ :cm | cm printString ] )!  ! 
#('March 30, 2003' '11:37:17 AM' nil)!

(CodeFiler organizerFor: MethodBrowser) reorganizeFrom: #(
('no category methods' methodList: )) !


!MethodBrowser methods !   
methodList: listPane
    "Private - Set the list of methods."
    methods isNil ifTrue: [ listPane contents: Array new. ^self].
    CursorManager execute changeFor: [listPane contents: (methods collect: [ :method | method printString])]!    ! 
#('March 30, 2003' '11:37:17 AM' 854452)!

(CodeFiler organizerFor: MethodBrowser) reorganizeFrom: #(
('no category methods' methodList: )) !


!MethodBrowser methods !
keywordPatternFor: selector

    | keywords pattern |
    pattern := WriteStream on: String new.
    keywords := selector asArrayOfSubstringsSeparatedBy: $:.
    keywords do: [:keyword | pattern nextPutAll: keyword; nextPut: $:] andBetweenDo: [pattern nextPut: $*].
    ^pattern contents!  ! 
#('November 19, 2001' '09:18:55 AM' nil)!

(CodeFiler organizerFor: MethodBrowser) reorganizeFrom: #(
('extensions' keywordPatternFor: )) !


!MethodBrowser methods !  
accept: textPane
        "Private - Accept the contents of textPane as an updated
         method and compile it.  Notify textPane if
         the compiler detects errors."

    | result aString |
    aString := textPane contents.
    result := (CodeFiler forClass: selectedMethod classField) compile: aString notifying: textPane.
    result isNil ifTrue: [^textPane modified: true].
    result key == selectedMethod selector
        ifTrue: [methods at: (methods indexOf: selectedMethod) put: (selectedMethod := result value)]
        ifFalse: [
            selectedMethod := result value.
            methods add: selectedMethod.
            self changed: #methodList: with: #restoreSelected: with: selectedMethod printString].
    textPane modified: false; cursorPosition: 0; anchorPosition: 0; forceSelectionOntoDisplay! ! 
#('May 8, 2002' '01:12:04 PM' nil)!

(CodeFiler organizerFor: MethodBrowser) reorganizeFrom: #(
('no category methods' accept: )) !


!MethodBrowser methods !  
advanceHighlightIndex

    highlightIndex := 1.!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: MethodBrowser) reorganizeFrom: #(
('extensions' advanceHighlightIndex )) !


!MethodBrowser methods ! 
resetHighlightIndex

    highlightIndex := 1.
    positions := nil.! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: MethodBrowser) reorganizeFrom: #(
('extensions' resetHighlightIndex )) !


!MethodBrowser methods !   
method: listPane
        "Private - Display source code for the selected method."

    | method index |
    index := listPane selection. index isNil ifTrue: [^self].
    method := methods at: index.
    method == selectedMethod
        ifTrue: [self advanceHighlightIndex]
        ifFalse: [
            selectedMethod := method.
            selectedMethod := selectedMethod classField compiledMethodAt: selectedMethod selector.
            selectedMethod isNil ifTrue: [self error: 'deleted method'].
            methods at: listPane selection put: selectedMethod.
            self resetHighlightIndex].

    self changed: #text:.
    self enableMethodsMenu.
    positions isNil ifTrue: [^self].
    positions isPoint
        ifTrue: [methodPane showSelectionFrom: positions x to: positions y + 1 ]
        ifFalse: [methodPane showSelectionFrom: positions position to: positions endPosition]!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: MethodBrowser) reorganizeFrom: #(
('extensions' method: )) !


!MethodBrowser methods !   
selectedClass
    "Private - answer the selected class."
        
    selectedMethod isNil ifTrue: [^nil].    
    ^selectedMethod classField!  ! 
#('May 3, 2002' '02:35:25 PM' nil)!

(CodeFiler organizerFor: MethodBrowser) reorganizeFrom: #(
('no category methods' selectedClass )) !


!MethodBrowser methods !
autoCompleteListForPane: aPane

    aPane buildAutoCompleteListForClass: self selectedClass!  ! 
#('May 3, 2002' '02:19:49 PM' nil)!

(CodeFiler organizerFor: MethodBrowser) reorganizeFrom: #(
('extensions' autoCompleteListForPane: )) !


  

CodeBrowser subclass: #MethodVersionBrowser
  instanceVariableNames: 
    ' methodVersions selectedVersion '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Browsers' )
  comment: ''!

!MethodVersionBrowser methods !
menuForMethodVersionsPane: aPane
    "Set the menu for my method versions pane"

    | menu |

    menu := Menu new
        title: 'version';
        owner: self;
        appendItem: 'Load' action: [:owner | self acceptTextForPane: (self paneAt: #text)];
        appendSeparator;
        appendItem: 'Update' action: [:owner | self update];
        yourself.
    aPane notNil ifTrue: [aPane setMenu: menu].
    self updateMethodVersionsMenu.
    ^menu!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: MethodVersionBrowser) reorganizeFrom: #(
('pane events handling' menuForMethodVersionsPane: )) !


!MethodVersionBrowser methods !
textForPane: aPane
    "Set the text for my text pane to be the source of the selected methodVersion"

    selectedVersion isNil
        ifTrue: [aPane contents: String new]
        ifFalse: [aPane contents: selectedVersion source]!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: MethodVersionBrowser) reorganizeFrom: #(
('pane events handling' textForPane: )) !


!MethodVersionBrowser methods !  
textForPane: aPane
    "Set the text for my text pane to be the source of the selected methodVersion"
    
    aPane contents: self initialContent!  ! 
#('January 26, 2008' '09:33:31 AM' 859820)!

(CodeFiler organizerFor: MethodVersionBrowser) reorganizeFrom: #(
('pane events handling' textForPane: )) !


!MethodVersionBrowser methods !  
acceptTextForPane: aPane

    | result oldMethod codeFiler theClass previousSourcePosition selector |

    methodVersions isEmpty
        ifTrue: [^self].

    CursorManager execute changeFor: [
        result := (CodeFiler forClass: methodVersions first smalltalkClass) compile: aPane contents notifying: aPane].

    aPane modified: result isNil; cursorPosition: 0; anchorPosition: 0; forceSelectionOntoDisplay.
    self update!   ! 
#('May 8, 2002' '01:12:04 PM' nil)!

(CodeFiler organizerFor: MethodVersionBrowser) reorganizeFrom: #(
('pane events handling' acceptTextForPane: )) !


!MethodVersionBrowser methods !
createViews
    "Private - create the panes for the receiver window."
    | ratio thisPane |

    ratio := 2 / 5.
    self
        addSubpane: ((thisPane := ListPane new)
            setName: #list;
            addHorizontalScrollbarStyle;
            printSelector: #stampPrintString;
            when: #needsContents send: #methodVersionsForPane: to: self with: thisPane;
            when: #needsMenu send: #menuForMethodVersionsPane: to: self with: thisPane;
            when: #clicked: send: #selectedMethodVersionForPane: to: self with: thisPane;
            framingRatio: (Rectangle leftTopUnit extentFromLeftTop: 1@ratio));
        addSubpane: ((thisPane := self toolTextPaneClass new)
            setName: #text;
            when: #needsContents send: #textForPane: to: self with: thisPane;
            when: #aboutToSave send: #acceptTextForPane: to: self with: thisPane;
            framingRatio: ((Rectangle leftTopUnit rightAndDown: 0@ratio)
                extentFromLeftTop: 1@(1 - ratio))).!   ! 
#('May 8, 2002' '01:12:04 PM' nil)!

(CodeFiler organizerFor: MethodVersionBrowser) reorganizeFrom: #(
('scheduling' createViews )) !


!MethodVersionBrowser methods ! 
initialContent
    "The initial source of the selected methodVersion"

    ^selectedVersion isNil ifTrue: [String new] ifFalse: [selectedVersion source]!    ! 
#('January 26, 2008' '09:32:51 AM' nil)!

(CodeFiler organizerFor: MethodVersionBrowser) reorganizeFrom: #(
('pane events handling' initialContent )) !


  

ViewManager subclass: #ModelObjectTest
  instanceVariableNames: 
    ' sharedValue timer '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



Inspector subclass: #OrderedCollectionInspector
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Debuggers' )
  comment: ''!

!OrderedCollectionInspector methods !   
accept: textPane
        "Private - Replace the selected instance variable
         with the result of evaluating the contents of textPane."
    | aString result |
    instIndex isNil ifTrue: [ ^self ].
    aString := textPane contents.

    SourceManager current
        logString: aString
        for: [
            result := CompilerInterface
                evaluate: aString
                in: object class
                to: object
                notifying: textPane
                ifFail: [ ^textPane modified: true ] ].

    instIndex > 1
        ifTrue: [ object at: ( instIndex - 1 ) put: result ].
    self changed: #instance:.
    textPane modified: false
!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: OrderedCollectionInspector) reorganizeFrom: #(
('no category methods' accept: )) !


 

ViewManager subclass: #PaneTester
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PaneTester subclass: #HeaderTester
  instanceVariableNames: 
    ' lastSelectedHeaderIndex ascending '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

ViewManager subclass: #PARTSBitEditor
  instanceVariableNames: 
    ' bitPen bitColor fillColor imagePen copy original scale windowSize changeFlag fileName saveBlock grid selection partWrapper '
  classVariableNames: 
    ' ColorDictionary '
  poolDictionaries: 
    ' GraphicsConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

Debugger subclass: #PARTSDeveloperDebugger
  instanceVariableNames: 
    ' partsDebugger application suspendedTimers '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSBitEditor subclass: #PARTSIconEditor
  instanceVariableNames: 
    ' andMask xorMask icon mode '
  classVariableNames: 
    ' CurrentClass '
  poolDictionaries: 
    ' GraphicsConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSIconEditor subclass: #PARTSIconEditorWindows
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' GraphicsConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



ViewManager subclass: #PersonEditor
  instanceVariableNames: 
    ' currentPerson changed '
  classVariableNames: 
    ' PersonList '
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

ViewManager subclass: #PersonPaneTester
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



MethodBrowser subclass: #SelectorBrowser
  instanceVariableNames: 
    ' sourceManager selectors selectedSelector method '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Browsers' )
  comment: ''!

!SelectorBrowser methods !   
sourceManager: aSourceManager
    sourceManager := aSourceManager! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SelectorBrowser) reorganizeFrom: #(
('get/set' sourceManager: )) !


!SelectorBrowser methods !   
sourceManager
    ^sourceManager!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SelectorBrowser) reorganizeFrom: #(
('get/set' sourceManager )) !


!SelectorBrowser methods !
createView
        "Private - create the panes for the receiver window."
    | xRatio yRatio pane oneLineHeight group |
    oneLineHeight := ListFont height + 8.
    xRatio := 2 / 5.
    yRatio := 2 / 5.
    self
        owner: self;
        label: 'Messages in ', selectedMethod printString.
    self addSubpane:
        ( ( pane := ListPane new )
            addHorizontalScrollbarStyle;
            setName: #selectors: ;
            when: #needsContents send: #selectors: to: self with: pane;
            when: #clicked: send: #selector: to: self with: pane;
            framingBlock: [ :box |
                box leftTop
                    extentFromLeftTop: ( box width * xRatio ) truncated @ ( box height * yRatio ) truncated ] ).
    self addSubpane:
        ( ( group := GroupPane new )
            framingBlock: [ :box |
                ( box leftTop right: ( box width * xRatio ) truncated )
                    extentFromLeftTop: ( box width * ( 1 - xRatio ) ) truncated @ oneLineHeight ] ).
    group
        addSubpane: ( ( pane := RadioButton new )
            contents: 'senders';
            when: #clicked: send: #sendersButton: to: self with: pane;
            framingRatio: ( ( Rectangle leftTopUnit rightAndDown: ( 1/15 @ 0 ) )
                extentFromLeftTop: 7/15 @ 1 );
            yourself ).
    group
        addSubpane: ( ( pane := RadioButton new )
            contents: 'implementors';
            selection: true;
            when: #clicked: send: #implementorsButton: to: self with: pane;
            framingRatio: ( ( Rectangle leftTopUnit rightAndDown: ( 8/15 @ 0 ) )
                extentFromLeftTop: 7/15 @ 1 );
            yourself ).
    self addSubpane:
        ( ( pane := ListPane new )
            addHorizontalScrollbarStyle;
            setName: #methodList: ;
            when: #needsContents send: #methodList: to: self with: pane;
            when: #needsMenu send: #listMenu: to: self with: pane;
            when: #clicked: send: #method: to: self with: pane;
            dragSource: self class dragDropEnabled;
            when: #dragSourceNeedsObject: send: #methodListSetDragObject: to: self;
            when: #dragSourceCut: send: #methodListCut: to: self;
            framingBlock: [ :box |
                ( box leftTop truncated rightAndDown: ( box width * xRatio ) truncated @ oneLineHeight )
                    extentFromLeftTop: ( box width * ( 1 - xRatio ) ) truncated @ ( ( box height * yRatio ) truncated - oneLineHeight ) ] ).
    self addSubpane:
        ( ( methodPane := self toolTextPaneClass new )
            setName: #text: ;
            when: #needsContents send: #text: to: self with: methodPane;
            when: #needsAutoCompleteList send: #autoCompleteListForPane: to: self with: methodPane;
            when: #aboutToSave send: #accept: to: self with: methodPane;
            dragTargetForFormats: #( 'string' ) operations: #( #move #copy );
            dragTarget: self class dragDropEnabled;
            framingRatio: ( ( Rectangle leftTopUnit rightAndDown: ( 0 @ yRatio ) )
                extentFromLeftTop: ( 1 @ ( 1 - yRatio ) ) ) )! ! 
#('May 8, 2002' '01:12:04 PM' nil)!

(CodeFiler organizerFor: SelectorBrowser) reorganizeFrom: #(
('no category methods' createView )) !


!SelectorBrowser methods !   
selector: listPane
        "Private - An item was selected in the selectors pane."
    | selector |
    selector := listPane selectedItem.
    methods := nil.
    self disableMethodsMenu.
    selectedMethod := method.
    selectedSelector := selector.
    self literal: selector.
    self changed: #methodList: ;
        changed: #text: .
    positions isPoint ifTrue: [methodPane showSelectionFrom: positions x to: positions y + 1].
    ( self paneAt: 'senders' ) selection
        ifTrue: [ self selSenders ]
        ifFalse: [ self selImplementors ]! ! 
#('November 19, 2001' '09:18:55 AM' nil)!

(CodeFiler organizerFor: SelectorBrowser) reorganizeFrom: #(
('no category methods' selector: )) !


!SelectorBrowser methods !  
selImplementors
        "Private - Pop-up a window with the
         implementors of the selected selector."
    CursorManager execute changeFor: [
        selectedSelector isNil ifFalse: [
            methods := OrderedCollection new.
            Smalltalk rootClasses do: [ :aClass |
                methods := methods, ( aClass implementorsOf: selectedSelector ) ].
            self literal: nil.
            self changed: #methodList: .
            methods isEmpty
                ifTrue: [ self disableMethodsMenu ]
                ifFalse: [ self enableMethodsMenu ] ] ]!   ! 
#('March 30, 2003' '05:20:18 PM' nil)!

(CodeFiler organizerFor: SelectorBrowser) reorganizeFrom: #(
('no category methods' selImplementors )) !


!SelectorBrowser methods !   
selImplementors
        "Private - Pop-up a window with the
         implementors of the selected selector."
    CursorManager execute changeFor: [
        selectedSelector isNil ifFalse: [
            methods := OrderedCollection new.
            self sourceManager smalltalk rootClasses do: [:aClass |
                methods addAll: ( aClass implementorsOf: selectedSelector)].
            methods := methods asSortedCollection: [:a :b | a classField name < b classField name].
            self literal: nil.
            self changed: #methodList: .
            methods isEmpty
                ifTrue: [self disableMethodsMenu]
                ifFalse: [self enableMethodsMenu]]]!    ! 
#('March 30, 2003' '05:20:18 PM' 870968)!

(CodeFiler organizerFor: SelectorBrowser) reorganizeFrom: #(
('no category methods' selImplementors )) !


!SelectorBrowser methods !
selImplementors
        "Private - Pop-up a window with the
         implementors of the selected selector."
    CursorManager execute changeFor: [
        selectedSelector isNil ifFalse: [
            methods := OrderedCollection new.
            self sourceManager smalltalk rootClasses do: [:aClass |
                methods addAll: ( aClass implementorsOf: selectedSelector)].
            methods := methods asSortedCollection: [:a :b | a classField name < b classField name].
            methods := methods asOrderedCollection.
            self literal: nil.
            self changed: #methodList: .
            methods isEmpty
                ifTrue: [self disableMethodsMenu]
                ifFalse: [self enableMethodsMenu]]]!   ! 
#('March 30, 2003' '05:25:31 PM' 871748)!

(CodeFiler organizerFor: SelectorBrowser) reorganizeFrom: #(
('no category methods' selImplementors )) !


!SelectorBrowser methods !
accept: textPane
        "Private - Accept the contents of textPane as an updated
         method and compile it.  Notify textPane if
         the compiler detects errors."
    | result class aString codeFiler selector previousSourcePosition oldMethod |

    selectedMethod = method
        ifFalse: [^super accept: textPane].

    result := (CodeFiler forClass: method classField) compile: textPane contents notifying: textPane.
    result isNil ifTrue: [^textPane modified: true].

    method := selectedMethod := result value.
    selectors := (method messages collect: [:m | (m isCompiledMethod) ifTrue: [m selector] ifFalse: [m]]) asSortedCollection.
    selectedSelector := nil.
    self
        changed: #selectors: ;
        changed: #methodList: .
    textPane modified: false; cursorPosition: 0; anchorPosition: 0; forceSelectionOntoDisplay!   ! 
#('May 8, 2002' '01:12:04 PM' nil)!

(CodeFiler organizerFor: SelectorBrowser) reorganizeFrom: #(
('no category methods' accept: )) !


!SelectorBrowser methods !  
selSenders
        "Private - Pop-up a window with the
         senders of the selected selector."
    CursorManager execute changeFor: [
        selectedSelector isNil ifFalse: [
            methods := OrderedCollection new.
            Smalltalk rootClasses do:[:aClass|
                methods := methods, (aClass sendersOf: selectedSelector)].
            self literal: selectedSelector.
            methods isEmpty
                ifTrue: [ self disableMethodsMenu ]
                ifFalse: [ self changed: #methodList: ; enableMethodsMenu ] ] ]! ! 
#('March 30, 2003' '05:21:05 PM' nil)!

(CodeFiler organizerFor: SelectorBrowser) reorganizeFrom: #(
('no category methods' selSenders )) !


!SelectorBrowser methods !
selSenders
        "Private - Pop-up a window with the
         senders of the selected selector."
    CursorManager execute changeFor: [
        selectedSelector isNil ifFalse: [
            methods := OrderedCollection new.
            self sourceManager smalltalk  rootClasses do:[:aClass|
                methods addAll: (aClass sendersOf: selectedSelector)].
            methods := methods asSortedCollection: [:a :b | a classField name < b classField name].
            self literal: selectedSelector.
            methods isEmpty
                ifTrue: [ self disableMethodsMenu ]
                ifFalse: [ self changed: #methodList: ; enableMethodsMenu ] ] ]!    ! 
#('March 30, 2003' '05:21:05 PM' 874624)!

(CodeFiler organizerFor: SelectorBrowser) reorganizeFrom: #(
('no category methods' selSenders )) !


!SelectorBrowser methods ! 
selSenders
        "Private - Pop-up a window with the
         senders of the selected selector."
    CursorManager execute changeFor: [
        selectedSelector isNil ifFalse: [
            methods := OrderedCollection new.
            self sourceManager smalltalk  rootClasses do:[:aClass|
                methods addAll: (aClass sendersOf: selectedSelector)].
            methods := methods asSortedCollection: [:a :b | a classField name < b classField name].
            methods := methods asOrderedCollection.
            self literal: selectedSelector.
            methods isEmpty
                ifTrue: [ self disableMethodsMenu ]
                ifFalse: [ self changed: #methodList: ; enableMethodsMenu ] ] ]!   ! 
#('March 30, 2003' '05:25:25 PM' 875368)!

(CodeFiler organizerFor: SelectorBrowser) reorganizeFrom: #(
('no category methods' selSenders )) !


   

Browser subclass: #TextWindow
  instanceVariableNames: 
    ' file partial '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'Windows-Views' )
  comment: ''!

!TextWindow methods ! 
<< anObject
    anObject isCharacter ifTrue: [^self nextPut: anObject].
    anObject isString ifTrue: [^self nextPutAll: anObject].
    self print: anObject.!   ! 
#('October 16, 2008' '07:12:15 PM' nil)!

(CodeFiler organizerFor: TextWindow) reorganizeFrom: #(
('extensions' << )) !


!TextWindow methods ! 
print: anObject
    anObject printOn: self!    ! 
#('October 16, 2008' '07:13:01 PM' nil)!

(CodeFiler organizerFor: TextWindow) reorganizeFrom: #(
('extensions' print: )) !


!TextWindow methods ! 
space: number
    number timesRepeat: [self space]!    ! 
#('April 29, 2003' '10:10:59 AM' nil)!

(CodeFiler organizerFor: TextWindow) reorganizeFrom: #(
('extensions' space: )) !




TextWindow subclass: #PARTSTextWindow
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

TextWindow subclass: #TranscriptWindow
  instanceVariableNames: ''
  classVariableNames: 
    ' DefaultClass DefaultText '
  poolDictionaries: ''
  categories: #( 'Windows-Views' )
  comment: ''!

!TranscriptWindow methods !
open
        "Create and open the receiver window."
    self createView.
    self addHelpManager.
    Transcript isNil
        ifTrue: [ Transcript := self ]
        ifFalse: [ Transcript become: self ].
    self openWindow.
    (self paneAt: #text) owner: self class defaultText!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: TranscriptWindow) reorganizeFrom: #(
('extensions' open )) !


!TranscriptWindow methods !
print: anObject
    anObject printOn: self!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: TranscriptWindow) reorganizeFrom: #(
('extensions' print: )) !


!TranscriptWindow methods !  
createView
        "Private - create the panes for the receiver window."
    | pane |
    self
        setLabel;
        owner: self.
    self mainView when: #aboutToClose send: #close: to: self with: self mainView.
    self addSubpane: ( ( pane := self textPaneClass new )
        setName: #text ;
        when: #saved send: #saveString: to: self with: pane;
        owner: self class defaultText;
        dragTargetForFormats: #( 'string' ) operations: #( #move #copy );
        dragTarget: self class dragDropEnabled;
        yourself )!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: TranscriptWindow) reorganizeFrom: #(
('extensions' createView )) !


!TranscriptWindow methods !  
labelWithoutPrefix: label
    super labelWithoutPrefix: label.
    self halt: 'Using label without prefix'.!  ! 
#('October 11, 2013' '02:34:37 PM' nil)!

(CodeFiler organizerFor: TranscriptWindow) reorganizeFrom: #(
('no category methods' labelWithoutPrefix: )) !


!TranscriptWindow methods !   
labelWithoutPrefix: label
    super labelWithoutPrefix: label.
    "self halt: 'Using label without prefix'."!    ! 
#('October 11, 2013' '02:41:01 PM' 879944)!

(CodeFiler organizerFor: TranscriptWindow) reorganizeFrom: #(
('no category methods' labelWithoutPrefix: )) !


!TranscriptWindow methods !
<< anObject
    anObject isCharacter ifTrue: [^self nextPut: anObject].
    anObject isString ifTrue: [^self nextPutAll: anObject].
    self print: anObject.!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: TranscriptWindow) reorganizeFrom: #(
('extensions' << )) !


!TranscriptWindow methods !  
store: anObject
    anObject storeOn: self!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: TranscriptWindow) reorganizeFrom: #(
('extensions' store: )) !


!TranscriptWindow methods !  
saveString: aPane
        "Private - Save the contents of a workspace."
    self class defaultText: aPane contents.
    aPane owner: aPane contents.
    ^aPane modified: false!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: TranscriptWindow) reorganizeFrom: #(
('extensions' saveString: )) !


!TranscriptWindow class methods !   
defaultText: aString
    DefaultText := aString!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: TranscriptWindow class) reorganizeFrom: #(
('extensions' defaultText: )) !


!TranscriptWindow class methods !
defaultText

    DefaultText isNil ifTrue: [DefaultText := ''].
    ^DefaultText!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: TranscriptWindow class) reorganizeFrom: #(
('extensions' defaultText )) !


  

ExternalBuffer subclass: #VirtualMachineConfiguration
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Special Objects' )
  comment: ''!

   

CodeWriter subclass: #VisualWorksClassWriter
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'Tools-Code Writers & Readers' )
  comment: ''!

!VisualWorksClassWriter methods !   
definitionString
    "   ^   <String>
    Return a string which is the definition of the class I represent."

    | stream categories |

    stream := WriteStream on: (String new: 64).
    categories := self codeFilerClass systemOrganizer categoriesOfElement: self forClass name asSymbol.
    self forClass fileOutOn: stream.
    stream
        cr ;space; space;
        nextPutAll: 'category: ';
        nextPutAll: categories first printString;
        cr.
    ^stream contents!  ! 
#('March 9, 2003' '09:01:04 AM' nil)!

(CodeFiler organizerFor: VisualWorksClassWriter) reorganizeFrom: #(
('accessing' definitionString )) !


!VisualWorksClassWriter methods !   
fileOutCommentOn: stream
    "   stream  <WriteStream>
        ^       self
    Put a textual version of my class comment to stream."

    stream cr; nextPutAll: self forClass name; nextPutAll: ' comment: ';
        nextPutAll: (self codeFilerClass commentFor: self forClass name asSymbol) storeString;
        nextPut: $!!;
        cr!    ! 
#('March 9, 2003' '09:27:50 AM' nil)!

(CodeFiler organizerFor: VisualWorksClassWriter) reorganizeFrom: #(
('filing out support' fileOutCommentOn: )) !


!VisualWorksClassWriter methods ! 
fileOutOn: aStream
    "File out all of my classes on aStream"

    super fileOutOn: aStream.
    self classes do: [:aClass |
        self
            forSuperclassOfClass: aClass;
            fileOutInitializeOn: aStream]!  ! 
#('March 9, 2003' '09:48:18 AM' nil)!

(CodeFiler organizerFor: VisualWorksClassWriter) reorganizeFrom: #(
('filing out' fileOutOn: )) !


 

VisualWorksClassWriter subclass: #TeamVClassWriter
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Code Writers & Readers' )
  comment: ''!



TextWindow subclass: #WalkbackWindow
  instanceVariableNames: 
    ' debugger '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Windows-Views' )
  comment: ''!

!WalkbackWindow methods !
initWindowSize
        "Private - answer the Rectangle within which
         the Walkback window should be opened."
    | extent offset |
    extent := ( 50 * SysFontWidth ) @  ( 18 * SysFontHeight ).
    offset := ( Display extent - extent ) // 2.
    ^offset extent: extent!  ! 
#('May 16, 2005' '10:26:02 PM' nil)!

(CodeFiler organizerFor: WalkbackWindow) reorganizeFrom: #(
('no category methods' initWindowSize )) !


!WalkbackWindow methods !
initWindowSize
        "Private - answer the Rectangle within which
         the Walkback window should be opened."
    | extent offset |
    extent := (100 * SysFontWidth) @  (18 * SysFontHeight).
    offset := (Display extent - extent) // 2.
    ^offset extent: extent!   ! 
#('May 16, 2005' '10:26:03 PM' 884472)!

(CodeFiler organizerFor: WalkbackWindow) reorganizeFrom: #(
('no category methods' initWindowSize )) !


  

MciFileStream subclass: #WaveAudio
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



ViewManager subclass: #WBCompositePaneTester
  instanceVariableNames: 
    ' classToTest frame '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

ViewManager subclass: #WBDevelopmentWindow
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



WBDevelopmentWindow subclass: #BitEditor
  instanceVariableNames: 
    ' bitPen bitColor bitPoint scale copy imagePen imageForm imageRect windowSize '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

BitEditor subclass: #ButtonEditor
  instanceVariableNames: 
    ' fileName '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBDevelopmentWindow subclass: #WBAttributeWindow
  instanceVariableNames: 
    ' owner hasChanged ownerChanged '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBDevelopmentWindow subclass: #WBDefaultScratchWindow
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

Association subclass: #WBEventArgumentDescription
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

Association subclass: #WBEventDescription
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

Object subclass: #WBEventMap
  instanceVariableNames: 
    ' map '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

Message subclass: #WBEventMessage
  instanceVariableNames: 
    ' source event '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

ViewManager subclass: #WBEventTranslationEditor
  instanceVariableNames: 
    ' newEventListBox eventMapListBox classListBox owner selectedClass eventMapKeys eventMap newEvents selectedOldEvent '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

Object subclass: #WBGraphicObject
  instanceVariableNames: 
    ' rect lastRect properties '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBGraphicObject subclass: #WBInterfaceObject
  instanceVariableNames: 
    ' foreColor backColor contents style font menu framingBlock tabPosition realClass resID parentWindow isInstVar creationMethodSelector realWidget '
  classVariableNames: 
    ' ClassAndStyleDict Templates '
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBInterfaceObject subclass: #FrameObject
  instanceVariableNames: 
    ' editor lookPolicy '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBInterfaceObject subclass: #PButton
  instanceVariableNames: 
    ' specialId '
  classVariableNames: 
    ' AutoRecognizeOkCancel '
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



WBInterfaceObject subclass: #PComboBox
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



WBInterfaceObject subclass: #PCompositePane
  instanceVariableNames: 
    ' initialFraming children defaultBackColor '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBInterfaceObject subclass: #PDrawnButton
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PDrawnButton subclass: #PActionButton
  instanceVariableNames: 
    ' action '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PComboBox subclass: #PDropDownList
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



WBInterfaceObject subclass: #PEntryField
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PEntryField subclass: #PEnhancedEntryField
  instanceVariableNames: 
    ' case character field getFocus justification maxSize autoTab '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBInterfaceObject subclass: #PEntryFieldGroup
  instanceVariableNames: 
    ' label children bestSize '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PEntryField subclass: #PFormattedEntryField
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBInterfaceObject subclass: #PGenericSubpane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBInterfaceObject subclass: #PGraphPane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PGraphPane subclass: #PAnimationPane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBInterfaceObject subclass: #PGroupbox
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



PGroupBox subclass: #PEllipticSkinBox
  instanceVariableNames: 
    ' rotation '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

!PEllipticSkinBox methods !  
displayWith: aPen clipRect: clipRect

    aPen setClipRect: (Rectangle origin: 0@0 extent: Display extent).
    self lookPolicy
        drawEllipticBox: self
        with: aPen
        rotation: self rotation! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: PEllipticSkinBox) reorganizeFrom: #(
('drawing' displayWith:clipRect: )) !


!PEllipticSkinBox methods !  
rotation
    ^rotation isNil ifTrue: [0.0] ifFalse: [rotation]!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: PEllipticSkinBox) reorganizeFrom: #(
('get/set' rotation )) !


!PEllipticSkinBox methods !   
copySpecificsTo: aPane
    aPane rotation: self rotation!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: PEllipticSkinBox) reorganizeFrom: #(
('copying' copySpecificsTo: )) !


!PEllipticSkinBox methods !   
rotation: aFloat
    rotation := aFloat.
    "self propertyAt: #rotation put: aFloat"!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: PEllipticSkinBox) reorganizeFrom: #(
('get/set' rotation: )) !


 

PDrawnButton subclass: #PLinkButton
  instanceVariableNames: 
    ' link type '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBInterfaceObject subclass: #PListBox
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PListBox subclass: #PButtonListBox
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PListBox subclass: #PColumnListBox
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PListBox subclass: #PListPane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PListBox subclass: #PMultipleSelectListBox
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



WBInterfaceObject subclass: #PRadioButtonGroup
  instanceVariableNames: 
    ' label numColumns children '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PRadioButtonGroup subclass: #PCheckBoxGroup
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBInterfaceObject subclass: #PRealWidgetControl
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PRealWidgetControl subclass: #PHeader
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants WinCommonControlConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PRealWidgetControl subclass: #PListView
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants WinCommonControlConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PRealWidgetControl subclass: #PProgressBar
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PGroupBox subclass: #PRectangularSkinBox
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

!PRectangularSkinBox methods !
displayWith: aPen clipRect: clipRect

    aPen setClipRect: (Rectangle origin: 0@0 extent: Display extent).
    self lookPolicy
        drawRectangularBox: self
        with: aPen
        clipRect: clipRect!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: PRectangularSkinBox) reorganizeFrom: #(
('drawing' displayWith:clipRect: )) !


  

PRealWidgetControl subclass: #PRichEdit
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBInterfaceObject subclass: #PScrollBar
  instanceVariableNames: 
    ' minimum maximum lineIncrement pageIncrement '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



WBInterfaceObject subclass: #PSpinButton
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBInterfaceObject subclass: #PStaticBox
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants SystemColorConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBInterfaceObject subclass: #PStaticGraphic
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBInterfaceObject subclass: #PStaticText
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBInterfaceObject subclass: #PStatusPane
  instanceVariableNames: 
    ' statusBoxes '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PRealWidgetControl subclass: #PStatusWindow
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants WinCommonControlConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PRealWidgetControl subclass: #PTabControl
  instanceVariableNames: 
    ' firstPage '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants WinCommonControlConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBInterfaceObject subclass: #PTextEdit
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



PGraphPane subclass: #PTextPane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBInterfaceObject subclass: #PToggle
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PToggle subclass: #PCheckBox
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PToggle subclass: #PRadioButton
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PToggle subclass: #PThreeStateButton
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PRealWidgetControl subclass: #PTrackBar
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' WinCommonControlConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PRealWidgetControl subclass: #PTreeView
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PRealWidgetControl subclass: #PUpDown
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PRealWidgetControl subclass: #PVideoPane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PScrollBar subclass: #PWBHorizontalScrollBar
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBInterfaceObject subclass: #PWBInvisibleGroupPane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PDrawnButton subclass: #PWBStaticGraphic
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBInterfaceObject subclass: #PWBToolBar
  instanceVariableNames: 
    ' cellSize elements useSystem '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



PScrollBar subclass: #PWBVerticalScrollBar
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



Menu subclass: #WBMenu
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

MenuItem subclass: #WBMenuItem
  instanceVariableNames: 
    ' menu owner enableSelector toggleSelector '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBDevelopmentWindow subclass: #WBMenuTester
  instanceVariableNames: 
    ' menus '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

Message subclass: #WBMessage
  instanceVariableNames: 
    ' source sourceSelector '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

ViewManager subclass: #WBMiniBrowserExample
  instanceVariableNames: 
    ' selectedClass selectedMethodSelector '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



StringDictionaryReader subclass: #WBNLSDictionaryReader
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBObject subclass: #FramingParameters
  instanceVariableNames: 
    ' initialExtent bottom top right left bottomRel topRel rightRel leftRel centerX centerY indent clientRect duHeight duWidth '
  classVariableNames: 
    ' InitializationSelector '
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBObject subclass: #WBAction
  instanceVariableNames: 
    ' receiver originator script '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBObject subclass: #WBAddress
  instanceVariableNames: 
    ' street1 street2 city state zip '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBObject subclass: #WBDevelopmentObject
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   
WBAbstractAddInModule class instanceVariableNames: ' loaded '
  categories: #( )
  comment: ''!

 
WBActionLinkAddInModule class instanceVariableNames: ''
  categories: #( )
  comment: ''!

   

WBDevelopmentObject subclass: #WBCodeGenBase
  instanceVariableNames: 
    ' owner '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBCodeGenBase subclass: #WBAbstractCodeModule
  instanceVariableNames: 
    ' object stream targetClass selector arguments comment targetClassDefinition category targetObject '
  classVariableNames: 
    ' ActiveCodeModules '
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBAbstractCodeModule subclass: #WBBasicCodeModule
  instanceVariableNames: 
    ' sourceString '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBCodeGenBase subclass: #WBClassDefinition
  instanceVariableNames: 
    ' classField poolNames nlsPools allInstVarNames instVarNames '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

!WBClassDefinition methods !  
classVarNamesString
        "Answer the receiver's class  variables as a string."
    | stream |
    stream := WriteStream on: (String new: 20).
    self classVarNames
        do: [ :eachName | stream nextPutAll: eachName ]
        andBetweenDo: [ stream space ].
    ^stream contents!    ! 
#('November 19, 2001' '09:18:54 AM' nil)!

(CodeFiler organizerFor: WBClassDefinition) reorganizeFrom: #(
('no category methods' classVarNamesString )) !




WBCodeGenBase subclass: #WBCodeGenerator
  instanceVariableNames: 
    ' properties policy useInstVars modules modulesToProcess classDefinitions '
  classVariableNames: 
    ' CurrentCodePolicy GenerateDirectBitmapRefs '
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBAbstractCodeModule subclass: #WBCodeModule
  instanceVariableNames: 
    ' varNames temporaries localFonts '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBCodeGenBase subclass: #WBCodePolicy
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBCodeGenBase subclass: #WBCodeStream
  instanceVariableNames: 
    ' stream indent lineStartPos maxLineSize endChar parenthesis noParenthesis '
  classVariableNames: 
    ' ActiveCodeModules '
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  
WBCompositePaneExampleAddInModule class instanceVariableNames: ''
  categories: #( )
  comment: ''!

 

WBCodeModule subclass: #WBCreateMenuModule
  instanceVariableNames: 
    ' menu menuIndex '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBCreateMenuModule subclass: #WBApplicationCoordinatorMenuModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  
WBCompositeMenuModule class instanceVariableNames: ''
  categories: #( )
  comment: ''!

 

WBCreateMenuModule subclass: #WBCreatePowerMenuModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBAbstractCodeModule subclass: #WBCreateViewsStubModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBDevelopmentObject subclass: #WBDescriptor
  instanceVariableNames: 
    ' name commonName comment flags '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBObject subclass: #WBDisplayContext
  instanceVariableNames: 
    ' window pen justification boundingBox cellBox cellInset cellBorder wrap borderColor scale '
  classVariableNames: 
    ' TextJustificationConstants '
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



WBCodePolicy subclass: #WBENVYCodePolicy
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBDevelopmentObject subclass: #WBGeometryManager
  instanceVariableNames: 
    ' owner '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBDevelopmentObject subclass: #WBHandle
  instanceVariableNames: 
    ' locator '
  classVariableNames: 
    ' HandleSize '
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBDevelopmentObject subclass: #WBKeyAccel
  instanceVariableNames: 
    ' keyCode text isControl isShift isAlt '
  classVariableNames: 
    ' KeyConstantsDict '
  poolDictionaries: 
    ' OperatingSystemConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBCodeModule subclass: #WBLayoutCodeModule
  instanceVariableNames: 
    ' frames '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBLayoutCodeModule subclass: #WBAbstractCreateViewsModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBAbstractCreateViewsModule subclass: #WBCreateViewModule
  instanceVariableNames: 
    ' view viewIndex '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBCreateViewModule subclass: #WBApplicationCoordinatorModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBCreateViewModule subclass: #WBCallOutModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBCreateViewModule subclass: #WBCompositePaneModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBCreateViewModule subclass: #WBCreatePowerViewModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBAbstractCreateViewsModule subclass: #WBCreateViewsModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



WBCreateViewsModule subclass: #WBCreatePowerViewsModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBDevelopmentObject subclass: #WBLocator
  instanceVariableNames: 
    ' receiver selector arguments '
  classVariableNames: 
    ' CopiedFigures '
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBDevelopmentObject subclass: #WBLookPolicy
  instanceVariableNames: 
    ' menuFont menuBarHeight titleBarHeight systemMenuWidth frameWidthBorder frameWidthSizable frameWidthDialog scrollBarArrowHeight scrollBarArrowWidth scrollBarHeight scrollBarWidth scrollBarThumbHeight scrollBarThumbWidth '
  classVariableNames: 
    ' Current Default '
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBLookPolicy subclass: #WBLookPolicyOS2
  instanceVariableNames: 
    ' pmWindowLibrary hwndDesktop '
  classVariableNames: 
    ' Down Left RadioBitmap Right Up '
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBLookPolicy subclass: #WBLookPolicyWin31
  instanceVariableNames: 
    ' userLibrary '
  classVariableNames: 
    ' Down Left Right Up '
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

!WBLookPolicyWin31 methods !
drawRectangularBox: aGroupBox with: aPen clipRect: clipRect

    | rect top textRect bottom |
    "rect := aGroupBox rect."
    rect := Rectangle leftBottom: aGroupBox rect leftBottom extent: aGroupBox rect extent + (0@(aGroupBox font height // 2)).
    top := rect top down: aGroupBox font height // 2.
    bottom := rect bottom up: 1.
    aPen font: aGroupBox font.
    textRect := (rect leftTop rightAndDown: 7 @ 3) extentFromLeftTop:
        (aGroupBox font wbStringWidth: aGroupBox contents) @ aGroupBox font height.
    aPen
        foreColor: Color red;
        wbLineFrom: rect left @ top to: rect left @ bottom;
        wbLineFrom: (rect right left: 1) @ top to: (rect right left: 1) @ bottom;
        wbLineFrom: rect left @ bottom to: rect right @ bottom;
        wbLineFrom: rect left @ top to: (rect left right: 5) @ top;
        wbLineFrom: (rect left right: ((aPen stringWidthOf: aGroupBox contents) + 12)) @ top to: rect right @ top;
        foreColor: aGroupBox foreColor;
        backColor: aGroupBox backColor;
        setTextAlign: WBDisplayContext defaultTextAlign;
        winDrawText: aGroupBox contents at: textRect origin.!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: WBLookPolicyWin31) reorganizeFrom: #(
('no category methods' drawRectangularBox:with:clipRect: )) !


!WBLookPolicyWin31 methods !
drawEllipticBox: anEllipticBox with: aPen rotation: rotation

    | rect top textRect bottom untitledRectangle |
    "rect := anEllipticBox rect."
    rect := Rectangle leftBottom: anEllipticBox rect leftBottom extent: anEllipticBox rect extent + (0@(anEllipticBox font height // 2)).
    top := rect top down: anEllipticBox font height // 2.
    bottom := rect bottom up: 1.
    aPen font: anEllipticBox font.
    textRect := (rect leftTop rightAndDown: 7 @ 3) extentFromLeftTop:
        (anEllipticBox font wbStringWidth: anEllipticBox contents) @ anEllipticBox font height.
    untitledRectangle := Rectangle origin: (rect left @ bottom) corner: (rect right @ top).
    aPen
        foreColor: Color black;
        wbLineFrom: rect left @ top to: rect left @ bottom;
        wbLineFrom: (rect right left: 1) @ top to: (rect right left: 1) @ bottom;
        wbLineFrom: rect left @ bottom to: rect right @ bottom;
        wbLineFrom: rect left @ top to: (rect left right: 5) @ top;
        wbLineFrom: (rect left right: ((aPen stringWidthOf: anEllipticBox contents) + 12)) @ top to: rect right @ top;
        foreColor: Color red;
        "setLineWidth: 2; foreColor: Color green; backColor: Color yellow;"
        ellipseUnfilled: untitledRectangle rotation: rotation; "foreColor: Color black;"
        foreColor: anEllipticBox foreColor;
        backColor: anEllipticBox backColor;
        setTextAlign: WBDisplayContext defaultTextAlign;
        winDrawText: anEllipticBox contents at: textRect origin.!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: WBLookPolicyWin31) reorganizeFrom: #(
('ellipse extension' drawEllipticBox:with:rotation: )) !


 

WBLookPolicy subclass: #WBLookPolicyWin95
  instanceVariableNames: 
    ' userLibrary '
  classVariableNames: 
    ' RadioBitmap SystemMenuBitmap '
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBDevelopmentObject subclass: #WBManagedPValue
  instanceVariableNames: 
    ' owner key value association '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBManagedPValue subclass: #WBManagedPFont
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBManagedPValue subclass: #WBManagedPNLSString
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



WBAbstractCodeModule subclass: #WBMethodStubModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



WBMethodStubModule subclass: #WBEventHandlerStubModule
  instanceVariableNames: 
    ' source event eventDescription '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBMethodStubModule subclass: #WBInstVarGetModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBMethodStubModule subclass: #WBInstVarSetModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBMethodStubModule subclass: #WBMenuItemStub
  instanceVariableNames: 
    ' title '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBAbstractCodeModule subclass: #WBModelCodeModule
  instanceVariableNames: 
    ' toBeRemoved '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBModelCodeModule subclass: #WBModelBasicSetModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



WBModelCodeModule subclass: #WBModelEventsTriggeredModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBModelCodeModule subclass: #WBModelGetModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBModelCodeModule subclass: #WBModelInitializeModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBDevelopmentObject subclass: #WBModelInstVar
  instanceVariableNames: 
    ' name myClass hasAccessors initialized lazy valueClass initializeValue hasEvent properties '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



WBModelCodeModule subclass: #WBModelSetModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBModelCodeModule subclass: #WBModelTriggerEventModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!


WBMultiViewAddInModule class instanceVariableNames: ''
  categories: #( )
  comment: ''!



WBObject subclass: #WBName
  instanceVariableNames: 
    ' first middle last '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBMethodStubModule subclass: #WBOpenMethodModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

OrderedCollection subclass: #WBOrderedCollection
  instanceVariableNames: 
    ' properties wbProperties wbPartEvents wbPartMessages wbEventTable '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBDevelopmentWindow subclass: #WBOutboardWindow
  instanceVariableNames: 
    ' owner ownerChanged '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBOutboardWindow subclass: #WBEventManagerWindow
  instanceVariableNames: 
    ' widgetList widgetFilterBox widgetListBox eventListBox handlerShowAll handlerListBox handlerListBoxFramingBlock handlerListBoxDragEnabled toLabel toField sendLabel sendField sendFieldShowAll methodTextEdit methodTextEditFramingBlock methodTextUpdateMsg '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



WBOutboardWindow subclass: #WBLayoutWizard
  instanceVariableNames: 
    ' sourceInstance widgetType modelList attributesList '
  classVariableNames: 
    ' DefaultButtons DefaultMenus LabelJustification MenuDefinitions StandardButtons StandardMenus WidgetMap '
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBOutboardWindow subclass: #WBModelDefinitionEditor
  instanceVariableNames: 
    ' dirty selectedModel attributes events models myClass hasAccessors name initializeValue lazy initialized hasEvent '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



WBOutboardWindow subclass: #WBModelObjectEditor
  instanceVariableNames: 
    ' objectList editButton removeButton nameLabel name instVar style when send '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBOutboardWindow subclass: #WBOutboardAttributeWindow
  instanceVariableNames: 
    ' currentWidget dirty currentWidgets '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBOutboardAttributeWindow subclass: #WBFontSelectionWindow
  instanceVariableNames: 
    ' selectedFont selectedPool poolManager sampleGroupBox sampleTextEdit '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBOutboardAttributeWindow subclass: #WBLayoutFrameEditor
  instanceVariableNames: 
    ' topAttachField leftAttachField bottomAttachField rightAttachField exampleAfter exampleBefore labels groups currentFramingBlocks '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants WBDevelopmentBitmaps '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBMessage subclass: #WBPartEvent
  instanceVariableNames: 
    ' sourceName '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



WBMessage subclass: #WBPartMessage
  instanceVariableNames: 
    ' receiverName '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



WBAttributeWindow subclass: #WBPARTSInterfaceEditor
  instanceVariableNames: 
    ' eventsRadioButton messagesRadioButton itemFilterPane selectorFilterPane sourceSelectorPane targetSelectorPane saveButton closeButton theWBPartEvents theWBPartMessages itemListPane selectorListPane itemFilter items itemSelected showEvents selectorFilter selectors selectorSelected wbEventList wbMessageList '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSInterfaceList subclass: #WBPARTSInterfaceList
  instanceVariableNames: 
    ' wbItems '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBPARTSInterfaceList subclass: #WBPARTSEventList
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBPARTSInterfaceList subclass: #WBPARTSMessageList
  instanceVariableNames: 
    ' wbItemTable '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBCodeModule subclass: #WBPartsModule
  instanceVariableNames: 
    ' wbPartInterfaceList '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBPartsModule subclass: #WBPartEventsModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBPartsModule subclass: #WBPartEventsTriggeredModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBPartsModule subclass: #WBPartMessagesModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBObject subclass: #WBPerson
  instanceVariableNames: 
    ' name address sex '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBDevelopmentObject subclass: #WBPlaceHolderObject
  instanceVariableNames: 
    ' owner '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBPlaceHolderObject subclass: #WBInstVarObject
  instanceVariableNames: 
    ' name '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



WBObject subclass: #WBPool
  instanceVariableNames: 
    ' pool poolName manager fileName subPools activeCategory '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBPool subclass: #WBBitmapPool
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



WBPool subclass: #WBFontPool
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBPool subclass: #WBNLSPool
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

Error subclass: #WBPoolError
  instanceVariableNames: 
    ' manager pool subPool '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  
WBPoolErrorAbsentKey class instanceVariableNames: ''
  categories: #( )
  comment: ''!

  
WBPoolErrorDuplicateKey class instanceVariableNames: ''
  categories: #( )
  comment: ''!

   
WBPoolErrorDuplicatePoolName class instanceVariableNames: ''
  categories: #( )
  comment: ''!

  
WBPoolErrorInvalidCategory class instanceVariableNames: ''
  categories: #( )
  comment: ''!


WBPoolErrorInvalidFile class instanceVariableNames: ''
  categories: #( )
  comment: ''!


WBPoolErrorInvalidKey class instanceVariableNames: ''
  categories: #( )
  comment: ''!

 
WBPoolErrorInvalidPool class instanceVariableNames: ''
  categories: #( )
  comment: ''!


WBPoolErrorInvalidPoolName class instanceVariableNames: ''
  categories: #( )
  comment: ''!


WBPoolErrorInvalidValue class instanceVariableNames: ''
  categories: #( )
  comment: ''!

   

WBObject subclass: #WBPoolManager
  instanceVariableNames: 
    ' pools allowDuplicateKeys updateSource '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



WBPoolManager subclass: #WBBitmapManager
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBPoolManager subclass: #WBFontManager
  instanceVariableNames: 
    ' generatePortableFontCode '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



WBPoolManager subclass: #WBNLSManager
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBOutboardWindow subclass: #WBPoolManagerWindow
  instanceVariableNames: 
    ' poolManager poolListBox poolListBoxFramingBlock poolPathField categoryListBox categoryListBoxFramingBlock categoryPathField showAllCategories keyListBox editorCompositePane activeCategoryField updateKeys '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBPoolManagerWindow subclass: #WBBitmapManagerWindow
  instanceVariableNames: 
    ' showDimensions keyDimensionInset '
  classVariableNames: 
    ' LastRCFileName SameValueForAllCategories '
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBPoolManagerWindow subclass: #WBFontManagerWindow
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBPoolManagerWindow subclass: #WBNLSManagerWindow
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  
WBPowerViewAddInModule class instanceVariableNames: ''
  categories: #( )
  comment: ''!



WBAbstractCodeModule subclass: #WBPrimaryModelInitializeModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



WBAbstractCodeModule subclass: #WBPrimaryModelModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBAbstractCodeModule subclass: #WBPrimaryModelOpenOnModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



WBDevelopmentWindow subclass: #WBPropertyEditor
  instanceVariableNames: 
    ' categoryList propertyList valueTrue valueFalse valueString comment changes '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  
WBPropertyManager class instanceVariableNames: ' managers cacheManagers '
  categories: #( )
  comment: ''!

 

WBDevelopmentObject subclass: #WBPrototype
  instanceVariableNames: 
    ' owner shell windows properties targetObject '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBDescriptor subclass: #WBResourceDescriptor
  instanceVariableNames: 
    ' value '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBResourceDescriptor subclass: #WBPropertyDescriptor
  instanceVariableNames: 
    ' category default resourceValues changeBlock '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBDevelopmentWindow subclass: #WBScratchWindow
  instanceVariableNames: 
    ' model '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



WBCodePolicy subclass: #WBStandardCodePolicy
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBOutboardAttributeWindow subclass: #WBStyleEditor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

Dictionary subclass: #WBSubPool
  instanceVariableNames: 
    ' fileName category owner '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



WBSubPool subclass: #WBBitmapSubPool
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBSubPool subclass: #WBFontSubPool
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



WBSubPool subclass: #WBNLSSubPool
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBDevelopmentWindow subclass: #WBSystemBitmapViewer
  instanceVariableNames: 
    ' graphic list '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



WBOutboardWindow subclass: #WBTabOrderEditor
  instanceVariableNames: 
    ' layoutForm status result removeGroupButton '
  classVariableNames: 
    ' IncludeOuter '
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBDevelopmentObject subclass: #WBTabPosition
  instanceVariableNames: 
    ' basicTabPosition groupPosition '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



WBPlaceHolderObject subclass: #WBTargetObject
  instanceVariableNames: 
    ' modelObjects eventsTriggered instVarMap realClass invalidInstVars oldHandlers '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



WBCodePolicy subclass: #WBTeamVCodePolicy
  instanceVariableNames: ''
  classVariableNames: 
    ' WBAnnotationManager WBTeamVInterface WBTeamVToolInterface '
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



WBDevelopmentWindow subclass: #WBTemplateEditor
  instanceVariableNames: 
    ' template templateList removeButton attributePalette styleLabel textLabel sample textEditor styleEditor sizeLabel templateGroup sizeButton '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants WBDevelopmentBitmaps '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

TextWindow subclass: #WBTextEditWindow
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



WBObject subclass: #WBTool
  instanceVariableNames: 
    ' file bitmap pen bitmapSelector selector rbSelector state numSpaces rectangle boundingBox enableSelector owner '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!


WBToolMenuAddInModule class instanceVariableNames: ''
  categories: #( )
  comment: ''!

 

ViewManager subclass: #WBTranslationChooser
  instanceVariableNames: 
    ' owner classNameListBox filters '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

Object subclass: #WBTranslator
  instanceVariableNames: 
    ' classToTranslate prototype codeGenerator '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



WBTranslator subclass: #WBEventTranslator
  instanceVariableNames: 
    ' eventMap '
  classVariableNames: 
    ' DefaultEventMap '
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBTranslator subclass: #WBNLSTranslator
  instanceVariableNames: 
    ' poolManager pools category menuAcceleratorCount '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBNLSTranslator subclass: #WBNLSExtractionTranslator
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBNLSTranslator subclass: #WBNLSReplacementTranslator
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBDevelopmentObject subclass: #WBTreeNode
  instanceVariableNames: 
    ' listString parent currentString children owner '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBTreeNode subclass: #WBPMenu
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBPMenu subclass: #WBPMenubar
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBTreeNode subclass: #WBPMenuItem
  instanceVariableNames: 
    ' isDivider keyAccel selector submenu '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



WBDevelopmentObject subclass: #WBUndoAction
  instanceVariableNames: 
    ' label undoAction redoAction '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



WBDevelopmentObject subclass: #WBUndoManager
  instanceVariableNames: 
    ' owner undoMenu redoMenu undoList current inUndo '
  classVariableNames: 
    ' MaxUndoLevels '
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



WBAbstractCodeModule subclass: #WBVersionCodeModule
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

ViewManager subclass: #WBWindowDialog
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBWindowDialog subclass: #WBAbstractPrompter
  instanceVariableNames: 
    ' result deferred '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



WBAbstractPrompter subclass: #WBEntryListPrompter
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  
WBWindows95AddInModule class instanceVariableNames: ''
  categories: #( )
  comment: ''!



WBCodePolicy subclass: #WBXoteryXCodePolicy
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

LinearHashTable variableSubclass: #WeakLinearHashTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Special Objects' )
  comment: ''!

!WeakLinearHashTable methods !
elementsDo: iterationBlock
    "Evaluate the <iterationBlock> once for each element in the receiver. If the receiver is empty, the block will not be evaluated."

    | value |
    1 to: self size do: [:index |
        (value := self at: index) isResidueOrNil ifFalse: [iterationBlock value: value]]!    ! 
#('December 21, 2001' '05:07:32 PM' nil)!

(CodeFiler organizerFor: WeakLinearHashTable) reorganizeFrom: #(
('no category methods' elementsDo: )) !


!WeakLinearHashTable methods !
keysAndValuesDo: iterationBlock
    "Evaluate the <iterationBlock> once for each key/value pair in the receiver. The key will be the first argument, the value will be the second argument to the block. If the receiver is empty, the block will not be evaluated."

    | value |
    1 to: self size do: [:index |
        (value := self at: index) isResidueOrNil
            ifFalse: [iterationBlock value: value key value: value value]]!    ! 
#('September 19, 2001' '12:28:58 PM' nil)!

(CodeFiler organizerFor: WeakLinearHashTable) reorganizeFrom: #(
('no category methods' keysAndValuesDo: )) !




Pattern subclass: #WildPattern
  instanceVariableNames: 
    ' patternCollection '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Text' )
  comment: ''!

  
Win32FindData class instanceVariableNames: ''
  categories: #( )
  comment: ''!

 

ExternalBuffer subclass: #WinBitmapFileHeader
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!



ExternalBuffer subclass: #WinBitmapInfoHeader
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!



WinBitmapInfoHeader subclass: #WinBitmapInfo
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!

 

ExternalBuffer subclass: #WinBitmapStruct
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!



ExternalBuffer subclass: #WinCharFormat
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' WinCommonControlConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

ExternalBuffer subclass: #WinColorref
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!



ExternalBuffer subclass: #WinDialogInfo
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Kernel-Structures' )
  comment: ''!

  

Object subclass: #Window
  instanceVariableNames: 
    ' handle rectangle children parent owner style graphicsTool properties '
  classVariableNames: 
    ' ControlKeys '
  poolDictionaries: 
    ' CharacterConstants GraphicsConstants OperatingSystemConstants VirtualKeyConstants '
  categories: #( 'Windows-Views' 'Windows-SubPanes' )
  comment: ''!

!Window methods ! 
prepareToValidate

    ^self children do: [:child | child prepareToValidate]! ! 
#('April 17, 2002' '04:14:19 PM' nil)!

(CodeFiler organizerFor: Window) reorganizeFrom: #(
('extensions' prepareToValidate )) !


!Window methods !
setAsTopmost
    
    self isHandleOk 
        ifTrue: [
            self handle setWindowPos: HwndTopmost rectangle: self rectangle fs: SwpShowwindow]
        ifFalse: [self whenValid: #setAsTopmost].! ! 
#('October 2, 2003' '09:01:41 AM' nil)!

(CodeFiler organizerFor: Window) reorganizeFrom: #(
('extensions' setAsTopmost )) !


!Window methods !
resizeToRect: aRectangle

    self handle
        setWindowPos: nil
        rectangle: aRectangle
        fs: SwpNozorder.!    ! 
#('April 26, 2002' '10:49:19 AM' nil)!

(CodeFiler organizerFor: Window) reorganizeFrom: #(
('extensions' resizeToRect: )) !


!Window methods !
isOpen
    ^self isHandleOk!   ! 
#('April 11, 2005' '08:23:00 AM' nil)!

(CodeFiler organizerFor: Window) reorganizeFrom: #(
('extensions' isOpen )) !


!Window methods !   
wmVScroll: wordInteger with: longInteger
        "Private - Scroll the receiver vertically.
        If the source of the message is a scroll control,
        then raise a control event."
    | w ctrlId |
    longInteger = 0 ifTrue: [ ^nil ].
    ctrlId := UserLibrary getWindowLong: longInteger index: GwlId.
    ( w := self childAtId: ctrlId ) isNil ifTrue: [ ^nil ].
    w
        syncControlEvent: wordInteger lowWord
        with: ( ( ExternalLong new uLongAtOffset: 0 put: wordInteger ) shortAtOffset: 2 ).
    ^nil!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Window) reorganizeFrom: #(
('no category methods' wmVScroll:with: )) !


 

Window subclass: #ApplicationWindow
  instanceVariableNames: 
    ' label collapsed menuWindow dependents activeTextPane '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants VirtualKeyConstants '
  categories: #( 'Windows-Views' )
  comment: ''!

!ApplicationWindow methods !   
boxOfSize: aPoint
        "Private - Answer a Rectangle with extent of aPoint
         and upper left corner at the cursor position."
    | corner |
    corner := Cursor sense.
    ^((corner max: (0 @ 0)) min: (Display extent - (0 @ 28) - aPoint))
        extent: aPoint.!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: ApplicationWindow) reorganizeFrom: #(
('extensions' boxOfSize: )) !


!ApplicationWindow methods !
textModified
        "Private - If any text pane has been modified,
         ask the user whether the changes should be saved,
         ignored, or cancel the operation.  If the user chooses
         save, the changes are saved.  Answer true if the
         user chooses save or ignore.  Otherwise, answer false."
    | title answer |
    self isTextModified ifFalse: [ ^false ].
    ( title := self label ) size = 0 ifTrue: [ title := 'Unsaved Changes' ].
    answer :=  MessageBox new
        title: title;
        message: 'Save current changes?';
        yesNoCancel;
        iconQuestion;
        defaultButton: 3;
        open.
    answer isNil ifTrue: [ ^true ].
    answer ifTrue: [
        self accept.
        ^self isTextModified ].
    self clearTextModified.  "in case 2 modified text pane"
    ^false!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: ApplicationWindow) reorganizeFrom: #(
('no category methods' textModified )) !


!ApplicationWindow methods ! 
saveImage
        "Private - The user selected SaveImage menu item
         from the File menu."
    Smalltalk isRunTime
        ifTrue: [ MessageBox message: 'Cannot save image with the run-time system.']
        ifFalse: [
            WorldViewer allInstances size > 0 ifTrue: [
                "Do it the second time to allow it to finish a garbage collection which goes on in parallel."
                 WorldViewer allInstances size > 0 ifTrue: [
                    MessageBox message:'Please close all WorldEditor and TerrainEditor windows first.'.
                    ^self]].
            CanvasLibrary isNil ifFalse: [OpenGLCanvasDLL wrapup. BSPTree initialize "clear caches"].
            HyperdriveLibrary isNil ifFalse: [HyperdriveDLL wrapup.].
            SaveImageDialog new openYesNo answer
                ifTrue: [ self saveImageNoConfirm ] ]!  ! 
#('May 7, 2002' '10:10:52 AM' nil)!

(CodeFiler organizerFor: ApplicationWindow) reorganizeFrom: #(
('no category methods' saveImage )) !


!ApplicationWindow methods !
buildWindow
        "Private - Create the host window for the receiver."
    | myRealRectangle focusPane extendedStyle |
    style isNil ifTrue: [ style := self getStyle ].
    ( extendedStyle := self extendedStyle ) isNil ifTrue: [
        self extendedStyle: ( extendedStyle := self defaultExtendedStyle ) ].
    NotificationManager newWindow notNil ifTrue: [
        NotificationManager newWindow: nil.
        ^nil ].   "A Walkback came up during creation of window"
    NotificationManager newWindow: self.

    " clear rectangle during build to force sizeChanged: to resize children "
    myRealRectangle := rectangle.
    rectangle := 0@0 extent: 0@0.

    self
        create: self windowClass
        title: label
        style: ( style bitAnd: ( WsVisible bitXor: 16rFFFFFFFF ) )  "create hidden, show after validate"
        extendedStyle: extendedStyle
        rectangle: rectangle
        parent: parent.
    NotificationManager newWindow: nil.
    self icon: self icon.

    self isHandleOk ifFalse: [ self halt: 'Unable to create window...'. ^nil ].

    self systemMenuHandle.

    "menu and subpanes created in the wmCreate message process"

    "Set the size of the frame window."
    self handle
        setWindowPos: nil
        rectangle: myRealRectangle
        fs: SwpNozorder.

    focusPane := self subPaneWithFocus.
    self activeTextPane: self searchForDefaultTextPane.
    focusPane notNil ifTrue: [ focusPane setFocus ].
    self subPaneWithFocus: focusPane!    ! 
#('April 15, 2002' '04:39:53 PM' nil)!

(CodeFiler organizerFor: ApplicationWindow) reorganizeFrom: #(
('no category methods' buildWindow )) !


!ApplicationWindow methods !   
initSize
        "Private - Answer the initial size of the receiver."
    | size |
    rectangle notNil ifTrue: [ ^rectangle ].
    size := [ owner initWindowSize ]
        on: MessageNotUnderstood do: [ :e | self initWindowSize ].
    ^size isRectangle
        ifTrue: [ size ]
        ifFalse: [ size isPoint
            ifTrue: [ self boxOfSize: size ]
            ifFalse: [ 0 @ 0 extent: 100@100 ] ]! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: ApplicationWindow) reorganizeFrom: #(
('no category methods' initSize )) !


 

Window subclass: #DialogBox
  instanceVariableNames: 
    ' wParam lParam sem hLibrary '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants '
  categories: #( 'Windows-Dialogs' )
  comment: ''!

   

CommonSystemDialog subclass: #ColorDialog
  instanceVariableNames: 
    ' chosen chooseColorStruct customColors lpCustColors '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants CommonDialogConstants OperatingSystemConstants '
  categories: #( 'Windows-Dialogs' )
  comment: ''!

   

CommonSystemDialog subclass: #FileDialog
  instanceVariableNames: 
    ' fileName openFileNameStruct filters lpstrFilter lpstrFile lpstrInitialDir lpstrTitle lpstrDefExt '
  classVariableNames: 
    ' DirName '
  poolDictionaries: 
    ' CommonDialogConstants OperatingSystemConstants '
  categories: #( 'Windows-Dialogs' )
  comment: ''!

!FileDialog methods ! 
minimalSaveFile: aString
        "Brings up the save file dialog with aString as the
         default name. Everything else is assumed to have
         be set previously. "
    self fileSpec: aString; hideReadonly; overwritePrompt.
    self save.!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: FileDialog) reorganizeFrom: #(
('no category methods' minimalSaveFile: )) !


!FileDialog class methods ! 
promptTitle: string directoryPathName: directoryPath
    ^self promptTitle: string directory: (Directory pathName: directoryPath)! ! 
#('December 28, 2013' '10:28:53 AM' nil)!

(CodeFiler organizerFor: FileDialog class) reorganizeFrom: #(
('generic prompt' promptTitle:directoryPathName: )) !


!FileDialog class methods !
promptTitle: string
    "Read prompt... returning either a full path name or nil if the user cancelled"
    ^self promptTitle: string directory: Directory current!   ! 
#('December 28, 2013' '10:22:38 AM' nil)!

(CodeFiler organizerFor: FileDialog class) reorganizeFrom: #(
('generic prompt' promptTitle: )) !


!FileDialog class methods !  
promptTitle: string directory: aDirectory
    "Read prompt... returning either a full path name or nil if the user cancelled"
    ^FileDialog new
        title: string;
        shareAware;
        addFilter: '*.*' description: 'All Files (*.*)';
        fileSpec: '*.*';
        directory:aDirectory;
        open;
        file!   ! 
#('December 28, 2013' '10:21:59 AM' nil)!

(CodeFiler organizerFor: FileDialog class) reorganizeFrom: #(
('generic prompt' promptTitle:directory: )) !


   

CommonSystemDialog subclass: #FontDialog
  instanceVariableNames: 
    ' chosen chosenForeColor chooseFontStruct lpLogFont '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants CommonDialogConstants OperatingSystemConstants '
  categories: #( 'Windows-Dialogs' )
  comment: ''!

 

ControlWindow subclass: #MenuWindow
  instanceVariableNames: 
    ' accel allMenus menus '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Windows-Views' )
  comment: ''!

  

DialogBox subclass: #MessageBox
  instanceVariableNames: 
    ' title message result resultSymbol '
  classVariableNames: 
    ' ResultSymbols '
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants '
  categories: #( 'Windows-Dialogs' )
  comment: ''!

!MessageBox class methods !
confirmContinueOrCancel: message
    | result |
    result := self threeStateNotify: 'Please Confirm (Cancel Will Halt)' withText: message.
    result isNil ifTrue: [self halt: message].
    ^result! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: MessageBox class) reorganizeFrom: #(
('extensions' confirmContinueOrCancel: )) !


!MessageBox class methods !
confirmContinue: message
    (self confirm: message,  ' Continue?') ifFalse: [self halt: message]! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: MessageBox class) reorganizeFrom: #(
('extensions' confirmContinue: )) !


   

DialogBox subclass: #NewSubclassDialog
  instanceVariableNames: 
    ' superclassName subclassName fixed pointer '
  classVariableNames: 
    ' ItemIds '
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Windows-Dialogs' )
  comment: ''!

 

Window subclass: #ObjectWindow
  instanceVariableNames: 
    ' label '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Windows-Views' )
  comment: ''!

  

FileDialog subclass: #PARTSFileDialog
  instanceVariableNames: 
    ' closedAction '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSFileDialog subclass: #PARTSAnyFileDialog
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

MenuWindow subclass: #PARTSMenuWindow
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSMenuWindow subclass: #PARTSMenuBar
  instanceVariableNames: ''
  classVariableNames: 
    ' IconDropMark '
  poolDictionaries: 
    ' GraphicsConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

MessageBox subclass: #PARTSMessageBox
  instanceVariableNames: 
    ' buttonValues closedAction '
  classVariableNames: 
    ' ButtonMap CancelValue '
  poolDictionaries: 
    ' PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSMenuWindow subclass: #PARTSPopupWindowOS2
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSMenuWindow subclass: #PARTSPopupWindowWindows
  instanceVariableNames: 
    ' baseMenuId '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

ObjectWindow subclass: #PARTSStarterWindow
  instanceVariableNames: ''
  classVariableNames: 
    ' CurrentClass PARTSStarter '
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSStarterWindow subclass: #PARTSStarterWindowWindows
  instanceVariableNames: ''
  classVariableNames: 
    ' FileMapRead WmExternalCall '
  poolDictionaries: 
    ' WinConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

ObjectWindow subclass: #PARTSTimerWindow
  instanceVariableNames: 
    ' items '
  classVariableNames: 
    ' PARTSTimer '
  poolDictionaries: 
    ' PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

CommonSystemDialog subclass: #PrintDialog
  instanceVariableNames: 
    ' hDCPrinter printDlgStruct hDevMode hDevNames '
  classVariableNames: 
    ' DevMode DevNames '
  poolDictionaries: 
    ' CommonDialogConstants OperatingSystemConstants '
  categories: #( 'Windows-Dialogs' )
  comment: ''!



Window subclass: #SubPane
  instanceVariableNames: 
    ' handlers topCorner framingBlock curFont menu popup id '
  classVariableNames: 
    ' Margin '
  poolDictionaries: 
    ' CharacterConstants GraphicsConstants OperatingSystemConstants VirtualKeyConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!

!SubPane methods !   
resizeRelativeToBottomRightOf: referencePane

    | referenceRectangle paneRectangle |

    referenceRectangle := referencePane frameRectangle.
    paneRectangle := self frameRectangle.

    self framingBlock: (CompositeLayout composing: referencePane framingBlock with:
        (LayoutFrame new
            leftRatio: 1; leftInset: paneRectangle left - referenceRectangle right;
            topRatio: 1; topInset: paneRectangle top - referenceRectangle bottom;
            rightRatio: 1; rightInset: referenceRectangle right - paneRectangle right;
            bottomRatio: 1; bottomInset: referenceRectangle bottom - paneRectangle bottom)).!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SubPane) reorganizeFrom: #(
('extensions' resizeRelativeToBottomRightOf: )) !


!SubPane methods !
resizeKeepingRightEdgeRelativeToRightEdgeOf: referencePane

    | referenceRectangle paneRectangle |

    referenceRectangle := referencePane frameRectangle.
    paneRectangle := self frameRectangle.

    self framingBlock rightRatio: referencePane framingBlock rightRatio.
    self framingBlock rightInset: referencePane framingBlock rightInset + (referenceRectangle right - paneRectangle right).!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SubPane) reorganizeFrom: #(
('extensions' resizeKeepingRightEdgeRelativeToRightEdgeOf: )) !


!SubPane methods !  
resizeKeepingRightEdgeRelativeToLeftEdgeOf: referencePane

    | referenceRectangle paneRectangle |

    referenceRectangle := referencePane frameRectangle.
    paneRectangle := self frameRectangle.

    self framingBlock rightRatio: referencePane framingBlock leftRatio.
    self framingBlock rightInset: referencePane framingBlock leftInset negated + (referenceRectangle left - paneRectangle right).!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SubPane) reorganizeFrom: #(
('extensions' resizeKeepingRightEdgeRelativeToLeftEdgeOf: )) !


!SubPane methods !   
resizeProportionalTo: referencePane

    | referenceRectangle paneRectangle |

    referenceRectangle := referencePane frameRectangle.
    paneRectangle := self frameRectangle.

    self framingBlock: (CompositeLayout composing: referencePane framingBlock with:
        (LayoutFrame new
            leftRatio: 0; leftInset: paneRectangle left - referenceRectangle left;
            topRatio: 0; topInset: paneRectangle top - referenceRectangle top;
            rightRatio: 1; rightInset: referenceRectangle right - paneRectangle right;
            bottomRatio: 1; bottomInset: referenceRectangle bottom - paneRectangle bottom)).!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SubPane) reorganizeFrom: #(
('extensions' resizeProportionalTo: )) !


!SubPane methods ! 
resizeRelativeToTopLeftOf: referencePane

    | referenceRectangle paneRectangle |

    referenceRectangle := referencePane frameRectangle.
    paneRectangle := self frameRectangle.

    self framingBlock: (CompositeLayout composing: referencePane framingBlock with:
        (LayoutFrame new
            leftRatio: 0; leftInset: paneRectangle left - referenceRectangle left;
            topRatio: 0; topInset: paneRectangle top - referenceRectangle top;
            rightRatio: 0; rightInset: referenceRectangle left - paneRectangle right;
            bottomRatio: 0; bottomInset: referenceRectangle top - paneRectangle bottom)).!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SubPane) reorganizeFrom: #(
('extensions' resizeRelativeToTopLeftOf: )) !


!SubPane methods !
wmVScroll: wordInteger with: longInteger
        "Private - Process the vertical scroll message."
    | type slider |
    "if message is from a child window, call super to pass it on to the child window."
    longInteger = 0 ifFalse: [ ^super wmVScroll: wordInteger with: longInteger ].
    type := wordInteger lowWord.
    type = SbLineup ifTrue: [ self scrollVertical: self amountToScrollUp ].
    type = SbLinedown ifTrue: [ self scrollVertical: self amountToScrollUp negated ].
    type = SbPageup ifTrue: [ self scrollVertical: self amountToPageUp ].
    type = SbPagedown ifTrue: [ self scrollVertical: self amountToPageUp negated ].
    type = SbThumbposition ifTrue: ["end of tracking"
        slider := ( ExternalLong new uLongAtOffset: 0 put: wordInteger ) shortAtOffset: 2.
        self updateVerticalSliderTo: wordInteger highWord.
        ^nil ].
    type = SbThumbtrack
        ifTrue: [
            slider := ( ExternalLong new uLongAtOffset: 0 put: wordInteger ) shortAtOffset: 2.
            self isOffScreen
                ifTrue: [
                    self moveTopCornerBy: self topCorner - (self topCorner x
                        @ (slider * self totalLength // 100 + 1))]
                ifFalse: [
                    self scrollTopCornerTo: (self topCorner x
                        @ (slider * self totalLength // 100 + 1))]]
        ifFalse: [ "Do not update the bar for SbSlidertrack."
            self updateVerticalSlider].
   ^nil!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SubPane) reorganizeFrom: #(
('no category methods' wmVScroll:with: )) !


!SubPane methods !  
resizeRelativeToTopRightOf: referencePane

    | referenceRectangle paneRectangle |

    referenceRectangle := referencePane frameRectangle.
    paneRectangle := self frameRectangle.

    self framingBlock: (CompositeLayout composing: referencePane framingBlock with:
        (LayoutFrame new
            leftRatio: 1; leftInset: paneRectangle left - referenceRectangle right;
            topRatio: 0; topInset: paneRectangle top - referenceRectangle top;
            rightRatio: 1; rightInset: referenceRectangle right - paneRectangle right;
            bottomRatio: 0; bottomInset: referenceRectangle top - paneRectangle bottom)).!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SubPane) reorganizeFrom: #(
('extensions' resizeRelativeToTopRightOf: )) !


!SubPane methods !   
resizeKeepingTopEdgeRelativeToBottomEdgeOf: referencePane

    | referenceRectangle paneRectangle |

    referenceRectangle := referencePane frameRectangle.
    paneRectangle := self frameRectangle.

    self framingBlock topRatio: referencePane framingBlock bottomRatio.
    self framingBlock topInset: referencePane framingBlock bottomInset negated + (paneRectangle top - referenceRectangle bottom).!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: SubPane) reorganizeFrom: #(
('extensions' resizeKeepingTopEdgeRelativeToBottomEdgeOf: )) !


 

SubPane subclass: #ControlPane
  instanceVariableNames: 
    ' value label '
  classVariableNames: 
    ' WinClassMap '
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants VirtualKeyConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!

   

ControlPane subclass: #Button
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants VirtualKeyConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!

  

Button subclass: #DrawnButton
  instanceVariableNames: 
    ' bitmap drawSelector '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!

  

DrawnButton subclass: #ActionButton
  instanceVariableNames: 
    ' action '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

ControlPane subclass: #EntryField
  instanceVariableNames: 
    ' selection modified '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants VirtualKeyConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!

!EntryField methods !   
selectEnd
        "Select the very end of the  receiver."

    self isHandleOk
        ifTrue: [ self selectFrom: self windowTextLength + 1 to: self windowTextLength + 1]
        ifFalse: [ self whenValid: #selectEnd]! ! 
#('April 27, 2005' '08:06:09 PM' nil)!

(CodeFiler organizerFor: EntryField) reorganizeFrom: #(
('no category methods' selectEnd )) !




EntryField subclass: #ComboEntryField
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants VirtualKeyConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!

  

ComboEntryField subclass: #AutoSelectComboEntryField
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants VirtualKeyConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!

   

EntryField subclass: #EnhancedEntryField
  instanceVariableNames: 
    ' case justification character field getFocus '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



SubPane subclass: #GraphPane
  instanceVariableNames: 
    ' firstTime stretch originalExtent updating mouse '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants VirtualKeyConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!

   

SubPane subclass: #GroupPane
  instanceVariableNames: 
    ' childClicked '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!

  

GroupPane subclass: #CompositePane
  instanceVariableNames: 
    ' initialSize '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

CompositePane subclass: #AddressPane
  instanceVariableNames: 
    ' address '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



CompositePane subclass: #DictionaryEditorPane
  instanceVariableNames: 
    ' dictionary listEditor detail '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

DictionaryEditorPane subclass: #AddressEditorPane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

CompositePane subclass: #EntryFieldGroup
  instanceVariableNames: 
    ' label dictionary '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

ControlPane subclass: #Header
  instanceVariableNames: 
    ' headings '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants VirtualKeyConstants WinCommonControlConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

DrawnButton subclass: #LinkButton
  instanceVariableNames: 
    ' link type '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



ControlPane subclass: #ListBox
  instanceVariableNames: 
    ' list height '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants VirtualKeyConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!

 

ListBox subclass: #ButtonListBox
  instanceVariableNames: 
    ' images imageList '
  classVariableNames: 
    ' ButtonExtent ButtonImages '
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

!ButtonListBox methods ! 
toggleState: itemIndex
        "Private - toggle the check state of the item with the given index."
    | currentValue |

    (self listAttribute size < itemIndex) ifTrue:[^self]. "Adriaan fixed this this way, silly out of bounds error possible"

    currentValue := ( self listAttribute at: itemIndex ) state.
    currentValue := self isThreeState
        ifFalse: [ currentValue == false ]
        ifTrue: [ currentValue == true ifTrue: [ nil ] ifFalse: [ currentValue notNil ] ].
    ( self listAttribute at: itemIndex ) state: currentValue.
    self invalidateRect: ( self buttonRectangleForIndex: itemIndex ).
    self triggerCheckedEvents: itemIndex value: currentValue!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: ButtonListBox) reorganizeFrom: #(
('no category methods' toggleState: )) !


 

ListBox subclass: #ColumnListBox
  instanceVariableNames: 
    ' columnWidths '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

ListBox subclass: #DropDownList
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants VirtualKeyConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!

   

DropDownList subclass: #ComboBox
  instanceVariableNames: 
    ' text entryField '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!

   

ComboBox subclass: #AutoSelectComboBox
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!

!AutoSelectComboBox methods !
list
    super list isNil ifTrue: [self list: #()].
    ^super list!  ! 
#('April 19, 2002' '05:30:30 PM' nil)!

(CodeFiler organizerFor: AutoSelectComboBox) reorganizeFrom: #(
('accessing' list )) !


   

ListBox subclass: #ExtendedListBox
  instanceVariableNames: 
    ' separatorString userCanReorder dragButton '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

SubPane subclass: #ListConnectionPane
  instanceVariableNames: 
    ' leftTitle leftList rightTitle rightList maximumHeight lineHeight characterExtent totalExtent visibleExtent visibleLines dragButton platformWindowLibrary leftListRectangle leftConnectorsRectangle rightListRectangle rightConnectorsRectangle leftToRightConnections '
  classVariableNames: 
    ' DefaultDragButton FrameStyle PlatformWindowLibrary ScrollOptions VerticalScrollBarStyle '
  poolDictionaries: 
    ' GraphicsConstants SystemValueConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

CompositePane subclass: #ListEditorPane
  instanceVariableNames: 
    ' list listbox item '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

SubPane subclass: #ListPane
  instanceVariableNames: 
    ' list selection currentLine '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants VirtualKeyConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!

 

ControlPane subclass: #ListView
  instanceVariableNames: 
    ' items headings imageList smallImageList '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants VirtualKeyConstants WinCommonControlConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

ListBox subclass: #MultipleSelectListBox
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!

!MultipleSelectListBox methods !  
restoreSelected: aCollection
    "Refresh the list from the owner. select the items in aCollection"

    | first stringCollection |
    stringCollection := aCollection collect: [:each | (self stringForItem: each) trimBlanks].
    self noRedraw: true; triggerEvent: #needsContents.

    1 to: self contents size do: [:index |
        (stringCollection indexOf: (self stringForItem: (self contents at: index)) trimBlanks) > 0
            ifTrue: [self selectIndex: index]].
    first := self selections notEmpty ifTrue: [self selections first - 3 max: 1] ifFalse: [1].
    self
        setTopIndex: first;
        noRedraw: false;
        invalidateRect: self rectangle.! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: MultipleSelectListBox) reorganizeFrom: #(
('extensions' restoreSelected: )) !


!MultipleSelectListBox methods !  
indexOfStringTrimmingBlanks: aString ifAbsent: aBlock

    1 to: self contents size do: [:index |
        (self stringForItem: (self contents at: index)) trimBlanks = aString ifTrue: [^index]].
    ^aBlock value!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: MultipleSelectListBox) reorganizeFrom: #(
('extensions' indexOfStringTrimmingBlanks:ifAbsent: )) !


 

MultipleSelectListBox subclass: #ColorMultipleSelectListBox
  instanceVariableNames: 
    ' colors '
  classVariableNames: 
    ' HighlightColorMap '
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!

 

CompositePane subclass: #NamePane
  instanceVariableNames: 
    ' name '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

CompositePane subclass: #OkCancelPane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

ControlPane subclass: #PARTSBaseNotebook
  instanceVariableNames: 
    ' orderedPages '
  classVariableNames: ''
  poolDictionaries: 
    ' PARTSNotebookConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



ComboBox subclass: #PARTSComboBoxPart
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' PARTSConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

ComboEntryField subclass: #PARTSComboEntryField
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

DrawnButton subclass: #PARTSDrawnButtonPart
  instanceVariableNames: ''
  classVariableNames: 
    ' CanBeDefaultButton SupportsBorder '
  poolDictionaries: 
    ' PARTSConstants SystemColorConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

DropDownList subclass: #PARTSDropDownListPart
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' PARTSConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

EntryField subclass: #PARTSEntryFieldPart
  instanceVariableNames: 
    ' emptyValue '
  classVariableNames: 
    ' AlignmentLabels AlignmentValues ConvertCharactersLabels ConvertCharactersValues '
  poolDictionaries: 
    ' CharacterConstants PARTSConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

EntryField subclass: #PARTSExpressionEntryField
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSEntryFieldPart subclass: #PARTSFormattedEntryField
  instanceVariableNames: 
    ' datum '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants PARTSConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSFormattedEntryField subclass: #PARTSAlphabeticEntryFieldPart
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSFormattedEntryField subclass: #PARTSDateEntryFieldPart
  instanceVariableNames: 
    ' dateSeparator dateFormat twoDigitYear useSystemFormat '
  classVariableNames: ''
  poolDictionaries: 
    ' PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



GraphPane subclass: #PARTSGraphPanePart
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' PARTSConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSGraphPanePart subclass: #PARTSDialPanePart
  instanceVariableNames: 
    ' dial '
  classVariableNames: ''
  poolDictionaries: 
    ' PARTSConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

GraphPane subclass: #PARTSIconPane
  instanceVariableNames: 
    ' button1DownLoc button2DownLoc icons selectedIcons '
  classVariableNames: ''
  poolDictionaries: 
    ' GraphicsConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

ListBox subclass: #PARTSListPanePart
  instanceVariableNames: ''
  classVariableNames: 
    ' SupportsShowDisabledScrollbar '
  poolDictionaries: 
    ' PARTSConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

GroupPane subclass: #PARTSMenuPaneWindows
  instanceVariableNames: ''
  classVariableNames: 
    ' IconDropMark '
  poolDictionaries: 
    ' GraphicsConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



MultipleSelectListBox subclass: #PARTSMultipleChoiceListPart
  instanceVariableNames: ''
  classVariableNames: 
    ' SupportsShowDisabledScrollbar '
  poolDictionaries: 
    ' PARTSConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSBaseNotebook subclass: #PARTSNotebook
  instanceVariableNames: 
    ' pagePaneGroup majorTabExtent minorTabExtent pageButtonExtent marginExtent bmps majorTabScrollPos minorTabScrollPos '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants GraphicsConstants PARTSNotebookConstants SystemColorConstants WinConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

GroupPane subclass: #PARTSNotebookClientAreaPane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



GroupPane subclass: #PARTSNotebookPagePane
  instanceVariableNames: 
    ' notebookPages '
  classVariableNames: ''
  poolDictionaries: 
    ' PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSFormattedEntryField subclass: #PARTSNumericField
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSNumericField subclass: #PARTSFixedDecimalEntryFieldPart
  instanceVariableNames: 
    ' signed decimalPlace digits '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSFixedDecimalEntryFieldPart subclass: #PARTSCurrencyEntryFieldPart
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSNumericField subclass: #PARTSFloatEntryFieldPart
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSNumericField subclass: #PARTSIntegerEntryFieldPart
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

SubPane subclass: #PARTSPane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSPane subclass: #PARTSGroupPane
  instanceVariableNames: 
    ' childClicked '
  classVariableNames: ''
  poolDictionaries: 
    ' PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSPane subclass: #PARTSMenuItemPane
  instanceVariableNames: 
    ' index theMenu '
  classVariableNames: ''
  poolDictionaries: 
    ' PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSMenuItemPane subclass: #PARTSMenuBitmapItemPart
  instanceVariableNames: 
    ' bitmap '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSPane subclass: #PARTSMenuLabelPart
  instanceVariableNames: 
    ' label '
  classVariableNames: ''
  poolDictionaries: 
    ' PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSMenuItemPane subclass: #PARTSMenuSeparatorPart
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSMenuItemPane subclass: #PARTSMenuTextItemPart
  instanceVariableNames: 
    ' label accelerator '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSGroupPane subclass: #PARTSNestedPart
  instanceVariableNames: 
    ' wrapper application showInternals copyMode fileDescriptor lastUpdateTime '
  classVariableNames: 
    ' IllegalTypes '
  poolDictionaries: 
    ' CharacterConstants GraphicsConstants PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSGroupPane subclass: #PARTSOrderedGroupPane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSOrderedGroupPane subclass: #PARTSMenuPart
  instanceVariableNames: 
    ' currentItemRow menuObject '
  classVariableNames: 
    ' VirtualKeysMap '
  poolDictionaries: 
    ' CharacterConstants GraphicsConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSFormattedEntryField subclass: #PARTSPhoneNumberEntryFieldPart
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSFormattedEntryField subclass: #PARTSPictureFieldPart
  instanceVariableNames: 
    ' pictureMask pictureCharacterPlaceholder '
  classVariableNames: 
    ' PictureCharacters '
  poolDictionaries: 
    ' CharacterConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

Button subclass: #PARTSPushButtonPart
  instanceVariableNames: ''
  classVariableNames: 
    ' SupportsBorder '
  poolDictionaries: 
    ' PARTSConstants SystemColorConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



SubPane subclass: #PARTSScrollPane
  instanceVariableNames: 
    ' child '
  classVariableNames: ''
  poolDictionaries: 
    ' PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

GroupPane subclass: #PARTSTabControlPagePart
  instanceVariableNames: 
    ' page '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSMenuBitmapItemPart subclass: #PARTSToolbarItem
  instanceVariableNames: 
    ' tool '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSToolbarItem subclass: #PARTSToolbarButtonPart
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' WinCommonControlConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSToolbarItem subclass: #PARTSToolbarSeparatorPart
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' WinCommonControlConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSToolbarButtonPart subclass: #PARTSToolbarToggleButtonPart
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' WinCommonControlConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSGroupPane subclass: #PARTSToolboxPart
  instanceVariableNames: 
    ' toolHeight toolWidth tools toolsWithLabels maxWidth '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSOrderedGroupPane subclass: #PARTSToolContainer
  instanceVariableNames: 
    ' currentItemIndex '
  classVariableNames: ''
  poolDictionaries: 
    ' GraphicsConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

DictionaryEditorPane subclass: #PersonEditorPane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

CompositePane subclass: #PersonPane
  instanceVariableNames: 
    ' person '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

CompositePane subclass: #RadioButtonGroup
  instanceVariableNames: 
    ' label list numColumns selection '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

RadioButtonGroup subclass: #CheckBoxGroup
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

ControlPane subclass: #RangeControl
  instanceVariableNames: 
    ' min max lineIncrement '
  classVariableNames: ''
  poolDictionaries: 
    ' VirtualKeyConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!

   

RangeControl subclass: #PagedRangeControl
  instanceVariableNames: 
    ' pageIncrement '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Windows-SubPanes' )
  comment: ''!



RangeControl subclass: #ProgressBar
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants WinCommonControlConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

ControlPane subclass: #ScintillaPane
  instanceVariableNames: 
    ' modified lastPosition findDialog replaceDialog autoCompleteList callTip lastCallTip usingCallTips '
  classVariableNames: 
    ' ClipboardHistory ReplaceHistory SearchHistory '
  poolDictionaries: 
    ' ScintillaConstants VirtualKeyConstants '
  categories: #( 'Tools-Scintilla Pane' )
  comment: ''!

!ScintillaPane methods !  
wordPartLeft

    self sendEditor: SCI_WORDPARTLEFT!  ! 
#('April 19, 2002' '12:34:00 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('cursor positioning' wordPartLeft )) !


!ScintillaPane methods !   
sourceManager
        "Answer the instance of ExpressionEvaluator (or subclass)
        which handles evaluations."
    ^self
        propertyAt: #sourceManager
        ifAbsentPut: [SourceManager current]! ! 
#('March 3, 2003' '10:13:27 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('text pane emulation' sourceManager )) !


!ScintillaPane methods !  
dll
    ^ScintillaDLL current! ! 
#('April 15, 2002' '12:12:18 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('querying' dll )) !


!ScintillaPane methods !  
beginReplace

    | selection dialog searchString |
    selection := self selection.
    dialog := self replaceDialog.
    self selection isEmpty ifTrue: [dialog disableSearchInSelection] ifFalse: [dialog enableSearchInSelection].
    dialog 
        searchString: ''; searchHistory: ScintillaPane searchHistory;
        replaceString: ''; replaceHistory: ScintillaPane replaceHistory.
    dialog open.

    ScintillaPane 
        rememberSearchString: dialog searchString;
        rememberReplaceString: dialog replaceString! ! 
#('April 26, 2002' '12:24:51 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('searching' beginReplace )) !


!ScintillaPane methods !
selection

    self sendEditor: SCI_GETSELTEXT buffer: ''.
    ^self dll buffer! ! 
#('April 19, 2002' '12:17:17 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('selection and clipboard handling' selection )) !


!ScintillaPane methods !
handleBraceHighlighting

    self findMatchingBracesAt: self cursorPosition do: [:brace1 :brace2 |
        brace2 = INVALID_POSITION ifTrue: [^self badBrace: brace1].
        self highlightBrace: brace1 and: brace2]!    ! 
#('May 3, 2002' '03:52:47 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('brace highlighting' handleBraceHighlighting )) !


!ScintillaPane methods !   
selectedString

    ^self selection!  ! 
#('April 19, 2002' '12:16:33 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('selection and clipboard handling' selectedString )) !


!ScintillaPane methods !   
sendEditor: message

    ^self dll send: message to: self!    ! 
#('April 19, 2002' '11:33:52 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('private-dll interface' sendEditor: )) !


!ScintillaPane methods ! 
selectLineAtCurrentSelection

    | line start end |
    line := self currentLineNumber.
    start := self lineStartPosition: line.
    end := self lineEndPosition: line.
    self selectFrom: start to: end!    ! 
#('April 19, 2002' '12:20:16 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('selection and clipboard handling' selectLineAtCurrentSelection )) !


!ScintillaPane methods ! 
clipboardHistoryString

    | stream |
    stream := WriteStream on: String new.
    ScintillaPane clipboardHistory do: [:string | stream nextPutAll: string] andBetweenDo: [stream nextPut: self autoCompleteSeparator].
    ^stream contents!    ! 
#('May 3, 2002' '11:20:13 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('selection and clipboard handling' clipboardHistoryString )) !


!ScintillaPane methods !  
notify: message at: position in: source
    "self halt: message."
    "
    self insertText: message at: position - 1.
    self selectFrom: position - 1 to: position + message size - 2.
    "
    self insertAndSelectText: message at: position - 1!   ! 
#('January 20, 2003' '10:53:25 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('text handling' notify:at:in: )) !


!ScintillaPane methods ! 
doInsertCallTip

    | charactersTypedSoFar charactersRemaining prefix pattern position |
    usingCallTips ifFalse: [^self].
    position := self cursorPosition.
    self lineUp; lineEnd.
    prefix := self wordAtCursor. 
    prefix isEmpty ifTrue: [^self cursorPosition: position; anchorPosition: position].
    
    pattern := WildPattern new: prefix, '*'.
    (pattern matches: lastCallTip) ifFalse: [^self cursorPosition: position; anchorPosition: position].
    charactersTypedSoFar := self cursorPosition - self wordStartPosition.
    charactersRemaining := lastCallTip size - (charactersTypedSoFar  + 1).
    self insertText: (lastCallTip copyFrom: charactersTypedSoFar + 1 to: lastCallTip size) at: self cursorPosition.
    self cursorPosition: self cursorPosition + charactersRemaining + 1; anchorPosition: self cursorPosition.
    self lineDown; lineEnd; deleteLineLeft.
    prefix size = lastCallTip size ifTrue: [self autoIndent] ifFalse: [self backspace; cancelCallTip].!   ! 
#('May 3, 2002' '03:59:48 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('call tips' doInsertCallTip )) !


!ScintillaPane methods !
nonTabbifiedSelectFrom: start to: end

    | noTabsContents tabs chunk newStart newEnd |
    noTabsContents := self untabbify: self contents.
    chunk := noTabsContents copyFrom: 1 to: (start min: noTabsContents size).
    tabs := (self tabbify: chunk) occurrencesOf: Character tab.
    newStart := start - 1 - (3 * tabs).
    chunk := noTabsContents copyFrom: 1 to: end - 1.
    tabs := (self tabbify: chunk) occurrencesOf: Character tab.
    newEnd := end - 1 -  (3 * tabs).

    self anchorPosition: newStart; cursorPosition: newEnd!    ! 
#('October 10, 2002' '11:09:26 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('selection and clipboard handling' nonTabbifiedSelectFrom:to: )) !


!ScintillaPane methods ! 
expressionEvaluatorClass
        "Private - answer the class of ExpressionEvaluator
        which is used if not otherwise specified."
    ^ScintillaExpressionEvaluator!    ! 
#('November 7, 2002' '10:46:45 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('text pane emulation' expressionEvaluatorClass )) !


!ScintillaPane methods !
setReadOnly: aBoolean

    ^self sendEditor: SCI_SETREADONLY with: aBoolean!  ! 
#('April 19, 2002' '11:50:01 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('configuring' setReadOnly: )) !


!ScintillaPane methods !  
anchorPosition: position

    ^self sendEditor: SCI_SETANCHOR with: position! ! 
#('April 19, 2002' '12:24:16 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('selection and clipboard handling' anchorPosition: )) !


!ScintillaPane methods !  
longFromTwoShorts: a and: b

    ^self dll longFromTwoShorts: a and: b!   ! 
#('April 19, 2002' '11:29:07 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('private-dll interface' longFromTwoShorts:and: )) !


!ScintillaPane methods !  
setTextFont

    self setTextFont: TextFont!  ! 
#('April 25, 2002' '03:02:42 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('configuring' setTextFont )) !


!ScintillaPane methods !   
findDialog

    findDialog isNil ifTrue: [findDialog := ScintillaFindDialog for: self].
    ^findDialog! ! 
#('April 26, 2002' '10:49:20 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('searching' findDialog )) !


!ScintillaPane methods !  
bindEditingKeys

    | key modifiers keyWord |
    key := SCK_DELETE. 
    modifiers := SCMOD_CTRL bitOr: SCMOD_SHIFT.
    keyWord := self longFromTwoShorts: key and: modifiers.
    
    self sendEditor: SCI_ASSIGNCMDKEY with: keyWord with: SCI_DELWORDRIGHT!   ! 
#('April 19, 2002' '11:34:57 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('configuring' bindEditingKeys )) !


!ScintillaPane methods !   
selectFrom: start to: end

    self anchorPosition: start; cursorPosition: end!   ! 
#('May 3, 2002' '03:49:51 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('selection and clipboard handling' selectFrom:to: )) !


!ScintillaPane methods !  
prepareToValidate

    ScintillaDLL current!  ! 
#('April 17, 2002' '04:15:50 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('scheduling' prepareToValidate )) !


!ScintillaPane methods !  
beginUndoAction

    self sendEditor: SCI_BEGINUNDOACTION!    ! 
#('May 14, 2002' '11:16:11 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('undo/redo/save' beginUndoAction )) !


!ScintillaPane methods !  
contents

    self sendEditor: SCI_GETTEXT buffer: '' with: self dll maxBufferSize.
    ^self untabbify: self dll buffer.!   ! 
#('April 19, 2002' '11:57:19 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('text handling' contents )) !


!ScintillaPane methods !
notifySavePointReached: parameter

    self modified: false.! ! 
#('April 16, 2002' '10:56:17 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('notifying' notifySavePointReached: )) !


!ScintillaPane methods ! 
forceSelectionOntoDisplay

    self sendEditor: SCI_SCROLLCARET!  ! 
#('May 3, 2002' '01:51:23 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('selection and clipboard handling' forceSelectionOntoDisplay )) !


!ScintillaPane methods !   
compilerError: errorMessage at: sourcePosition in: sourceCode for: aClass

    | difference |
    difference := sourcePosition - (self tabbify: (sourceCode copyFrom: 1 to: (sourcePosition min: sourceCode size))) size.
    ^self expressionEvaluator compilerError: errorMessage at: sourcePosition - difference in: sourceCode for: aClass! ! 
#('October 16, 2002' '08:27:50 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('development support' compilerError:at:in:for: )) !


!ScintillaPane methods !
totalWidth
        "Private - Answer the width of the receiver's graphics medium."
        
    ^rectangle width!    ! 
#('April 19, 2002' '11:52:53 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('querying' totalWidth )) !


!ScintillaPane methods !   
indentCurrentLine: indent

    | position line |
    line := self currentLineNumber.
    self sendEditor: SCI_SETLINEINDENTATION with: line with: indent.
    position := self sendEditor: SCI_GETLINEINDENTPOSITION with: line.
    self anchorPosition: position; cursorPosition: position.!    ! 
#('April 19, 2002' '02:21:07 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('indenting' indentCurrentLine: )) !


!ScintillaPane methods !  
sendersOfSelection

    | selector |
    selector := self selection trimBlanks.
    selector isEmpty ifTrue: [selector := self wordAtCursor].
    (selector includes: $*) ifTrue: [CursorManager execute changeFor: [selector := self findWildcardSelector: selector]].

    selector notNil ifTrue: [
        self sourceManager sendersOf: selector asSymbol ifNone: [
            selector := self findWildcardSelector: selector, '*'.
            selector isNil ifTrue: [^self].
            self sourceManager sendersOf: selector asSymbol]]!    ! 
#('March 3, 2003' '10:13:27 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('development support' sendersOfSelection )) !


!ScintillaPane methods ! 
modified: aBoolean

    modified := aBoolean.!    ! 
#('April 18, 2002' '02:33:13 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('configuring' modified: )) !


!ScintillaPane methods ! 
modified: aBoolean

    modified == aBoolean ifTrue: [^self].
    modified := aBoolean.
    self backgroundColor: (modified ifTrue: [255@255@0] ifFalse: [255@255@255])!    ! 
#('April 25, 2005' '10:44:44 AM' 999024)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('configuring' modified: )) !


!ScintillaPane methods !  
modified: aBoolean

    modified == aBoolean ifTrue: [^self].
    modified := aBoolean.
    self foregroundColor: (modified ifTrue: [255@0@0] ifFalse: [0@0@0])!    ! 
#('April 27, 2005' '08:58:03 AM' 999244)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('configuring' modified: )) !


!ScintillaPane methods !  
currentLineNumber

    ^self sendEditor: SCI_LINEFROMPOSITION with: self cursorPosition!  ! 
#('May 3, 2002' '03:52:02 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('text handling' currentLineNumber )) !


!ScintillaPane methods !  
backspace

    self cancelCallTip.
    self privateBackspace.
    self showCurrentCallTip!  ! 
#('May 3, 2002' '03:00:01 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('text handling' backspace )) !


!ScintillaPane methods !  
do: aString
    self setEvaluate: true.
    ^self expressionEvaluator evaluate: aString ifError: [nil]!   ! 
#('January 20, 2003' '10:53:28 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('development support' do: )) !


!ScintillaPane methods ! 
swapCursorAndAnchor

    | cursor anchor |
    cursor := self cursorPosition.
    anchor := self anchorPosition.
    cursor = anchor ifTrue: [^self goToMatchingBracePosition].
    self anchorPosition: cursor; cursorPosition: anchor!  ! 
#('May 3, 2002' '03:49:42 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('cursor positioning' swapCursorAndAnchor )) !


!ScintillaPane methods !   
insertText: aString at: index

    self sendEditor: SCI_INSERTTEXT buffer: aString with: index!   ! 
#('April 19, 2002' '12:07:49 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('text handling' insertText:at: )) !


!ScintillaPane methods !  
evaluate: aString ifError: errorBlock
    self setEvaluate: true.
    ^self expressionEvaluator evaluate: aString ifError: errorBlock!    ! 
#('March 7, 2003' '05:07:20 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('development support' evaluate:ifError: )) !


!ScintillaPane methods !  
accept

    self cancelAutoComplete; cancelCallTip.
    self setEvaluate: false.
    self triggerEvent: #aboutToSave.
    self modified ifFalse: [^self].
    self triggerEvent: #saved!  ! 
#('May 3, 2002' '03:32:37 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('text handling' accept )) !


!ScintillaPane methods ! 
lineUp

    self sendEditor: SCI_LINEUP!  ! 
#('May 3, 2002' '03:39:38 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('cursor positioning' lineUp )) !


!ScintillaPane methods !
replaceDialog

    replaceDialog isNil ifTrue: [replaceDialog := ScintillaReplaceDialog for: self].
    ^replaceDialog!  ! 
#('April 26, 2002' '10:49:20 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('searching' replaceDialog )) !


!ScintillaPane methods !   
removeMargins

    self sendEditor: SCI_SETMARGINWIDTHN with: 1 with: 0!  ! 
#('April 19, 2002' '11:40:22 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('configuring' removeMargins )) !


!ScintillaPane methods ! 
beginFind

    | selection dialog |
    selection := self selection trimBlanks. (selection includes: Character cr) ifTrue: [selection := ''].
    dialog := self findDialog.
    dialog searchString: selection; searchHistory: ScintillaPane searchHistory.
    dialog open.
    ScintillaPane rememberSearchString: dialog searchString!   ! 
#('April 26, 2002' '12:23:01 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('searching' beginFind )) !


!ScintillaPane methods !   
expressionEvaluator
        "Answer the instance of ExpressionEvaluator (or subclass)
        which handles evaluations."
    ^self
        propertyAt: #expressionEvaluator
        ifAbsentPut: [ self expressionEvaluatorClass on: self ]!  ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('text pane emulation' expressionEvaluator )) !


!ScintillaPane methods !  
wordPartRight

    self sendEditor: SCI_WORDPARTRIGHT!    ! 
#('April 19, 2002' '12:34:29 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('cursor positioning' wordPartRight )) !


!ScintillaPane methods !  
enableDefaultPopUpMenu

    self sendEditor: SCI_USEPOPUP with: true! ! 
#('April 19, 2002' '11:39:24 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('configuring' enableDefaultPopUpMenu )) !


!ScintillaPane methods !
doAutoCompleteWith: autoCompleteString

    | charactersTypedSoFar charactersRemaining |
    charactersTypedSoFar := self cursorPosition - self wordStartPosition.
    (autoCompleteString occurrencesOf: self autoCompleteSeparator) = 0 
        ifFalse: [self sendEditor: SCI_AUTOCSHOW buffer: autoCompleteString with: charactersTypedSoFar. ^true].

    autoCompleteString isEmpty ifTrue: [^false].
    
    "only one string"
    self cursorPosition: self cursorPosition - charactersTypedSoFar; backspace.
    self insertText: autoCompleteString at: self cursorPosition.
    self cursorPosition: self cursorPosition + autoCompleteString size; anchorPosition: self cursorPosition.
    ^true!   ! 
#('May 14, 2002' '11:17:41 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('auto complete' doAutoCompleteWith: )) !


!ScintillaPane methods !   
untabbify: aString

    ^aString replaceAll: (String with: Character tab) with: '    '!   ! 
#('April 16, 2002' '01:58:28 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('text handling' untabbify: )) !


!ScintillaPane methods !  
highShortFromLong: a

    ^self dll highShortFromLong: a! ! 
#('April 19, 2002' '11:28:55 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('private-dll interface' highShortFromLong: )) !


!ScintillaPane methods !  
isReadOnly

    ^(self sendEditor: SCI_GETREADONLY) == 1! ! 
#('April 19, 2002' '11:52:05 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('querying' isReadOnly )) !


!ScintillaPane methods !   
doAll
    self evaluate: self contents ifError: [^self].!  ! 
#('February 25, 2003' '10:09:24 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('development support' doAll )) !


!ScintillaPane methods !  
pasteSelection

    self sendEditor: SCI_PASTE!   ! 
#('May 3, 2002' '11:31:18 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('selection and clipboard handling' pasteSelection )) !


!ScintillaPane methods !  
again

    | newPosition |
    self findDialog isDown
        ifTrue: [
            newPosition := self cursorPosition max: self anchorPosition.
            self cursorPosition: newPosition; anchorPosition: newPosition]
        ifFalse: [
            newPosition := (self cursorPosition min: self anchorPosition) - 1.
            self cursorPosition: newPosition; anchorPosition: newPosition].

    self findDialog findNextClicked!  ! 
#('April 26, 2002' '10:49:20 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('searching' again )) !


!ScintillaPane methods !   
pasteFromHistory

    | history |
    history := self clipboardHistoryString.
    self sendEditor: SCI_USERLISTSHOW buffer: history!    ! 
#('May 3, 2002' '11:31:32 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('selection and clipboard handling' pasteFromHistory )) !


!ScintillaPane methods !
anchorPosition

    ^self sendEditor: SCI_GETANCHOR!  ! 
#('April 19, 2002' '12:14:57 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('selection and clipboard handling' anchorPosition )) !


!ScintillaPane methods !   
endUndoAction

    self sendEditor: SCI_ENDUNDOACTION!    ! 
#('May 14, 2002' '11:16:20 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('undo/redo/save' endUndoAction )) !


!ScintillaPane methods !
tabbify: aString

    ^aString replaceAll: '    ' with: (String with: Character tab).!    ! 
#('April 16, 2002' '01:57:39 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('text handling' tabbify: )) !


!ScintillaPane methods !
NEWevaluate: aString ifError: errorBlock
    self setEvaluate: true.
    ^self expressionEvaluator evaluate: aString ifError: errorBlock! ! 
#('February 25, 2003' '10:09:21 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('development support' NEWevaluate:ifError: )) !


!ScintillaPane methods !   
sendEditor: message buffer: aString with: arg1

    | long1 |
    arg1 isBoolean ifTrue: [long1 := arg1 ifTrue: [1] ifFalse: [0]] ifFalse: [long1 := arg1].

    ^self dll send: message to: self buffer: aString with: long1! ! 
#('April 19, 2002' '12:03:15 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('private-dll interface' sendEditor:buffer:with: )) !


!ScintillaPane methods ! 
grabFocus

    self sendEditor: SCI_GRABFOCUS!    ! 
#('April 19, 2002' '12:30:35 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('scheduling' grabFocus )) !


!ScintillaPane methods !  
handleDoubleClick

    | start end |
    self findMatchingBracesAt: lastPosition do: [:brace1 :brace2 |
        (brace1 = INVALID_POSITION or: [brace2 = INVALID_POSITION]) ifFalse: [^self selectFrom: brace1 + 1 to: brace2]].

    Notifier isControlKeyDownNow ifFalse: [^self].

    self cursorPosition: lastPosition.
    self wordPartLeft; wordPartRightExtend!   ! 
#('May 3, 2002' '03:50:34 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('notifying' handleDoubleClick )) !


!ScintillaPane methods !  
initialize

    super initialize.
    self modified: false.
    self disableDefaultPopUpMenu.
    autoCompleteList := #().
    usingCallTips := false.!   ! 
#('May 3, 2002' '03:59:11 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('initializing' initialize )) !


!ScintillaPane methods !  
style: styleNumber bold: aBoolean

    ^self sendEditor: SCI_STYLESETBOLD with: styleNumber with: aBoolean.!  ! 
#('April 19, 2002' '11:50:21 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('styling text' style:bold: )) !


!ScintillaPane methods !  
notifyKillFocus: parameter

    self losingFocus.!    ! 
#('April 15, 2002' '02:02:03 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('notifying' notifyKillFocus: )) !


!ScintillaPane methods !
style: styleNumber backgroundColor: anRGBPoint

    | color |
    color := self colorAsLongRed: anRGBPoint x green: anRGBPoint y blue: anRGBPoint z.
    ^self sendEditor: SCI_STYLESETBACK with: styleNumber with: color.! ! 
#('April 19, 2002' '11:50:18 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('styling text' style:backgroundColor: )) !


!ScintillaPane methods !   
style: styleNumber foregroundColor: anRGBPoint

    | color |
    color := self colorAsLongRed: anRGBPoint x green: anRGBPoint y blue: anRGBPoint z.
    ^self sendEditor: SCI_STYLESETFORE with: styleNumber with: color.! ! 
#('April 19, 2002' '11:50:23 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('styling text' style:foregroundColor: )) !


!ScintillaPane methods !   
wordAtCursor

    | string start end |
    start := self wordStartPosition. end := self wordEndPosition.
    string := (String withAll: ((start to: end) collect: [:index | self characterAt: index])) trimBlanks.
    string := string reject: [:character | '[]().;' includes: character].
    ^string! ! 
#('April 25, 2002' '03:42:11 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('text handling' wordAtCursor )) !


!ScintillaPane methods !
previousLine

    | lineNumber size |
    lineNumber := self currentLineNumber.
    size := self sendEditor: SCI_GETLINE buffer: '' with: (lineNumber - 1 max: 0).
    self dll bufferAt: size put: 0.
    ^self dll buffer!  ! 
#('April 19, 2002' '12:09:34 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('text handling' previousLine )) !


!ScintillaPane methods !
copySelection

    ScintillaPane rememberClipboardString: self selectedString.
    self sendEditor: SCI_COPY!    ! 
#('May 3, 2002' '11:07:31 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('selection and clipboard handling' copySelection )) !


!ScintillaPane methods !   
goToMatchingBracePosition

    self findMatchingBracesAt: self cursorPosition do: [:brace1 :brace2 | 
        brace2 = INVALID_POSITION ifFalse: [
            self cursorPosition: brace2.
            Notifier isShiftKeyDown ifFalse: [self anchorPosition: brace2].
            self forceSelectionOntoDisplay]].!    ! 
#('May 3, 2002' '03:53:04 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('cursor positioning' goToMatchingBracePosition )) !


!ScintillaPane methods ! 
sourceManager: aSourceManager
    self propertyAt: #sourceManager put: aSourceManager! ! 
#('March 3, 2003' '10:13:27 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('text pane emulation' sourceManager: )) !


!ScintillaPane methods ! 
showCurrentCallTip

    | prefix pattern currentTip |
    usingCallTips ifFalse: [^self].
    self triggerEvent: #needsAutoCompleteList.
    prefix := self wordAtCursor asLowercase.
    prefix size < 3 ifTrue: [^self cancelCallTip].
    pattern := WildPattern new: prefix, '*'.
    currentTip := autoCompleteList detect: [:word | pattern matches: word asLowercase] ifNone: [^self cancelCallTip].
    callTip = currentTip ifTrue: [^self].
    callTip := currentTip.
    self cancelCallTip.
    self sendEditor: SCI_CALLTIPSHOW buffer: currentTip with: 0!   ! 
#('May 3, 2002' '03:59:53 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('call tips' showCurrentCallTip )) !


!ScintillaPane methods ! 
notifyUpdateUI: parameter

    lastPosition := self cursorPosition.
    self handleBraceHighlighting.!   ! 
#('May 3, 2002' '03:52:43 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('notifying' notifyUpdateUI: )) !


!ScintillaPane methods !
cursorPosition: position

    ^self sendEditor: SCI_SETCURRENTPOS with: position! ! 
#('April 19, 2002' '12:06:36 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('cursor positioning' cursorPosition: )) !


!ScintillaPane methods !
findWildcardSelector: wildPattern
    "wildPattern        <String>
    Return the name of the selector specified by wildPattern, which includes the wildcard character.
    If the wildPattern is just *, however, answer * because the user probably means it literally.
    ** will answer all of the selectors in Smalltalk, and is not used as a selector anywhere (yet) anyways."

    | candidates selector pattern |
    wildPattern = '*' ifTrue: [^wildPattern].
    pattern := Pattern new: wildPattern.
    candidates := Set new: 100.
    self sourceManager getSourceClasses do: [:aClass |
        aClass selectors do: [:each |
            (pattern matches: each)
                ifTrue: [candidates add: each]].
        aClass class selectors do: [:each |
            (pattern matches: each)
                ifTrue: [candidates add: each]]].

    candidates isEmpty ifTrue: [MessageBox message: 'No matching selectors'. ^nil].
    candidates size = 1 ifTrue: [^candidates any].
    selector := (ChooseOneDialog new openOn: candidates asSortedCollection label: 'Choose a Selector').
    (selector isNil or: [selector isEmpty]) ifTrue: [selector := nil].
    ^selector!  ! 
#('March 3, 2003' '10:13:27 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('development support' findWildcardSelector: )) !


!ScintillaPane methods !  
tabKeyInput: aKeyboardInputEvent
        "Private - Respond to the tab keystroke."

    aKeyboardInputEvent isControlKeyDown ifFalse: [^nil].
    self triggerEvent: #controlTabbed ifNotHandled: [
        aKeyboardInputEvent isShiftKeyDown
                ifTrue: [
                    [(self tabScope previousTabStop: self) setFocus]
                        on: Error do: [ :e | ^self  "Stack overflow because no valid tab stop"]]
                ifFalse:  [
                    [(self tabScope nextTabStop: self) setFocus]
                        on: Error do: [ :e | ^self ]]]!  ! 
#('April 19, 2002' '12:31:42 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('scheduling' tabKeyInput: )) !


!ScintillaPane methods !   
lineDown

    self sendEditor: SCI_LINEDOWN!  ! 
#('May 3, 2002' '03:42:06 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('cursor positioning' lineDown )) !


!ScintillaPane methods !  
savePointReached

    self
        sendEditor: SCI_EMPTYUNDOBUFFER;
        sendEditor: SCI_SETSAVEPOINT!   ! 
#('April 19, 2002' '12:13:38 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('undo/redo/save' savePointReached )) !


!ScintillaPane methods !   
wordPartLeftExtend

    self sendEditor: SCI_WORDPARTLEFTEXTEND!  ! 
#('April 19, 2002' '12:34:17 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('cursor positioning' wordPartLeftExtend )) !


!ScintillaPane methods ! 
lineEndPosition: line

    ^self sendEditor: SCI_GETLINEENDPOSITION with: line!   ! 
#('April 19, 2002' '12:22:53 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('cursor positioning' lineEndPosition: )) !


!ScintillaPane methods !   
previousIndent

    | line |
    line := self currentLineNumber.
    ^self sendEditor: SCI_GETLINEINDENTATION with: line - 1!   ! 
#('April 19, 2002' '02:19:46 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('indenting' previousIndent )) !


!ScintillaPane methods !  
currentCharacter

    ^self characterAt: self cursorPosition! ! 
#('May 3, 2002' '03:53:20 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('text handling' currentCharacter )) !


!ScintillaPane methods !   
sendEditor: message with: arg1 with: arg2

    | long1 long2 |
    arg1 isBoolean ifTrue: [long1 := arg1 ifTrue: [1] ifFalse: [0]] ifFalse: [long1 := arg1].
    arg2 isBoolean ifTrue: [long2 := arg2 ifTrue: [1] ifFalse: [0]] ifFalse: [long2 := arg2].

    ^self dll send: message to: self with: long1 with: long2! ! 
#('April 19, 2002' '11:37:23 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('private-dll interface' sendEditor:with:with: )) !


!ScintillaPane methods !   
selectedItem

    ^self selection!    ! 
#('April 19, 2002' '12:16:30 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('selection and clipboard handling' selectedItem )) !


!ScintillaPane methods ! 
keyboardInput: anEvent

    | virtualKey |
    virtualKey := anEvent virtualKey.
    (anEvent characterValue = SpaceKey and: [anEvent isControlKeyDown]) ifTrue: [
        self beginUndoAction.
        self backspace. 
        self doAutoComplete.
        self endUndoAction].

    (virtualKey == TabKey or: [virtualKey == BacktabKey]) ifTrue: [self tabKeyInput: anEvent].
    virtualKey = 12 "keypad 5" ifTrue: [^self swapCursorAndAnchor].
    virtualKey = EscapeKey ifTrue: [self cancelAutoComplete; cancelCallTip].
    (anEvent characterValue = ReturnKey and: [lastCallTip notNil]) ifTrue: [^self doInsertCallTip].
    super keyboardInput: anEvent.!   ! 
#('May 14, 2002' '11:27:15 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('notifying' keyboardInput: )) !


!ScintillaPane methods !
setSelectionHighlightStyle

    | backColor foreColor |
    foreColor := self colorAsLongRed: 255 green: 255 blue: 255.
    backColor := self colorAsLongRed: 98 green: 98 blue: 255.
    ^self 
        sendEditor: SCI_SETSELBACK with: true with: backColor;
        sendEditor: SCI_SETSELFORE with: true with: foreColor.!  ! 
#('June 19, 2002' '09:46:49 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('coloring' setSelectionHighlightStyle )) !


!ScintillaPane methods !
currentLine

    | lineNumber size |
    lineNumber := self currentLineNumber.
    size := self sendEditor: SCI_GETLINE with: lineNumber.
    self dll bufferAt: size put: 0.
    ^self dll buffer!   ! 
#('April 19, 2002' '12:00:23 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('text handling' currentLine )) !


!ScintillaPane methods ! 
autoCompleteStringFrom: wordList

    | strings stream word partialWord partialWordSize firstCharacter lowerCasePartialWord |
    partialWordSize := self cursorPosition - self wordStartPosition.
    partialWord := self wordAtCursor copyFrom: 1 to: partialWordSize.
    lowerCasePartialWord := partialWord asLowercase.
    lowerCasePartialWord isEmpty ifTrue: [^''].
    firstCharacter := lowerCasePartialWord first.
    stream := ReadStream on: self contents.
    strings :=OrderedCollection new: wordList size + 200.
    [(word := stream nextKeyword) notNil] whileTrue: [(word first isLetter and: [word first asLowercase = firstCharacter]) ifTrue: [strings add: word]].

    wordList do: [:word | strings add: word asString].
    strings := ScintillaPane unshmooshSelectors: strings.
    [strings includes: partialWord] whileTrue: [strings remove: partialWord].
    strings := strings select: [:string | (string size >= 3) and: [string equalsIgnoreCase: lowerCasePartialWord upTo: partialWordSize]].
    stream := WriteStream on: String new.
    strings asSet asSortedCollection do: [:string | stream nextPutAll: string] andBetweenDo: [stream nextPut: self autoCompleteSeparator].
    ^stream contents!   ! 
#('May 6, 2002' '02:49:53 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('auto complete' autoCompleteStringFrom: )) !


!ScintillaPane methods !
popupMenu
        "Private - Answer the popup Menu for the receiver."

    | menu |
    menu := super popupMenu.
    menu isNil ifTrue: [
        menu := Menu new
            owner: self;
            title: 'TextPanePopup';
            appendItem: 'Cu\ut' replaceEscapeCharacters selector: #cutSelection ;
            appendItem: '\uCopy' replaceEscapeCharacters selector: #copySelection;
            appendItem: '\uPaste' replaceEscapeCharacters selector: #pasteSelection;
            appendSeparator ;
            appendItem: '\uDo It' replaceEscapeCharacters selector: #doIt;
            appendItem: '\uShow It' replaceEscapeCharacters selector: #printIt;
            appendItem: '\uInspect It' replaceEscapeCharacters selector: #inspectIt;
            appendSeparator;
            appendItem: 'Senders' selector: #sendersOfSelection;
            appendItem: 'Implementors' selector: #implementorsOfSelection;
            appendItem: 'References' selector: #referencesOfSelection;
            appendSeparator ;
            appendItem: 'Undo' selector: #undo ;
            appendItem: 'Redo' selector: #redo;
            appendItem: '\uSave' replaceEscapeCharacters selector: #accept ;
            appendItem: 'Restore' selector: #restore;
            yourself].

    ^self popupFromMenu: menu! ! 
#('April 18, 2002' '10:47:46 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('scheduling' popupMenu )) !


!ScintillaPane methods !  
buildAutoCompleteListForClass: aClass

    | currentWord words |
    currentWord := self wordAtCursor trimBlanks.
    (currentWord isEmpty or: [currentWord first isLowercase]) ifTrue: [^self autoCompleteList: (self autocompleteWordsFor: aClass)].
    currentWord first isUppercase ifTrue: [
        words := OrderedCollection new.
        Smalltalk keys do: [:key | words add: key asString].
        aClass sharedPools do: [:pool | (Smalltalk at: pool) keys do: [:key | words add: key asString]].
        ^self autoCompleteList: words asSet asSortedCollection]!  ! 
#('March 16, 2003' '09:38:13 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('auto complete' buildAutoCompleteListForClass: )) !


!ScintillaPane methods !  
autoCompleteSeparator

    ^Character value: 11!  ! 
#('May 3, 2002' '11:16:57 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('auto complete' autoCompleteSeparator )) !


!ScintillaPane methods !  
aboutToSaveImage

    super aboutToSaveImage.
    self 
        propertyAt: #storedInformation put: true;
        propertyAt: #contents put: self contents;
        propertyAt: #modified put: self modified;
        propertyAt: #cursorPosition put: self cursorPosition;
        propertyAt: #anchorPosition put: self anchorPosition!   ! 
#('May 3, 2002' '03:52:59 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('scheduling' aboutToSaveImage )) !


!ScintillaPane methods !  
sendEditor: message with: arg1

    | long1 |
    arg1 isBoolean ifTrue: [long1 := arg1 ifTrue: [1] ifFalse: [0]] ifFalse: [long1 := arg1].

    ^self dll send: message to: self with: long1! ! 
#('April 19, 2002' '11:36:39 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('private-dll interface' sendEditor:with: )) !


!ScintillaPane methods !
lineStartPosition: line

    ^(self sendEditor: SCI_GETLINEENDPOSITION with: line - 1) + 1!   ! 
#('April 19, 2002' '12:19:17 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('cursor positioning' lineStartPosition: )) !


!ScintillaPane methods ! 
setTextFont: aFont

    self
        sendEditor: SCI_STYLESETFONT buffer: aFont faceName with: STYLE_DEFAULT;
        sendEditor: SCI_STYLESETSIZE with: STYLE_DEFAULT with: aFont pointSize;
        sendEditor: SCI_STYLESETBOLD with: STYLE_DEFAULT with: aFont bold;
        sendEditor: SCI_STYLESETITALIC with: STYLE_DEFAULT with: aFont italic!   ! 
#('April 25, 2002' '03:02:42 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('configuring' setTextFont: )) !


!ScintillaPane methods !  
setSmalltalkTabbing

    self
        sendEditor: SCI_SETTABWIDTH with: 4;
        sendEditor: SCI_SETINDENT with: 4;
        sendEditor: SCI_SETUSETABS with: 1!  ! 
#('April 19, 2002' '11:49:49 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('configuring' setSmalltalkTabbing )) !


!ScintillaPane methods !   
privateBackspace

    self sendEditor: SCI_DELETEBACK!    ! 
#('May 3, 2002' '02:59:20 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('text handling' privateBackspace )) !


!ScintillaPane methods !   
canUndo

    ^(self sendEditor: SCI_CANUNDO) == 1!    ! 
#('April 19, 2002' '12:12:46 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('undo/redo/save' canUndo )) !


!ScintillaPane methods !
characterAt: position

    | value |
    value := (self sendEditor: SCI_GETCHARAT with: position) clampedTo: 0 and: 255.
    ^Character value: value!   ! 
#('April 19, 2002' '11:54:18 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('text handling' characterAt: )) !


!ScintillaPane methods !
contents: aString

    | tabbedString |
    aString notNil ifTrue: [tabbedString := self tabbify: aString].
    self sendEditor: SCI_SETTEXT buffer: tabbedString with: tabbedString size.
    self modified: false.
    self savePointReached.
    self triggerEvent: #needsAutoCompleteList!   ! 
#('May 3, 2002' '02:33:25 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('text handling' contents: )) !


!ScintillaPane methods !  
deleteLineLeft

    self sendEditor: SCI_DELLINELEFT! ! 
#('May 3, 2002' '03:41:48 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('cursor positioning' deleteLineLeft )) !


!ScintillaPane methods !
cutSelection

    ScintillaPane rememberClipboardString: self selectedString.
    self sendEditor: SCI_CUT!  ! 
#('May 3, 2002' '11:07:39 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('selection and clipboard handling' cutSelection )) !


!ScintillaPane methods !
doIt

    self doIt: [^self].
    self insertAndSelectText: '' at: (self cursorPosition max: self anchorPosition)!   ! 
#('May 3, 2002' '03:52:26 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('development support' doIt )) !


!ScintillaPane methods ! 
doIt

    self doIt: [^self].
"
    self insertAndSelectText: '' at: (self cursorPosition max: self anchorPosition)
"! ! 
#('February 7, 2014' '02:55:17 PM' 1028412)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('development support' doIt )) !


!ScintillaPane methods !
inspectIt

    (self doIt: [^self]) inspect!  ! 
#('April 17, 2002' '04:44:02 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('development support' inspectIt )) !


!ScintillaPane methods ! 
lineEnd

    self sendEditor: SCI_LINEEND!    ! 
#('May 3, 2002' '03:39:44 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('cursor positioning' lineEnd )) !


!ScintillaPane methods !   
colorAsLongRed: red green: green blue: blue

    ^self dll colorAsLongRed: red green: green blue: blue!   ! 
#('April 19, 2002' '11:28:44 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('private-dll interface' colorAsLongRed:green:blue: )) !


!ScintillaPane methods !  
notifyCharAdded: winAddress

    | character |
    character := (ScNotification atAddress: winAddress) ch.
    self handleCharAdded: character! ! 
#('April 17, 2002' '04:21:44 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('notifying' notifyCharAdded: )) !


!ScintillaPane methods !
disableDefaultPopUpMenu

    self sendEditor: SCI_USEPOPUP with: false!   ! 
#('April 19, 2002' '11:39:07 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('configuring' disableDefaultPopUpMenu )) !


!ScintillaPane methods !   
wordEndPosition

    ^self sendEditor: SCI_WORDENDPOSITION with: self cursorPosition with: true!  ! 
#('April 19, 2002' '12:11:10 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('cursor positioning' wordEndPosition )) !


!ScintillaPane methods !
undoAll

    [self canUndo] whileTrue: [self undo]!   ! 
#('April 16, 2002' '10:50:43 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('undo/redo/save' undoAll )) !


!ScintillaPane methods !
highlightBrace: brace1 and: brace2

    self sendEditor: SCI_BRACEHIGHLIGHT with: brace1 with: brace2!    ! 
#('April 19, 2002' '12:27:16 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('brace highlighting' highlightBrace:and: )) !


!ScintillaPane methods !
autoCompleteList: strings

    autoCompleteList := (strings collect: [:string | string asString]) asSortedCollection! ! 
#('May 3, 2002' '03:32:21 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('auto complete' autoCompleteList: )) !


!ScintillaPane methods !  
isCallTipActive

    | result |
    result := self sendEditor: SCI_CALLTIPACTIVE.
    Transcript cr; << 'isCallTipActive='; << result.
    ^result ~~ 0!   ! 
#('May 3, 2002' '03:47:22 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('call tips' isCallTipActive )) !


!ScintillaPane methods !
isTextPane
        "Answer true if receiver is a kind of TextPane."
    ^true!    ! 
#('April 15, 2002' '01:04:33 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('querying' isTextPane )) !


!ScintillaPane methods !   
foregroundColor: aPoint
    | foreColor |
    foreColor := self colorAsLongRed: aPoint x green: aPoint y blue: aPoint z.
    ^self 
        sendEditor: SCI_STYLESETFORE with: false with: foreColor.!  ! 
#('April 25, 2005' '10:43:02 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('coloring' foregroundColor: )) !


!ScintillaPane methods ! 
foregroundColor: aPoint
    | foreColor |
    foreColor := self colorAsLongRed: aPoint x green: aPoint y blue: aPoint z.
    self 
        sendEditor: SCI_STYLESETFORE with: false with: foreColor.!   ! 
#('April 25, 2005' '10:43:17 AM' 1032000)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('coloring' foregroundColor: )) !


!ScintillaPane methods ! 
implementorsOfSelection

    | selector |
    selector := self selection trimBlanks.
    selector isEmpty ifTrue: [selector := self wordAtCursor].
    "(selector includes: $*) ifTrue: [CursorManager execute changeFor: [selector := self findWildcardSelector: selector]]."

    selector isNil ifTrue: [^self].
    
    selector := self findWildcardSelector: selector, '*'.
    (selector isNil or: [selector isEmpty]) ifTrue: [^self].
    self sourceManager implementorsOf: selector asSymbol.!   ! 
#('March 3, 2003' '10:57:27 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('development support' implementorsOfSelection )) !


!ScintillaPane methods !
showSelectionFrom: start to: end

    self nonTabbifiedSelectFrom: start to: end.
    self forceSelectionOntoDisplay!    ! 
#('April 18, 2002' '05:29:27 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('selection and clipboard handling' showSelectionFrom:to: )) !


!ScintillaPane methods !
redoAll

    [self canRedo] whileTrue: [self redo]!   ! 
#('April 16, 2002' '10:50:43 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('undo/redo/save' redoAll )) !


!ScintillaPane methods !
autoIndent

    | indent |
    indent := self previousIndent.
    self indentCurrentLine: indent!   ! 
#('April 19, 2002' '02:18:43 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('indenting' autoIndent )) !


!ScintillaPane methods !  
cancelAutoComplete

    self sendEditor: SCI_AUTOCCANCEL! ! 
#('May 3, 2002' '02:49:37 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('auto complete' cancelAutoComplete )) !


!ScintillaPane methods ! 
referencesOfSelection

    | name |
    name := self selection trimBlanks.
    name isEmpty ifTrue: [name := self wordAtCursor].
    name := name asSymbol.
    (Smalltalk includesKey: name)
        ifTrue: [Smalltalk sendersOf: (Smalltalk associationAt: name)]
        ifFalse: [MessageBox warning: name, ' is not a global variable.']! ! 
#('May 7, 2002' '09:54:49 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('development support' referencesOfSelection )) !


!ScintillaPane methods !
doAutoCompleteTryHarder

    CursorManager execute changeFor: [
        self doAutoCompleteWith: (self autoCompleteStringFrom: (Symbol privateSymbolTable asArray select: [:symbol | symbol notEmpty and: [symbol first isLowercase]]))]!    ! 
#('May 14, 2002' '11:06:10 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('auto complete' doAutoCompleteTryHarder )) !


!ScintillaPane methods !   
badBrace: bracePosition

    self sendEditor: SCI_BRACEBADLIGHT with: bracePosition!  ! 
#('April 19, 2002' '12:25:31 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('brace highlighting' badBrace: )) !


!ScintillaPane methods !  
canRedo

    ^(self sendEditor: SCI_CANREDO) == 1!    ! 
#('April 19, 2002' '12:12:27 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('undo/redo/save' canRedo )) !


!ScintillaPane methods !
configureAutocomplete

    self 
        sendEditor: SCI_AUTOCSETCHOOSESINGLE with: false;
        sendEditor: SCI_AUTOCSETIGNORECASE with: true;
        sendEditor: SCI_AUTOCSETDROPRESTOFWORD with: false;
        sendEditor: SCI_AUTOCSETSEPARATOR with: self autoCompleteSeparator asciiValue!  ! 
#('May 10, 2002' '09:47:24 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('configuring' configureAutocomplete )) !


!ScintillaPane methods !   
setBraceHighlightStyle

    | braceStyle badBraceStyle |
    braceStyle := 34. badBraceStyle := 35.

    self
        style: braceStyle foregroundColor: 98@98@255;
        style: braceStyle backgroundColor: 255@255@255;
        style: braceStyle bold: true;
        style: badBraceStyle foregroundColor: 255@98@98;
        style: badBraceStyle backgroundColor: 255@255@255;
        style: badBraceStyle bold: true!   ! 
#('July 17, 2002' '09:54:58 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('coloring' setBraceHighlightStyle )) !


!ScintillaPane methods !
restore

    self cancelAutoComplete; cancelCallTip.
    self undoAll.
    self triggerEvent: #needsContents!   ! 
#('May 3, 2002' '03:03:08 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('undo/redo/save' restore )) !


!ScintillaPane methods !   
wordStartPosition

    ^self sendEditor: SCI_WORDSTARTPOSITION with: self cursorPosition with: true!  ! 
#('April 19, 2002' '12:10:48 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('cursor positioning' wordStartPosition )) !


!ScintillaPane methods !  
doIt: aBlock

    | aString answer |
    self setEvaluate: true.
    (aString := self selection) isEmpty ifTrue: [self selectLineAtCurrentSelection. aString := self selection].
    answer := self expressionEvaluator evaluate: aString ifError: aBlock.
    ^answer!   ! 
#('April 19, 2002' '12:24:28 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('development support' doIt: )) !


!ScintillaPane methods ! 
modified
    ^modified!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('querying' modified )) !


!ScintillaPane methods !
insertAfterSelection: aString

    self sendEditor: SCI_INSERTTEXT buffer: aString with: self cursorPosition! ! 
#('October 24, 2002' '01:08:56 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('text handling' insertAfterSelection: )) !


!ScintillaPane methods ! 
queryClientRectangle

    | rectStruct |
    rectStruct := WinRectangle new.
    self isHandleOk
        ifTrue: [self dll getClientRect: self handle rect: rectStruct]
        ifFalse: [^self osError ].

    ^rectStruct!    ! 
#('April 15, 2002' '04:26:54 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('querying' queryClientRectangle )) !


!ScintillaPane methods ! 
redo

    self cancelAutoComplete; cancelCallTip.
    self sendEditor: SCI_REDO! ! 
#('May 3, 2002' '03:02:48 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('undo/redo/save' redo )) !


!ScintillaPane methods !  
cursorPosition

    ^self sendEditor: SCI_GETCURRENTPOS!  ! 
#('April 19, 2002' '12:06:30 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('cursor positioning' cursorPosition )) !


!ScintillaPane methods ! 
notifyDoubleClick: parameter

    self handleDoubleClick! ! 
#('April 16, 2002' '01:42:13 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('notifying' notifyDoubleClick: )) !


!ScintillaPane methods !  
findMatchingBracesAt: initialPosition do: aTwoArgumentBlock
    "look at the current position and at the previous position, so the cursor can be ahead or behind the brace."

    | character position matchingPosition |
    position := initialPosition.
    character := self characterAt: position.
    ('()[]' includes: character) ifTrue: [
        matchingPosition := self sendEditor: SCI_BRACEMATCH with: position.
        matchingPosition > -1 ifTrue: [^aTwoArgumentBlock value: position value: matchingPosition]].
    position := position - 1.
    character := self characterAt: position.
    ('()[]' includes: character) ifTrue: [
        ^aTwoArgumentBlock value: position value: (self sendEditor: SCI_BRACEMATCH with: position)].
    ^aTwoArgumentBlock value:INVALID_POSITION value: INVALID_POSITION!  ! 
#('April 19, 2002' '12:26:43 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('brace highlighting' findMatchingBracesAt:do: )) !


!ScintillaPane methods !   
expressionEvaluator: anExpressionEvaluator
        "Set the instance of ExpressionEvaluator (or subclass)
        which handles evaluations."
    anExpressionEvaluator pane: self.
    self propertyAt: #expressionEvaluator put: anExpressionEvaluator!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('text pane emulation' expressionEvaluator: )) !


!ScintillaPane methods ! 
handleCharAdded: character

    character = Character lf ifTrue: [^self autoIndent].
    character asciiValue = 22 "ctrl-shift-v" ifTrue: [self undo. ^self pasteFromHistory].
    (character = Character space or: [character = Character cr]) ifTrue: [self cancelCallTip. ^self triggerEvent: #needsAutoCompleteList].
    self showCurrentCallTip.!    ! 
#('May 3, 2002' '03:10:44 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('notifying' handleCharAdded: )) !


!ScintillaPane methods !   
lowShortFromLong: a

    ^self dll lowShortFromLong: a!   ! 
#('April 19, 2002' '11:29:21 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('private-dll interface' lowShortFromLong: )) !


!ScintillaPane methods !   
setSmalltalkWordCharacters

    | characters |
    characters := 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890_:'.
    self sendEditor: SCI_SETWORDCHARS buffer: characters!  ! 
#('April 19, 2002' '11:51:30 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('configuring' setSmalltalkWordCharacters )) !


!ScintillaPane methods !
wordPartRightExtend

    self sendEditor: SCI_WORDPARTRIGHTEXTEND!    ! 
#('April 19, 2002' '12:34:24 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('cursor positioning' wordPartRightExtend )) !


!ScintillaPane methods !
sendEditor: message buffer: aString

    ^self dll send: message to: self buffer: aString!    ! 
#('April 19, 2002' '11:33:56 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('private-dll interface' sendEditor:buffer: )) !


!ScintillaPane methods !  
length
    
    ^self sendEditor: SCI_GETLENGTH!  ! 
#('April 19, 2002' '05:24:39 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('text handling' length )) !


!ScintillaPane methods !  
doAutoComplete

    self triggerEvent: #needsAutoCompleteList.
    (self doAutoCompleteWith: (self autoCompleteStringFrom: autoCompleteList)) ifTrue: [^self].
    self doAutoCompleteTryHarder!    ! 
#('May 14, 2002' '11:12:48 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('auto complete' doAutoComplete )) !


!ScintillaPane methods !
setEvaluate: aBoolean
        "Private - specify whether a compilation for the receiver
        is evaluating an expression or compiling a method."
    self propertyAt: #evaluate put: aBoolean!    ! 
#('April 17, 2002' '04:42:22 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('development support' setEvaluate: )) !


!ScintillaPane methods !  
undo

    self cancelAutoComplete; cancelCallTip.
    self sendEditor: SCI_UNDO! ! 
#('May 3, 2002' '03:02:54 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('undo/redo/save' undo )) !


!ScintillaPane methods !  
backgroundColor: aPoint
    | backColor |
    backColor := self colorAsLongRed: aPoint x green: aPoint y blue: aPoint z.
    self 
        sendEditor: SCI_STYLESETBACK with: false with: backColor!    ! 
#('April 25, 2005' '10:42:34 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('coloring' backgroundColor: )) !


!ScintillaPane methods ! 
cancelCallTip

    usingCallTips ifFalse: [^self].
    callTip notNil ifTrue: [lastCallTip := callTip. callTip := nil].
    self sendEditor: SCI_CALLTIPCANCEL! ! 
#('May 3, 2002' '03:59:26 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('call tips' cancelCallTip )) !


!ScintillaPane methods !  
validate

    super validate.
    self
        setTextFont;
        disableDefaultPopUpMenu;
        setSmalltalkTabbing;
        setBraceHighlightStyle;
        setSelectionHighlightStyle;
        setSmalltalkWordCharacters;
        bindEditingKeys;
        removeMargins;
        configureAutocomplete.

    (self propertyAt: #storedInformation ifAbsent: [false]) ifFalse: [^self].
    self
        contents: (self propertyAt: #contents ifAbsent: ['']);
        modified: (self propertyAt: #modified ifAbsent: [false]);
        cursorPosition: (self propertyAt: #cursorPosition ifAbsent: [0]);
        anchorPosition: (self propertyAt: #anchorPosition ifAbsent: [0])!    ! 
#('June 19, 2002' '09:40:21 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('scheduling' validate )) !


!ScintillaPane methods !
notifySetFocus: parameter

    self gettingFocus.!    ! 
#('April 15, 2002' '02:02:10 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('notifying' notifySetFocus: )) !


!ScintillaPane methods ! 
autocompleteWordsFor: aClass

    | words currentClass |
    words := OrderedCollection new.
    words addAll: self class defaultAutocompleteEntries.
    aClass notNil ifTrue: [
        words addAll: (self class unshmooshSelectors: (aClass selectors)).
        aClass sharedPools do: [:pool | words addAll: (self sourceManager smalltalk at: pool) keys].
        currentClass := aClass.
        [currentClass notNil] whileTrue: [words addAll: currentClass instVarNames. currentClass := currentClass superclass]].
    ^words collect: [:word | word asString]!  ! 
#('March 16, 2003' '09:39:10 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('auto complete' autocompleteWordsFor: )) !


!ScintillaPane methods !   
selectAll

    self sendEditor: SCI_SELECTALL.
    self grabFocus!   ! 
#('April 19, 2002' '12:16:24 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('selection and clipboard handling' selectAll )) !


!ScintillaPane methods !
notifySavePointLeft: parameter

    self modified: true.! ! 
#('April 15, 2002' '01:52:45 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('notifying' notifySavePointLeft: )) !


!ScintillaPane methods !
printIt

    | result |
    result := self doIt: [^self].
    self insertAndSelectText: result printString at: (self cursorPosition max: self anchorPosition)!  ! 
#('May 3, 2002' '03:53:16 PM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('development support' printIt )) !


!ScintillaPane methods !  
evaluating

    ^self propertyAt: #evaluate ifAbsent: [false]!    ! 
#('April 18, 2002' '11:46:13 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('development support' evaluating )) !


!ScintillaPane methods !
insertAndSelectText: aString at: index

    | validIndex |
    validIndex := index min: self length.
    self insertText: aString at: validIndex.
    self anchorPosition: validIndex; cursorPosition: validIndex + aString size.! ! 
#('January 20, 2003' '10:53:25 AM' nil)!

(CodeFiler organizerFor: ScintillaPane) reorganizeFrom: #(
('selection and clipboard handling' insertAndSelectText:at: )) !


!ScintillaPane class methods !  
new

    ScintillaDLL current.   "Ensure the DLL is loaded before creating instances."
    ^super new!   ! 
#('April 16, 2002' '10:50:43 AM' nil)!

(CodeFiler organizerFor: ScintillaPane class) reorganizeFrom: #(
('instance creation' new )) !


!ScintillaPane class methods ! 
clipboardHistory

    ClipboardHistory isNil ifTrue: [ClipboardHistory := OrderedCollection new].
    ^ClipboardHistory! ! 
#('May 3, 2002' '11:06:28 AM' nil)!

(CodeFiler organizerFor: ScintillaPane class) reorganizeFrom: #(
('searching' clipboardHistory )) !


!ScintillaPane class methods !   
merge: aString intoHistory: aCollection

    (aCollection includes: aString) ifTrue: [aCollection remove: aString].

    aCollection addFirst: aString.
    aCollection size > self historySize ifTrue: [aCollection removeLast].! ! 
#('April 26, 2002' '12:20:05 PM' nil)!

(CodeFiler organizerFor: ScintillaPane class) reorganizeFrom: #(
('private' merge:intoHistory: )) !


!ScintillaPane class methods !
asNumber: aString

    (aString asLowercase includes: $x) ifFalse: [^aString asInteger].
    ^Compiler evaluate: '0', (aString copyFrom: (aString asLowercase indexOf: $x) + 1 to: aString size), 'r16'! ! 
#('April 12, 2002' '02:03:16 PM' nil)!

(CodeFiler organizerFor: ScintillaPane class) reorganizeFrom: #(
('notification' asNumber: )) !


!ScintillaPane class methods !
searchString!   ! 
#('April 18, 2002' '05:36:38 PM' nil)!

(CodeFiler organizerFor: ScintillaPane class) reorganizeFrom: #(
('private' searchString )) !


!ScintillaPane class methods !  
rememberSearchString: aString

    aString trimBlanks isEmpty ifTrue: [^self].
    self merge: aString intoHistory: self searchHistory!  ! 
#('May 3, 2002' '11:01:10 AM' nil)!

(CodeFiler organizerFor: ScintillaPane class) reorganizeFrom: #(
('searching' rememberSearchString: )) !


!ScintillaPane class methods !  
constructEventsTriggered
    "(self initializeEventsTriggered)"

    ^super constructEventsTriggered
        add: #aboutToSave;
        add: #saved;
        add: #needsContents;
        add: #needsAutoCompleteList;
        add: #controlTabbed;
        yourself!  ! 
#('May 3, 2002' '11:40:12 AM' nil)!

(CodeFiler organizerFor: ScintillaPane class) reorganizeFrom: #(
('events' constructEventsTriggered )) !


!ScintillaPane class methods !  
defaultAutocompleteEntries

    ^#(
        self super
        ifTrue: ifFalse: whileTrue: whileFalse:
        isNil notNil
        collect: select: reject: inject: into: detect: ifNone: includes: includesIdentical: includesKey:
        remove: removeAll add: addAll:
        ifAbsent: ifIdenticalAbsent:
        size occurrencesOf
        asArray asSortedCollection asOrderedCollection asSet removeIdenticals withoutNils
        printString asSymbol
        Transcript Array Dictionary OrderedCollection SortedCollection Junk).!   ! 
#('May 7, 2002' '09:54:49 AM' nil)!

(CodeFiler organizerFor: ScintillaPane class) reorganizeFrom: #(
('autocomplete' defaultAutocompleteEntries )) !


!ScintillaPane class methods !  
searchHistory

    SearchHistory isNil ifTrue: [SearchHistory := OrderedCollection new].
    ^SearchHistory! ! 
#('April 26, 2002' '12:17:46 PM' nil)!

(CodeFiler organizerFor: ScintillaPane class) reorganizeFrom: #(
('searching' searchHistory )) !


!ScintillaPane class methods !   
constructConstants
    "(self constructConstants)"

    | stream |
    Smalltalk at: #ScintillaConstants put: PoolDictionary new.
    stream := ReadStream on: self constantsText.
    [stream atEnd] whileFalse: [ScintillaConstants at: (stream upTo: Character space) asSymbol put: (self asNumber: stream nextLine)].
    ^ScintillaConstants!   ! 
#('April 12, 2002' '02:08:19 PM' nil)!

(CodeFiler organizerFor: ScintillaPane class) reorganizeFrom: #(
('notification' constructConstants )) !


!ScintillaPane class methods !   
replaceHistory

    ReplaceHistory isNil ifTrue: [ReplaceHistory := OrderedCollection new].
    ^ReplaceHistory! ! 
#('April 26, 2002' '12:18:02 PM' nil)!

(CodeFiler organizerFor: ScintillaPane class) reorganizeFrom: #(
('searching' replaceHistory )) !


!ScintillaPane class methods !  
unshmooshSelectors: selectors
    "Separate multi-keyword selectors into their components..."
    
    | selectorParts |
    selectorParts := OrderedCollection new.
    selectors do: [:selector | (selector includes: $:) ifTrue: [selectorParts addAll: selector keywords] ifFalse:[ selectorParts add: selector]].
    ^selectorParts!    ! 
#('April 25, 2002' '03:21:49 PM' nil)!

(CodeFiler organizerFor: ScintillaPane class) reorganizeFrom: #(
('autocomplete' unshmooshSelectors: )) !


!ScintillaPane class methods !  
constantsText

    ^'INVALID_POSITION -1
SCI_START 2000
SCI_OPTIONAL_START 3000
SCI_LEXER_START 4000
SCI_ADDTEXT 2001
SCI_ADDSTYLEDTEXT 2002
SCI_INSERTTEXT 2003
SCI_CLEARALL 2004
SCI_CLEARDOCUMENTSTYLE 2005
SCI_GETLENGTH 2006
SCI_GETCHARAT 2007
SCI_GETCURRENTPOS 2008
SCI_GETANCHOR 2009
SCI_GETSTYLEAT 2010
SCI_REDO 2011
SCI_SETUNDOCOLLECTION 2012
SCI_SELECTALL 2013
SCI_SETSAVEPOINT 2014
SCI_GETSTYLEDTEXT 2015
SCI_CANREDO 2016
SCI_MARKERLINEFROMHANDLE 2017
SCI_MARKERDELETEHANDLE 2018
SCI_GETUNDOCOLLECTION 2019
SCWS_INVISIBLE 0
SCWS_VISIBLEALWAYS 1
SCWS_VISIBLEAFTERINDENT 2
SCI_GETVIEWWS 2020
SCI_SETVIEWWS 2021
SCI_POSITIONFROMPOINT 2022
SCI_POSITIONFROMPOINTCLOSE 2023
SCI_GOTOLINE 2024
SCI_GOTOPOS 2025
SCI_SETANCHOR 2026
SCI_GETCURLINE 2027
SCI_GETENDSTYLED 2028
SC_EOL_CRLF 0
SC_EOL_CR 1
SC_EOL_LF 2
SCI_CONVERTEOLS 2029
SCI_GETEOLMODE 2030
SCI_SETEOLMODE 2031
SCI_STARTSTYLING 2032
SCI_SETSTYLING 2033
SCI_GETBUFFEREDDRAW 2034
SCI_SETBUFFEREDDRAW 2035
SCI_SETTABWIDTH 2036
SCI_GETTABWIDTH 2121
SC_CP_UTF8 65001
SCI_SETCODEPAGE 2037
SCI_SETUSEPALETTE 2039
MARKER_MAX 31
SC_MARK_CIRCLE 0
SC_MARK_ROUNDRECT 1
SC_MARK_ARROW 2
SC_MARK_SMALLRECT 3
SC_MARK_SHORTARROW 4
SC_MARK_EMPTY 5
SC_MARK_ARROWDOWN 6
SC_MARK_MINUS 7
SC_MARK_PLUS 8
SC_MARK_VLINE 9
SC_MARK_LCORNER 10
SC_MARK_TCORNER 11
SC_MARK_BOXPLUS 12
SC_MARK_BOXPLUSCONNECTED 13
SC_MARK_BOXMINUS 14
SC_MARK_BOXMINUSCONNECTED 15
SC_MARK_LCORNERCURVE 16
SC_MARK_TCORNERCURVE 17
SC_MARK_CIRCLEPLUS 18
SC_MARK_CIRCLEPLUSCONNECTED 19
SC_MARK_CIRCLEMINUS 20
SC_MARK_CIRCLEMINUSCONNECTED 21
SC_MARK_BACKGROUND 22
SC_MARK_CHARACTER 10000
SC_MARKNUM_FOLDEREND 25
SC_MARKNUM_FOLDEROPENMID 26
SC_MARKNUM_FOLDERMIDTAIL 27
SC_MARKNUM_FOLDERTAIL 28
SC_MARKNUM_FOLDERSUB 29
SC_MARKNUM_FOLDER 30
SC_MARKNUM_FOLDEROPEN 31
SC_MASK_FOLDERS 0xFE000000
SCI_MARKERDEFINE 2040
SCI_MARKERSETFORE 2041
SCI_MARKERSETBACK 2042
SCI_MARKERADD 2043
SCI_MARKERDELETE 2044
SCI_MARKERDELETEALL 2045
SCI_MARKERGET 2046
SCI_MARKERNEXT 2047
SCI_MARKERPREVIOUS 2048
SC_MARGIN_SYMBOL 0
SC_MARGIN_NUMBER 1
SCI_SETMARGINTYPEN 2240
SCI_GETMARGINTYPEN 2241
SCI_SETMARGINWIDTHN 2242
SCI_GETMARGINWIDTHN 2243
SCI_SETMARGINMASKN 2244
SCI_GETMARGINMASKN 2245
SCI_SETMARGINSENSITIVEN 2246
SCI_GETMARGINSENSITIVEN 2247
STYLE_DEFAULT 32
STYLE_LINENUMBER 33
STYLE_BRACELIGHT 34
STYLE_BRACEBAD 35
STYLE_CONTROLCHAR 36
STYLE_INDENTGUIDE 37
STYLE_LASTPREDEFINED 39
STYLE_MAX 127
SC_CHARSET_ANSI 0
SC_CHARSET_DEFAULT 1
SC_CHARSET_BALTIC 186
SC_CHARSET_CHINESEBIG5 136
SC_CHARSET_EASTEUROPE 238
SC_CHARSET_GB2312 134
SC_CHARSET_GREEK 161
SC_CHARSET_HANGUL 129
SC_CHARSET_MAC 77
SC_CHARSET_OEM 255
SC_CHARSET_RUSSIAN 204
SC_CHARSET_SHIFTJIS 128
SC_CHARSET_SYMBOL 2
SC_CHARSET_TURKISH 162
SC_CHARSET_JOHAB 130
SC_CHARSET_HEBREW 177
SC_CHARSET_ARABIC 178
SC_CHARSET_VIETNAMESE 163
SC_CHARSET_THAI 222
SCI_STYLECLEARALL 2050
SCI_STYLESETFORE 2051
SCI_STYLESETBACK 2052
SCI_STYLESETBOLD 2053
SCI_STYLESETITALIC 2054
SCI_STYLESETSIZE 2055
SCI_STYLESETFONT 2056
SCI_STYLESETEOLFILLED 2057
SCI_STYLERESETDEFAULT 2058
SCI_STYLESETUNDERLINE 2059
SC_CASE_MIXED 0
SC_CASE_UPPER 1
SC_CASE_LOWER 2
SCI_STYLESETCASE 2060
SCI_STYLESETCHARACTERSET 2066
SCI_SETSELFORE 2067
SCI_SETSELBACK 2068
SCI_SETCARETFORE 2069
SCI_ASSIGNCMDKEY 2070
SCI_CLEARCMDKEY 2071
SCI_CLEARALLCMDKEYS 2072
SCI_SETSTYLINGEX 2073
SCI_STYLESETVISIBLE 2074
SCI_GETCARETPERIOD 2075
SCI_SETCARETPERIOD 2076
SCI_SETWORDCHARS 2077
SCI_BEGINUNDOACTION 2078
SCI_ENDUNDOACTION 2079
INDIC_MAX 7
INDIC_PLAIN 0
INDIC_SQUIGGLE 1
INDIC_TT 2
INDIC_DIAGONAL 3
INDIC_STRIKE 4
INDIC0_MASK 0x20
INDIC1_MASK 0x40
INDIC2_MASK 0x80
INDICS_MASK 0xE0
SCI_INDICSETSTYLE 2080
SCI_INDICGETSTYLE 2081
SCI_INDICSETFORE 2082
SCI_INDICGETFORE 2083
SCI_SETSTYLEBITS 2090
SCI_GETSTYLEBITS 2091
SCI_SETLINESTATE 2092
SCI_GETLINESTATE 2093
SCI_GETMAXLINESTATE 2094
SCI_GETCARETLINEVISIBLE 2095
SCI_SETCARETLINEVISIBLE 2096
SCI_GETCARETLINEBACK 2097
SCI_SETCARETLINEBACK 2098
SCI_STYLESETCHANGEABLE 2099
SCI_AUTOCSHOW 2100
SCI_AUTOCCANCEL 2101
SCI_AUTOCACTIVE 2102
SCI_AUTOCPOSSTART 2103
SCI_AUTOCCOMPLETE 2104
SCI_AUTOCSTOPS 2105
SCI_AUTOCSETSEPARATOR 2106
SCI_AUTOCGETSEPARATOR 2107
SCI_AUTOCSELECT 2108
SCI_AUTOCSETCANCELATSTART 2110
SCI_AUTOCGETCANCELATSTART 2111
SCI_AUTOCSETFILLUPS 2112
SCI_AUTOCSETCHOOSESINGLE 2113
SCI_AUTOCGETCHOOSESINGLE 2114
SCI_AUTOCSETIGNORECASE 2115
SCI_AUTOCGETIGNORECASE 2116
SCI_USERLISTSHOW 2117
SCI_AUTOCSETAUTOHIDE 2118
SCI_AUTOCGETAUTOHIDE 2119
SCI_AUTOCSETDROPRESTOFWORD 2270
SCI_AUTOCGETDROPRESTOFWORD 2271
SCI_SETINDENT 2122
SCI_GETINDENT 2123
SCI_SETUSETABS 2124
SCI_GETUSETABS 2125
SCI_SETLINEINDENTATION 2126
SCI_GETLINEINDENTATION 2127
SCI_GETLINEINDENTPOSITION 2128
SCI_GETCOLUMN 2129
SCI_SETHSCROLLBAR 2130
SCI_GETHSCROLLBAR 2131
SCI_SETINDENTATIONGUIDES 2132
SCI_GETINDENTATIONGUIDES 2133
SCI_SETHIGHLIGHTGUIDE 2134
SCI_GETHIGHLIGHTGUIDE 2135
SCI_GETLINEENDPOSITION 2136
SCI_GETCODEPAGE 2137
SCI_GETCARETFORE 2138
SCI_GETUSEPALETTE 2139
SCI_GETREADONLY 2140
SCI_SETCURRENTPOS 2141
SCI_SETSELECTIONSTART 2142
SCI_GETSELECTIONSTART 2143
SCI_SETSELECTIONEND 2144
SCI_GETSELECTIONEND 2145
SCI_SETPRINTMAGNIFICATION 2146
SCI_GETPRINTMAGNIFICATION 2147
SC_PRINT_NORMAL 0
SC_PRINT_INVERTLIGHT 1
SC_PRINT_BLACKONWHITE 2
SC_PRINT_COLOURONWHITE 3
SC_PRINT_COLOURONWHITEDEFAULTBG 4
SCI_SETPRINTCOLOURMODE 2148
SCI_GETPRINTCOLOURMODE 2149
SCFIND_WHOLEWORD 2
SCFIND_MATCHCASE 4
SCFIND_WORDSTART 0x00100000
SCFIND_REGEXP 0x00200000
SCI_FINDTEXT 2150
SCI_FORMATRANGE 2151
SCI_GETFIRSTVISIBLELINE 2152
SCI_GETLINE 2153
SCI_GETLINECOUNT 2154
SCI_SETMARGINLEFT 2155
SCI_GETMARGINLEFT 2156
SCI_SETMARGINRIGHT 2157
SCI_GETMARGINRIGHT 2158
SCI_GETMODIFY 2159
SCI_SETSEL 2160
SCI_GETSELTEXT 2161
SCI_GETTEXTRANGE 2162
SCI_HIDESELECTION 2163
SCI_POINTXFROMPOSITION 2164
SCI_POINTYFROMPOSITION 2165
SCI_LINEFROMPOSITION 2166
SCI_POSITIONFROMLINE 2167
SCI_LINESCROLL 2168
SCI_SCROLLCARET 2169
SCI_REPLACESEL 2170
SCI_SETREADONLY 2171
SCI_NULL 2172
SCI_CANPASTE 2173
SCI_CANUNDO 2174
SCI_EMPTYUNDOBUFFER 2175
SCI_UNDO 2176
SCI_CUT 2177
SCI_COPY 2178
SCI_PASTE 2179
SCI_CLEAR 2180
SCI_SETTEXT 2181
SCI_GETTEXT 2182
SCI_GETTEXTLENGTH 2183
SCI_GETDIRECTFUNCTION 2184
SCI_GETDIRECTPOINTER 2185
SCI_SETOVERTYPE 2186
SCI_GETOVERTYPE 2187
SCI_SETCARETWIDTH 2188
SCI_GETCARETWIDTH 2189
SCI_SETTARGETSTART 2190
SCI_GETTARGETSTART 2191
SCI_SETTARGETEND 2192
SCI_GETTARGETEND 2193
SCI_REPLACETARGET 2194
SCI_REPLACETARGETRE 2195
SCI_SEARCHINTARGET 2197
SCI_SETSEARCHFLAGS 2198
SCI_GETSEARCHFLAGS 2199
SCI_CALLTIPSHOW 2200
SCI_CALLTIPCANCEL 2201
SCI_CALLTIPACTIVE 2202
SCI_CALLTIPPOSSTART 2203
SCI_CALLTIPSETHLT 2204
SCI_CALLTIPSETBACK 2205
SCI_VISIBLEFROMDOCLINE 2220
SCI_DOCLINEFROMVISIBLE 2221
SC_FOLDLEVELBASE 0x400
SC_FOLDLEVELWHITEFLAG 0x1000
SC_FOLDLEVELHEADERFLAG 0x2000
SC_FOLDLEVELNUMBERMASK 0x0FFF
SCI_SETFOLDLEVEL 2222
SCI_GETFOLDLEVEL 2223
SCI_GETLASTCHILD 2224
SCI_GETFOLDPARENT 2225
SCI_SHOWLINES 2226
SCI_HIDELINES 2227
SCI_GETLINEVISIBLE 2228
SCI_SETFOLDEXPANDED 2229
SCI_GETFOLDEXPANDED 2230
SCI_TOGGLEFOLD 2231
SCI_ENSUREVISIBLE 2232
SCI_SETFOLDFLAGS 2233
SCI_ENSUREVISIBLEENFORCEPOLICY 2234
SCI_SETTABINDENTS 2260
SCI_GETTABINDENTS 2261
SCI_SETBACKSPACEUNINDENTS 2262
SCI_GETBACKSPACEUNINDENTS 2263
SC_TIME_FOREVER 10000000
SCI_SETMOUSEDWELLTIME 2264
SCI_GETMOUSEDWELLTIME 2265
SCI_WORDSTARTPOSITION 2266
SCI_WORDENDPOSITION 2267
SC_WRAP_NONE 0
SC_WRAP_WORD 1
SCI_SETWRAPMODE 2268
SCI_GETWRAPMODE 2269
SC_CACHE_NONE 0
SC_CACHE_CARET 1
SC_CACHE_PAGE 2
SC_CACHE_DOCUMENT 3
SCI_SETLAYOUTCACHE 2272
SCI_GETLAYOUTCACHE 2273
SCI_LINEDOWN 2300
SCI_LINEDOWNEXTEND 2301
SCI_LINEUP 2302
SCI_LINEUPEXTEND 2303
SCI_CHARLEFT 2304
SCI_CHARLEFTEXTEND 2305
SCI_CHARRIGHT 2306
SCI_CHARRIGHTEXTEND 2307
SCI_WORDLEFT 2308
SCI_WORDLEFTEXTEND 2309
SCI_WORDRIGHT 2310
SCI_WORDRIGHTEXTEND 2311
SCI_HOME 2312
SCI_HOMEEXTEND 2313
SCI_LINEEND 2314
SCI_LINEENDEXTEND 2315
SCI_DOCUMENTSTART 2316
SCI_DOCUMENTSTARTEXTEND 2317
SCI_DOCUMENTEND 2318
SCI_DOCUMENTENDEXTEND 2319
SCI_PAGEUP 2320
SCI_PAGEUPEXTEND 2321
SCI_PAGEDOWN 2322
SCI_PAGEDOWNEXTEND 2323
SCI_EDITTOGGLEOVERTYPE 2324
SCI_CANCEL 2325
SCI_DELETEBACK 2326
SCI_TAB 2327
SCI_BACKTAB 2328
SCI_NEWLINE 2329
SCI_FORMFEED 2330
SCI_VCHOME 2331
SCI_VCHOMEEXTEND 2332
SCI_ZOOMIN 2333
SCI_ZOOMOUT 2334
SCI_DELWORDLEFT 2335
SCI_DELWORDRIGHT 2336
SCI_LINECUT 2337
SCI_LINEDELETE 2338
SCI_LINETRANSPOSE 2339
SCI_LOWERCASE 2340
SCI_UPPERCASE 2341
SCI_LINESCROLLDOWN 2342
SCI_LINESCROLLUP 2343
SCI_DELETEBACKNOTLINE 2344
SCI_MOVECARETINSIDEVIEW 2401
SCI_LINELENGTH 2350
SCI_BRACEHIGHLIGHT 2351
SCI_BRACEBADLIGHT 2352
SCI_BRACEMATCH 2353
SCI_GETVIEWEOL 2355
SCI_SETVIEWEOL 2356
SCI_GETDOCPOINTER 2357
SCI_SETDOCPOINTER 2358
SCI_SETMODEVENTMASK 2359
EDGE_NONE 0
EDGE_LINE 1
EDGE_BACKGROUND 2
SCI_GETEDGECOLUMN 2360
SCI_SETEDGECOLUMN 2361
SCI_GETEDGEMODE 2362
SCI_SETEDGEMODE 2363
SCI_GETEDGECOLOUR 2364
SCI_SETEDGECOLOUR 2365
SCI_SEARCHANCHOR 2366
SCI_SEARCHNEXT 2367
SCI_SEARCHPREV 2368
CARET_SLOP 0x01
CARET_CENTER 0x02
CARET_STRICT 0x04
CARET_XEVEN 0x08
CARET_XJUMPS 0x10
SCI_SETCARETPOLICY 2369
SCI_LINESONSCREEN 2370
SCI_USEPOPUP 2371
SCI_SELECTIONISRECTANGLE 2372
SCI_SETZOOM 2373
SCI_GETZOOM 2374
SCI_CREATEDOCUMENT 2375
SCI_ADDREFDOCUMENT 2376
SCI_RELEASEDOCUMENT 2377
SCI_GETMODEVENTMASK 2378
SCI_SETFOCUS 2380
SCI_GETFOCUS 2381
SCI_SETSTATUS 2382
SCI_GETSTATUS 2383
SCI_SETMOUSEDOWNCAPTURES 2384
SCI_GETMOUSEDOWNCAPTURES 2385
SC_CURSORNORMAL -1
SC_CURSORWAIT 3
SCI_SETCURSOR 2386
SCI_GETCURSOR 2387
SCI_SETCONTROLCHARSYMBOL 2388
SCI_GETCONTROLCHARSYMBOL 2389
SCI_WORDPARTLEFT 2390
SCI_WORDPARTLEFTEXTEND 2391
SCI_WORDPARTRIGHT 2392
SCI_WORDPARTRIGHTEXTEND 2393
VISIBLE_SLOP 0x01
VISIBLE_STRICT 0x04
SCI_SETVISIBLEPOLICY 2394
SCI_DELLINELEFT 2395
SCI_DELLINERIGHT 2396
SCI_SETXOFFSET 2397
SCI_GETXOFFSET 2398
SCI_GRABFOCUS 2400
SCI_STARTRECORD 3001
SCI_STOPRECORD 3002
SCI_SETLEXER 4001
SCI_GETLEXER 4002
SCI_COLOURISE 4003
SCI_SETPROPERTY 4004
SCI_SETKEYWORDS 4005
SCI_SETLEXERLANGUAGE 4006
SC_MOD_INSERTTEXT 0x1
SC_MOD_DELETETEXT 0x2
SC_MOD_CHANGESTYLE 0x4
SC_MOD_CHANGEFOLD 0x8
SC_PERFORMED_USER 0x10
SC_PERFORMED_UNDO 0x20
SC_PERFORMED_REDO 0x40
SC_LASTSTEPINUNDOREDO 0x100
SC_MOD_CHANGEMARKER 0x200
SC_MOD_BEFOREINSERT 0x400
SC_MOD_BEFOREDELETE 0x800
SC_MODEVENTMASKALL 0xF77
SCEN_CHANGE 768
SCEN_SETFOCUS 512
SCEN_KILLFOCUS 256
SCK_DOWN 300
SCK_UP 301
SCK_LEFT 302
SCK_RIGHT 303
SCK_HOME 304
SCK_END 305
SCK_PRIOR 306
SCK_NEXT 307
SCK_DELETE 308
SCK_INSERT 309
SCK_ESCAPE 7
SCK_BACK 8
SCK_TAB 9
SCK_RETURN 13
SCK_ADD 310
SCK_SUBTRACT 311
SCK_DIVIDE 312
SCMOD_SHIFT 1
SCMOD_CTRL 2
SCMOD_ALT 4
SCN_STYLENEEDED 2000
SCN_CHARADDED 2001
SCN_SAVEPOINTREACHED 2002
SCN_SAVEPOINTLEFT 2003
SCN_MODIFYATTEMPTRO 2004
SCN_KEY 2005
SCN_DOUBLECLICK 2006
SCN_UPDATEUI 2007
SCN_MODIFIED 2008
SCN_MACRORECORD 2009
SCN_MARGINCLICK 2010
SCN_NEEDSHOWN 2011
SCN_PAINTED 2013
SCN_USERLISTSELECTION 2014
SCN_URIDROPPED 2015
SCN_DWELLSTART 2016
SCN_DWELLEND 2017
SCI_GETCLIENTRECTANGLE 6969'!  ! 
#('April 18, 2002' '01:39:25 PM' nil)!

(CodeFiler organizerFor: ScintillaPane class) reorganizeFrom: #(
('notification' constantsText )) !


!ScintillaPane class methods !
rememberReplaceString: aString

    aString trimBlanks isEmpty ifTrue: [^self].
    self merge: aString intoHistory: self replaceHistory!    ! 
#('May 3, 2002' '11:02:03 AM' nil)!

(CodeFiler organizerFor: ScintillaPane class) reorganizeFrom: #(
('searching' rememberReplaceString: )) !


!ScintillaPane class methods ! 
historySize
    ^10!   ! 
#('April 26, 2002' '12:20:12 PM' nil)!

(CodeFiler organizerFor: ScintillaPane class) reorganizeFrom: #(
('private' historySize )) !


!ScintillaPane class methods !   
rememberClipboardString: aString

    aString trimBlanks isEmpty ifTrue: [^self].
    self merge: aString intoHistory: self clipboardHistory!    ! 
#('May 3, 2002' '11:06:04 AM' nil)!

(CodeFiler organizerFor: ScintillaPane class) reorganizeFrom: #(
('searching' rememberClipboardString: )) !


!ScintillaPane class methods !   
windowClass
        "Private - Answer the host system window class name of the receiver."

    ^'Scintilla'! ! 
#('April 16, 2002' '10:50:43 AM' nil)!

(CodeFiler organizerFor: ScintillaPane class) reorganizeFrom: #(
('private' windowClass )) !


!ScintillaPane class methods !   
autocompleteWordsFor: aClass

    | words currentClass |
    self obsolete.
    words := OrderedCollection new.
    words addAll: self defaultAutocompleteEntries.
    aClass notNil ifTrue: [
        words addAll: (self unshmooshSelectors: (aClass selectors)).
        aClass sharedPools do: [:pool | words addAll: (Smalltalk at: pool) keys].
        currentClass := aClass.
        [currentClass notNil] whileTrue: [words addAll: currentClass instVarNames. currentClass := currentClass superclass]].
    ^words collect: [:word | word asString]! ! 
#('March 16, 2003' '09:36:54 AM' nil)!

(CodeFiler organizerFor: ScintillaPane class) reorganizeFrom: #(
('autocomplete' autocompleteWordsFor: )) !


!ScintillaPane class methods !
searchString: aString!  ! 
#('April 18, 2002' '05:37:55 PM' nil)!

(CodeFiler organizerFor: ScintillaPane class) reorganizeFrom: #(
('private' searchString: )) !


!ScintillaPane class methods ! 
constructNotifications
    "(self initializeNotifications)"

    ^super constructNotifications copy
        at: SCN_CHARADDED put: #notifyCharAdded:;
        at: SCN_DOUBLECLICK put: #notifyDoubleClick:;
        at: SCEN_SETFOCUS put: #notifySetFocus:;
        at: SCEN_KILLFOCUS put: #notifyKillFocus:;
        at: SCN_SAVEPOINTREACHED put: #notifySavePointReached:;
        at: SCN_SAVEPOINTLEFT put: #notifySavePointLeft:;
        at: SCN_UPDATEUI put: #notifyUpdateUI:;
        yourself!  ! 
#('April 16, 2002' '02:46:37 PM' nil)!

(CodeFiler organizerFor: ScintillaPane class) reorganizeFrom: #(
('notification' constructNotifications )) !


 

PagedRangeControl subclass: #ScrollBar
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!



CompositePane subclass: #SexPane
  instanceVariableNames: 
    ' sex '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



GroupPane subclass: #SpinButton
  instanceVariableNames: 
    ' upDown entryField min max master value list '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



ControlPane subclass: #StaticPane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!

 

StaticPane subclass: #GroupBox
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!


EllipticSkinBox class instanceVariableNames: ''
  categories: #( )
  comment: ''!

!EllipticSkinBox class methods !   
constructEventsTriggered
    "PhoneSkin::Events Search on this for methods that make direct use of phone skin events..."
    "EllipticSkinBox initializeEventsTriggered"
    ^PhoneSkin allPhoneSkinEvents!  ! 
#('May 12, 2011' '09:25:03 AM' nil)!

(CodeFiler organizerFor: EllipticSkinBox class) reorganizeFrom: #(
('events handled' constructEventsTriggered )) !


!EllipticSkinBox class methods ! 
constructEventsTriggered
    "PhoneSkin::Events Search on this for methods that make direct use of phone skin events...; This method is in EllipticSkinBox class, category events handled."
    "EllipticSkinBox initializeEventsTriggered"
    ^PhoneSkin allPhoneSkinEvents!   ! 
#('May 12, 2011' '09:31:35 AM' 1068472)!

(CodeFiler organizerFor: EllipticSkinBox class) reorganizeFrom: #(
('events handled' constructEventsTriggered )) !


!EllipticSkinBox class methods ! 
constructEventsTriggered
    "This CLASS method is in EllipticSkinBox, category 'events handled'."
    "PhoneSkin::Events Search on this for methods that make direct use of phone skin events..."
    "EllipticSkinBox initializeEventsTriggered"
    ^PhoneSkin allPhoneSkinEvents!   ! 
#('May 12, 2011' '12:55:15 PM' 1068880)!

(CodeFiler organizerFor: EllipticSkinBox class) reorganizeFrom: #(
('events handled' constructEventsTriggered )) !


 

GroupBox subclass: #PARTSGroupPanePart
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  
RectangularSkinBox class instanceVariableNames: ''
  categories: #( )
  comment: ''!

!RectangularSkinBox class methods ! 
constructEventsTriggered
    "PhoneSkin::Events Search on this for methods that make direct use of phone skin events..."
    "RectangularSkinBox initializeEventsTriggered"
    ^PhoneSkin allPhoneSkinEvents!   ! 
#('May 12, 2011' '09:25:30 AM' nil)!

(CodeFiler organizerFor: RectangularSkinBox class) reorganizeFrom: #(
('events handled' constructEventsTriggered )) !


!RectangularSkinBox class methods !   
constructEventsTriggered
    "PhoneSkin::Events Search on this for methods that make direct use of phone skin events...; This method is in RectangularSkinBox class, category events handled."
    "RectangularSkinBox initializeEventsTriggered"
    ^PhoneSkin allPhoneSkinEvents! ! 
#('May 12, 2011' '09:32:38 AM' 1070148)!

(CodeFiler organizerFor: RectangularSkinBox class) reorganizeFrom: #(
('events handled' constructEventsTriggered )) !


!RectangularSkinBox class methods !   
constructEventsTriggered
    "This CLASS method is in RectangularSkinBox, category 'events handled'."
    "PhoneSkin::Events Search on this for methods that make direct use of phone skin events..."
    "RectangularSkinBox initializeEventsTriggered"
    ^PhoneSkin allPhoneSkinEvents! ! 
#('May 12, 2011' '12:55:46 PM' 1070568)!

(CodeFiler organizerFor: RectangularSkinBox class) reorganizeFrom: #(
('events handled' constructEventsTriggered )) !


  

StaticPane subclass: #StaticBox
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!

   

StaticPane subclass: #StaticGraphic
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!

   

StaticGraphic subclass: #PARTSStaticGraphicPart
  instanceVariableNames: ''
  classVariableNames: 
    ' StyleLabels StyleValues '
  poolDictionaries: 
    ' PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

StaticPane subclass: #StaticText
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!

  

StaticText subclass: #PARTSStaticTextPart
  instanceVariableNames: ''
  classVariableNames: 
    ' StyleLabels StyleValues '
  poolDictionaries: 
    ' PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



SubPane subclass: #StatusPane
  instanceVariableNames: 
    ' inset statusBoxes colors justified resizable helpText '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants SystemColorConstants SystemValueConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

ControlPane subclass: #StatusWindow
  instanceVariableNames: 
    ' innerParts minimumHeight '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants WinCommonControlConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

ObjectWindow subclass: #SystemWindow
  instanceVariableNames: ''
  classVariableNames: 
    ' WmStcallback '
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Windows-Views' )
  comment: ''!

 

ControlPane subclass: #TabControl
  instanceVariableNames: 
    ' items imageList '
  classVariableNames: 
    ' InputCommands '
  poolDictionaries: 
    ' OperatingSystemConstants VirtualKeyConstants WinCommonControlConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

TabControl subclass: #PARTSTabControlPart
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

EntryField subclass: #TextEdit
  instanceVariableNames: 
    ' wrap '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!

 

TextEdit subclass: #SpinButtonEntryField
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



SubPane subclass: #TextPane
  instanceVariableNames: 
    ' textHolder selection changedArea modified priorSelection priorText newSelection '
  classVariableNames: 
    ' CaseSensitive Forward LeftBrackets NewString PriorCommand RightBrackets SearchString UndoBuffer '
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants VirtualKeyConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!

!TextPane methods !   
beginFind

    ^self findReplace! ! 
#('April 26, 2002' '11:36:31 AM' nil)!

(CodeFiler organizerFor: TextPane) reorganizeFrom: #(
('extensions' beginFind )) !


!TextPane methods !
findWildcardSelector: wildPattern
    "wildPattern        <String>
    Return the name of the selector specified by wildPattern, which includes the wildcard character.
    If the wildPattern is just *, however, answer * because the user probably means it literally.
    ** will answer all of the selectors in Smalltalk, and is not used as a selector anywhere (yet) anyways."

    | candidates selector pattern |

    wildPattern = '*'
        ifTrue: [^wildPattern].
    pattern := Pattern new: wildPattern.
    candidates := Set new: 100.
    SourceManager current getSourceClasses do: [:aClass |
        aClass selectors do: [:each |
            (pattern matches: each)
                ifTrue: [candidates add: each]].
        aClass class selectors do: [:each |
            (pattern matches: each)
                ifTrue: [candidates add: each]]].

    candidates isEmpty ifTrue: [
        MessageBox message: 'No matching selectors'.
        ^nil].

    candidates size = 1
        ifTrue: [^candidates any].

    selector := (ChooseOneDialog new openOn: candidates asSortedCollection label: 'Choose a Selector').
    (selector notNil and: [selector isEmpty]) ifTrue: [selector := nil].
    ^selector!  ! 
#('October 21, 2002' '05:51:25 PM' nil)!

(CodeFiler organizerFor: TextPane) reorganizeFrom: #(
('extensions' findWildcardSelector: )) !


!TextPane methods !  
sendersOfSelection

    | selector |
    selector := self selectedItem trimBlanks.
    (selector includes: $*) ifTrue: [
        CursorManager execute changeFor: [selector := self findWildcardSelector: selector]].

    selector notNil ifTrue: [
        SourceManager current sendersOf: selector asSymbol ifNone: [
            selector := self findWildcardSelector: selector, '*'.
            selector isNil ifTrue: [^self].
            SourceManager current sendersOf: selector asSymbol]]!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: TextPane) reorganizeFrom: #(
('extensions' sendersOfSelection )) !


!TextPane methods !  
beginReplace

    ^self findReplace!  ! 
#('April 26, 2002' '11:36:46 AM' nil)!

(CodeFiler organizerFor: TextPane) reorganizeFrom: #(
('extensions' beginReplace )) !


!TextPane methods ! 
tabKeyInput: aKeyboardInputEvent
        "Private - Respond to the tab keystroke."
    aKeyboardInputEvent isControlKeyDown ifFalse: [ ^nil ].
    self triggerEvent: #controlTabbed
        ifNotHandled: [
            aKeyboardInputEvent isShiftKeyDown
                ifTrue: [
                    [( self tabScope previousTabStop: self ) setFocus ]
                        on: Error
                        do: [ :e | ^self  "Stack overflow because no valid tab stop " ] ]
                ifFalse:  [
                    [( self tabScope nextTabStop: self ) setFocus ]
                        on: Error do: [ :e | ^self ] ] ]! ! 
#('April 18, 2002' '04:30:05 PM' nil)!

(CodeFiler organizerFor: TextPane) reorganizeFrom: #(
('no category methods' tabKeyInput: )) !


!TextPane methods !
restore
        "Restore the contents of the receiver to the previously set
        contents."

    UndoBuffer := self contents.
    self cancel!  ! 
#('May 16, 2001' '11:44:49 AM' nil)!

(CodeFiler organizerFor: TextPane) reorganizeFrom: #(
('no category methods' restore )) !


!TextPane methods !   
implementorsOfSelection

    | selector |

    selector := self selectedItem trimBlanks.
    (selector includes: $*) ifTrue: [
        CursorManager execute changeFor: [selector := self findWildcardSelector: selector]].

    selector notNil ifTrue: [
        SourceManager current implementorsOf: selector asSymbol ifNone: [
            selector := self findWildcardSelector: selector, '*'.
            selector isNil ifTrue: [^self].
            SourceManager current implementorsOf: selector asSymbol]]!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: TextPane) reorganizeFrom: #(
('extensions' implementorsOfSelection )) !


!TextPane methods ! 
popupMenu
        "Private - Answer the popup Menu for the receiver."
    | m otherMenu editMenu smalltalkMenu editTitle |
    m := super popupMenu.
    m isNil
        ifTrue: [
            m := Menu new
                appendItem: 'Cu\ut' replaceEscapeCharacters selector: #cutSelection ;
                appendItem: '\uCopy' replaceEscapeCharacters selector: #copySelection;
                appendItem: '\uPaste' replaceEscapeCharacters selector: #pasteSelection.
            Smalltalk isRunTime ifFalse: [
                m
                    appendSeparator ;
                    appendItem: '\uDo It' replaceEscapeCharacters selector: #doIt;
                    appendItem: '\uShow It' replaceEscapeCharacters selector: #printIt;
                    appendItem: '\uInspect It' replaceEscapeCharacters selector: #inspectIt;
                    appendSeparator;
                    appendItem: 'Senders' selector: #sendersOfSelection;
                    appendItem: 'Implementors' selector: #implementorsOfSelection;
                    appendItem: 'References' selector: #referencesOfSelection].

            m
                appendSeparator ;
                appendItem: '\uSave' replaceEscapeCharacters selector: #accept ;
                appendItem: 'A\ugain' replaceEscapeCharacters selector: #again.

            "retrieve the Edit/Smalltalk menus from the main window's window policy"
            editMenu := [ self mainWindow windowPolicy class editMenu ]
                on: MessageNotUnderstood do: [ nil ].
            editMenu notNil ifTrue: [ m appendSubMenu: ( editMenu allOwners: self ) ].
            Smalltalk isRunTime ifFalse: [
                smalltalkMenu := [ self mainWindow windowPolicy class smalltalkMenu: true ]
                    on: MessageNotUnderstood do: [ nil ].
                smalltalkMenu notNil ifTrue: [ m appendSubMenu: ( smalltalkMenu allOwners: self mainWindow owner ) ] ].

            m owner: self;
                title: 'TextPanePopup' ]
        ifFalse: [
            " if the popup is not the Edit menu, return it "
            editTitle := '\uEdit' replaceEscapeCharacters.
            ( m title ~= editTitle and: [ ( m isThere: editTitle ) not ] ) ifTrue: [ ^m ].

            editMenu :=
                ( m title = editTitle )
                    ifTrue: [ m ] "The entire popup is the edit menu."
                    ifFalse: [ m subMenuTitled: editTitle ] ]. "popup has a edit subitem."

        " copy popup menu attributes for File menu "
        m getIndex: #accept ifAbsent: [^m]. "Check to be sure the item is there."
        ( otherMenu := self mainWindow menuTitled: '\uFile' replaceEscapeCharacters ) isNil
            ifFalse: [ m copyItemAttributes: #accept from: otherMenu ].

        " copy popup menu attributes for Edit menu "

        ( otherMenu := self mainWindow menuTitled: '\uEdit' replaceEscapeCharacters ) isNil
            ifFalse: [
                otherMenu owner initMenu.
                ( Array with: m with: editMenu ) do: [ :mm |
                    mm copyItemAttributes: #copySelection from: otherMenu;
                        copyItemAttributes: #cutSelection from: otherMenu;
                        copyItemAttributes: #pasteSelection from: otherMenu ].
                "editMenu copyItemAttributes: #clearSelection from: otherMenu" ].

    ^self popupFromMenu: m!  ! 
#('April 26, 2002' '11:18:53 AM' nil)!

(CodeFiler organizerFor: TextPane) reorganizeFrom: #(
('no category methods' popupMenu )) !


!TextPane methods !   
referencesOfSelection

    | name |
    name := self selectedItem trimBlanks asSymbol.
    (Smalltalk includesKey: name)
        ifTrue: [SourceManager current sendersOf: (Smalltalk associationAt: name)]
        ifFalse: [MessageBox warning: name, ' is not a global variable.']!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: TextPane) reorganizeFrom: #(
('extensions' referencesOfSelection )) !


  

TextEdit subclass: #TextPaneControl
  instanceVariableNames: ''
  classVariableNames: 
    ' CaseSensitive Forward LeftBrackets NewString PriorCommand RightBrackets SearchString '
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants VirtualKeyConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!



TextPaneControl subclass: #PARTSTextPanePart
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants PARTSConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

TextPaneControl subclass: #RichEdit
  instanceVariableNames: 
    ' cookies '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants WinCommonControlConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

Button subclass: #Toggle
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!

!Toggle methods ! 
setValue
        "Private - Set the check state of the receiver to value."
    UserLibrary
        sendMessage: handle
        msg: BmSetcheck
        wparam: value asParameter
        lparam: nil! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: Toggle) reorganizeFrom: #(
('no category methods' setValue )) !




Toggle subclass: #CheckBox
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!



CheckBox subclass: #PARTSCheckBoxPart
  instanceVariableNames: ''
  classVariableNames: 
    ' SupportsLabelLeftOfButton '
  poolDictionaries: 
    ' PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

Toggle subclass: #RadioButton
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!

 

RadioButton subclass: #PARTSRadioButtonPart
  instanceVariableNames: ''
  classVariableNames: 
    ' SupportsLabelLeftOfButton '
  poolDictionaries: 
    ' PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



CheckBox subclass: #ThreeStateButton
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Windows-SubPanes' )
  comment: ''!

  

ControlPane subclass: #Toolbar
  instanceVariableNames: 
    ' tools toolWidth toolHeight bitmapHeight bitmapWidth toolIDs registrationKeyName registrationValueName autoSave '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants WinCommonControlConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



GroupPane subclass: #ToolPane
  instanceVariableNames: 
    ' buttonState clickState buttonPressed tools colors toolsBitmap '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants SystemColorConstants SystemValueConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

ToolPane subclass: #PARTSToolPane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

ControlWindow subclass: #ToolTip
  instanceVariableNames: 
    ' tools '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants WinCommonControlConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

ApplicationWindow subclass: #TopPane
  instanceVariableNames: 
    ' handlers framingBlock '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Windows-Views' )
  comment: ''!



TopPane subclass: #DialogTopPane
  instanceVariableNames: 
    ' sem '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants '
  categories: #( 'Windows-Views' )
  comment: ''!

   

DialogTopPane subclass: #PARTSDialogTopPane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

DialogTopPane subclass: #PARTSPrebuiltDialogTopPane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

TopPane subclass: #PARTSTopPane
  instanceVariableNames: ''
  classVariableNames: 
    ' ExitOnLastWindow '
  poolDictionaries: 
    ' PARTSConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSTopPane subclass: #PARTSWindowPart
  instanceVariableNames: ''
  classVariableNames: 
    ' SystemMenuLabel '
  poolDictionaries: 
    ' PARTSConstants SystemValueConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSWindowPart subclass: #PARTSDialogWindowPart
  instanceVariableNames: 
    ' suspendProcessSemaphore '
  classVariableNames: 
    ' DefaultFrameStyle '
  poolDictionaries: 
    ' CharacterConstants PARTSConstants SystemValueConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



PagedRangeControl subclass: #TrackBar
  instanceVariableNames: 
    ' ticks '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants VirtualKeyConstants WinCommonControlConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

ControlPane subclass: #TreeView
  instanceVariableNames: 
    ' items imageList handleItemMap itemHandleMap '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants VirtualKeyConstants WinCommonControlConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

RangeControl subclass: #UpDown
  instanceVariableNames: 
    ' buddy '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants WinCommonControlConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

SubPane subclass: #VideoPane
  instanceVariableNames: 
    ' video stretch '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

ComboBox subclass: #WBComboBox
  instanceVariableNames: 
    ' fullList disabled isListVisible isListSizeDynamic '
  classVariableNames: 
    ' IsListSizeDynamicDefault '
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

ComboEntryField subclass: #WBComboEntryField
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



CompositePane subclass: #WBCompositePaneScratchWindow
  instanceVariableNames: 
    ' model '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



CompositePane subclass: #WBDefaultCompositePaneScratchWindow
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  
WBDevelopmentCompositePane class instanceVariableNames: ''
  categories: #( )
  comment: ''!



TopPane subclass: #WBDialogTopPane
  instanceVariableNames: 
    ' sem dialogOwner '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

DrawnButton subclass: #WBDrawnButton
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

EntryField subclass: #WBEntryField
  instanceVariableNames: 
    ' justSet '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBDevelopmentSubPane subclass: #WBFramerExample
  instanceVariableNames: 
    ' frameRect paneRect extent '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  
WBGroupBox class instanceVariableNames: ''
  categories: #( )
  comment: ''!


WBHorizontalScrollBar class instanceVariableNames: ''
  categories: #( )
  comment: ''!

 

EntryField subclass: #WBKeyEntryField
  instanceVariableNames: 
    ' accelerator '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

GroupPane subclass: #WBLayoutForm
  instanceVariableNames: 
    ' selections handles redrawMovingWidget dragOutline cursorOffset bandRect currentNib cursorSelectPoint allowMove motionState releaseState popupMenu loadedWidgets cursors minSize maxSize duplicateOffset duplicateWidgets directEditor showOrder targetIsFirst useFence useDirectSelect shellHandles drawingBitmap '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

ListBox subclass: #WBListBox
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

EntryField subclass: #WBListEntryField
  instanceVariableNames: 
    ' owningListBox '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants VirtualKeyConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



WBDevelopmentCompositePane subclass: #WBPoolEditorCompositePane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



WBPoolEditorCompositePane subclass: #WBBitmapEditorCompositePane
  instanceVariableNames: 
    ' bitmapPane editBitmapButton editButtonButton sizeButton sizePane sameBitmapButton '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants WBDevelopmentBitmaps '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBPoolEditorCompositePane subclass: #WBFontEditorCompositePane
  instanceVariableNames: 
    ' nameField nameLabel styleField styleLabel sizeField sizeLabel strikeOutCheckBox italicCheckBox boldCheckBox underscoreCheckBox fixedWidthCheckBox selectButton sampleTextEdit sampleGroupBox '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBPoolEditorCompositePane subclass: #WBNLSEditorCompositePane
  instanceVariableNames: 
    ' categoryEditLabel categoryEditField keyEditLabel keyEditField valueEditLabel valueEditField '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBDevelopmentSubPane subclass: #WBScrollingPane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

DrawnButton subclass: #WBStaticGraphic
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants GraphicsConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBLayoutForm subclass: #WBTabOrderLayoutForm
  instanceVariableNames: 
    ' widgets soloWidgets groups dragWidget largeFont smallFont '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

SubPane subclass: #WBToolPalette
  instanceVariableNames: 
    ' selection size cellSize tpStyle elements cacheRedraw cachedElements useSystem '
  classVariableNames: 
    ' AutoScale '
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

!WBToolPalette methods !
button1Down: aPoint
        "Private - left button was pressed"
    | index |

    ( self isLocalDragSource and: [ self isDragButton: 1 ] )
        ifTrue: [ self dragOnMove: true location: aPoint ].

    index := self highlight: selection.
    self event: #gettingFocus.
    self captureMouseInput.
    Notifier consumeInputUntil: [:event |
        index := self highlight: index.
        #osiHack.
        "Code for drag/drop from tool bar."
        event selector = #button1Move: ifTrue: [
            ( self isLocalDragSource
                and: [ self dragOnMove
                    and: [ self isDragSourceInitiation: event arguments first ] ] )
                        ifTrue: [
                            "self clearMouseCapture."
                            self unHighlightBitmap: index.
                            ^self ] ].
        (event notNil and: [ event selector == #button1Up: ])
    ].
    self clearMouseCapture.

    (self isEnabled: index) ifTrue: [
        selection := index.
        self isPreAutomatic ifTrue: [self unHighlightBitmap: selection].
        self generateEventFor: selection.
        self eventFor: selection.
        self event: #select. "Obsolete"
        self triggerEvent: #clicked: with: self selector.
        self isPostAutomatic ifTrue: [self unHighlightBitmap: selection].
        self isAutomatic ifTrue: [ selection := nil ].
    ] ifFalse: [
        self highlightBitmap: selection.
    ].!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: WBToolPalette) reorganizeFrom: #(
('no category methods' button1Down: )) !


 

WBToolPalette subclass: #WBMultiToolPalette
  instanceVariableNames: 
    ' pages '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBToolPalette subclass: #WBToolBar
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

!WBToolBar methods !
highlightProgrammatically: key

    | index |
    index := key isSymbol ifTrue: [self elementAtSelector: key] ifFalse: [key].

    (self isEnabled: index) ifFalse: [^self].
    self unHighlightBitmap: selection.
    self highlightBitmap: index.
    selection := index.
    self event: #selecting. "Obsolete"
    self triggerEvent: #selecting: with: (self selectorAt: index).
    self isPreAutomatic | self isPostAutomatic ifTrue: [
        self displayKey: index.
        Time delayFor: 75.
        self unHighlightBitmap: selection.
        selection := nil].
    ^index!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: WBToolBar) reorganizeFrom: #(
('extensions' highlightProgrammatically: )) !




TopPane subclass: #WBTopPane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

ListBox subclass: #WBTreeListBox
  instanceVariableNames: 
    ' noSelect owningEditBox previousSelection cachedFlatList '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   
WBVerticalScrollBar class instanceVariableNames: ''
  categories: #( )
  comment: ''!

   

WBDevelopmentWindow subclass: #WindowBuilder
  instanceVariableNames: 
    ' prototype geometryManager undoManager scrollingForm currentLayoutForm name instVar styleEditor status sizeButton positionButton toolBar attributeBar groups entries outboards dirty editPalette cleanedOutCode customSubMenu editedClass titleText styleText titleEditor when perform thePane currentWhen sizePane positionPane '
  classVariableNames: 
    ' CustomPanes DevBitmapFileName EditorClass Extras HelpDict Properties Scrapbook ToolbarTool UserBitmapFileName WBClasses WBClipboard WBIcon '
  poolDictionaries: 
    ' CharacterConstants ColorConstants CommonDialogConstants OperatingSystemConstants VirtualKeyConstants WBDevelopmentBitmaps '
  categories: #( 'PARTS and Others' )
  comment: ''!



ViewManager subclass: #WindowDialog
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Windows-Dialogs' )
  comment: ''!



WindowDialog subclass: #AboutDialog
  instanceVariableNames: 
    ' bitmap '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Windows-Dialogs' )
  comment: ''!

  

WindowDialog subclass: #ChooseOneDialog
  instanceVariableNames: 
    ' selection contents listPane '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Windows-Dialogs' )
  comment: ''!

!ChooseOneDialog methods !   
openOn: aCollection label: aString selection: anObject

    self labelWithoutPrefix: aString.
    contents := aCollection.
    self createPanes; selection: anObject.
    ^self open!  ! 
#('May 28, 2004' '08:51:40 AM' nil)!

(CodeFiler organizerFor: ChooseOneDialog) reorganizeFrom: #(
('private' openOn:label:selection: )) !


!ChooseOneDialog methods ! 
openOn: aCollection label: aString selection: anObject

    self labelWithoutPrefix: aString.
    contents := aCollection.
    self selection: anObject.
    self createPanes.
    ^self open!    ! 
#('May 28, 2004' '08:51:40 AM' 1100268)!

(CodeFiler organizerFor: ChooseOneDialog) reorganizeFrom: #(
('private' openOn:label:selection: )) !


!ChooseOneDialog methods ! 
open
    "open a dialog to let the user choose one string of many.
     aCollection may contain strings or symbols."

    self openWindow.
    ^self selection!    ! 
#('May 8, 2002' '02:12:58 PM' nil)!

(CodeFiler organizerFor: ChooseOneDialog) reorganizeFrom: #(
('private' open )) !


!ChooseOneDialog methods ! 
initialize

    super initialize.
    contents := Array new.
    selection := Array new.!   ! 
#('May 8, 2002' '02:12:58 PM' nil)!

(CodeFiler organizerFor: ChooseOneDialog) reorganizeFrom: #(
('private' initialize )) !


!ChooseOneDialog methods !   
addListBox
        "private - Add the listbox to the receiver"

    | charSize lineHeight |
    charSize := WindowDialog unitMultiplier.
    lineHeight := charSize y.
    self addSubpane: ((listPane := ListBox new)
        owner: self;
        contents: contents;
        when: #needsContents send: #choices: to: self with: listPane;
        when: #changed: send: #setSelectedItem: to: self with: listPane;
        when: #doubleClicked: send: #selectedItem: to: self with: listPane;
        framingBlock:   [:box | (box leftTop
            rightAndDown: (5@2) * charSize)
            extentFromLeftTop: (65 @ 13) * charSize]).!   ! 
#('February 12, 2003' '10:34:10 AM' nil)!

(CodeFiler organizerFor: ChooseOneDialog) reorganizeFrom: #(
('private' addListBox )) !


!ChooseOneDialog methods ! 
addListBox
        "private - Add the listbox to the receiver"

    | charSize lineHeight |
    charSize := WindowDialog unitMultiplier.
    lineHeight := charSize y.
    self addSubpane: ((listPane := ListBox new)
        owner: self;
        contents: contents;
        selection: selection;
        when: #needsContents send: #choices: to: self with: listPane;
        when: #changed: send: #setSelectedItem: to: self with: listPane;
        when: #doubleClicked: send: #selectedItem: to: self with: listPane;
        framingBlock:   [:box | (box leftTop
            rightAndDown: (5@2) * charSize)
            extentFromLeftTop: (65 @ 13) * charSize]).!    ! 
#('May 28, 2004' '08:51:40 AM' 1101612)!

(CodeFiler organizerFor: ChooseOneDialog) reorganizeFrom: #(
('private' addListBox )) !


!ChooseOneDialog methods !  
initWindowSize
        "private - return the default size of a ChooseOneDialog"

    ^75 @ 20 * WindowDialog unitMultiplier.!    ! 
#('February 12, 2003' '10:33:39 AM' nil)!

(CodeFiler organizerFor: ChooseOneDialog) reorganizeFrom: #(
('private' initWindowSize )) !


!ChooseOneDialog methods ! 
openOn: aCollection label: aString

    self labelWithoutPrefix: aString.
    contents := aCollection.
    self createPanes.
    ^self open!   ! 
#('May 8, 2002' '02:12:58 PM' nil)!

(CodeFiler organizerFor: ChooseOneDialog) reorganizeFrom: #(
('private' openOn:label: )) !


!ChooseOneDialog methods !
createPanes

    | charSize lineHeight thisPane |
    charSize := WindowDialog unitMultiplier.
    lineHeight := charSize y.

    self addListBox.
    self addSubpane: ((thisPane := Button new)
        owner: self;
        defaultPushButton;
        contents: 'Ok';
        when: #clicked send: #ok: to: self with: thisPane;
        framingBlock: [:box | (box leftTop rightAndDown: (22@16) * charSize) extentFromLeftTop: (7@2) * charSize]).

    self addSubpane: ((thisPane := Button new)
        owner: self;
        contents: 'Cancel';
        when: #clicked send: #cancel: to: self with: thisPane;
        framingBlock:   [:box | (box leftTop rightAndDown: (43@16) * charSize) extentFromLeftTop: (7@2) * charSize]).!   ! 
#('February 12, 2003' '10:36:28 AM' nil)!

(CodeFiler organizerFor: ChooseOneDialog) reorganizeFrom: #(
('private' createPanes )) !


!ChooseOneDialog methods !
ok: aButton
        "private -- The OK button was pressed; it a selection
        has been made, close the window, otherwise beep in
        frustration"

    self selection isNil ifTrue:    [Terminal bell] ifFalse:  [
    self selection isEmpty ifTrue: [self selection: nil. self close] ifFalse: [
    "otherwise" self close]].!    ! 
#('July 18, 2002' '02:15:07 PM' nil)!

(CodeFiler organizerFor: ChooseOneDialog) reorganizeFrom: #(
('private' ok: )) !


!ChooseOneDialog methods !
on: aCollection label: aString

    self labelWithoutPrefix: aString.
    contents := aCollection.
    self createPanes.!   ! 
#('May 8, 2002' '02:12:58 PM' nil)!

(CodeFiler organizerFor: ChooseOneDialog) reorganizeFrom: #(
('private' on:label: )) !


  

ChooseOneDialog subclass: #ChooseManyDialog
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Windows-Dialogs' )
  comment: ''!

!ChooseManyDialog methods ! 
selection: aCollection
        "private - set the selection to be an array of the selected choices
        from the contents array"

    aCollection isNil ifTrue: [
        ^selection := nil
    ].

    selection := Array new: aCollection size.
    1 to: aCollection size do:   [:anIndex |
        selection at: anIndex put: (contents at: (aCollection at: anIndex))
    ].!    ! 
#('May 17, 2002' '11:52:53 AM' nil)!

(CodeFiler organizerFor: ChooseManyDialog) reorganizeFrom: #(
('private' selection: )) !


!ChooseManyDialog methods !
addListBox
        "private - Add the listbox to the receiver, in this case, a multipleSelectListBox"

    | charSize lineHeight |
    charSize := WindowDialog unitMultiplier.
    lineHeight := charSize y.

    self addSubpane: ((listPane := MultipleSelectListBox new)
        owner: self;
        extendedSelect;
        contents: contents;
        when: #needsContents send: #choices: to: self with: listPane;
        when: #changed: send: #select: to: self with: listPane;
        when: #doubleClicked: send: #returnSelection: to: self with: listPane;
        framingBlock:   [:box | (box leftTop rightAndDown: (5@2) * charSize) extentFromLeftTop: (25 @ 13) * charSize]).!   ! 
#('May 8, 2002' '02:12:58 PM' nil)!

(CodeFiler organizerFor: ChooseManyDialog) reorganizeFrom: #(
('private' addListBox )) !


!ChooseManyDialog methods ! 
addListBox
        "private - Add the listbox to the receiver, in this case, a multipleSelectListBox"

    | charSize lineHeight |
    charSize := WindowDialog unitMultiplier.
    lineHeight := charSize y.

    self addSubpane: ((listPane := MultipleSelectListBox new)
        owner: self;
        extendedSelect;
        contents: contents;
        listFont: ListFont;
        when: #needsContents send: #choices: to: self with: listPane;
        when: #changed: send: #select: to: self with: listPane;
        when: #doubleClicked: send: #returnSelection: to: self with: listPane;
        framingBlock:   [:box | (box leftTop rightAndDown: (5@2) * charSize) extentFromLeftTop: (25 @ 13) * charSize]).!  ! 
#('October 16, 2003' '10:55:03 AM' 1106348)!

(CodeFiler organizerFor: ChooseManyDialog) reorganizeFrom: #(
('private' addListBox )) !


!ChooseManyDialog methods !
addListBox
        "private - Add the listbox to the receiver, in this case, a multipleSelectListBox"

    | charSize lineHeight |
    charSize := WindowDialog unitMultiplier.
    lineHeight := charSize y.

    self addSubpane: ((listPane := MultipleSelectListBox new)
        owner: self;
        extendedSelect;
        contents: contents;
        listFont: ListFont;
        when: #needsContents send: #choices: to: self with: listPane;
        when: #changed: send: #select: to: self with: listPane;
        when: #doubleClicked: send: #returnSelection: to: self with: listPane;
        framingBlock:   [:box | (box leftTop rightAndDown: (5@2) * charSize) extentFromLeftTop: (25 @ 13) * charSize]).!  ! 
#('October 16, 2003' '10:55:08 AM' 1107208)!

(CodeFiler organizerFor: ChooseManyDialog) reorganizeFrom: #(
('private' addListBox )) !


!ChooseManyDialog methods !
initWindowSize
        "private - return the default size of a ChooseOneDialog"
    ^35 @ 20 * WindowDialog unitMultiplier.!  ! 
#('October 16, 2003' '10:48:14 AM' nil)!

(CodeFiler organizerFor: ChooseManyDialog) reorganizeFrom: #(
('private' initWindowSize )) !


!ChooseManyDialog methods !
createPanes
"ChooseManyDialog new on: #(1 2 3 4 5) label: 'Build which worlds?'; selectAll; open.
"

    | charSize lineHeight thisPane |
    charSize := WindowDialog unitMultiplier.
    lineHeight := charSize y.

    self addListBox.
    self addSubpane: ((thisPane := Button new)
        owner: self;
        defaultPushButton;
        contents: 'Ok';
        when: #clicked send: #ok: to: self with: thisPane;
        framingBlock: [:box | (box leftTop rightAndDown: (4@16) * WindowDialog unitMultiplier) extentFromLeftTop: (7@2) * WindowDialog unitMultiplier]).

    self addSubpane: ((thisPane := Button new)
        owner: self;
        contents: 'Cancel';
        when: #clicked send: #cancel: to: self with: thisPane;
        framingBlock:   [:box | (box leftTop rightAndDown: (23@16) * WindowDialog unitMultiplier) extentFromLeftTop: (7@2) * WindowDialog unitMultiplier]).! ! 
#('October 16, 2003' '10:52:47 AM' nil)!

(CodeFiler organizerFor: ChooseManyDialog) reorganizeFrom: #(
('private' createPanes )) !


!ChooseManyDialog methods !   
createPanes
"ChooseManyDialog new on: #(1 2 3 4 5) label: 'Build which worlds?'; selectAll; open.
"

    | charSize lineHeight thisPane |
    charSize := WindowDialog unitMultiplier.
    lineHeight := charSize y.

    self addListBox.
    self addSubpane: ((thisPane := Button new)
        owner: self;
        defaultPushButton;
        contents: 'Ok';
        when: #clicked send: #ok: to: self with: thisPane;
        framingBlock: [:box | (box leftTop rightAndDown: (4@16) * WindowDialog unitMultiplier) extentFromLeftTop: (7@2) * WindowDialog unitMultiplier]).

    self addSubpane: ((thisPane := Button new)
        owner: self;
        contents: 'Cancel';
        when: #clicked send: #cancel: to: self with: thisPane;
        framingBlock:   [:box | (box leftTop rightAndDown: (23@16) * WindowDialog unitMultiplier) extentFromLeftTop: (7@2) * WindowDialog unitMultiplier]).! ! 
#('October 16, 2003' '10:53:22 AM' 1109304)!

(CodeFiler organizerFor: ChooseManyDialog) reorganizeFrom: #(
('private' createPanes )) !


!ChooseManyDialog methods !   
createPanes

    | charSize lineHeight thisPane |
    charSize := WindowDialog unitMultiplier.
    lineHeight := charSize y.

    self addListBox.
    self addSubpane: ((thisPane := Button new)
        owner: self;
        defaultPushButton;
        contents: 'Ok';
        when: #clicked send: #ok: to: self with: thisPane;
        framingBlock: [:box | (box leftTop rightAndDown: (4@16) * WindowDialog unitMultiplier) extentFromLeftTop: (7@2) * WindowDialog unitMultiplier]).

    self addSubpane: ((thisPane := Button new)
        owner: self;
        contents: 'Cancel';
        when: #clicked send: #cancel: to: self with: thisPane;
        framingBlock:   [:box | (box leftTop rightAndDown: (23@16) * WindowDialog unitMultiplier) extentFromLeftTop: (7@2) * WindowDialog unitMultiplier]).!    ! 
#('October 16, 2003' '10:53:26 AM' 1110384)!

(CodeFiler organizerFor: ChooseManyDialog) reorganizeFrom: #(
('private' createPanes )) !


!ChooseManyDialog methods !   
choices: aPane
    "private - Set the listBox's choices"

    aPane contents: self contents! ! 
#('May 8, 2002' '02:12:58 PM' nil)!

(CodeFiler organizerFor: ChooseManyDialog) reorganizeFrom: #(
('private' choices: )) !


!ChooseManyDialog methods !   
selectAll

    self selection: (1 to: contents size) asArray.
    listPane restoreSelected: self contents.
        
    self selection: (1 to: contents size) asArray.
    listPane restoreSelected: self contents.!  ! 
#('May 17, 2002' '11:57:39 AM' nil)!

(CodeFiler organizerFor: ChooseManyDialog) reorganizeFrom: #(
('private' selectAll )) !




WindowDialog subclass: #FindReplaceDialog
  instanceVariableNames: 
    ' toFind replaceWith forward confirm command caseSensitive '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Windows-Dialogs' )
  comment: ''!

  

WindowDialog subclass: #GetAndSetBuilder
  instanceVariableNames: 
    ' editedClass typeMap instVar types newInitializeFlag sourceManager '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Tools-Navigator' )
  comment: ''!

!GetAndSetBuilder methods !   
openOn: aClass

    | theClass thisPane  font boldFont |
    self halt.
    theClass := aClass.
    theClass isNil | theClass isBehavior not
        ifTrue: [theClass := self class].
    theClass instVarNames isEmpty
        ifTrue: [^MessageBox message: 'No instance variables for ', theClass name].

    newInitializeFlag := false.
    font := TextFont.
    boldFont := (Font fromFont: TextFont graphicsMedium: Display)
        bold: true;
        makeFont;
        yourself.

    self
        editedClass: theClass;
        defaultInstVar: theClass instVarNames first;
        typeMap: Dictionary new;
        types: self defaultTypeList;
        buildTypeMap;

        label: 'Get & Set Builder';
        owner: self;

        addSubpane: (StaticText new
            font: font;
            contents: 'Class:';
            framingRatio: (1/16 @ (1/16) extent: 3/16 @ (1/16)));

        addSubpane: (StaticText new
            font: boldFont;
            when: #getContents perform: #getClassName:;
            framingRatio: (1/4 @ (1/16) extent: 11/16 @ (1/16)));

        addSubpane: (StaticText new
            font: font;
            contents: 'Instance Variable:';
            framingRatio: (1/16 @ (3/16) extent: 1/2 @ (1/16)));

        addSubpane: (StaticText new
            font: font;
            contents: 'Type:';
            framingRatio: (5/8 @ (3/16) extent: 5/16 @ (1/16)));

        addSubpane: ((thisPane := ListBox new)
            setName: #instanceVariables;
            font: font;
            when: #needsContents send: #getInstVarList: to: self with: thisPane;
            when: #changed: send: #selectInstVar: to: self with: thisPane;
            framingRatio: (1/16 @ (5/16) extent: 1/2 @ (1/2)));

        addSubpane: ((thisPane := EntryField new)
            setName: #argumentType;
            font: font;
            when: #needsContents send: #getInstVarType: to: self with: thisPane;
            when: #changed: send: #enteredType: to: self with: thisPane;
            framingRatio: (5/8 @ (5/16) extent: 5/16 @ (5/64)));

        addSubpane: ((thisPane := ListBox new)
            setName: #argumentTypes;
            font: font;
            when: #needsContents send: #getInstVarTypeList: to: self with: thisPane;
            when: #changed: send: #selectInstVarType: to: self with: thisPane;
            framingRatio: (5/8 @ (7/16) extent: 5/16 @ (3/8)));

        addSubpane: ((thisPane := Button new)
            font: font;
            contents: 'Build';
            defaultPushButton;
            when: #clicked send: #build: to: self with: thisPane;
            framingRatio: ((1/16 @ (7/8) extent: 1/4 @ (1/16)) expandBy: 0 @ (1/64)));

        addSubpane: ((thisPane := CheckBox new)
            font: font;
            contents: 'New/Initialize';
            when: #clicked: send: #clickedNewInitialize: to: self with: thisPane;
            framingRatio: ((3/8 @ (7/8) extent: 5/16 @ (1/16)) expandBy: 0 @ (1/64)));

        addSubpane: ((thisPane := Button new)
            font: font;
            contents: 'Exit';
            when: #clicked send: #exit: to: self with: thisPane;
            framingRatio: ((11/16 @ (7/8) extent: 1/4 @ (1/16)) expandBy: 0 @ (1/64)));

        openWindow!    ! 
#('March 30, 2003' '12:38:21 PM' nil)!

(CodeFiler organizerFor: GetAndSetBuilder) reorganizeFrom: #(
('scheduling' openOn: )) !


!GetAndSetBuilder methods !  
openOn: aClass

    | theClass thisPane  font boldFont |
    theClass := aClass.
    theClass isNil | theClass isBehavior not
        ifTrue: [theClass := self class].
    theClass instVarNames isEmpty
        ifTrue: [^MessageBox message: 'No instance variables for ', theClass name].

    newInitializeFlag := false.
    font := TextFont.
    boldFont := (Font fromFont: TextFont graphicsMedium: Display)
        bold: true;
        makeFont;
        yourself.

    self
        editedClass: theClass;
        defaultInstVar: theClass instVarNames first;
        typeMap: Dictionary new;
        types: self defaultTypeList;
        buildTypeMap;

        label: 'Get & Set Builder';
        owner: self;

        addSubpane: (StaticText new
            font: font;
            contents: 'Class:';
            framingRatio: (1/16 @ (1/16) extent: 3/16 @ (1/16)));

        addSubpane: (StaticText new
            font: boldFont;
            when: #getContents perform: #getClassName:;
            framingRatio: (1/4 @ (1/16) extent: 11/16 @ (1/16)));

        addSubpane: (StaticText new
            font: font;
            contents: 'Instance Variable:';
            framingRatio: (1/16 @ (3/16) extent: 1/2 @ (1/16)));

        addSubpane: (StaticText new
            font: font;
            contents: 'Type:';
            framingRatio: (5/8 @ (3/16) extent: 5/16 @ (1/16)));

        addSubpane: ((thisPane := ListBox new)
            setName: #instanceVariables;
            font: font;
            when: #needsContents send: #getInstVarList: to: self with: thisPane;
            when: #changed: send: #selectInstVar: to: self with: thisPane;
            framingRatio: (1/16 @ (5/16) extent: 1/2 @ (1/2)));

        addSubpane: ((thisPane := EntryField new)
            setName: #argumentType;
            font: font;
            when: #needsContents send: #getInstVarType: to: self with: thisPane;
            when: #changed: send: #enteredType: to: self with: thisPane;
            framingRatio: (5/8 @ (5/16) extent: 5/16 @ (5/64)));

        addSubpane: ((thisPane := ListBox new)
            setName: #argumentTypes;
            font: font;
            when: #needsContents send: #getInstVarTypeList: to: self with: thisPane;
            when: #changed: send: #selectInstVarType: to: self with: thisPane;
            framingRatio: (5/8 @ (7/16) extent: 5/16 @ (3/8)));

        addSubpane: ((thisPane := Button new)
            font: font;
            contents: 'Build';
            defaultPushButton;
            when: #clicked send: #build: to: self with: thisPane;
            framingRatio: ((1/16 @ (7/8) extent: 1/4 @ (1/16)) expandBy: 0 @ (1/64)));

        addSubpane: ((thisPane := CheckBox new)
            font: font;
            contents: 'New/Initialize';
            when: #clicked: send: #clickedNewInitialize: to: self with: thisPane;
            framingRatio: ((3/8 @ (7/8) extent: 5/16 @ (1/16)) expandBy: 0 @ (1/64)));

        addSubpane: ((thisPane := Button new)
            font: font;
            contents: 'Exit';
            when: #clicked send: #exit: to: self with: thisPane;
            framingRatio: ((11/16 @ (7/8) extent: 1/4 @ (1/16)) expandBy: 0 @ (1/64)));

        openWindow!    ! 
#('March 30, 2003' '04:50:53 PM' 1113620)!

(CodeFiler organizerFor: GetAndSetBuilder) reorganizeFrom: #(
('scheduling' openOn: )) !


!GetAndSetBuilder methods !  
sourceManager: aSourceManager
    sourceManager := aSourceManager! ! 
#('March 30, 2003' '12:59:08 PM' nil)!

(CodeFiler organizerFor: GetAndSetBuilder) reorganizeFrom: #(
('accessing' sourceManager: )) !


!GetAndSetBuilder methods !
sourceManager
    ^sourceManager!  ! 
#('March 30, 2003' '12:58:52 PM' nil)!

(CodeFiler organizerFor: GetAndSetBuilder) reorganizeFrom: #(
('accessing' sourceManager )) !


!GetAndSetBuilder methods ! 
enteredType: aPane

    | aString |
    aString := aPane contents.
    aString = self dontUseString
        ifTrue: [self typeMap at: self instVar put: nil]
        ifFalse: [
            self typeMap at: self instVar put: aString.
            (types includes: aString) ifFalse: [self types add: aString]].
    self updateArgumentTypesPane!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: GetAndSetBuilder) reorganizeFrom: #(
('pane events' enteredType: )) !


!GetAndSetBuilder methods !   
addGetAndSetFor: aCollection in: aClass on: stream
    "Add get and set methods for the instance variables in aCollection, which is a collection of two-element arrays.
    The first element is the symbol for the instance variable name, the second is a symbol for the type."

    | instVarName instVarType type |
    self halt.
    stream
        nextPut: $!!;
        nextPutAll: aClass name;
        nextPutAll: ' methodsFor: ''get/set'' !!'.

    aCollection do: [:pair |
        instVarName := pair first asString.
        instVarType := pair last asString.
        instVarType at: 1 put: (instVarType first asUpperCase).
        type := (instVarType first isVowel
            ifTrue: ['an']
            ifFalse: ['a']), instVarType.
        (aClass instVarNames includes: instVarName)
            ifFalse: [self error: 'Bad instance variable name.'].
        stream
            cr; cr;
            nextPutAll: instVarName;
            cr;
            nextPutAll: '    ^';
            nextPutAll: instVarName;
            nextPut: $!!;
            cr; cr;
            nextPutAll: instVarName;
            nextPutAll: ': ';
            nextPutAll: type;
            cr;
            nextPutAll: '    ';
            nextPutAll: instVarName;
            nextPutAll: ' := ';
            nextPutAll: type;
            nextPut: $!!].

    stream nextPutAll: ' !!'!  ! 
#('March 30, 2003' '12:32:59 PM' nil)!

(CodeFiler organizerFor: GetAndSetBuilder) reorganizeFrom: #(
('building' addGetAndSetFor:in:on: )) !


!GetAndSetBuilder methods ! 
addGetAndSetFor: aCollection in: aClass on: stream
    "Add get and set methods for the instance variables in aCollection, which is a collection of two-element arrays.
    The first element is the symbol for the instance variable name, the second is a symbol for the type."

    | instVarName instVarType type |
    stream
        nextPut: $!!;
        nextPutAll: aClass name;
        nextPutAll: ' methodsFor: ''get/set'' !!'.

    aCollection do: [:pair |
        instVarName := pair first asString.
        instVarType := pair last asString.
        instVarType at: 1 put: (instVarType first asUpperCase).
        type := (instVarType first isVowel
            ifTrue: ['an']
            ifFalse: ['a']), instVarType.
        (aClass instVarNames includes: instVarName)
            ifFalse: [self error: 'Bad instance variable name.'].
        stream
            cr; cr;
            nextPutAll: instVarName;
            cr;
            nextPutAll: '    ^';
            nextPutAll: instVarName;
            nextPut: $!!;
            cr; cr;
            nextPutAll: instVarName;
            nextPutAll: ': ';
            nextPutAll: type;
            cr;
            nextPutAll: '    ';
            nextPutAll: instVarName;
            nextPutAll: ' := ';
            nextPutAll: type;
            nextPut: $!!].

    stream nextPutAll: ' !!'!  ! 
#('March 30, 2003' '12:36:11 PM' 1121596)!

(CodeFiler organizerFor: GetAndSetBuilder) reorganizeFrom: #(
('building' addGetAndSetFor:in:on: )) !


!GetAndSetBuilder methods ! 
addGetAndSetFor: aCollection in: aClass on: stream
    "Add get and set methods for the instance variables in aCollection, which is a collection of two-element arrays.
    The first element is the symbol for the instance variable name, the second is a symbol for the type."

    | instVarName instVarType type |
    stream
        nextPut: $!!;
        nextPutAll: aClass name;
        nextPutAll: ' methodsFor: ''get/set'' !!'.

    aCollection do: [:pair |
        instVarName := pair first asString.
        instVarType := pair last asString.
        instVarType at: 1 put: (instVarType first asUpperCase).
        type := (instVarType first isVowel
            ifTrue: ['an']
            ifFalse: ['a']), instVarType.
        (aClass instVarNames includes: instVarName)
            ifFalse: [self error: 'Bad instance variable name.'].
        stream
            cr; cr;
            nextPutAll: instVarName;
            cr;
            nextPutAll: '    ^';
            nextPutAll: instVarName;
            nextPut: $!!;
            cr; cr;
            nextPutAll: instVarName;
            nextPutAll: ': ';
            nextPutAll: type;
            cr;
            nextPutAll: '    ';
            nextPutAll: instVarName;
            nextPutAll: ' := ';
            nextPutAll: type;
            nextPut: $!!].

    stream nextPutAll: ' !!'!  ! 
#('March 30, 2003' '12:36:19 PM' 1123180)!

(CodeFiler organizerFor: GetAndSetBuilder) reorganizeFrom: #(
('building' addGetAndSetFor:in:on: )) !


!GetAndSetBuilder methods ! 
addGetAndSetFor: aCollection in: aClass withNewInitialize: aBoolean
    "Add get and set methods for the instance variables in aCollection, which is a collection of two-element arrays.
    The first element is the symbol for the instance variable name, the second is a symbol for the type.
    If aBoolean is true, also add a new-initialize pair of methods.
    Example usage:
        self addGetAndSetFor: #((x Integer) (y Integer)) in: Point withNewInitialize: false."

    | stream |
    stream := ReadWriteStream on: (String new: 100).
    aBoolean
        ifTrue: [self addNewInitializeFor: aCollection in: aClass on: stream].
    self addGetAndSetFor: aCollection in: aClass on: stream.
    stream
        position: 0;
        fileIn!  ! 
#('March 30, 2003' '01:00:28 PM' nil)!

(CodeFiler organizerFor: GetAndSetBuilder) reorganizeFrom: #(
('building' addGetAndSetFor:in:withNewInitialize: )) !


!GetAndSetBuilder methods !  
addGetAndSetFor: aCollection in: aClass withNewInitialize: aBoolean
    "Add get and set methods for the instance variables in aCollection, which is a collection of two-element arrays.
    The first element is the symbol for the instance variable name, the second is a symbol for the type.
    If aBoolean is true, also add a new-initialize pair of methods.
    Example usage:
        self addGetAndSetFor: #((x Integer) (y Integer)) in: Point withNewInitialize: false."

    | stream |
    stream := ReadWriteStream on: (String new: 100).
    aBoolean
        ifTrue: [self addNewInitializeFor: aCollection in: aClass on: stream].
    self addGetAndSetFor: aCollection in: aClass on: stream.
    "
    stream
        position: 0;
        fileIn
    "
    stream position: 0.
    self sourceManger fileInFrom: stream! ! 
#('March 30, 2003' '01:00:28 PM' 1126324)!

(CodeFiler organizerFor: GetAndSetBuilder) reorganizeFrom: #(
('building' addGetAndSetFor:in:withNewInitialize: )) !


!GetAndSetBuilder methods !  
addGetAndSetFor: aCollection in: aClass withNewInitialize: aBoolean
    "Add get and set methods for the instance variables in aCollection, which is a collection of two-element arrays.
    The first element is the symbol for the instance variable name, the second is a symbol for the type.
    If aBoolean is true, also add a new-initialize pair of methods.
    Example usage:
        self addGetAndSetFor: #((x Integer) (y Integer)) in: Point withNewInitialize: false."

    | stream |
    stream := ReadWriteStream on: (String new: 100).
    aBoolean
        ifTrue: [self addNewInitializeFor: aCollection in: aClass on: stream].
    self addGetAndSetFor: aCollection in: aClass on: stream.
    "
    stream
        position: 0;
        fileIn
    "
    stream position: 0.
    self sourceManager fileInFrom: stream!    ! 
#('March 30, 2003' '01:03:24 PM' 1127280)!

(CodeFiler organizerFor: GetAndSetBuilder) reorganizeFrom: #(
('building' addGetAndSetFor:in:withNewInitialize: )) !


!GetAndSetBuilder methods !  
selectInstVarType: aPane

    | selection |
    selection := aPane selectedItem.
    selection = self dontUseString
        ifTrue: [self typeMap at: self instVar put: nil]
        ifFalse: [
            self typeMap at: self instVar put: selection.
            (types includes: selection)ifFalse: [self types add: selection]].
    self updateArgumentTypePane!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: GetAndSetBuilder) reorganizeFrom: #(
('pane events' selectInstVarType: )) !


!GetAndSetBuilder methods ! 
defaultTypeList

    ^#('Face3D' 'Point3D' 'String' 'Symbol' 'Collection' 'Boolean' 'Number' 'Float' 'Plane' 'Object3D' 'Transformation4D') asSortedCollection
        add: self dontUseString;
        yourself!   ! 
#('December 21, 2001' '02:57:44 PM' nil)!

(CodeFiler organizerFor: GetAndSetBuilder) reorganizeFrom: #(
('defaults' defaultTypeList )) !




WindowDialog subclass: #ListDialog
  instanceVariableNames: 
    ' title font textLines list minEntriesToShow maxEntriesToShow returnItems selection clientExtentDlg pmOwner '
  classVariableNames: 
    ' FrameStyle '
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

ListDialog subclass: #MultiSelectListDialog
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WindowDialog subclass: #ObjectLoadDialog
  instanceVariableNames: 
    ' changeMap description sourceTitle sourceList destTitle destList showCancel dragButton changeMapPane clientExtentDlg updatedChangeMap '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WindowDialog subclass: #PARTSDialog
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSDialog subclass: #PARTSContentsEditor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSContentsEditor subclass: #PARTSArrayEditor
  instanceVariableNames: 
    ' array listBox itemField sizeField answer '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSDialog subclass: #PARTSDialEditor
  instanceVariableNames: 
    ' dialParameters answer ticks '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSContentsEditor subclass: #PARTSDictionaryEditor
  instanceVariableNames: 
    ' dictionary modified listBox keyField valueField answer '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSContentsEditor subclass: #PARTSOrderedCollectionEditor
  instanceVariableNames: 
    ' oc modified listBox staticText itemField answer '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSDialog subclass: #PARTSPointEditor
  instanceVariableNames: 
    ' point xItem yItem '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSPointEditor subclass: #PARTSExtentEditor
  instanceVariableNames: 
    ' title '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSDialog subclass: #PARTSPropertiesEditor
  instanceVariableNames: 
    ' properties object extentFromLeftTop stylesLeftTop stylesRightBottom actions '
  classVariableNames: 
    ' StylesDictionary '
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

PARTSDialog subclass: #PARTSRelativeLayoutDialog
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSRelativeLayoutDialog subclass: #PARTSFieldOrderDialog
  instanceVariableNames: 
    ' list clientExtentDlg answer '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

PARTSRelativeLayoutDialog subclass: #PARTSSequenceEditor
  instanceVariableNames: ''
  classVariableNames: 
    ' FrameStyle '
  poolDictionaries: 
    ' GraphicsConstants PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSSequenceEditor subclass: #' S22'
  instanceVariableNames: 
    ' wrapper events selectedEvent changedEvents linkListDict clientExtentDlg linkListMidpointRatio linkEntryHeight '
  classVariableNames: ''
  poolDictionaries: 
    ' GraphicsConstants '
  categories: #( )
  comment: ''!

  

PARTSSequenceEditor subclass: #PARTSPathSequenceEditor
  instanceVariableNames: 
    ' list changed entryHeight clientExtentDlg listRect entryRects answer '
  classVariableNames: ''
  poolDictionaries: 
    ' GraphicsConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



PARTSDialog subclass: #PARTSSimpleTextEditor
  instanceVariableNames: 
    ' answer '
  classVariableNames: ''
  poolDictionaries: 
    ' PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSSimpleTextEditor subclass: #PARTSSimpleRichTextEditor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' PARTSConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

PARTSDialog subclass: #PARTSTabOrderEditor
  instanceVariableNames: 
    ' orderedChildren tabStops groupLeaders children answer '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WindowDialog subclass: #PrintAbortDialog
  instanceVariableNames: 
    ' printer title '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Windows-Dialogs' )
  comment: ''!

  

WindowDialog subclass: #ProgressIndicatorDialog
  instanceVariableNames: 
    ' canceled messageText percentText percentGraphic percentComplete noCancel prevPercentComplete showPercent '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Windows-Dialogs' )
  comment: ''!



WindowDialog subclass: #ProgressIndicatorDialogThatWorks
  instanceVariableNames: 
    ' percent message messagePane percentPane progressPane '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'Windows-Dialogs' )
  comment: ''!

!ProgressIndicatorDialogThatWorks methods ! 
open

    super open.
    progressPane disableAll.
    self update.!    ! 
#('August 14, 2001' '10:22:07 AM' nil)!

(CodeFiler organizerFor: ProgressIndicatorDialogThatWorks) reorganizeFrom: #(
('scheduling' open )) !


!ProgressIndicatorDialogThatWorks methods !
open

    Float clearExceptionFlags.
    super open.
    progressPane disableAll.
    self update.!    ! 
#('November 18, 2010' '11:18:05 AM' 1136000)!

(CodeFiler organizerFor: ProgressIndicatorDialogThatWorks) reorganizeFrom: #(
('scheduling' open )) !


!ProgressIndicatorDialogThatWorks methods !  
initialize

    super initialize.
    message := ''.
    percent := 0.0!    ! 
#('August 14, 2001' '09:59:27 AM' nil)!

(CodeFiler organizerFor: ProgressIndicatorDialogThatWorks) reorganizeFrom: #(
('initializing' initialize )) !


!ProgressIndicatorDialogThatWorks methods !
open: title message: ignored

    message := title.
    self open!   ! 
#('August 14, 2001' '10:15:24 AM' nil)!

(CodeFiler organizerFor: ProgressIndicatorDialogThatWorks) reorganizeFrom: #(
('scheduling' open:message: )) !


!ProgressIndicatorDialogThatWorks methods !   
message: aString

    message := aString! ! 
#('August 14, 2001' '09:58:49 AM' nil)!

(CodeFiler organizerFor: ProgressIndicatorDialogThatWorks) reorganizeFrom: #(
('configuring' message: )) !


!ProgressIndicatorDialogThatWorks methods !   
openViewsOnce
        "Open the window once.
            For PARTS support."
    #addedByOSI.
    self mainView isHandleOk
        ifTrue: [ self mainView openModeless ]
        ifFalse: [ self openModeless ].!    ! 
#('August 14, 2001' '10:15:15 AM' nil)!

(CodeFiler organizerFor: ProgressIndicatorDialogThatWorks) reorganizeFrom: #(
('private-scheduling' openViewsOnce )) !


!ProgressIndicatorDialogThatWorks methods !   
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| mainView msSansSerif10 xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Instance Variables"
	messagePane := StaticText new.
	percentPane := StaticText new.
	progressPane := ScrollBar new.
	
		"Font Definitions"
	msSansSerif10 := Font new
		fromByteArray: #[243 255 255 255 0 0 0 0 0 0 0 0 0 0 0 0 144 1 0 0 0 0 0 0 1 2 1 34 77 83 32 83 97 110 115 32 83 101 114 105 102 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ].
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		labelWithoutPrefix: 'Progress Indicator';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -98 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -22 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -98 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -22 * yDU).
	self addView: mainView.
	
	messagePane "StaticText"
		owner: self;
		setName: 'messagePane';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 4 * xDU;
				topRatio: 0; topInset: 6 * yDU;
				rightRatio: 0; rightInset: -194 * xDU;
				bottomRatio: 0; bottomInset: -20 * yDU);
		centered;
		contents: 'Message';
		startGroup;
		noTabStop;
		font: msSansSerif10.
	mainView addSubpane: messagePane.
	
	percentPane "StaticText"
		owner: self;
		setName: 'percentPane';
		addClipsiblingsStyle;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 84 * xDU;
				topRatio: 0; topInset: 37/2 * yDU;
				rightRatio: 0; rightInset: -112 * xDU;
				bottomRatio: 0; bottomInset: -53/2 * yDU);
		centered;
		contents: 'Percent';
		startGroup;
		noTabStop;
		font: msSansSerif10.
	mainView addSubpane: percentPane.
	
	progressPane "ScrollBar"
		owner: self;
		setName: 'progressPane';
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 6 * xDU;
				topRatio: 0; topInset: 30 * yDU;
				rightRatio: 0; rightInset: -190 * xDU;
				bottomRatio: 0; bottomInset: -38 * yDU);
		startGroup;
		noTabStop;
		font: SysFont;
		horizontal.
	mainView addSubpane: progressPane!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: ProgressIndicatorDialogThatWorks) reorganizeFrom: #(
('private-scheduling' createViews )) !


!ProgressIndicatorDialogThatWorks methods ! 
noCancel!   ! 
#('August 14, 2001' '10:08:11 AM' nil)!

(CodeFiler organizerFor: ProgressIndicatorDialogThatWorks) reorganizeFrom: #(
('configuring' noCancel )) !


!ProgressIndicatorDialogThatWorks methods !   
update

    messagePane contents: message.
    percentPane contents: percent asInteger printString, '%'.
    progressPane value: percent asInteger.
    self title: message, ' [', percent asInteger printString, ' %]'.!  ! 
#('May 16, 2003' '01:43:51 PM' nil)!

(CodeFiler organizerFor: ProgressIndicatorDialogThatWorks) reorganizeFrom: #(
('updating' update )) !


!ProgressIndicatorDialogThatWorks methods !   
update

    messagePane contents: message.
    percentPane contents: percent asInteger printString, '%'.
    progressPane value: percent asInteger.
    self label: message, ' [', percent asInteger printString, ' %]'.!  ! 
#('May 16, 2003' '01:43:51 PM' 1140820)!

(CodeFiler organizerFor: ProgressIndicatorDialogThatWorks) reorganizeFrom: #(
('updating' update )) !


!ProgressIndicatorDialogThatWorks methods !   
update

    messagePane contents: message.
    percentPane contents: percent asInteger printString, '%'.
    progressPane value: percent asInteger.
    self label: message, ' [', percent asInteger printString, '%]'.!   ! 
#('May 16, 2003' '01:43:51 PM' 1141244)!

(CodeFiler organizerFor: ProgressIndicatorDialogThatWorks) reorganizeFrom: #(
('updating' update )) !


!ProgressIndicatorDialogThatWorks methods !   
percent: aNumber

    percent := aNumber.
    self update!   ! 
#('August 14, 2001' '09:49:09 AM' nil)!

(CodeFiler organizerFor: ProgressIndicatorDialogThatWorks) reorganizeFrom: #(
('configuring' percent: )) !


!ProgressIndicatorDialogThatWorks class methods ! 
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk 3.1.0 Win32"

	^3.1!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: ProgressIndicatorDialogThatWorks class) reorganizeFrom: #(
('no category methods' wbBasicVersion )) !


  

WindowDialog subclass: #Prompter
  instanceVariableNames: 
    ' exitBlock reply evaluating withBlank '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Windows-Dialogs' )
  comment: ''!

   

Prompter subclass: #PARTSPrompter
  instanceVariableNames: 
    ' closedAction validationMessage '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WindowDialog subclass: #PrompterDialog
  instanceVariableNames: 
    ' title prompt defaultAnswer previousAnswers cancelBlock answer '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Windows-Dialogs' )
  comment: ''!

!PrompterDialog methods !   
createPanes
        "Private - create the panes for the receiver."

    | lineHeight charSize pane font |
    charSize := WindowDialog unitMultiplier.
    lineHeight := charSize y.

    (pane := self topPaneClass new)
        owner: self;
        labelWithoutPrefix: title;
        font: ButtonFont.
    self addView: pane.

    self addSubpane: (StaticText new
        setName: #prompt;
        leftJustified;
        contents: prompt;
        framingBlock: [:box |
            (box leftTop rightAndDown: (1 @ 1) * charSize) extentFromLeftTop: (38 @ 1) * charSize]).

    self addSubpane: (AutoSelectComboBox dropDown
        setName: #text;
        when: #needsContents send: #contentsForText to: self;
        framingBlock: [:box |  (box leftTop rightAndDown: (1 @ (5/2)) * charSize) extentFromLeftTop: ((38 @ 5) * charSize) rounded]).

    self addSubpane: ((pane := Button new)
        setName: #ok;
        defaultPushButton;
        contents: 'Ok';
        when: #clicked send: #ok to: self;
        framingBlock: [:box | (box leftTop rightAndDown: ((38 - 20) @ 5) * charSize) extentFromLeftTop: 10@1.5 * charSize]).

    self addSubpane: ((pane := Button new)
            setName: #cancel;
            pushButton;
            contents: 'Cancel';
            when: #clicked send: #cancel to: self;
            framingBlock: [:box | (box leftTop rightAndDown: ((38 - 9.0) @ 5) * charSize) extentFromLeftTop: 10@1.5 * charSize])! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: PrompterDialog) reorganizeFrom: #(
('private-scheduling' createPanes )) !


!PrompterDialog methods ! 
initWindowSize
        "Private - Answer the window size."
    ^40 @ (35/5) * WindowDialog unitMultiplier!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: PrompterDialog) reorganizeFrom: #(
('private-scheduling' initWindowSize )) !


   

ListDialog subclass: #RadioButtonDialog
  instanceVariableNames: 
    ' radioButtons '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WindowDialog subclass: #SaveImageAsDialog
  instanceVariableNames: 
    ' icon iconFileName imageFileName canceled '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Windows-Dialogs' )
  comment: ''!

  

WindowDialog subclass: #SaveImageDialog
  instanceVariableNames: 
    ' answer cbBackupImage '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Windows-Dialogs' )
  comment: ''!



WindowDialog subclass: #ScintillaFindDialog
  instanceVariableNames: 
    ' searchString searchHistory textPane '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants ScintillaConstants '
  categories: #( 'Tools-Scintilla Pane' )
  comment: ''!

!ScintillaFindDialog methods !
options

    | options |
    options := 0.
    self isMatchCase ifTrue: [options := options bitOr: SCFIND_MATCHCASE].
    self isMatchWholeWordsOnly ifTrue: [options := options bitOr: SCFIND_WHOLEWORD].
    self isRegularExpression ifTrue: [options := options bitOr: SCFIND_REGEXP].
    ^options! ! 
#('April 19, 2002' '03:25:00 PM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('options' options )) !


!ScintillaFindDialog methods !   
searchString: aString

    searchString := aString!   ! 
#('April 19, 2002' '02:47:01 PM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('string handling' searchString: )) !


!ScintillaFindDialog methods ! 
findNextClicked

        self doFindNext ifTrue: [self close]!    ! 
#('May 3, 2002' '02:00:01 PM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('event handling' findNextClicked )) !


!ScintillaFindDialog methods !   
isUp

    ^self upButton selection!   ! 
#('April 19, 2002' '02:40:45 PM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('options' isUp )) !


!ScintillaFindDialog methods !  
setUpButton

    self upButton selection: true.
    self downButton selection: false.!   ! 
#('April 26, 2002' '10:49:20 AM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('event handling' setUpButton )) !


!ScintillaFindDialog methods !
matchCaseButton

    ^self paneNamed: #matchCase! ! 
#('April 19, 2002' '02:06:33 PM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('panes' matchCaseButton )) !


!ScintillaFindDialog methods ! 
upButton 

    ^self paneNamed: #up!  ! 
#('April 19, 2002' '02:06:03 PM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('panes' upButton )) !


!ScintillaFindDialog methods !
transformBackslashExpressionButton

    ^self paneNamed: #transformBackslashExpression!   ! 
#('April 19, 2002' '02:07:08 PM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('panes' transformBackslashExpressionButton )) !


!ScintillaFindDialog methods !  
findTextPane

    ^self paneNamed: #findText! ! 
#('April 19, 2002' '04:38:44 PM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('panes' findTextPane )) !


!ScintillaFindDialog methods !
isRegularExpression

    ^self regularExpressionButton selection! ! 
#('April 19, 2002' '03:22:34 PM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('options' isRegularExpression )) !


!ScintillaFindDialog methods !   
cancelButton

    ^self paneNamed: #cancel!   ! 
#('April 19, 2002' '02:05:40 PM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('panes' cancelButton )) !


!ScintillaFindDialog methods !
initialize

    super initialize.
    searchHistory := #().
    searchString := ''.!    ! 
#('April 26, 2002' '12:15:42 PM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('initializing' initialize )) !


!ScintillaFindDialog methods !   
textPane: aScintillaPane

    textPane := aScintillaPane! ! 
#('April 26, 2002' '10:49:20 AM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('initializing' textPane: )) !


!ScintillaFindDialog methods !
doFindNext

    | position |
    self searchString isEmpty ifTrue: [self close. ^false].

    textPane sendEditor: SCI_SEARCHANCHOR.
    self isDown
        ifTrue: [position := textPane sendEditor: SCI_SEARCHNEXT buffer: self searchString with: self options]
        ifFalse: [position := textPane sendEditor: SCI_SEARCHPREV buffer: self searchString with: self options].

    position = INVALID_POSITION ifTrue: [self warnSearchStringNotFound. ^false].
    textPane swapCursorAndAnchor; forceSelectionOntoDisplay.
    ^true!  ! 
#('July 16, 2002' '09:22:47 AM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('event handling' doFindNext )) !


!ScintillaFindDialog methods !  
searchStringFor: aPane

    aPane
        contents: (Array with: searchString), searchHistory;
        selection: searchString! ! 
#('April 19, 2002' '04:42:23 PM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('event handling' searchStringFor: )) !


!ScintillaFindDialog methods !   
searchString

    ^searchString!  ! 
#('April 19, 2002' '02:46:44 PM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('string handling' searchString )) !


!ScintillaFindDialog methods !  
matchWholeWordsOnlyButton

    ^self paneNamed: #matchWholeWordsOnly! ! 
#('April 19, 2002' '02:06:21 PM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('panes' matchWholeWordsOnlyButton )) !


!ScintillaFindDialog methods !   
searchHistory: strings

    searchHistory := strings! ! 
#('April 19, 2002' '04:43:21 PM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('string handling' searchHistory: )) !


!ScintillaFindDialog methods !
setDownButton

    self downButton selection: true.
    self upButton selection: false.! ! 
#('April 26, 2002' '10:49:20 AM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('event handling' setDownButton )) !


!ScintillaFindDialog methods !  
textPane
    ^self textPane!   ! 
#('April 26, 2002' '10:49:20 AM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('panes' textPane )) !


!ScintillaFindDialog methods !
downButton

    ^self paneNamed: #down!   ! 
#('April 19, 2002' '02:06:08 PM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('panes' downButton )) !


!ScintillaFindDialog methods !  
isDown

    ^self downButton selection!   ! 
#('April 19, 2002' '02:38:34 PM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('options' isDown )) !


!ScintillaFindDialog methods !
isSearchInWholeFile

    ^true!   ! 
#('April 19, 2002' '05:13:03 PM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('options' isSearchInWholeFile )) !


!ScintillaFindDialog methods !   
isSearchInSelection

    ^false!  ! 
#('April 19, 2002' '05:12:58 PM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('options' isSearchInSelection )) !


!ScintillaFindDialog methods !   
warnSearchStringNotFound
    ^MessageBox warning: 'Search string not found.'!  ! 
#('May 3, 2002' '01:56:11 PM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('event handling' warnSearchStringNotFound )) !


!ScintillaFindDialog methods !  
isTransformBackslashExpression

    ^self transformBackslashExpressionButton selection!   ! 
#('April 19, 2002' '03:23:09 PM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('options' isTransformBackslashExpression )) !


!ScintillaFindDialog methods !
isMatchCase

    ^self matchCaseButton selection! ! 
#('April 19, 2002' '03:21:56 PM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('options' isMatchCase )) !


!ScintillaFindDialog methods !   
isMatchWholeWordsOnly

    ^self matchWholeWordsOnlyButton selection! ! 
#('April 19, 2002' '03:22:16 PM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('options' isMatchWholeWordsOnly )) !


!ScintillaFindDialog methods ! 
createViewsOnce

    super createViewsOnce.
    self findTextPane list: searchHistory!   ! 
#('April 19, 2002' '04:41:59 PM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('private-scheduling' createViewsOnce )) !


!ScintillaFindDialog methods !
createViews

    "WARNING!! This method was automatically generated by
    WindowBuilder. Code you add here which does not conform to
    the WindowBuilder API will probably be lost the next time
    you save your layout definition."

    | cancel down findNext findText groupBox1 mainView
    matchCase matchWholeWordsOnly msSansSerif8 msSansSerif81
    msSansSerif82 msSansSerif83 msSansSerif84 msSansSerif85
    msSansSerif86 regularExpression staticText1
    transformBackslashExpressions up xDU yDU |

    #generated.
    xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
    yDU := 1.
    mainView := self topPaneClass new.

        "Temporary Variables"
    cancel := Button new.
    down := RadioButton new.
    findNext := Button new.
    findText := AutoSelectComboBox new.
    groupBox1 := GroupBox new.
    matchCase := CheckBox new.
    matchWholeWordsOnly := CheckBox new.
    regularExpression := CheckBox new.
    staticText1 := StaticText new.
    transformBackslashExpressions := CheckBox new.
    up := RadioButton new.

        "Font Definitions"
    msSansSerif83 := Font new
        fromByteArray: #[245 255 255 255 0 0 0 0 0 0 0 0 0 0 0 0 144 1 0 0 0 0 0 0 1 2 1 34 77 83 32 83 97 110 115 32 83 101 114 105 102 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ].
    msSansSerif84 := Font new
        fromByteArray: #[245 255 255 255 0 0 0 0 0 0 0 0 0 0 0 0 144 1 0 0 0 0 0 0 1 2 1 34 77 83 32 83 97 110 115 32 83 101 114 105 102 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ].
    msSansSerif85 := Font new
        fromByteArray: #[245 255 255 255 0 0 0 0 0 0 0 0 0 0 0 0 144 1 0 0 0 0 0 0 1 2 1 34 77 83 32 83 97 110 115 32 83 101 114 105 102 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ].
    msSansSerif82 := Font new
        fromByteArray: #[245 255 255 255 0 0 0 0 0 0 0 0 0 0 0 0 144 1 0 0 0 0 0 0 1 2 1 34 77 83 32 83 97 110 115 32 83 101 114 105 102 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ].
    msSansSerif86 := Font new
        fromByteArray: #[245 255 255 255 0 0 0 0 0 0 0 0 0 0 0 0 144 1 0 0 0 0 0 0 1 2 1 34 77 83 32 83 97 110 115 32 83 101 114 105 102 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ].
    msSansSerif8 := Font new
        fromByteArray: #[245 255 255 255 0 0 0 0 0 0 0 0 0 0 0 0 144 1 0 0 0 0 0 0 1 2 1 34 77 83 32 83 97 110 115 32 83 101 114 105 102 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ].
    msSansSerif81 := Font new
        fromByteArray: #[245 255 255 255 0 0 0 0 0 0 0 0 0 0 0 0 144 1 0 0 0 0 0 0 1 2 1 34 77 83 32 83 97 110 115 32 83 101 114 105 102 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ].

    mainView
        owner: self;
        setName: 'mainView';
        alignRelativeToScreen;
        addModalBorderStyle;
        labelWithoutPrefix: 'Find';
        noSmalltalkMenuBar;
        framingBlock:
            (LayoutFrame new
                leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
                leftInset: -104 * xDU;
                topRatio: 1/2 / (SysFont height / 8);
                topInset: -31 * yDU;
                rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
                rightInset: -104 * xDU;
                bottomRatio: 1/2 / (SysFont height / 8);
                bottomInset: -31 * yDU).
    self addView: mainView.

    findText "AutoSelectComboBox"
        owner: self;
        setName: 'findText';
        when: #needsContents send: #searchStringFor: to: self withArgument: findText;
        when: #textChanged: send: #searchString: to: self;
        framingBlock:
            (LayoutFrame new
                leftRatio: 0; leftInset: 36 * xDU;
                topRatio: 0; topInset: 4 * yDU;
                rightRatio: 0; rightInset: -148 * xDU;
                bottomRatio: 0; bottomInset: -68 * yDU);
        dropDown;
        startGroup;
        font: msSansSerif8.
    mainView
        addSubpane: findText;
        subPaneWithFocus: findText.

    matchWholeWordsOnly "CheckBox"
        owner: self;
        setName: 'matchWholeWordsOnly';
        addClipsiblingsStyle;
        framingBlock:
            (LayoutFrame new
                leftRatio: 0; leftInset: 9/2 * xDU;
                topRatio: 0; topInset: 19 * yDU;
                rightRatio: 0; rightInset: -185/2 * xDU;
                bottomRatio: 0; bottomInset: -27 * yDU);
        contents: 'Match &whole words only';
        startGroup;
        font: msSansSerif81.
    mainView addSubpane: matchWholeWordsOnly.

    matchCase "CheckBox"
        owner: self;
        setName: 'matchCase';
        addClipsiblingsStyle;
        framingBlock:
            (LayoutFrame new
                leftRatio: 0; leftInset: 9/2 * xDU;
                topRatio: 0; topInset: 29 * yDU;
                rightRatio: 0; rightInset: -185/2 * xDU;
                bottomRatio: 0; bottomInset: -37 * yDU);
        contents: 'Match &case';
        startGroup;
        font: msSansSerif81.
    mainView addSubpane: matchCase.

    regularExpression "CheckBox"
        owner: self;
        setName: 'regularExpression';
        addClipsiblingsStyle;
        framingBlock:
            (LayoutFrame new
                leftRatio: 0; leftInset: 9/2 * xDU;
                topRatio: 0; topInset: 39 * yDU;
                rightRatio: 0; rightInset: -185/2 * xDU;
                bottomRatio: 0; bottomInset: -47 * yDU);
        contents: 'Regular &expression';
        startGroup;
        font: msSansSerif81.
    mainView addSubpane: regularExpression.

    transformBackslashExpressions "CheckBox"
        owner: self;
        setName: 'transformBackslashExpressions';
        addClipsiblingsStyle;
        framingBlock:
            (LayoutFrame new
                leftRatio: 0; leftInset: 9/2 * xDU;
                topRatio: 0; topInset: 48 * yDU;
                rightRatio: 0; rightInset: -185/2 * xDU;
                bottomRatio: 0; bottomInset: -56 * yDU);
        contents: 'Transform &backslash expressions';
        startGroup;
        font: msSansSerif81.
    mainView addSubpane: transformBackslashExpressions.

    up "RadioButton"
        owner: self;
        setName: 'up';
        addClipsiblingsStyle;
        when: #clicked: send: #setUpButton to: self;
        framingBlock:
            (LayoutFrame new
                leftRatio: 0; leftInset: 211/2 * xDU;
                topRatio: 0; topInset: 55/2 * yDU;
                rightRatio: 0; rightInset: -263/2 * xDU;
                bottomRatio: 0; bottomInset: -71/2 * yDU);
        contents: '&Up';
        startGroup;
        font: msSansSerif82.
    mainView addSubpane: up.

    down "RadioButton"
        owner: self;
        setName: 'down';
        addClipsiblingsStyle;
        when: #clicked: send: #setDownButton to: self;
        when: #needsContents send: #setDownButton to: self;
        framingBlock:
            (LayoutFrame new
                leftRatio: 0; leftInset: 211/2 * xDU;
                topRatio: 0; topInset: 75/2 * yDU;
                rightRatio: 0; rightInset: -267/2 * xDU;
                bottomRatio: 0; bottomInset: -91/2 * yDU);
        contents: '&Down';
        noTabStop;
        font: msSansSerif82.
    mainView addSubpane: down.

    findNext "Button"
        owner: self;
        setName: 'findNext';
        when: #clicked send: #findNextClicked to: self;
        framingBlock:
            (LayoutFrame new
                leftRatio: 0; leftInset: 152 * xDU;
                topRatio: 0; topInset: 4 * yDU;
                rightRatio: 0; rightInset: -204 * xDU;
                bottomRatio: 0; bottomInset: -16 * yDU);
        defaultPushButton;
        contents: '&Find Next';
        startGroup;
        font: msSansSerif83.
    mainView addSubpane: findNext.

    cancel "Button"
        owner: self;
        setName: 'cancel';
        when: #clicked send: #cancelClicked to: self;
        framingBlock:
            (LayoutFrame new
                leftRatio: 0; leftInset: 152 * xDU;
                topRatio: 0; topInset: 20 * yDU;
                rightRatio: 0; rightInset: -204 * xDU;
                bottomRatio: 0; bottomInset: -32 * yDU);
        cancelPushButton;
        contents: 'Cancel';
        startGroup;
        font: msSansSerif84.
    mainView addSubpane: cancel.

    staticText1
        owner: self;
        framingBlock:
            (LayoutFrame new
                leftRatio: 0; leftInset: 2 * xDU;
                topRatio: 0; topInset: 6 * yDU;
                rightRatio: 0; rightInset: -34 * xDU;
                bottomRatio: 0; bottomInset: -14 * yDU);
        centered;
        contents: 'Fi&nd What:';
        startGroup;
        noTabStop;
        font: msSansSerif85.
    mainView addSubpane: staticText1.

    groupBox1
        owner: self;
        framingBlock:
            (LayoutFrame new
                leftRatio: 0; leftInset: 102 * xDU;
                topRatio: 0; topInset: 20 * yDU;
                rightRatio: 0; rightInset: -148 * xDU;
                bottomRatio: 0; bottomInset: -48 * yDU);
        contents: 'Direction';
        startGroup;
        noTabStop;
        font: msSansSerif86.
    mainView addSubpane: groupBox1!  ! 
#('April 26, 2002' '10:49:20 AM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('private-scheduling' createViews )) !


!ScintillaFindDialog methods !
cancelClicked

    self close.!   ! 
#('April 26, 2002' '10:49:20 AM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('event handling' cancelClicked )) !


!ScintillaFindDialog methods !  
regularExpressionButton

    ^self paneNamed: #regularExpression! ! 
#('April 19, 2002' '02:06:44 PM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('panes' regularExpressionButton )) !


!ScintillaFindDialog methods ! 
findNextButton

    ^self paneNamed: #findNext!   ! 
#('April 19, 2002' '02:05:28 PM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog) reorganizeFrom: #(
('panes' findNextButton )) !


!ScintillaFindDialog class methods !
for: aScintillaPane

    ^self new
        textPane: aScintillaPane;
        createViewsOnce!   ! 
#('April 26, 2002' '10:49:20 AM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog class) reorganizeFrom: #(
('instance creation' for: )) !


!ScintillaFindDialog class methods !
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk 3.1.0 Win32"

	^3.1!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: ScintillaFindDialog class) reorganizeFrom: #(
('window builder' wbBasicVersion )) !




ScintillaFindDialog subclass: #ScintillaReplaceDialog
  instanceVariableNames: 
    ' replaceString replaceHistory '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants ScintillaConstants '
  categories: #( 'Tools-Scintilla Pane' )
  comment: ''!

!ScintillaReplaceDialog methods !  
replaceAllClicked

    | initialStart start end searchStringSize replaceStringSize position atLeastOneFound |
    atLeastOneFound := false.
    self isSearchInSelection
        ifTrue: [start := textPane cursorPosition min: textPane anchorPosition. end := textPane cursorPosition max: textPane anchorPosition]
        ifFalse: [start := 0. end := textPane length].

    initialStart := start. searchStringSize := self searchString size. replaceStringSize := self replaceString size.
    [
        textPane sendEditor: SCI_SETTARGETSTART with: start.
        textPane sendEditor: SCI_SETTARGETEND with: end.
        position := textPane sendEditor: SCI_SEARCHINTARGET buffer: self searchString with: searchStringSize.
        position = INVALID_POSITION ifTrue: [
            atLeastOneFound ifFalse: [^self warnSearchStringNotFound].
            self isSearchInSelection ifTrue: [textPane cursorPosition: initialStart; anchorPosition: end].
            ^self].

        atLeastOneFound := true.
        textPane sendEditor: SCI_SETTARGETSTART with: position.
        textPane sendEditor: SCI_SETTARGETEND with: position + searchStringSize.
        self isRegularExpression
            ifTrue: [textPane sendEditor: SCI_REPLACETARGETRE buffer: self replaceString with: self replaceString size]
            ifFalse: [textPane sendEditor: SCI_REPLACETARGET buffer: self replaceString with: self replaceString size].
        start := position + 1. end := end - searchStringSize + replaceStringSize.
        true] whileTrue!    ! 
#('May 3, 2002' '01:57:30 PM' nil)!

(CodeFiler organizerFor: ScintillaReplaceDialog) reorganizeFrom: #(
('event handling' replaceAllClicked )) !


!ScintillaReplaceDialog methods !   
isDown
    ^true!  ! 
#('April 25, 2002' '05:10:00 PM' nil)!

(CodeFiler organizerFor: ScintillaReplaceDialog) reorganizeFrom: #(
('options' isDown )) !


!ScintillaReplaceDialog methods !  
enableFindAndReplaceButtons

    self findNextButton enable.
    self replaceButton enable.! ! 
#('April 25, 2002' '04:15:53 PM' nil)!

(CodeFiler organizerFor: ScintillaReplaceDialog) reorganizeFrom: #(
('event handling' enableFindAndReplaceButtons )) !


!ScintillaReplaceDialog methods !  
replaceHistory: strings

    replaceHistory := strings!   ! 
#('April 26, 2002' '12:24:25 PM' nil)!

(CodeFiler organizerFor: ScintillaReplaceDialog) reorganizeFrom: #(
('string handling' replaceHistory: )) !


!ScintillaReplaceDialog methods ! 
replaceButton

    ^self paneNamed: #replace! ! 
#('April 25, 2002' '04:12:22 PM' nil)!

(CodeFiler organizerFor: ScintillaReplaceDialog) reorganizeFrom: #(
('panes' replaceButton )) !


!ScintillaReplaceDialog methods ! 
selectionButton

    ^self paneNamed: #selection! ! 
#('April 19, 2002' '05:00:12 PM' nil)!

(CodeFiler organizerFor: ScintillaReplaceDialog) reorganizeFrom: #(
('panes' selectionButton )) !


!ScintillaReplaceDialog methods !   
enableSearchInSelection

    self selectionButton enable.
    self selectionButton selection: true.
    self findNextButton disable.
    self replaceButton disable.!  ! 
#('April 25, 2002' '04:11:49 PM' nil)!

(CodeFiler organizerFor: ScintillaReplaceDialog) reorganizeFrom: #(
('event handling' enableSearchInSelection )) !


!ScintillaReplaceDialog methods !  
findNextClicked

    | newPosition |
    self isDown
        ifTrue: [
            newPosition := textPane cursorPosition max: textPane anchorPosition.
            textPane cursorPosition: newPosition; anchorPosition: newPosition]
        ifFalse: [
            newPosition := (textPane cursorPosition min: textPane anchorPosition) - 1.
            textPane cursorPosition: newPosition; anchorPosition: newPosition].

    ^self doFindNext.! ! 
#('May 3, 2002' '01:58:57 PM' nil)!

(CodeFiler organizerFor: ScintillaReplaceDialog) reorganizeFrom: #(
('event handling' findNextClicked )) !


!ScintillaReplaceDialog methods ! 
disableSearchInSelection

    self selectionButton selection: false.
    self wholeFileButton selection: true.
    self selectionButton disable.
    self findNextButton enable.
    self replaceButton enable.!  ! 
#('April 25, 2002' '04:18:06 PM' nil)!

(CodeFiler organizerFor: ScintillaReplaceDialog) reorganizeFrom: #(
('event handling' disableSearchInSelection )) !


!ScintillaReplaceDialog methods ! 
disableFindAndReplaceButtons

    self findNextButton disable.
    self replaceButton disable.!  ! 
#('April 25, 2002' '04:15:45 PM' nil)!

(CodeFiler organizerFor: ScintillaReplaceDialog) reorganizeFrom: #(
('event handling' disableFindAndReplaceButtons )) !


!ScintillaReplaceDialog methods ! 
createViews

	"WARNING!! This method was automatically generated by 
	WindowBuilder. Code you add here which does not conform to 
	the WindowBuilder API will probably be lost the next time 
	you save your layout definition."

	| cancel findNext findText groupBox1 mainView matchCase 
	matchWholeWordsOnly msSansSerif8 regularExpression replace 
	replaceAll replaceText selection staticText1 staticText2 
	transformBackslashExpressions wholeFile xDU yDU |
	
	#generated.
	xDU := (SysFont width + 1 roundTo: 2) / (SysFont width roundTo: 2).
	yDU := 1.
	mainView := self topPaneClass new.
	
		"Temporary Variables"
	cancel := Button new.
	findNext := Button new.
	findText := AutoSelectComboBox new.
	groupBox1 := GroupBox new.
	matchCase := CheckBox new.
	matchWholeWordsOnly := CheckBox new.
	regularExpression := CheckBox new.
	replace := Button new.
	replaceAll := Button new.
	replaceText := AutoSelectComboBox new.
	selection := RadioButton new.
	staticText1 := StaticText new.
	staticText2 := StaticText new.
	transformBackslashExpressions := CheckBox new.
	wholeFile := RadioButton new.
	
		"Font Definitions"
	msSansSerif8 := Font new
		fromByteArray: #[245 255 255 255 0 0 0 0 0 0 0 0 0 0 0 0 144 1 0 0 0 0 0 0 1 2 1 34 77 83 32 83 97 110 115 32 83 101 114 105 102 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ].
	
	mainView
		owner: self;
		setName: 'mainView';
		alignRelativeToScreen;
		addModalBorderStyle;
		removeSystemMenuStyle;
		labelWithoutPrefix: 'Replace';
		noSmalltalkMenuBar;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				leftInset: -106 * xDU;
				topRatio: 1/2 / (SysFont height / 8);
				topInset: -37 * yDU;
				rightRatio: 1/2 / ((SysFont width roundTo: 2) / 4);
				rightInset: -106 * xDU;
				bottomRatio: 1/2 / (SysFont height / 8);
				bottomInset: -37 * yDU).
	self addView: mainView.
	
	findText "AutoSelectComboBox"
		owner: self;
		setName: 'findText';
		when: #needsContents send: #searchStringFor: to: self withArgument: findText;
		when: #textChanged: send: #searchString: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 40 * xDU;
				topRatio: 0; topInset: 4 * yDU;
				rightRatio: 0; rightInset: -152 * xDU;
				bottomRatio: 0; bottomInset: -68 * yDU);
		dropDown;
		startGroup;
		font: msSansSerif8.
	mainView
		addSubpane: findText;
		subPaneWithFocus: findText.
	
	replaceText "AutoSelectComboBox"
		owner: self;
		setName: 'replaceText';
		addClipsiblingsStyle;
		when: #needsContents send: #replaceStringFor: to: self withArgument: replaceText;
		when: #textChanged: send: #replaceString: to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 40 * xDU;
				topRatio: 0; topInset: 18 * yDU;
				rightRatio: 0; rightInset: -152 * xDU;
				bottomRatio: 0; bottomInset: -82 * yDU);
		dropDown;
		startGroup;
		font: msSansSerif8.
	mainView addSubpane: replaceText.
	
	selection "RadioButton"
		owner: self;
		setName: 'selection';
		addClipsiblingsStyle;
		when: #clicked: send: #disableFindAndReplaceButtons to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 199/2 * xDU;
				topRatio: 0; topInset: 41 * yDU;
				rightRatio: 0; rightInset: -263/2 * xDU;
				bottomRatio: 0; bottomInset: -49 * yDU);
		contents: '&Selection';
		startGroup;
		font: msSansSerif8.
	mainView addSubpane: selection.
	
	wholeFile "RadioButton"
		owner: self;
		setName: 'wholeFile';
		addClipsiblingsStyle;
		when: #clicked: send: #enableFindAndReplaceButtons to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 199/2 * xDU;
				topRatio: 0; topInset: 51 * yDU;
				rightRatio: 0; rightInset: -267/2 * xDU;
				bottomRatio: 0; bottomInset: -59 * yDU);
		contents: 'Wh&ole file';
		noTabStop;
		font: msSansSerif8.
	mainView addSubpane: wholeFile.
	
	findNext "Button"
		owner: self;
		setName: 'findNext';
		when: #clicked send: #findNextClicked to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 156 * xDU;
				topRatio: 0; topInset: 4 * yDU;
				rightRatio: 0; rightInset: -208 * xDU;
				bottomRatio: 0; bottomInset: -16 * yDU);
		contents: '&Find Next';
		startGroup;
		font: msSansSerif8.
	mainView addSubpane: findNext.
	
	replace "Button"
		owner: self;
		setName: 'replace';
		when: #clicked send: #replaceClicked to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 156 * xDU;
				topRatio: 0; topInset: 37/2 * yDU;
				rightRatio: 0; rightInset: -208 * xDU;
				bottomRatio: 0; bottomInset: -61/2 * yDU);
		contents: '&Replace';
		startGroup;
		font: msSansSerif8.
	mainView addSubpane: replace.
	
	replaceAll "Button"
		owner: self;
		setName: 'replaceAll';
		when: #clicked send: #replaceAllClicked to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 156 * xDU;
				topRatio: 0; topInset: 67/2 * yDU;
				rightRatio: 0; rightInset: -208 * xDU;
				bottomRatio: 0; bottomInset: -91/2 * yDU);
		defaultPushButton;
		contents: 'Replace &All';
		startGroup;
		font: msSansSerif8.
	mainView addSubpane: replaceAll.
	
	cancel "Button"
		owner: self;
		setName: 'cancel';
		when: #clicked send: #cancelClicked to: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 156 * xDU;
				topRatio: 0; topInset: 48 * yDU;
				rightRatio: 0; rightInset: -208 * xDU;
				bottomRatio: 0; bottomInset: -60 * yDU);
		cancelPushButton;
		contents: 'Cancel';
		startGroup;
		font: msSansSerif8.
	mainView addSubpane: cancel.
	
	staticText1
		owner: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 3/2 * xDU;
				topRatio: 0; topInset: 6 * yDU;
				rightRatio: 0; rightInset: -63/2 * xDU;
				bottomRatio: 0; bottomInset: -14 * yDU);
		centered;
		contents: 'Fi&nd what:';
		startGroup;
		noTabStop;
		font: msSansSerif8.
	mainView addSubpane: staticText1.
	
	staticText2
		owner: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 3/2 * xDU;
				topRatio: 0; topInset: 20 * yDU;
				rightRatio: 0; rightInset: -79/2 * xDU;
				bottomRatio: 0; bottomInset: -28 * yDU);
		centered;
		contents: 'Re&place with:';
		startGroup;
		noTabStop;
		font: msSansSerif8.
	mainView addSubpane: staticText2.
	
	matchWholeWordsOnly "CheckBox"
		owner: self;
		setName: 'matchWholeWordsOnly';
		addClipsiblingsStyle;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 7/2 * xDU;
				topRatio: 0; topInset: 67/2 * yDU;
				rightRatio: 0; rightInset: -183/2 * xDU;
				bottomRatio: 0; bottomInset: -83/2 * yDU);
		contents: 'Match &whole words only';
		startGroup;
		font: msSansSerif8.
	mainView addSubpane: matchWholeWordsOnly.
	
	matchCase "CheckBox"
		owner: self;
		setName: 'matchCase';
		addClipsiblingsStyle;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 7/2 * xDU;
				topRatio: 0; topInset: 87/2 * yDU;
				rightRatio: 0; rightInset: -183/2 * xDU;
				bottomRatio: 0; bottomInset: -103/2 * yDU);
		contents: 'Match &case';
		startGroup;
		font: msSansSerif8.
	mainView addSubpane: matchCase.
	
	regularExpression "CheckBox"
		owner: self;
		setName: 'regularExpression';
		addClipsiblingsStyle;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 7/2 * xDU;
				topRatio: 0; topInset: 53 * yDU;
				rightRatio: 0; rightInset: -183/2 * xDU;
				bottomRatio: 0; bottomInset: -61 * yDU);
		contents: 'Regular &expression';
		startGroup;
		font: msSansSerif8.
	mainView addSubpane: regularExpression.
	
	transformBackslashExpressions "CheckBox"
		owner: self;
		setName: 'transformBackslashExpressions';
		addClipsiblingsStyle;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 7/2 * xDU;
				topRatio: 0; topInset: 125/2 * yDU;
				rightRatio: 0; rightInset: -183/2 * xDU;
				bottomRatio: 0; bottomInset: -141/2 * yDU);
		contents: 'Transform &backslash expressions';
		startGroup;
		font: msSansSerif8.
	mainView addSubpane: transformBackslashExpressions.
	
	groupBox1
		owner: self;
		framingBlock: 
			(LayoutFrame new
				leftRatio: 0; leftInset: 96 * xDU;
				topRatio: 0; topInset: 34 * yDU;
				rightRatio: 0; rightInset: -152 * xDU;
				bottomRatio: 0; bottomInset: -62 * yDU);
		contents: 'Replace in';
		startGroup;
		noTabStop;
		font: msSansSerif8.
	mainView addSubpane: groupBox1!   ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: ScintillaReplaceDialog) reorganizeFrom: #(
('private-scheduling' createViews )) !


!ScintillaReplaceDialog methods ! 
isSearchInWholeFile

    ^self wholeFileButton selection! ! 
#('April 19, 2002' '05:12:36 PM' nil)!

(CodeFiler organizerFor: ScintillaReplaceDialog) reorganizeFrom: #(
('options' isSearchInWholeFile )) !


!ScintillaReplaceDialog methods ! 
replaceString
    ^replaceString!  ! 
#('April 25, 2002' '05:08:13 PM' nil)!

(CodeFiler organizerFor: ScintillaReplaceDialog) reorganizeFrom: #(
('string handling' replaceString )) !


!ScintillaReplaceDialog methods !   
replaceClicked

    | position start end |
    textPane selection isEmpty ifTrue: [self findNextClicked ifFalse: [^self]]. "make sure the first one is found"
    start := textPane cursorPosition min: textPane anchorPosition. end := textPane cursorPosition max: textPane anchorPosition.
    textPane sendEditor: SCI_SETTARGETSTART with: start.
    textPane sendEditor: SCI_SETTARGETEND with: end.
    textPane sendEditor: SCI_SEARCHANCHOR.

    self isDown
        ifTrue: [position := textPane sendEditor: SCI_SEARCHNEXT buffer: self searchString with: self options]
        ifFalse: [position := textPane sendEditor: SCI_SEARCHPREV buffer: self searchString with: self options].

    position = INVALID_POSITION ifTrue: [^self warnSearchStringNotFound].

    self isRegularExpression
        ifTrue: [textPane sendEditor: SCI_REPLACETARGETRE buffer: self replaceString with: self replaceString size]
        ifFalse: [textPane sendEditor: SCI_REPLACETARGET buffer: self replaceString with: self replaceString size].

    textPane cursorPosition: start + replaceString size; anchorPosition: start + replaceString size.
    self findNextClicked!    ! 
#('May 17, 2002' '11:34:56 AM' nil)!

(CodeFiler organizerFor: ScintillaReplaceDialog) reorganizeFrom: #(
('event handling' replaceClicked )) !


!ScintillaReplaceDialog methods ! 
wholeFileButton

    ^self paneNamed: #wholeFile! ! 
#('April 19, 2002' '05:01:27 PM' nil)!

(CodeFiler organizerFor: ScintillaReplaceDialog) reorganizeFrom: #(
('panes' wholeFileButton )) !


!ScintillaReplaceDialog methods !   
isSearchInSelection

    ^self selectionButton selection! ! 
#('April 19, 2002' '05:12:44 PM' nil)!

(CodeFiler organizerFor: ScintillaReplaceDialog) reorganizeFrom: #(
('options' isSearchInSelection )) !


!ScintillaReplaceDialog methods ! 
replaceStringFor: aPane

    aPane
        contents: (Array with: replaceString), replaceHistory;
        selection: replaceString! ! 
#('April 26, 2002' '12:26:37 PM' nil)!

(CodeFiler organizerFor: ScintillaReplaceDialog) reorganizeFrom: #(
('event handling' replaceStringFor: )) !


!ScintillaReplaceDialog methods !
replaceAllButton

    ^self paneNamed: #replaceAll!   ! 
#('April 26, 2002' '12:16:18 PM' nil)!

(CodeFiler organizerFor: ScintillaReplaceDialog) reorganizeFrom: #(
('panes' replaceAllButton )) !


!ScintillaReplaceDialog methods !  
initialize
    super initialize.
    searchHistory := #().
    searchString := ''.!  ! 
#('April 19, 2002' '05:27:37 PM' nil)!

(CodeFiler organizerFor: ScintillaReplaceDialog) reorganizeFrom: #(
('initializing' initialize )) !


!ScintillaReplaceDialog methods ! 
replaceString: aString

    replaceString := aString! ! 
#('April 25, 2002' '05:11:21 PM' nil)!

(CodeFiler organizerFor: ScintillaReplaceDialog) reorganizeFrom: #(
('string handling' replaceString: )) !


!ScintillaReplaceDialog class methods !
wbBasicVersion

	"Private - Answer the WindowBuilder Pro version.
		Generated in: Visual Smalltalk 3.1.0 Win32"

	^3.1!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: ScintillaReplaceDialog class) reorganizeFrom: #(
('window builder' wbBasicVersion )) !


 

WindowDialog subclass: #SelectPersonDialog
  instanceVariableNames: 
    ' selectedPerson '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

ListDialog subclass: #SeparatedListDialog
  instanceVariableNames: 
    ' separators '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WindowDialog subclass: #WBDevelopmentDialog
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBDevelopmentDialog subclass: #WBAboutDialog
  instanceVariableNames: ''
  classVariableNames: 
    ' InitTranscript '
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants WBDevelopmentBitmaps '
  categories: #( 'PARTS and Others' )
  comment: ''!



WBDevelopmentDialog subclass: #WBAddInManager
  instanceVariableNames: 
    ' changed selection '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBDevelopmentDialog subclass: #WBAttributeEditor
  instanceVariableNames: 
    ' thePane '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBAttributeEditor subclass: #WBActionEditor
  instanceVariableNames: 
    ' action method changed author history '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



WBDevelopmentDialog subclass: #WBCallOutEditor
  instanceVariableNames: 
    ' owner callOutMap callOutList panesList selector '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBDevelopmentDialog subclass: #WBChooseClassDialog
  instanceVariableNames: 
    ' result classList classListBox default allowOthers '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



WBChooseClassDialog subclass: #WBChoosePaneDialog
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBDevelopmentDialog subclass: #WBColorDialog
  instanceVariableNames: 
    ' result foreColor backColor thePane colors '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBDevelopmentDialog subclass: #WBCreateBitmap
  instanceVariableNames: 
    ' okButton result widthField heightField keyField initialKey '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



WBCreateBitmap subclass: #WBCreateButton
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBDevelopmentDialog subclass: #WBCreateClassDialog
  instanceVariableNames: 
    ' newClass limitTo cache '
  classVariableNames: 
    ' DefaultPackage DefaultSuperClass DefaultType '
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBDevelopmentDialog subclass: #WBDefaultDialogScratchWindow
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBAttributeEditor subclass: #WBDialogEditor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



WBDevelopmentDialog subclass: #WBDialogScratchWindow
  instanceVariableNames: 
    ' model '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants WBBitmaps '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBDevelopmentDialog subclass: #WBEditClassDialog
  instanceVariableNames: 
    ' selectedClass alt mostRecent mostFrequent filter package list ok '
  classVariableNames: 
    ' Filter FilterList FrequentClasses PackageChoice RecentClasses '
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBAttributeEditor subclass: #WBEnhancedAttributeEditor
  instanceVariableNames: 
    ' thePropertyManager '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBAttributeEditor subclass: #WBEnhancedEntryFieldEditor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



WBAttributeEditor subclass: #WBFileSelectorEditor
  instanceVariableNames: 
    ' title filters descriptions fileDialog '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



WBDevelopmentDialog subclass: #WBFramingEditor
  instanceVariableNames: 
    ' result beforeScaleFactor hasFramed currentRect currentRectList parentRect largeParentRect framingParameters originXAnchor originYAnchor cornerXAnchor cornerYAnchor originYStyleFixed originYStyleScaled originXStyleFixed originXStyleScaled cornerXStyleFixed cornerXStyleScaled cornerYStyleFixed cornerYStyleScaled xCenteredCheckBox yCenteredCheckBox beforeRect afterRect leftRelative rightRelative topRelative bottomRelative '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBAttributeEditor subclass: #WBHeaderEditor
  instanceVariableNames: 
    ' width alignment image label removeButton list '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBAttributeEditor subclass: #WBLinkEditor
  instanceVariableNames: 
    ' link type '
  classVariableNames: 
    ' Descriptions '
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBDevelopmentDialog subclass: #WBListChooser
  instanceVariableNames: 
    ' reply sel '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBAttributeEditor subclass: #WBListEditor
  instanceVariableNames: 
    ' list listBox item '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBEnhancedAttributeEditor subclass: #WBListViewEditor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBDevelopmentDialog subclass: #WBMenuEditor
  instanceVariableNames: 
    ' warnedAboutAccelerators editedMenu shiftLeftButton shiftUpButton shiftDownButton shiftRightButton result hasAccelCheckBox keyShortCutEditor menuItemsEditor testItButton selectorEditor dividerState isAlt isShift isCtrl '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



WBMenuEditor subclass: #WBMenubarEditor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBListChooser subclass: #WBMultiListChooser
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBEnhancedAttributeEditor subclass: #WBProgressBarEditor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBDevelopmentDialog subclass: #WBResizeBitmap
  instanceVariableNames: 
    ' okButton newWidthField newHeightField newExtent oldExtent isButtonBitmap isResizeAll isScaled '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBColorDialog subclass: #WBRGBColorDialog
  instanceVariableNames: 
    ' elements defaults tempColors '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBEnhancedAttributeEditor subclass: #WBRichTextEditor
  instanceVariableNames: 
    ' contents '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBDevelopmentDialog subclass: #WBScrapbookRetrieve
  instanceVariableNames: 
    ' layoutPane removedQuick chapter page scrapbook '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBDevelopmentDialog subclass: #WBScrapbookStore
  instanceVariableNames: 
    ' layoutPane isQuick '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBAttributeEditor subclass: #WBScrollBarEditor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBAttributeEditor subclass: #WBStaticTextEditor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



WBAttributeEditor subclass: #WBStatusPaneEditor
  instanceVariableNames: 
    ' boxes list clipboard '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



WBEnhancedAttributeEditor subclass: #WBStatusWindowEditor
  instanceVariableNames: 
    ' statusFields width contents name type '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBEnhancedAttributeEditor subclass: #WBTabControlEditor
  instanceVariableNames: 
    ' label pageClass toolTip pages removeButton image '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



WBAttributeEditor subclass: #WBTimerEditor
  instanceVariableNames: 
    ' period '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WBAttributeEditor subclass: #WBToolBarEditor
  instanceVariableNames: 
    ' elements list useSystem clipboard '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants WBDevelopmentBitmaps '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WBEnhancedAttributeEditor subclass: #WBTrackBarEditor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBEnhancedAttributeEditor subclass: #WBTreeViewEditor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBDevelopmentDialog subclass: #WBUndoRedoDialog
  instanceVariableNames: 
    ' undoManager undoList redoList undoButton redoButton levels '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WBEnhancedAttributeEditor subclass: #WBUpDownEditor
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



WBDevelopmentDialog subclass: #WBUserInfoDialog
  instanceVariableNames: 
    ' companyField serialNumberField nameField '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



WBAttributeEditor subclass: #WBWindowEditor
  instanceVariableNames: 
    ' iconFile iconEditor '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

FrameObject subclass: #WindowFrameObject
  instanceVariableNames: 
    ' children iconFile createdBy modifiedBy '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!



WindowFrameObject subclass: #CompositeFrameObject
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

ExternalHandle variableByteSubclass: #WindowHandle
  classVariableNames: 
    ' NullWindowHandle '
  poolDictionaries: 
    ' CharacterConstants OperatingSystemConstants SystemValueConstants '
  categories: #( 'Kernel-Structures' )
  comment: ''!



Object subclass: #WindowPolicy
  instanceVariableNames: 
    ' window '
  classVariableNames: ''
  poolDictionaries: 
    ' VirtualKeyConstants '
  categories: #( 'Windows-Support' )
  comment: ''!



WindowPolicy subclass: #NoMenusWindowPolicy
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Windows-Support' )
  comment: ''!



WindowPolicy subclass: #StandardWindowPolicy
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' VirtualKeyConstants '
  categories: #( 'Windows-Support' )
  comment: ''!

!StandardWindowPolicy class methods !   
editMenu
        "Answer the standard Edit menu."
    ^Menu new
        title: '\uEdit' replaceEscapeCharacters;
        appendItem: '\uUndo\tCtrl+Z' replaceEscapeCharacters selector: #undo accelKey: $Z accelBits: AfControl;
        appendItem: '\uRedo\tCtrl+Shift+Z' replaceEscapeCharacters selector: #redo accelKey: $Z accelBits: AfControl | AfShift;

        accelKey: BackspaceKey accelBits: AfAlt for: #undo;
        appendSeparator;
        appendItem: 'Cu\ut\tCtrl+X' replaceEscapeCharacters selector: #cutSelection accelKey: $X accelBits: AfControl;
        accelKey: DeleteKey accelBits: AfShift for: #cutSelection;
        appendItem: '\uCopy\tCtrl+C' replaceEscapeCharacters selector: #copySelection accelKey: $C accelBits: AfControl;
        accelKey: InsertKey accelBits: AfControl for: #copySelection;
        appendItem: '\uPaste\tCtrl+V' replaceEscapeCharacters selector: #pasteSelection accelKey: $V accelBits: AfControl;
        accelKey: InsertKey accelBits: AfShift for: #pasteSelection;
        appendSeparator;
        appendItem: 'Cl\uear\tDel' replaceEscapeCharacters selector: #clearSelection; "accelKey: DeleteKey accelBits: 0;"
        appendItem: 'Select \uAll\tCtrl+A' replaceEscapeCharacters selector: #selectAll accelKey: $A accelBits: AfControl;
        appendItem: '\uRestore\tCtrl+R' replaceEscapeCharacters selector: #restore accelKey: $R accelBits: AfControl;
        appendSeparator;
        appendItem: '\uFind/Replace...\tCtrl+F' replaceEscapeCharacters selector: #findReplace accelKey: $F accelBits: AfControl;
        appendItem: 'Find A\ugain\tCtrl+G' replaceEscapeCharacters selector: #again accelKey: $G accelBits: AfControl;
        yourself!   ! 
#('April 26, 2002' '11:42:32 AM' nil)!

(CodeFiler organizerFor: StandardWindowPolicy class) reorganizeFrom: #(
('no category methods' editMenu )) !


 

StandardWindowPolicy subclass: #SmalltalkWindowPolicy
  instanceVariableNames: ''
  classVariableNames: 
    ' ToolItems '
  poolDictionaries: 
    ' VirtualKeyConstants '
  categories: #( 'Windows-Support' )
  comment: ''!

!SmalltalkWindowPolicy class methods !
editMenu
        "Answer the standard Edit menu for browsers."
    ^Menu new
        title: '\uEdit' replaceEscapeCharacters;
        
        appendItem: '\uUndo\tCtrl+Z' replaceEscapeCharacters selector: #undo accelKey: $Z accelBits: AfControl;
        appendItem: '\uRedo\tCtrl+Shift+Z' replaceEscapeCharacters selector: #redo accelKey: $Z accelBits: AfControl | AfShift;
        accelKey: BackspaceKey accelBits: AfAlt for: #undo;
        appendItem: '\uRestore\tCtrl+R' replaceEscapeCharacters selector: #restore accelKey: $R accelBits: AfControl;
        appendSeparator;
        
        appendItem: 'Cu\ut\tCtrl+X' replaceEscapeCharacters selector: #cutSelection accelKey: $X accelBits: AfControl;
        accelKey: DeleteKey accelBits: AfShift for: #cutSelection;
        appendItem: '\uCopy\tCtrl+C' replaceEscapeCharacters selector: #copySelection accelKey: $C accelBits: AfControl;
        accelKey: InsertKey accelBits: AfControl for: #copySelection;
        appendItem: '\uPaste\tCtrl+V' replaceEscapeCharacters selector: #pasteSelection accelKey: $V accelBits: AfControl;
        accelKey: InsertKey accelBits: AfShift for: #pasteSelection;
        appendSeparator;
        
        appendItem: 'Select \uAll\tCtrl+A' replaceEscapeCharacters selector: #selectAll accelKey: $A accelBits: AfControl;
        appendSeparator;
        
        appendItem: '\uFind...\tCtrl+F' replaceEscapeCharacters selector: #beginFind accelKey: $F accelBits: AfControl;
        appendItem: '\uReplace...\tCtrl+H' replaceEscapeCharacters selector: #beginReplace accelKey: $H accelBits: AfControl;
        appendItem: 'Find A\ugain\tCtrl+G' replaceEscapeCharacters selector: #again accelKey: $G accelBits: AfControl;
        accelKey: F3Key accelBits: 0 for: #again;
        yourself!   ! 
#('April 26, 2002' '11:41:18 AM' nil)!

(CodeFiler organizerFor: SmalltalkWindowPolicy class) reorganizeFrom: #(
('no category methods' editMenu )) !


!SmalltalkWindowPolicy class methods !  
addSmalltalkToolItemsTo: aMenu
        "Private - add menu items that launch development tools to aMenu."
    aMenu
        appendItem: 'New \uWorkspace\tCtrl+W' replaceEscapeCharacters selector: #openWorkspace accelKey: $W accelBits: AfControl;
        appendItem: '\uBrowse Classes\tCtrl+B' replaceEscapeCharacters selector: #openNavigatorBrowser accelKey: $B accelBits: AfControl;
        appendItem: '\uBrowse Hierarchy\tAlt+H' replaceEscapeCharacters selector: #openClassBrowser accelKey: $H accelBits: AfAlt;
        appendItem: 'Browse Dis\uk\tCtrl+K' replaceEscapeCharacters selector: #openDiskBrowser accelKey: $K accelBits: AfControl;
        appendItem: 'Browse Se\urvices' replaceEscapeCharacters selector: #openServiceManagerWindow;
        appendSeparator;
        appendItem: 'Compress Changes...' selector: #compressChanges;
        appendItem: 'Compress Sources...' selector: #compressSources.

    self toolItems do: [ :item |
        aMenu appendItem: ( item at: 1 ) action: ( item at: 2 ) commandKey: ( item at: 3 ) ]! ! 
#('April 26, 2002' '11:41:59 AM' nil)!

(CodeFiler organizerFor: SmalltalkWindowPolicy class) reorganizeFrom: #(
('no category methods' addSmalltalkToolItemsTo: )) !




ExternalBuffer subclass: #WinDrawItemStruct
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Kernel-Structures' )
  comment: ''!

  

ExternalBuffer subclass: #WinEditStream
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' WinCommonControlConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  
WinFileTime class instanceVariableNames: ''
  categories: #( )
  comment: ''!

   

ExternalBuffer subclass: #WinFormatRange
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' WinCommonControlConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

 

ExternalBuffer subclass: #WinHdItem
  instanceVariableNames: 
    ' address '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



ExternalBuffer subclass: #WinLogBrush
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!



ExternalBuffer subclass: #WinLogFont
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!

 

Object subclass: #WinLogicalObject
  instanceVariableNames: 
    ' handle stockObject '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!

 

WinLogicalObject subclass: #WinLogicalBrush
  instanceVariableNames: 
    ' style color hatch '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'Kernel-Structures' )
  comment: ''!

  

WinLogicalObject subclass: #WinLogicalPalette
  instanceVariableNames: 
    ' logPalette '
  classVariableNames: ''
  poolDictionaries: 
    ' OperatingSystemConstants '
  categories: #( 'Kernel-Structures' )
  comment: ''!

  

WinLogicalObject subclass: #WinLogicalPen
  instanceVariableNames: 
    ' style width color '
  classVariableNames: ''
  poolDictionaries: 
    ' ColorConstants OperatingSystemConstants '
  categories: #( 'Kernel-Structures' )
  comment: ''!



ExternalBuffer subclass: #WinLogPalette
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!

  

ExternalBuffer subclass: #WinLogPen
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!

  

ExternalBuffer subclass: #WinLvColumn
  instanceVariableNames: 
    ' address '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

ExternalBuffer subclass: #WinLvItem
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

ExternalBuffer subclass: #WinMeasureItemStruct
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!

   

ExternalBuffer subclass: #WinMessage
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!

 

ExternalBuffer subclass: #WinMetafileheader
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!

  

ExternalBuffer subclass: #WinMetafilepict
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!



ExternalBuffer subclass: #WinMetaheader
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!

  

ExternalBuffer subclass: #WinMinmaxinfo
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!

  

ExternalBuffer subclass: #WinNmhdr
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!

   

WinNmhdr subclass: #WinHdNotify
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WinNmhdr subclass: #WinLvDispinfo
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WinNmhdr subclass: #WinLvKeydown
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

WinNmhdr subclass: #WinNmListview
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WinNmhdr subclass: #WinNmTreeview
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 
WinOfstruct class instanceVariableNames: ''
  categories: #( )
  comment: ''!

   

ExternalBuffer subclass: #WinPaintStructure
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!

  

ExternalBuffer subclass: #WinPaletteEntry
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!



ExternalBuffer subclass: #WinParaFormat
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    ' WinCommonControlConstants '
  categories: #( 'PARTS and Others' )
  comment: ''!

  

ExternalBuffer subclass: #WinPoint
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!

   

ExternalBuffer subclass: #WinRectangle
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!

   

ExternalBuffer subclass: #WinStructArray
  instanceVariableNames: 
    ' collection '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!

   
WinSystemTime class instanceVariableNames: ''
  categories: #( )
  comment: ''!

 

ExternalBuffer subclass: #WinTbAddBitmap
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

ExternalBuffer subclass: #WinTbButton
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WinNmhdr subclass: #WinTbNotify
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

ExternalBuffer subclass: #WinTbSaveParams
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

ExternalBuffer subclass: #WinTcItem
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

ExternalBuffer subclass: #WinTextMetrics
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!

 

ExternalBuffer subclass: #WinToolinfo
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

WinNmhdr subclass: #WinTooltiptext
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!



WinNmhdr subclass: #WinTvDispinfo
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

 

ExternalBuffer subclass: #WinTvInsertstruct
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

ExternalBuffer subclass: #WinTvItem
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

   

WinNmhdr subclass: #WinTvKeydown
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'PARTS and Others' )
  comment: ''!

  

ExternalBuffer subclass: #WinWindowClass
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!

 

ExternalBuffer subclass: #WinWindowPlacement
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Structures' )
  comment: ''!

 

TextPaneErrorHandler subclass: #WorkspaceErrorHandler
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Compiler Support' )
  comment: ''!

  

ExpressionEvaluator subclass: #WorkspaceExpressionEvaluator
  instanceVariableNames: 
    ' pools variableDictionary compiler compilationScope '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Kernel-Messages' )
  comment: ''!

!WorkspaceExpressionEvaluator methods !   
evaluate: aString ifError: errorBlock
        "Private - evaluate aString as compiled Smalltalk source code.
        If a compilation error occurs, answer the result of evaluating
        errorBlock, otherwise answer the result of the evaluation."
    | c compileResult |
    c := self compiler nameScope: self compilationScope.
    SourceManager current
        logString: aString
        for: [
            compileResult := c evaluate: aString.
            compileResult wasSuccessful ifFalse: [ ^errorBlock value ] ].
    ^compileResult value
! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: WorkspaceExpressionEvaluator) reorganizeFrom: #(
('no category methods' evaluate:ifError: )) !


 
WorldGlobal class instanceVariableNames: ''
  categories: #( )
  comment: ''!

!WorldGlobal class methods !   
oneMillimeter
    ^0.001!  ! 
#('December 27, 2016' '03:21:55 PM' nil)!

(CodeFiler organizerFor: WorldGlobal class) reorganizeFrom: #(
('globals' oneMillimeter )) !


!WorldGlobal class methods !  
negativeEpsilon
    ^self epsilon negated! ! 
#('December 27, 2016' '03:21:25 PM' nil)!

(CodeFiler organizerFor: WorldGlobal class) reorganizeFrom: #(
('globals' negativeEpsilon )) !


!WorldGlobal class methods !
epsilon
    ^1.0e-6!   ! 
#('December 27, 2016' '03:19:34 PM' nil)!

(CodeFiler organizerFor: WorldGlobal class) reorganizeFrom: #(
('globals' epsilon )) !


!WorldGlobal class methods !
largeEpsilonSquared
    ^self largeEpsilon * self largeEpsilon!    ! 
#('December 27, 2016' '03:20:36 PM' nil)!

(CodeFiler organizerFor: WorldGlobal class) reorganizeFrom: #(
('globals' largeEpsilonSquared )) !


!WorldGlobal class methods !
largeEpsilon
    ^1.0e-3!  ! 
#('December 27, 2016' '03:20:02 PM' nil)!

(CodeFiler organizerFor: WorldGlobal class) reorganizeFrom: #(
('globals' largeEpsilon )) !


!WorldGlobal class methods !   
veryLargeEpsilon
    ^0.01!    ! 
#('December 27, 2016' '03:23:06 PM' nil)!

(CodeFiler organizerFor: WorldGlobal class) reorganizeFrom: #(
('globals' veryLargeEpsilon )) !


   

Stream subclass: #WriteStream
  instanceVariableNames: 
    ' writeLimit '
  classVariableNames: ''
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'Base-Streams' )
  comment: ''!

!WriteStream methods !   
print: anObject
    "Ask anObject to print itself on self"

    ^anObject printOn: self! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: WriteStream) reorganizeFrom: #(
('extensions' print: )) !


!WriteStream methods !
<< anObject
    anObject isCharacter ifTrue: [^self nextPut: anObject].
    anObject isString ifTrue: [^self nextPutAll: anObject].
    self print: anObject!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: WriteStream) reorganizeFrom: #(
('extensions' << )) !


!WriteStream methods !
space: number
    number timesRepeat: [self space]!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: WriteStream) reorganizeFrom: #(
('extensions' space: )) !


!WriteStream methods !
store: anObject
    "Ask anObject to store itself on self"

    ^anObject storeOn: self! ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: WriteStream) reorganizeFrom: #(
('extensions' store: )) !


!WriteStream methods !
crIndent: indent
    self cr. indent timesRepeat: [self space].!   ! 
#('September 19, 2001' '12:29:34 PM' nil)!

(CodeFiler organizerFor: WriteStream) reorganizeFrom: #(
('extensions' crIndent: )) !


!WriteStream methods !  
crtab: tabs
    self cr. tabs timesRepeat: [self tab].!    ! 
#('February 5, 2003' '10:31:56 AM' nil)!

(CodeFiler organizerFor: WriteStream) reorganizeFrom: #(
('extensions' crtab: )) !


 

WriteStream subclass: #ReadWriteStream
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Base-Streams' )
  comment: ''!

!ReadWriteStream methods !  
nextFourBytesAsInteger

    | answer |
    answer := 0.
    #( 1 256 65536 16777216 ) do: [ : n |
        answer := answer + (self nextByte* n)].
    ^answer!    ! 
#('January 1, 1970' '01:01:01 AM' nil)!

(CodeFiler organizerFor: ReadWriteStream) reorganizeFrom: #(
('extensions' nextFourBytesAsInteger )) !


  

ReadWriteStream subclass: #FileStream
  instanceVariableNames: 
    ' file pageStart writtenOn lastByte lineDelimiter '
  classVariableNames: 
    ' PartialReadHeaderSize PartialReadThreshold '
  poolDictionaries: 
    ' CharacterConstants '
  categories: #( 'Base-Streams' )
  comment: ''!

!FileStream methods ! 
nextChunk
        "Answer a String up to '!!!!', undoubling embedded !!!!'s.
         Trailing white space is skipped.  The methods in
         sources.sml and change.log are in chunk format."
    | answer in str |
    answer := super nextChunk.
    self lineDelimiter == Cr ifTrue: [^answer].
    in := ReadStream on: answer.
    answer := WriteStream on: (String new: answer size).
    [in atEnd] whileFalse: [
        str := in upTo: Lf.
        (str at: str size) = Cr
            ifTrue: [str := str copyFrom: 1 to: str size - 1].
        answer nextPutAll: str].
    ^answer contents!    ! 
#('November 22, 2001' '02:45:31 PM' nil)!

(CodeFiler organizerFor: FileStream) reorganizeFrom: #(
('no category methods' nextChunk )) !
CodeFiler systemOrganizer: (ClassBasedOrganizer fromArray: #(
('Base-Collections' Array Array2D Bag BucketHashTable ByteArray Collection Dictionary DoubleByteString DoubleByteSymbol FixedSizeCollection HashedCollection HashTable IdentityDictionary IdentityDictionary2D IdentitySet IdentitySortedCollection IndexedCollection Interval
        LinearHashTable LinearIdentityHashTable LinearInlineHashTable LinearSymbolHashTable MethodDictionary MonitoredCollection OrderedCollection OrderedDictionary OrderedIdentityDictionary PriorityQueue Set SortedCollection SparseRectangleArray String Symbol
        SymbolSet)
('Base-Magnitudes' Association Character Date FixedPoint Float Fraction Integer LargeInteger LargeNegativeInteger LargePositiveInteger Magnitude Number Point Point3D RandomNumberStream Rectangle SmallInteger Time TimeStamp)
('Base-Streams' FileStream MixedFileStream ReadStream ReadWriteStream Stream StringDictionaryReader WriteStream)
('Base-Files' Directory File FileSearchResults FileSystemComponent FileSystemContainer FileSystemEntity FileSystemLocator FileSystemPath FileVolume NetworkFilePath)
('Base-Graphics' Bitmap Color DIB GraphicsMedium GraphicsTool IndexedColor Pen Printer RecordingPen RGBColor Screen StoredPicture TextTool)
('Base-Text' Pattern StringModel TextSelection WildPattern)
('Kernel-Objects' BlockClosure Boolean Context False HomeContext Object OneArgumentBlock True TwoArgumentBlock ZeroArgumentBlock)
('Kernel-Behaviors' Behavior Class MetaClass PoolDictionary)
('Kernel-Delegation' ContainerObject DelegationObject SelfInitializingObject)
('Kernel-Messages' ExpressionEvaluator Message MethodExecutor ScintillaExpressionEvaluator WorkspaceExpressionEvaluator)
('Kernel-Source Management' ClassInstaller DefinitionInstaller LibrarySourceReference ObjectMutator SourceChunkReference SourceManager StreamReference StringReference SystemStreamReference)
('Kernel-Processes and Events' ActionSequence CollectionAccessor ConstantAccessor EvaluableAction EventManager InputEvent KeyboardInputEvent LinkMessage Process ProcessScheduler Semaphore SharedBoolean SharedValue Timer UnregisteredEvent)
('Kernel-Exception Handling' APICallEntryPointNotFound APICallError APICallInvalidArgumentType APICallUnknownPrimitiveFailure ArithmeticError BindDuplicate BindError ClassShapeMismatch ControlError Error Exception ExceptionFilter ExceptionHandler ExceptionSet FileAlreadyExists FileError
        FileErrorWriteProtected FileSharingViolation FileSystemAccessDenied HostFileSystemError KeyboardInterrupt LoggedWarning MessageNotUnderstood Notification ProcessTermination ProgressNotification ProtectedFrameMarker RecompilationNotification TooManyOpenFiles
        UnresolvedExternal VetoAction Warning ZeroDivide)
('Kernel-Compiler Support' BlockDescription CompilationError CompilationResult CompiledInitializer CompiledMethod CompiledMethodDefinition CompilerErrorHandler CompilerInterface CompilerNameScope DictionaryScope GlobalPoolScope HaltingErrorHandler MultiplePoolScope NonInteractiveErrorHandler
        SilentErrorHandler TextPaneErrorHandler TraditionalCompilerErrorHandler VariableLocator VariableLocatorNoSource WorkspaceErrorHandler)
('Kernel-Special Objects' DeletedClass EmptySlot Ephemeron EphemeronDictionary NotificationManager ResidueObject ServiceRegistry SessionModel SystemDictionary SystemWeakRegistries UndefinedObject VirtualMachineConfiguration WeakKeyedRegistry WeakLinearHashTable WeakRegistry)
('Kernel-Host Interfaces' CallBack ClipboardManager CursorManager Font HelpManager Icon NationalLanguageSupport OperatingSystemInformation)
('Kernel-Structures' Atom CallBack16 DeviceContext ExternalAddress ExternalBuffer ExternalGlobalAddress ExternalGlobalHandle ExternalHandle ExternalHeapAddress ExternalHeapHandle ExternalLong ExternalMemoryHandle ExternalSegmentedAddress FileHandle SelfDefinedStructure Win32FindData
        WinBitmapFileHeader WinBitmapInfo WinBitmapInfoHeader WinBitmapStruct WinColorref WinDialogInfo WindowHandle WinDrawItemStruct WinFileTime WinLargeInteger WinLogBrush WinLogFont WinLogicalBrush WinLogicalObject WinLogicalPalette WinLogicalPen WinLogPalette
        WinLogPen WinMeasureItemStruct WinMemorystatus WinMessage WinMetafileheader WinMetafilepict WinMetaheader WinMinmaxinfo WinNmhdr WinOfstruct WinPaintStructure WinPaletteEntry WinPoint WinRectangle WinStructArray WinSystemTime WinTextMetrics WinWindowClass
        WinWindowPlacement)
('Kernel-DLLs' CommonControlsDLL CommonDialogDLL DynamicLinkLibrary DynamicLinkLibrary16 GDIDLL KernelDLL KernelDLL16 ShellDLL ThunkWin32sDLL ThunkWin95DLL UserDLL VirtualMachineDLL VirtualMachineExe WNetDLL)
('Kernel-Object Libraries' ObjectStore ObjectStoreExternal ObjectStoreReader SmalltalkLibrary SmalltalkLibraryBinder)
('Windows-Views' ApplicationCoordinator ApplicationWindow ControlWindow DialogCoordinator DialogTopPane DialogWindow ListChooser MainWindow MenuWindow ObjectWindow SystemWindow TersecriptWindow TextWindow TopPane TranscriptWindow ViewManager WalkbackWindow Window)
('Windows-SubPanes' AutoSelectComboBox AutoSelectComboEntryField Button CheckBox ColorMultipleSelectListBox ComboBox ComboEntryField ControlPane DrawnButton DropDownList EllipticSkinBox EntryField GraphPane GroupBox GroupPane ListBox ListPane MultipleSelectListBox PagedRangeControl
        RadioButton RangeControl RectangularSkinBox ScrollBar StaticBox StaticGraphic StaticPane StaticText SubPane TextEdit TextPane TextPaneControl ThreeStateButton Toggle Window)
('Windows-Dialogs' AboutDialog ChooseManyDialog ChooseOneDialog ColorDialog CommonSystemDialog DialogBox FileDialog FindReplaceDialog FontDialog MessageBox NewSubclassDialog PrintAbortDialog PrintDialog ProgressIndicatorDialog ProgressIndicatorDialogThatWorks Prompter PrompterDialog
        SaveImageAsDialog SaveImageDialog WindowDialog)
('Windows-Support' CompositeLayout ComputedLayout DialogLayoutFrame DragDropObject DragDropSession LayoutFrame LayoutUnit LocalDragDropObject LocalDragDropSession Menu MenuItem NoMenusWindowPolicy SmalltalkWindowPolicy StandardWindowPolicy WindowPolicy)
('Services-Service Manager' InitializationFile InitializationFileSection Service ServiceManager ServiceManagerWindow)
('PARTS and Others' AboutToReplaceFile ActionButton AddressEditorPane AddressPane AddressPaneTester AviVideo BitEditor ButtonEditor ButtonListBox ButtonListBoxItem CdAudio CheckBoxGroup CodeGenerationPrivateServices ColumnListBox CompositeFrameObject CompositePane DictionaryEditorPane
        EnhancedEntryField EntryFieldGroup ExtendedListBox FrameObject FramingParameters GroupPropertyAccessor Header HeaderItem HeaderTester ImageList LinkButton LinkPropertyAccessor ListConnectionPane ListDialog ListEditorPane ListItem ListView ListViewItem
        MaskedStylePropertyAccessor MciDevice MciFileStream MciStream ModelObjectTest MultimediaDLL MultiSelectListDialog NamePane ObjectChangeMap ObjectDumper ObjectFiler ObjectLibrary ObjectLoadDialog ObjectLoader ObjectPropertyAccessor ObjectReference ObjectStoreFile
        ObjectStoreFileExternal ObjectStoreFileObjects ObjectStoreFileWithVersion ObjectStoreObject ObjectStoreObjects ObjectStoreRoot ObjectStoreSpace ObjectStoreSpaceExternals ObjectStoreWithClient ObjectStoreWriter OkCancelPane PActionButton PaneTester PAnimationPane
        PARTSAddObject PARTSAddObjectDialog PARTSAddPartObject PARTSAddPartSession PARTSAliasLink PARTSAliasMessage PARTSAlphabeticEntryFieldPart PARTSAnyFileDialog PARTSAnyFileDialogPart PARTSApplication PARTSApplicationCoordinator PARTSApplicationHolder PARTSApplicationLoadError
        PARTSApplicationProperty PARTSArrayEditor PARTSArrayHolderPart PARTSBackgroundColorSettingsEditor PARTSBaseNotebook PARTSBitEditor PARTSCatalog PARTSCatalogDragSession PARTSCheckBoxPart PARTSChooseFileDialog PARTSClipboardAccessorPart PARTSCodeGeneratorInterface
        PARTSCodeGeneratorReaderInterface PARTSCodeGeneratorWriterInterface PARTSCollectionHolder PARTSComboBoxPart PARTSComboEntryField PARTSCommonPropertiesEditor PARTSComparisonPart PARTSComputationPart PARTSConfirmerPart PARTSConfirmerWithCancelPart PARTSContentsEditor
        PARTSConversionPart PARTSCurrencyEntryFieldPart PARTSCursorManager PARTSCyclicReference PARTSDateEntryFieldPart PARTSDeveloperDebugger PARTSDevelopmentSessionManager PARTSDial PARTSDialEditor PARTSDialog PARTSDialogTopPane PARTSDialogWindowPart PARTSDialPanePart
        PARTSDictionaryEditor PARTSDictionaryHolderPart PARTSDiskAccessorPart PARTSDosDirectory PARTSDosFileDescriptor PARTSDragDropSpec PARTSDragResult PARTSDragSession PARTSDrawnButtonPart PARTSDropDownListPart PARTSEditMenu PARTSEditor PARTSEditorMoveObject
        PARTSEditorMoveSession PARTSEditorState PARTSEmptyFile PARTSEntryFieldPart PARTSException PARTSExecutablePartFileProcessor PARTSExeFileProcessor PARTSExpressionEntryField PARTSExtentEditor PARTSFieldOrderDialog PARTSFile PARTSFileAccessorPart PARTSFileDescriptor
        PARTSFileDialog PARTSFileDialogPart PARTSFileMenu PARTSFileNotFound PARTSFileOperationContext PARTSFileProcessor PARTSFileType PARTSFileVersion PARTSFixedDecimalEntryFieldPart PARTSFloatEntryFieldPart PARTSFormattedEntryField PARTSFormGenerator PARTSFormGeneratorItem
        PARTSFramer PARTSGetExecutionContext PARTSGraphPanePart PARTSGroupPane PARTSGroupPanePart PARTSGroupPanePropertiesEditor PARTSHelpManager PARTSHelpMenu PARTSHostInterface PARTSIcon PARTSIconEditor PARTSIconEditorWindows PARTSIconPane PARTSIncorrectVersion
        PARTSInformationDialogPart PARTSIniFile PARTSIntegerEntryFieldPart PARTSInterfaceList PARTSInvalidApplication PARTSInvalidExternalDataItemSize PARTSLaunchPadPart PARTSLink PARTSLinkColorSettingsEditor PARTSLinkEditState PARTSLinkJunctionPart PARTSLinkReference
        PARTSLinkSettings PARTSListPanePart PARTSLoadContext PARTSLocalDragDropObject PARTSLocalDragDropSession PARTSMenuBar PARTSMenuBitmapItemPart PARTSMenuItemPane PARTSMenuLabelPart PARTSMenuPaneWindows PARTSMenuPart PARTSMenuSeparatorPart PARTSMenuTextItemPart
        PARTSMenuWindow PARTSMessageBox PARTSMessageNotUnderstood PARTSMirrorCopyDictionary PARTSMouseButtonsSettingsEditor PARTSMultipleChoiceListPart PARTSNestedPart PARTSNestedPartBrowser PARTSNestedPartLoadError PARTSNonvisualPart PARTSNonvisualPartPropertyDialog
        PARTSNotebook PARTSNotebookClientAreaPane PARTSNotebookPage PARTSNotebookPageAttributes PARTSNotebookPagePane PARTSNotOnSearchPath PARTSNumberHolderPart PARTSNumericField PARTSOpenDialogWindowPropertiesEditor PARTSOpenSaveFileDialog PARTSOpenWindowPropertiesEditor
        PARTSOrderedCollectionEditor PARTSOrderedCollectionHolderPart PARTSOrderedGroupPane PARTSOrderedVisualPartPropertyDialog PARTSPane PARTSPartAccessorPart PARTSPartBrowser PARTSPartFileProcessor PARTSPartPropertiesEditor PARTSPartPropertyDialog PARTSPartPropertySubdialog
        PARTSPasteObject PARTSPasteSession PARTSPathSequenceEditor PARTSPhoneNumberEntryFieldPart PARTSPictureFieldPart PARTSPictureMaskEditor PARTSPointEditor PARTSPopupWindowOS2 PARTSPopupWindowWindows PARTSPrebuiltDialog PARTSPrebuiltDialogTopPane PARTSPrebuiltMessageBox
        PARTSPrinterPart PARTSPrompter PARTSPrompterPart PARTSPropertiesEditor PARTSPropertyBinaryStyle PARTSPropertyBoolean PARTSPropertyButton PARTSPropertyButtonGroup PARTSPropertyButtonGroupWS PARTSPropertyButtonGroupWSExtended PARTSPropertyColorAndFont PARTSPropertyCreateForm
        PARTSPropertyCreateTable PARTSPropertyDateFormat PARTSPropertyDragDrop PARTSPropertyEditButton PARTSPropertyExpression PARTSPropertyFixedList PARTSPropertyFormattedString PARTSPropertyFormGeneratorButton PARTSPropertyGraphic PARTSPropertyIcon PARTSPropertyLineOfButtons
        PARTSPropertyList PARTSPropertyMenuAccelerator PARTSPropertyNumber PARTSPropertyPseudoStyle PARTSPropertySequenceChildren PARTSPropertyStaticText PARTSPropertyString PARTSPropertyStructure PARTSPropertyText PARTSPropertyUnit PARTSPropertyWindowStyle PARTSPushButtonPart
        PARTSRadioButtonPart PARTSReferenceBrowser PARTSRelativeLayoutDialog PARTSRepeatDropSession PARTSRuntimeSessionManager PARTSScenario PARTSScenarioComment PARTSScenarioEditor PARTSScenarioPairs PARTSScript PARTSScriptCompilerInterface PARTSScriptContext
        PARTSScriptDefinition PARTSScriptDictionary PARTSScriptSource PARTSScrollPane PARTSSequenceEditor PARTSSessionManager PARTSSettings PARTSSettingsEditor PARTSSettingsViewer PARTSSilentErrorHandler PARTSSimpleRichTextEditor PARTSSimpleTextEditor PARTSSizeWindowPart
        PARTSSmalltalkLibraryFileProcessor PARTSSourceFileProcessor PARTSSpeakerDLL PARTSSpeakerPart PARTSStandardBracketsMenu PARTSStandardEditMenu PARTSStandardFileMenu PARTSStandardHelpMenu PARTSStandardMenu PARTSStarterWindow PARTSStarterWindowWindows PARTSStaticGraphicPart
        PARTSStaticTextPart PARTSStoreContext PARTSStringHolderPart PARTSStringTemplate PARTSStringTemplatePart PARTSSublinkReference PARTSTabControlPagePart PARTSTabControlPart PARTSTabOrderEditor PARTSTeamVNestedPartBrowser PARTSTextIcon PARTSTextPaneErrorHandler
        PARTSTextPanePart PARTSTextWindow PARTSTimerPart PARTSTimerWindow PARTSTimeStamp PARTSToolbarButtonPart PARTSToolbarItem PARTSToolbarSeparatorPart PARTSToolbarToggleButtonPart PARTSToolboxPart PARTSToolContainer PARTSToolPane PARTSTopPane PARTSTypedValueHolder
        PARTSUpgradeObject PARTSUpgradePanePart PARTSUpgradeTablePane PARTSUpgradeVisualPart PARTSValueHolderPart PARTSVisualPartPropertyDialog PARTSWindow PARTSWindowPart PARTSWindowSizeEditor PARTSWorkbenchSessionManager PARTSWrapper PButton PButtonListBox
        PCheckBox PCheckBoxGroup PColumnListBox PComboBox PCompositePane PDrawnButton PDropDownList PEllipticSkinBox PEnhancedEntryField PEntryField PEntryFieldGroup PersonEditor PersonEditorPane PersonPane PersonPaneTester PFormattedEntryField PGenericSubpane
        PGraphPane PGroupbox PGroupBox PHeader PLinkButton PListBox PListPane PListView PMultipleSelectListBox PProgressBar PRadioButton PRadioButtonGroup PRealWidgetControl PRectangularSkinBox PRichEdit ProgressBar PropertyAccessor PropertyInterface PropertyManager
        PropertyPage PScrollBar PSpinButton PStaticBox PStaticGraphic PStaticText PStatusPane PStatusWindow PTabControl PTextEdit PTextPane PThreeStateButton PToggle PTrackBar PTreeView PUpDown PVideoPane PWBHorizontalScrollBar PWBInvisibleGroupPane PWBStaticGraphic
        PWBToolBar PWBVerticalScrollBar RadioButtonDialog RadioButtonGroup RichEdit RichEdit32DLL RichEditParagraphFormatDialog RichEditTabStopDialog SelectorPropertyAccessor SelectPersonDialog SeparatedListDialog SexPane SmalltalkLibraryBuilder SmalltalkLibraryObjects
        SmalltalkLibraryReporter SpinButton SpinButtonEntryField StatusBox StatusField StatusPane StatusWindow StylePropertyAccessor TabControl TabControlItem TabControlPage Tool Toolbar ToolbarButton ToolbarItem ToolbarSeparator ToolbarToggleButton ToolPane
        ToolTip TrackBar TreeView TreeViewItem UnknownImport UpDown UpgraderForDirectory UpgraderForFile VideoPane WaveAudio WBAboutDialog WBAbstractAddInModule WBAbstractCodeModule WBAbstractCreateViewsModule WBAbstractPrompter WBAction WBActionEditor WBActionLinkAddInModule
        WBAddInManager WBAddress WBApplicationCoordinatorMenuModule WBApplicationCoordinatorModule WBAttributeEditor WBAttributeWindow WBBasicCodeModule WBBitmapEditorCompositePane WBBitmapManager WBBitmapManagerWindow WBBitmapPool WBBitmapSubPool WBCallOutEditor
        WBCallOutModule WBChooseClassDialog WBChoosePaneDialog WBClassDefinition WBCodeGenBase WBCodeGenerator WBCodeModule WBCodePolicy WBCodeStream WBColorDialog WBComboBox WBComboEntryField WBCompositeMenuModule WBCompositePaneExampleAddInModule WBCompositePaneModule
        WBCompositePaneScratchWindow WBCompositePaneTester WBCreateBitmap WBCreateButton WBCreateClassDialog WBCreateMenuModule WBCreatePowerMenuModule WBCreatePowerViewModule WBCreatePowerViewsModule WBCreateViewModule WBCreateViewsModule WBCreateViewsStubModule
        WBDefaultCompositePaneScratchWindow WBDefaultDialogScratchWindow WBDefaultScratchWindow WBDescriptor WBDevelopmentCompositePane WBDevelopmentDialog WBDevelopmentObject WBDevelopmentSubPane WBDevelopmentWindow WBDialogEditor WBDialogScratchWindow WBDialogTopPane
        WBDisplayContext WBDrawnButton WBEditClassDialog WBEnhancedAttributeEditor WBEnhancedEntryFieldEditor WBEntryField WBEntryListPrompter WBENVYCodePolicy WBEventArgumentDescription WBEventDescription WBEventHandlerStubModule WBEventManagerWindow WBEventMap
        WBEventMessage WBEventTranslationEditor WBEventTranslator WBFileSelectorEditor WBFontEditorCompositePane WBFontManager WBFontManagerWindow WBFontPool WBFontSelectionWindow WBFontSubPool WBFramerExample WBFramingEditor WBGeometryManager WBGraphicObject
        WBGroupBox WBHandle WBHeaderEditor WBHorizontalScrollBar WBInstVarGetModule WBInstVarObject WBInstVarSetModule WBInterfaceObject WBKeyAccel WBKeyEntryField WBLayoutCodeModule WBLayoutForm WBLayoutFrameEditor WBLayoutWizard WBLinkEditor WBListBox WBListChooser
        WBListEditor WBListEntryField WBListViewEditor WBLocator WBLookPolicy WBLookPolicyOS2 WBLookPolicyWin31 WBLookPolicyWin95 WBManagedPFont WBManagedPNLSString WBManagedPValue WBMenu WBMenubarEditor WBMenuEditor WBMenuItem WBMenuItemStub WBMenuTester WBMessage
        WBMethodStubModule WBMiniBrowserExample WBModelBasicSetModule WBModelCodeModule WBModelDefinitionEditor WBModelEventsTriggeredModule WBModelGetModule WBModelInitializeModule WBModelInstVar WBModelObjectEditor WBModelSetModule WBModelTriggerEventModule
        WBMultiListChooser WBMultiToolPalette WBMultiViewAddInModule WBName WBNLSDictionaryReader WBNLSEditorCompositePane WBNLSExtractionTranslator WBNLSManager WBNLSManagerWindow WBNLSPool WBNLSReplacementTranslator WBNLSSubPool WBNLSTranslator WBObject WBOldEventHandlerStubModule
        WBOpenMethodModule WBOrderedCollection WBOutboardAttributeWindow WBOutboardWindow WBPartEvent WBPartEventsModule WBPartEventsTriggeredModule WBPartMessage WBPartMessagesModule WBPARTSEventList WBPARTSInterfaceEditor WBPARTSInterfaceList WBPARTSMessageList
        WBPartsModule WBPerson WBPlaceHolderObject WBPMenu WBPMenubar WBPMenuItem WBPool WBPoolEditorCompositePane WBPoolError WBPoolErrorAbsentKey WBPoolErrorDuplicateKey WBPoolErrorDuplicatePoolName WBPoolErrorInvalidCategory WBPoolErrorInvalidFile WBPoolErrorInvalidKey
        WBPoolErrorInvalidPool WBPoolErrorInvalidPoolName WBPoolErrorInvalidValue WBPoolManager WBPoolManagerWindow WBPowerViewAddInModule WBPrimaryModelInitializeModule WBPrimaryModelModule WBPrimaryModelOpenOnModule WBProgressBarEditor WBPropertyDescriptor
        WBPropertyEditor WBPropertyManager WBPrototype WBResizeBitmap WBResourceDescriptor WBRGBColorDialog WBRichTextEditor WBScrapbookRetrieve WBScrapbookStore WBScratchWindow WBScrollBarEditor WBScrollingPane WBStandardCodePolicy WBStaticGraphic WBStaticTextEditor
        WBStatusPaneEditor WBStatusWindowEditor WBStyleEditor WBSubPool WBSystemBitmapViewer WBTabControlEditor WBTabOrderEditor WBTabOrderLayoutForm WBTabPosition WBTargetObject WBTeamVCodePolicy WBTemplateEditor WBTextEditWindow WBTimerEditor WBTool WBToolBar
        WBToolBarEditor WBToolMenuAddInModule WBToolPalette WBTopPane WBTrackBarEditor WBTranslationChooser WBTranslator WBTreeListBox WBTreeNode WBTreeViewEditor WBUndoAction WBUndoManager WBUndoRedoDialog WBUpDownEditor WBUserInfoDialog WBVersionCodeModule
        WBVerticalScrollBar WBWindowDialog WBWindowEditor WBWindows95AddInModule WBXoteryXCodePolicy WinCharFormat WindowBuilder WindowFrameObject WinEditStream WinFormatRange WinHdItem WinHdLayout WinHdNotify WinLvColumn WinLvDispinfo WinLvItem WinLvKeydown
        WinNmListview WinNmTreeview WinParaFormat WinTbAddBitmap WinTbButton WinTbNotify WinTbSaveParams WinTcItem WinToolinfo WinTooltiptext WinTvDispinfo WinTvInsertstruct WinTvItem WinTvKeydown)
('-------------------------------------------------' )
('Tools-Browsers' Browser ChangeSetBrowser ClassBrowser ClassHierarchyBrowser CodeBrowser MethodBrowser MethodVersionBrowser SelectorBrowser SessionModel SourceChunk)
('Tools-Navigator' BrowserView ClassBasedOrganizer CodeBrowserSelection GetAndSetBuilder MethodBasedOrganizer NavigatorBrowser Organizer)
('Tools-Debuggers' ByteArrayInspector Debugger DictionaryInspector DoubleByteStringInspector FieldInspector GraphicInspector Inspector OrderedCollectionInspector)
('Tools-Development Support' ChangeLogCompressor LatestChangesExtractor MethodClassifier MethodVersion SmalltalkToolInterface)
('Tools-Code Writers & Readers' ClassReader CodeFiler CodeFilerClassWriter CodeFilerOrganizationWriter CodeWriter DigitalkClassWriter IBMSmalltalkClassWriter ParcPlaceClassReader RTFClassWriter TeamVClassWriter VisualWorksClassWriter)
('Tools-Change Sets' ChangeSet ChangeSetAddProtocolItem ChangeSetClassCommentItem ChangeSetClassDefinitionItem ChangeSetClassReorganizationItem ChangeSetEvaluateItem ChangeSetItem ChangeSetManager ChangeSetMethodHighlightItem ChangeSetMethodItem ChangeSetMethodReorganizationItem
        ChangeSetProtocolItem ChangeSetRemoveClassItem ChangeSetRemoveMethodItem ChangeSetRemoveProtocolItem ChangeSetRenameProtocolItem ClassBasedChangeSetItem NonRecordingChangeSet)
('Tools-Scintilla Pane' ExpressionEvaluator ScintillaDLL ScintillaExpressionEvaluator ScintillaFindDialog ScintillaPane ScintillaReplaceDialog ScNotification)
('--------------------------------------------------' )
('3D-Basic' BoundingBox Point3D Point4D WorldGlobal)
('---------------------------------------------------' )
('Constructor' Example)

)) !
    "If there is a changeSetManager in the image, then reconstruct myself as a changeSet"
    ((Smalltalk includesKey: #CodeFiler) and: [Smalltalk includesKey: #ChangeSetManager])
        ifTrue: [
            Smalltalk at: #TemporaryJunkChangeSet put: ChangeSet new.
            (Smalltalk at: #TemporaryJunkChangeSet)
                name: 'CodeFiler';
                creationDate: (Date fromString: 'May 11, 1995');
                creationTime: (Time fromString: '04:08:16 PM');
                comment: 'CodeFiler ChangeSet Comment
';
                allowChanges] !

    ((Smalltalk includesKey: #CodeFiler) and: [Smalltalk includesKey: #ChangeSetManager])
        ifTrue: [
            TemporaryJunkChangeSet
               addItem: (ChangeSetClassDefinitionItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:08:24 PM');
                   className: 'CodeFiler';
                   yourself);
               addItem: (ChangeSetClassReorganizationItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:08:38 PM');
                   className: 'CodeFiler';
                   newCategories: #('Tools-Development Support');
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:08:45 PM');
                   className: 'CodeFiler';
                   protocol: 'accessing';
                   selector: #definitionString;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:08:45 PM');
                   className: 'CodeFiler';
                   protocol: 'accessing';
                   selector: #forClass;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:08:45 PM');
                   className: 'CodeFiler';
                   protocol: 'accessing';
                   selector: #methodOrganizer;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:08:45 PM');
                   className: 'CodeFiler';
                   protocol: 'accessing';
                   selector: #classes:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:08:45 PM');
                   className: 'CodeFiler';
                   protocol: 'accessing';
                   selector: #classes;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:08:45 PM');
                   className: 'CodeFiler';
                   protocol: 'accessing';
                   selector: #forClass:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:08:45 PM');
                   className: 'CodeFiler';
                   protocol: 'filing in';
                   selector: #fileInFrom:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:08:45 PM');
                   className: 'CodeFiler';
                   protocol: 'filing out';
                   selector: #fileOutPreambleOn:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:08:45 PM');
                   className: 'CodeFiler';
                   protocol: 'filing out';
                   selector: #fileOutOn:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:08:45 PM');
                   className: 'CodeFiler';
                   protocol: 'filing out';
                   selector: #fileOutProtocol:on:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:08:45 PM');
                   className: 'CodeFiler';
                   protocol: 'filing out';
                   selector: #fileOutProtocolsOn:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:08:45 PM');
                   className: 'CodeFiler';
                   protocol: 'filing out';
                   selector: #fileOutDefinitionOn:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:08:45 PM');
                   className: 'CodeFiler';
                   protocol: 'filing out';
                   selector: #fileOutCommentOn:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:08:45 PM');
                   className: 'CodeFiler';
                   protocol: 'filing out';
                   selector: #fileOutMethods:on:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:08:45 PM');
                   className: 'CodeFiler';
                   protocol: 'filing out';
                   selector: #fileOutMethod:on:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:08:45 PM');
                   className: 'CodeFiler';
                   protocol: 'filing out';
                   selector: #fileOutOrganizationFor:on:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:08:45 PM');
                   className: 'CodeFiler';
                   protocol: 'logging';
                   selector: #logSource:forSelector:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:08:45 PM');
                   className: 'CodeFiler';
                   protocol: 'logging';
                   selector: #logSource:forSelector:withPreviousSourcePosition:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:08:45 PM');
                   className: 'CodeFiler';
                   protocol: 'parsing';
                   selector: #selectorFor:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:08:45 PM');
                   className: 'CodeFiler';
                   protocol: 'private';
                   selector: #privateFileOutMethod:on:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:08:45 PM');
                   className: 'CodeFiler';
                   protocol: 'private';
                   selector: #nextIdentifierFrom:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:08:45 PM');
                   className: 'CodeFiler';
                   protocol: 'private';
                   selector: #compilerError:at:in:for:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:08:45 PM');
                   className: 'CodeFiler';
                   protocol: 'private';
                   selector: #keywordSelectorFrom:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:09:39 PM');
                   className: 'CodeFiler class';
                   protocol: 'instance creation';
                   selector: #forClass:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:09:39 PM');
                   className: 'CodeFiler class';
                   protocol: 'instance creation';
                   selector: #forClasses:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:09:39 PM');
                   className: 'CodeFiler class';
                   protocol: 'constants-access';
                   selector: #description;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:09:39 PM');
                   className: 'CodeFiler class';
                   protocol: 'system organizer';
                   selector: #systemOrganizer:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:09:39 PM');
                   className: 'CodeFiler class';
                   protocol: 'system organizer';
                   selector: #systemOrganizer;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:09:39 PM');
                   className: 'CodeFiler class';
                   protocol: 'system organizer';
                   selector: #initializeSystemOrganizer;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:09:39 PM');
                   className: 'CodeFiler class';
                   protocol: 'class organizers';
                   selector: #initializeClassOrganizers;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:09:39 PM');
                   className: 'CodeFiler class';
                   protocol: 'class organizers';
                   selector: #classOrganizers;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:09:39 PM');
                   className: 'CodeFiler class';
                   protocol: 'class organizers';
                   selector: #setOrganizer:for:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:09:39 PM');
                   className: 'CodeFiler class';
                   protocol: 'class organizers';
                   selector: #setOrganizerFor:to:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:09:39 PM');
                   className: 'CodeFiler class';
                   protocol: 'class organizers';
                   selector: #removeOrganizerFor:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:09:39 PM');
                   className: 'CodeFiler class';
                   protocol: 'class organizers';
                   selector: #organizerFor:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:09:39 PM');
                   className: 'CodeFiler class';
                   protocol: 'class comments';
                   selector: #initializeClassComments;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:09:39 PM');
                   className: 'CodeFiler class';
                   protocol: 'class comments';
                   selector: #commentFor:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:09:39 PM');
                   className: 'CodeFiler class';
                   protocol: 'class comments';
                   selector: #setCommentFor:to:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:09:39 PM');
                   className: 'CodeFiler class';
                   protocol: 'class comments';
                   selector: #classComments;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:09:39 PM');
                   className: 'CodeFiler class';
                   protocol: 'private';
                   selector: #privateBuildOrganizerFor:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:09:39 PM');
                   className: 'CodeFiler class';
                   protocol: 'templates-access';
                   selector: #definitionTemplate;
                   yourself);
               addItem: (ChangeSetClassDefinitionItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:20 PM');
                   className: 'ClassBasedOrganizer';
                   yourself);
               addItem: (ChangeSetClassDefinitionItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:20 PM');
                   className: 'MethodBasedOrganizer';
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:26 PM');
                   className: 'ClassBasedOrganizer';
                   protocol: 'elements';
                   selector: #reorganize:into:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:26 PM');
                   className: 'ClassBasedOrganizer';
                   protocol: 'defaults-access';
                   selector: #defaultCategory;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:26 PM');
                   className: 'ClassBasedOrganizer';
                   protocol: 'initializing';
                   selector: #initialize;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:26 PM');
                   className: 'ClassBasedOrganizer';
                   protocol: 'updating';
                   selector: #update;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:26 PM');
                   className: 'ClassBasedOrganizer';
                   protocol: 'private';
                   selector: #isNameOfValidClass:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:38 PM');
                   className: 'MethodBasedOrganizer';
                   protocol: 'accessing';
                   selector: #owner:;
                   yourself);
                yourself] !

    ((Smalltalk includesKey: #CodeFiler) and: [Smalltalk includesKey: #ChangeSetManager])
        ifTrue: [
            TemporaryJunkChangeSet
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:38 PM');
                   className: 'MethodBasedOrganizer';
                   protocol: 'accessing';
                   selector: #owner:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:38 PM');
                   className: 'MethodBasedOrganizer';
                   protocol: 'categories';
                   selector: #removeCategory:ifAbsent:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:38 PM');
                   className: 'MethodBasedOrganizer';
                   protocol: 'elements';
                   selector: #removeElement:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:38 PM');
                   className: 'MethodBasedOrganizer';
                   protocol: 'elements';
                   selector: #addElement:toCategory:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:38 PM');
                   className: 'MethodBasedOrganizer';
                   protocol: 'elements';
                   selector: #reorganizeFrom:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:38 PM');
                   className: 'MethodBasedOrganizer';
                   protocol: 'defaults-access';
                   selector: #defaultCategory;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:38 PM');
                   className: 'MethodBasedOrganizer';
                   protocol: 'initializing';
                   selector: #initialize;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:38 PM');
                   className: 'MethodBasedOrganizer';
                   protocol: 'private';
                   selector: #privateBuildAllUncategorized;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:38 PM');
                   className: 'MethodBasedOrganizer';
                   protocol: 'updating';
                   selector: #update;
                   yourself);
               addItem: (ChangeSetClassDefinitionItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:43 PM');
                   className: 'Organizer';
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'accessing';
                   selector: #categoryToElement;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'accessing';
                   selector: #owner:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'accessing';
                   selector: #owner;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'categories';
                   selector: #removeCategory:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'categories';
                   selector: #removeCategories:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'categories';
                   selector: #isKnownCategory:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'categories';
                   selector: #categories;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'categories';
                   selector: #elementsOfCategory:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'categories';
                   selector: #addCategory:before:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'categories';
                   selector: #rename:to:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'categories';
                   selector: #removeCategory:ifAbsent:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'categories';
                   selector: #addCategory:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'elements';
                   selector: #reorganizeFrom:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'elements';
                   selector: #isElement:inCategory:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'elements';
                   selector: #elements;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'elements';
                   selector: #removeElements:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'elements';
                   selector: #removeElement:fromCategories:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'elements';
                   selector: #removeElement:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'elements';
                   selector: #removeElement:fromCategory:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'elements';
                   selector: #organizationFor:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'elements';
                   selector: #addElement:toCategory:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'elements';
                   selector: #addElements:toCategories:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'elements';
                   selector: #reorganize:into:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'elements';
                   selector: #categoriesOfElement:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'elements';
                   selector: #addElement:toCategories:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'elements';
                   selector: #categoryOfElement:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'storing';
                   selector: #editString;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'storing';
                   selector: #editStringForElements:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'storing';
                   selector: #editStringForCategories:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'storing';
                   selector: #storeOn:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'caching';
                   selector: #notDirty;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'caching';
                   selector: #isDirty;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'updating';
                   selector: #update;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'updating';
                   selector: #updateDefaultCategory;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'initializing';
                   selector: #initialize;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'defaults-access';
                   selector: #defaultCategory;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'private-caching';
                   selector: #makeDirty;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:48 PM');
                   className: 'Organizer';
                   protocol: 'private-caching';
                   selector: #makeClean;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:57 PM');
                   className: 'Organizer class';
                   protocol: 'no category methods';
                   selector: #new;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:11:57 PM');
                   className: 'Organizer class';
                   protocol: 'no category methods';
                   selector: #fromArray:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:13:36 PM');
                   className: 'Class';
                   protocol: 'no category methods';
                   selector: #variableByteSubclass:classVariableNames:poolDictionaries:category:;
                   yourself);
                yourself] !

    ((Smalltalk includesKey: #CodeFiler) and: [Smalltalk includesKey: #ChangeSetManager])
        ifTrue: [
            TemporaryJunkChangeSet
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:13:36 PM');
                   className: 'Class';
                   protocol: 'no category methods';
                   selector: #variableByteSubclass:classVariableNames:poolDictionaries:category:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:13:36 PM');
                   className: 'Class';
                   protocol: 'no category methods';
                   selector: #subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:13:36 PM');
                   className: 'Class';
                   protocol: 'no category methods';
                   selector: #variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:13:36 PM');
                   className: 'Class';
                   protocol: 'no category methods';
                   selector: #subclass:instanceVariableNames:classVariableNames:poolDictionaries:isVariable:isPointers:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:13:36 PM');
                   className: 'Class';
                   protocol: 'no category methods';
                   selector: #variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:categories:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:13:36 PM');
                   className: 'Class';
                   protocol: 'no category methods';
                   selector: #variableByteSubclass:instanceVariableNames:classVariableNames:poolDictionaries:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:13:36 PM');
                   className: 'Class';
                   protocol: 'no category methods';
                   selector: #variableByteSubclass:classVariableNames:poolDictionaries:categories:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:13:36 PM');
                   className: 'Class';
                   protocol: 'no category methods';
                   selector: #subclass:instanceVariableNames:classVariableNames:poolDictionaries:categories:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:14:36 PM');
                   className: 'UndefinedObject';
                   protocol: 'no category methods';
                   selector: #subclass:instanceVariableNames:classVariableNames:poolDictionaries:categories:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:14:36 PM');
                   className: 'UndefinedObject';
                   protocol: 'no category methods';
                   selector: #subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:14:45 PM');
                   className: 'UndefinedObject';
                   protocol: 'no category methods';
                   selector: #variableByteSubclass:classVariableNames:poolDictionaries:category:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:14:45 PM');
                   className: 'UndefinedObject';
                   protocol: 'no category methods';
                   selector: #variableByteSubclass:classVariableNames:poolDictionaries:categories:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:14:45 PM');
                   className: 'UndefinedObject';
                   protocol: 'no category methods';
                   selector: #variableByteSubclass:instanceVariableNames:classVariableNames:poolDictionaries:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:14:52 PM');
                   className: 'UndefinedObject';
                   protocol: 'no category methods';
                   selector: #variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:14:52 PM');
                   className: 'UndefinedObject';
                   protocol: 'no category methods';
                   selector: #variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:categories:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:17:20 PM');
                   className: 'Collection';
                   protocol: 'no category methods';
                   selector: #any:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:17:20 PM');
                   className: 'Collection';
                   protocol: 'no category methods';
                   selector: #any;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'May 11, 1995');
                   time: (Time fromString: '04:42:25 PM');
                   className: 'String';
                   protocol: 'no category methods';
                   selector: #firstWord;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'June 26, 1995');
                   time: (Time fromString: '01:31:25 PM');
                   className: 'ComboBox';
                   protocol: 'extensions';
                   selector: #enableRedraw;
                   yourself);
               addItem: (ChangeSetRemoveMethodItem new
                   date: (Date fromString: 'September 28, 1995');
                   time: (Time fromString: '06:21:21 PM');
                   className: 'CodeFiler class';
                   selector: #setOrganizer:for:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'September 28, 1995');
                   time: (Time fromString: '06:22:55 PM');
                   className: 'Behavior';
                   protocol: 'no category methods';
                   selector: #methodsFor:;
                   yourself);
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'September 28, 1995');
                   time: (Time fromString: '06:23:05 PM');
                   className: 'Behavior';
                   protocol: 'no category methods';
                   selector: #methods;
                   yourself);
                yourself] !

    "If there is a changeSetManager in the image, then reconstruct myself as a changeSet"
    ((Smalltalk includesKey: #CodeFiler) and: [Smalltalk includesKey: #ChangeSetManager])
        ifTrue: [
            TemporaryJunkChangeSet disallowChanges.
            CodeFiler changeSetManager add: TemporaryJunkChangeSet.
            Smalltalk removeKey: #TemporaryJunkChangeSet] !

    "If there is a changeSetManager in the image, then reconstruct myself as a changeSet"
    ((Smalltalk includesKey: #CodeFiler) and: [Smalltalk includesKey: #ChangeSetManager])
        ifTrue: [
            Smalltalk at: #TemporaryJunkChangeSet put: ChangeSet new.
            (Smalltalk at: #TemporaryJunkChangeSet)
                name: 'Lost Knnowledge';
                creationDate: (Date fromString: 'October 3, 2001');
                creationTime: (Time fromString: '10:52:23 AM');
                comment: 'Comment for: Lost Knnowledge';
                allowChanges] !

    ((Smalltalk includesKey: #CodeFiler) and: [Smalltalk includesKey: #ChangeSetManager])
        ifTrue: [
            TemporaryJunkChangeSet
               addItem: (ChangeSetMethodItem new
                   date: (Date fromString: 'October 3, 2001');
                   time: (Time fromString: '11:29:36 AM');
                   className: 'Level';
                   protocol: 'collision detection';
                   selector: #buildCollisionDetectionTree;
                   yourself);
                yourself] !

    "If there is a changeSetManager in the image, then reconstruct myself as a changeSet"
    ((Smalltalk includesKey: #CodeFiler) and: [Smalltalk includesKey: #ChangeSetManager])
        ifTrue: [
            TemporaryJunkChangeSet disallowChanges.
            CodeFiler changeSetManager add: TemporaryJunkChangeSet.
            Smalltalk removeKey: #TemporaryJunkChangeSet] !


"evaluate"   
"*** saved image on: December 27, 2016 03:40:03 PM ***"!

  
'
    SourceManager current newCompressChanges
'!

"evaluate" 
"*** saved image on: December 27, 2016 03:40:11 PM ***"!  
"*** Image started on: December 27, 2016 03:41:22 PM ***"!

"evaluate"  
"*** saved image on: December 27, 2016 03:42:58 PM ***"!  
"*** Image started on: Wednesday, January 18, 2017 22:46:10 ***"!


!Time class methods !  
fromString: aString
        "Answer a Time for the value given by aString.
        aString must be in the form specified by the
        current system time format."
    | aStream hh mm ss timeSeparator timeId isPm |
    aStream := ReadStream on: aString.
    timeSeparator := NationalLanguage timeSeparator at: 1.
    hh := (aStream upTo: timeSeparator) asInteger.       " hours "
    (hh < 0 or: [hh > 23]) ifTrue: [^self error: 'error in hours'].

    mm := (aStream upTo: timeSeparator) asInteger.    " minutes "
    (mm > 59) ifTrue: [^self error: 'error in minutes'].

    ss := (aStream upTo: $ ) asInteger.                            " seconds "
    (ss > 59) ifTrue: [^self error: 'error in seconds'].

    timeId := aStream next: ((aStream readLimit) - (aStream position)).
    timeId := timeId trimBlanks.
    isPm := hh > 11 or: [timeId = NationalLanguage time2359].

    (isPm and: [hh <= 11]) ifTrue: [hh := hh + 12].
    ^self fromSeconds: ( hh * 60 + mm * 60 + ss)!   !
(CodeFiler organizerFor: Time class) reorganizeFrom: #(
('no category methods' fromString: )) !

(CodeFiler organizerFor: Time class) reorganizeFrom: #(
('no category methods' fromString: )) !


"evaluate"   
"*** saved image on: Wednesday, January 18, 2017 22:49:32 ***"!   
"*** Image started on: Sunday, January 7, 2018 13:14:35 ***"!

!BlockClosure methods !  
printOn: aStream
        "Append the ASCII representation
         of the receiver to aStream."
    | limit each |
    (RecursiveSet includes: self)
        ifTrue: [^self printRecursionOn: aStream].
    RecursiveSet add: self.
    limit := aStream position + 2000.
    self class printOn: aStream.
    aStream nextPut: $(.
    1 to: self size do: [ :i |
        (aStream position > limit)
            ifTrue: [
                '...etc...)' printOn: aStream.
                RecursiveSet remove: self ifAbsent: [].
                ^self].
        each := self at: i.
		each isInteger
			ifTrue: [ each printOn: aStream base: 16 showRadix: false ]
			ifFalse: [ each printOn: aStream ].
        aStream space].
    aStream nextPut: $).
    RecursiveSet remove: self ifAbsent: []!    ! 
#('Sunday, January 7, 2018' '13:20:46' nil)!

(CodeFiler organizerFor: BlockClosure) reorganizeFrom: #(
('no category methods' printOn: )) !


!BlockClosure methods !  
printOn: aStream
    
    aStream << 'aBlock ('; << self argumentCount; << ' parameters, method '; << self method selector; << ', class '; << self method class; << ')'!  ! 
#('Sunday, January 7, 2018' '13:20:46' 1287300)!

(CodeFiler organizerFor: BlockClosure) reorganizeFrom: #(
('no category methods' printOn: )) !

(CodeFiler organizerFor: BlockClosure) reorganizeFrom: #(
('no category methods' printOn: )) !


  
'[''hi'']'!

"evaluate" 
"*** saved image on: Sunday, January 7, 2018 13:21:47 ***"!   
"*** Image started on: Sunday, January 7, 2018 13:31:52 ***"!

 
'
FileHandle cleanHandles
'!


'
    FileHandle cleanHandles
'!

"evaluate"  
"*** saved image on: Sunday, January 7, 2018 13:34:30 ***"!   
"*** Image started on: Sunday, January 7, 2018 13:49:44 ***"!

"evaluate"   
(CodeFiler systemOrganizer addCategory: 'Scanner/Parser' before: 'Constructor')!

"evaluate"
CodeFiler systemOrganizer rename: 'Constructor' to: 'Grammar Constructor'!

"evaluate"  
(CodeFiler systemOrganizer addCategory: 'Table Constructor' before: nil)!

"define class"   

Object subclass: #Scanner
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

"evaluate" 

Object subclass: #Scanner
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Scanner/Parser' )!

"define class"

Object subclass: #Parser
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: Parser to: ''!


"evaluate" 

Object subclass: #Parser
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Scanner/Parser' )
  comment: ''!

"evaluate"  
(CodeFiler organizerFor: Parser class) rename: 'no category methods' to: 'parsing tables'!

!Parser class methods ! 
rawParserTables
    "Fill in the code of the form ^#(....)"  "Note: ^ is the Smalltalk return statement."! ! 
#('Sunday, January 7, 2018' '13:53:43' nil)!

(CodeFiler organizerFor: Parser class) reorganizeFrom: #(
('parsing tables' rawParserTables )) !


"evaluate" 
(CodeFiler organizerFor: 'Scanner class')  addCategory: 'scanning tables' before: nil!

"evaluate"  
(CodeFiler organizerFor: Scanner class) removeCategory: 'no category methods' ifAbsent: [nil]!

!Scanner class methods !
rawScannerTables
    "Fill in the code of the form ^#(....)"  "Note: ^ is the Smalltalk return statement."!    ! 
#('Sunday, January 7, 2018' '13:54:25' nil)!

(CodeFiler organizerFor: Scanner class) reorganizeFrom: #(
('scanning tables' rawScannerTables )) !


"evaluate"  
(CodeFiler organizerFor: 'Scanner class')  addCategory: 'scanning grammar' before: 'scanning tables'!

!Scanner class methods ! 
grammar
    "Fill in the code of the form ^'  .....  '    "  
    "Note: Strings are surrounded by single quotes."
    "You will have to replace INTERNAL QUOTES by 2 single quotes."!   ! 
#('Sunday, January 7, 2018' '13:56:58' nil)!

(CodeFiler organizerFor: Scanner class) reorganizeFrom: #(
('scanning grammar' grammar )) !


"evaluate"  
(CodeFiler organizerFor: Parser class) rename: 'parsing tables' to: 'tables'!

"evaluate"   
(CodeFiler organizerFor: 'Parser class')  addCategory: 'grammars' before: 'tables'!

!Parser class methods !
grammar
    "Fill in the code of the form ^'  .....  '    "  
    "Note: Strings are surrounded by single quotes."
    "You will have to replace INTERNAL QUOTES by 2 single quotes."!   ! 
#('Sunday, January 7, 2018' '13:58:02' nil)!

(CodeFiler organizerFor: Parser class) reorganizeFrom: #(
('grammars' grammar )) !


!Scanner class methods ! 
grammar
    "Fill in the code of the form ^'  .....  '    "  
    "Note: Strings are surrounded by single quotes."
    "You will have to replace INTERNAL QUOTES by 2 single quotes."!   ! 
#('Sunday, January 7, 2018' '13:58:13' 1291060)!

(CodeFiler organizerFor: Scanner class) reorganizeFrom: #(
('scanning grammar' grammar )) !

(CodeFiler organizerFor: Scanner class) reorganizeFrom: #(
('scanning grammar' grammar )) !


"evaluate"  
(CodeFiler organizerFor: Scanner class) rename: 'scanning grammar' to: 'grammars'!

"evaluate"  
(CodeFiler organizerFor: Scanner class) rename: 'scanning tables' to: 'tables'!

"evaluate" 
Example removeFromSystem!

"evaluate"   
CodeFiler removeOrganizerFor: #Example!

"evaluate" 
CodeFiler removeOrganizerFor: #'Example class'!

"define class" 

Object subclass: #Parser
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

"define class"  

Object subclass: #Scanner
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!


!Parser class methods !  
grammar
    "Fill in the code of the form ^'  .....  '    "
    "Note: Strings are surrounded by single quotes."
    "You will have to replace INTERNAL QUOTES by 2 single quotes."! !
(CodeFiler organizerFor: Parser class) reorganizeFrom: #(
('grammars' grammar )) !

(CodeFiler organizerFor: Parser class) reorganizeFrom: #(
('grammars' grammar )) !



!Parser class methods !  
rawParserTables
    "Fill in the code of the form ^#(....)"  "Note: ^ is the Smalltalk return statement."! !
(CodeFiler organizerFor: Parser class) reorganizeFrom: #(
('tables' rawParserTables )) !

(CodeFiler organizerFor: Parser class) reorganizeFrom: #(
('tables' rawParserTables )) !



"evaluate"   
(CodeFiler organizerFor: Parser) removeCategory: 'no category methods' ifAbsent: [nil]!CodeFiler setCommentFor: Parser to: ''!



!Scanner class methods !
grammar
    "Fill in the code of the form ^'  .....  '    "
    "Note: Strings are surrounded by single quotes."
    "You will have to replace INTERNAL QUOTES by 2 single quotes."! !
(CodeFiler organizerFor: Scanner class) reorganizeFrom: #(
('grammars' grammar )) !

(CodeFiler organizerFor: Scanner class) reorganizeFrom: #(
('grammars' grammar )) !



!Scanner class methods !   
rawScannerTables
    "Fill in the code of the form ^#(....)"  "Note: ^ is the Smalltalk return statement."!    !
(CodeFiler organizerFor: Scanner class) reorganizeFrom: #(
('tables' rawScannerTables )) !

(CodeFiler organizerFor: Scanner class) reorganizeFrom: #(
('tables' rawScannerTables )) !



"evaluate"   
(CodeFiler organizerFor: Scanner) removeCategory: 'no category methods' ifAbsent: [nil]!CodeFiler setCommentFor: Scanner to: ''!


"evaluate"  
"*** saved image on: Sunday, January 7, 2018 14:03:29 ***"!   
"*** Image started on: Wednesday, April 11, 2018 12:33:37 ***"!   
"*** Image started on: December 31, 2018 11:42:50 AM ***"!

"evaluate"  
(CodeFiler systemOrganizer addCategory: 'hhh' before: 'Table Constructor')!

"evaluate" 
CodeFiler systemOrganizer removeCategory: 'hhh' ifAbsent: [nil].!

"evaluate"   
Scanner removeFromSystem!

"evaluate"   
CodeFiler removeOrganizerFor: #Scanner!

"evaluate" 
CodeFiler removeOrganizerFor: #'Scanner class'!

"evaluate" 
Parser removeFromSystem!

"evaluate"
CodeFiler removeOrganizerFor: #Parser!

"evaluate"  
CodeFiler removeOrganizerFor: #'Parser class'!

"evaluate"  
"*** saved image on: December 31, 2018 11:50:31 AM ***"!  
"*** Image started on: December 31, 2018 06:12:23 PM ***"!

"evaluate"  
"*** saved image on: December 31, 2018 06:12:45 PM ***"!  
"*** Image started on: December 13, 2019 12:44:01 PM ***"!


!Date class methods ! 
monthIndexFromString: aString
   "Returns 1 through 12 if it is a day name; otherwise 0."
   | prefix |
   prefix := (aString prefix: 3) asLowercase.
   #('jun' 'jul') indexedDo: [:index :month |
    month = prefix ifTrue: [^index + 5]].
   prefix := prefix prefix: 2.
   #('ja' 'fe' 'ma' 'ap' 'ma' 'ju' 'ju' 'au' 'se' 'oc' 'no' 'de') indexedDo: [:index :month |
    month = prefix ifTrue: [^index]].
   ^0
!  !

!Date class methods !
fromString: aString
    "Decodes a date from the string from a host of possibilities
    such as 'Friday 2 of January, 2020', 'Jan 2, 2020', '2 Jan, 2020'
    or '02-01-2020', '02/01/20', or even '20/02/01. If the order
    of the month and day cannot be resolved, we assume month
    followed by day. Similarly, if the year cannot be differentiated
    from the others, it's assumed to be last."

    | aStream field1 field2 field3 field1IsInteger field2IsInteger field3IsInteger monthFirst yearIsFirst day month year |

    "Pick up candidate fields..."
    aStream := aString asStream.
    field1 := aStream nextWord.
    (Date dayIndexFromString: aString) > 0 ifTrue: [field1 := aStream nextWord].
    field2 := aStream nextWord.
    (field2 asLowercase = 'of')
        ifTrue: [field2 := aStream nextWord].
    field3 := aStream nextWord.

    "Convert to integer (when they are integers)."
    field1IsInteger := field1 first isDigit.
    field2IsInteger := field2 first isDigit.
    field3IsInteger := field3 first isDigit.

    field1IsInteger ifTrue: [field1 := field1 asInteger].
    field2IsInteger ifTrue: [field2 := field2 asInteger].
    field3IsInteger ifTrue: [field3 := field3 asInteger].

    "Pick up the year."
    year := (field1IsInteger and: [field1 > 12])
        ifTrue: [yearIsFirst := true. field1]
        ifFalse: [field3].
    year < 100 ifTrue: [year := year + 2000].

    "Pick up the month."
    month :=
        (field1IsInteger not) ifTrue: [monthFirst := true. Date monthIndexFromString: field1] ifFalse: [
        (field2IsInteger not) ifTrue: [Date monthIndexFromString: field2] ifFalse: [
        (field1 > 12) ifTrue: [field2] ifFalse: [
        monthFirst := true. field1]]].

    "Pick up the day."
    day := yearIsFirst notNil
        ifTrue: [field2 > 12 ifTrue: [field2] ifFalse: [field3]]
        ifFalse: [monthFirst notNil ifTrue: [field2] ifFalse: [field1]].

    "Build and return the date."
    ^self newDay: day month: (#(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec) at: month) year: year.

!  !

!Date class methods !
dayIndexFromString: aString
   "Returns 1 through 7 if it is a day name; otherwise 0."
   | prefix |
   prefix := (aString prefix: 2) asLowercase.
   #('mo' 'tu' 'we' 'th' 'fr' 'sa' 'su') indexedDo: [:index :day |
    day = prefix ifTrue: [^index]].
   ^0
!    !
(CodeFiler organizerFor: Date class) reorganizeFrom: #(
('recent addition' monthIndexFromString: fromString: dayIndexFromString: )) !

(CodeFiler organizerFor: Date class) reorganizeFrom: #(
('recent addition' monthIndexFromString: fromString: dayIndexFromString: )) !


"evaluate"   
CodeFiler systemOrganizer: (ClassBasedOrganizer fromArray: #(('Base-Collections' Array Array2D Bag BucketHashTable ByteArray Collection Dictionary DoubleByteString DoubleByteSymbol FixedSizeCollection HashedCollection HashTable IdentityDictionary IdentityDictionary2D IdentitySet IdentitySortedCollection IndexedCollection Interval
        LinearHashTable LinearIdentityHashTable LinearInlineHashTable LinearSymbolHashTable MethodDictionary MonitoredCollection OrderedCollection OrderedDictionary OrderedIdentityDictionary PriorityQueue Set SortedCollection SparseRectangleArray String Symbol
        SymbolSet)
('Base-Magnitudes' Association Character Date FixedPoint Float Fraction Integer LargeInteger LargeNegativeInteger LargePositiveInteger Magnitude Number Point Point3D RandomNumberStream Rectangle SmallInteger Time TimeStamp)
('Base-Streams' FileStream MixedFileStream ReadStream ReadWriteStream Stream StringDictionaryReader WriteStream)
('Base-Files' Directory File FileSearchResults FileSystemComponent FileSystemContainer FileSystemEntity FileSystemLocator FileSystemPath FileVolume NetworkFilePath)
('Base-Graphics' Bitmap Color DIB GraphicsMedium GraphicsTool IndexedColor Pen Printer RecordingPen RGBColor Screen StoredPicture TextTool)
('Base-Text' Pattern StringModel TextSelection WildPattern)
('Kernel-Objects' BlockClosure Boolean Context False HomeContext Object OneArgumentBlock True TwoArgumentBlock ZeroArgumentBlock)
('Kernel-Behaviors' Behavior Class MetaClass PoolDictionary)
('Kernel-Delegation' ContainerObject DelegationObject SelfInitializingObject)
('Kernel-Messages' ExpressionEvaluator Message MethodExecutor ScintillaExpressionEvaluator WorkspaceExpressionEvaluator)
('Kernel-Source Management' ClassInstaller DefinitionInstaller LibrarySourceReference ObjectMutator SourceChunkReference SourceManager StreamReference StringReference SystemStreamReference)
('Kernel-Processes and Events' ActionSequence CollectionAccessor ConstantAccessor EvaluableAction EventManager InputEvent KeyboardInputEvent LinkMessage Process ProcessScheduler Semaphore SharedBoolean SharedValue Timer UnregisteredEvent)
('Kernel-Exception Handling' APICallEntryPointNotFound APICallError APICallInvalidArgumentType APICallUnknownPrimitiveFailure ArithmeticError BindDuplicate BindError ClassShapeMismatch ControlError Error Exception ExceptionFilter ExceptionHandler ExceptionSet FileAlreadyExists FileError
        FileErrorWriteProtected FileSharingViolation FileSystemAccessDenied HostFileSystemError KeyboardInterrupt LoggedWarning MessageNotUnderstood Notification ProcessTermination ProgressNotification ProtectedFrameMarker RecompilationNotification TooManyOpenFiles
        UnresolvedExternal VetoAction Warning ZeroDivide)
('Kernel-Compiler Support' BlockDescription CompilationError CompilationResult CompiledInitializer CompiledMethod CompiledMethodDefinition CompilerErrorHandler CompilerInterface CompilerNameScope DictionaryScope GlobalPoolScope HaltingErrorHandler MultiplePoolScope NonInteractiveErrorHandler
        SilentErrorHandler TextPaneErrorHandler TraditionalCompilerErrorHandler VariableLocator VariableLocatorNoSource WorkspaceErrorHandler)
('Kernel-Special Objects' DeletedClass EmptySlot Ephemeron EphemeronDictionary NotificationManager ResidueObject ServiceRegistry SessionModel SystemDictionary SystemWeakRegistries UndefinedObject VirtualMachineConfiguration WeakKeyedRegistry WeakLinearHashTable WeakRegistry)
('Kernel-Host Interfaces' CallBack ClipboardManager CursorManager Font HelpManager Icon NationalLanguageSupport OperatingSystemInformation)
('Kernel-Structures' Atom CallBack16 DeviceContext ExternalAddress ExternalBuffer ExternalGlobalAddress ExternalGlobalHandle ExternalHandle ExternalHeapAddress ExternalHeapHandle ExternalLong ExternalMemoryHandle ExternalSegmentedAddress FileHandle SelfDefinedStructure Win32FindData
        WinBitmapFileHeader WinBitmapInfo WinBitmapInfoHeader WinBitmapStruct WinColorref WinDialogInfo WindowHandle WinDrawItemStruct WinFileTime WinLargeInteger WinLogBrush WinLogFont WinLogicalBrush WinLogicalObject WinLogicalPalette WinLogicalPen WinLogPalette
        WinLogPen WinMeasureItemStruct WinMemorystatus WinMessage WinMetafileheader WinMetafilepict WinMetaheader WinMinmaxinfo WinNmhdr WinOfstruct WinPaintStructure WinPaletteEntry WinPoint WinRectangle WinStructArray WinSystemTime WinTextMetrics WinWindowClass
        WinWindowPlacement)
('Kernel-DLLs' CommonControlsDLL CommonDialogDLL DynamicLinkLibrary DynamicLinkLibrary16 GDIDLL KernelDLL KernelDLL16 ShellDLL ThunkWin32sDLL ThunkWin95DLL UserDLL VirtualMachineDLL VirtualMachineExe WNetDLL)
('Kernel-Object Libraries' ObjectStore ObjectStoreExternal ObjectStoreReader SmalltalkLibrary SmalltalkLibraryBinder)
('Windows-Views' ApplicationCoordinator ApplicationWindow ControlWindow DialogCoordinator DialogTopPane DialogWindow ListChooser MainWindow MenuWindow ObjectWindow SystemWindow TersecriptWindow TextWindow TopPane TranscriptWindow ViewManager WalkbackWindow Window)
('Windows-SubPanes' AutoSelectComboBox AutoSelectComboEntryField Button CheckBox ColorMultipleSelectListBox ComboBox ComboEntryField ControlPane DrawnButton DropDownList EllipticSkinBox EntryField GraphPane GroupBox GroupPane ListBox ListPane MultipleSelectListBox PagedRangeControl
        RadioButton RangeControl RectangularSkinBox ScrollBar StaticBox StaticGraphic StaticPane StaticText SubPane TextEdit TextPane TextPaneControl ThreeStateButton Toggle Window)
('Windows-Dialogs' AboutDialog ChooseManyDialog ChooseOneDialog ColorDialog CommonSystemDialog DialogBox FileDialog FindReplaceDialog FontDialog MessageBox NewSubclassDialog PrintAbortDialog PrintDialog ProgressIndicatorDialog ProgressIndicatorDialogThatWorks Prompter PrompterDialog
        SaveImageAsDialog SaveImageDialog WindowDialog)
('Windows-Support' CompositeLayout ComputedLayout DialogLayoutFrame DragDropObject DragDropSession LayoutFrame LayoutUnit LocalDragDropObject LocalDragDropSession Menu MenuItem NoMenusWindowPolicy SmalltalkWindowPolicy StandardWindowPolicy WindowPolicy)
('Services-Service Manager' InitializationFile InitializationFileSection Service ServiceManager ServiceManagerWindow)
('PARTS and Others' AboutToReplaceFile ActionButton AddressEditorPane AddressPane AddressPaneTester AviVideo BitEditor ButtonEditor ButtonListBox ButtonListBoxItem CdAudio CheckBoxGroup CodeGenerationPrivateServices ColumnListBox CompositeFrameObject CompositePane DictionaryEditorPane
        EnhancedEntryField EntryFieldGroup ExtendedListBox FrameObject FramingParameters GroupPropertyAccessor Header HeaderItem HeaderTester ImageList LinkButton LinkPropertyAccessor ListConnectionPane ListDialog ListEditorPane ListItem ListView ListViewItem
        MaskedStylePropertyAccessor MciDevice MciFileStream MciStream ModelObjectTest MultimediaDLL MultiSelectListDialog NamePane ObjectChangeMap ObjectDumper ObjectFiler ObjectLibrary ObjectLoadDialog ObjectLoader ObjectPropertyAccessor ObjectReference ObjectStoreFile
        ObjectStoreFileExternal ObjectStoreFileObjects ObjectStoreFileWithVersion ObjectStoreObject ObjectStoreObjects ObjectStoreRoot ObjectStoreSpace ObjectStoreSpaceExternals ObjectStoreWithClient ObjectStoreWriter OkCancelPane PActionButton PaneTester PAnimationPane
        PARTSAddObject PARTSAddObjectDialog PARTSAddPartObject PARTSAddPartSession PARTSAliasLink PARTSAliasMessage PARTSAlphabeticEntryFieldPart PARTSAnyFileDialog PARTSAnyFileDialogPart PARTSApplication PARTSApplicationCoordinator PARTSApplicationHolder PARTSApplicationLoadError
        PARTSApplicationProperty PARTSArrayEditor PARTSArrayHolderPart PARTSBackgroundColorSettingsEditor PARTSBaseNotebook PARTSBitEditor PARTSCatalog PARTSCatalogDragSession PARTSCheckBoxPart PARTSChooseFileDialog PARTSClipboardAccessorPart PARTSCodeGeneratorInterface
        PARTSCodeGeneratorReaderInterface PARTSCodeGeneratorWriterInterface PARTSCollectionHolder PARTSComboBoxPart PARTSComboEntryField PARTSCommonPropertiesEditor PARTSComparisonPart PARTSComputationPart PARTSConfirmerPart PARTSConfirmerWithCancelPart PARTSContentsEditor
        PARTSConversionPart PARTSCurrencyEntryFieldPart PARTSCursorManager PARTSCyclicReference PARTSDateEntryFieldPart PARTSDeveloperDebugger PARTSDevelopmentSessionManager PARTSDial PARTSDialEditor PARTSDialog PARTSDialogTopPane PARTSDialogWindowPart PARTSDialPanePart
        PARTSDictionaryEditor PARTSDictionaryHolderPart PARTSDiskAccessorPart PARTSDosDirectory PARTSDosFileDescriptor PARTSDragDropSpec PARTSDragResult PARTSDragSession PARTSDrawnButtonPart PARTSDropDownListPart PARTSEditMenu PARTSEditor PARTSEditorMoveObject
        PARTSEditorMoveSession PARTSEditorState PARTSEmptyFile PARTSEntryFieldPart PARTSException PARTSExecutablePartFileProcessor PARTSExeFileProcessor PARTSExpressionEntryField PARTSExtentEditor PARTSFieldOrderDialog PARTSFile PARTSFileAccessorPart PARTSFileDescriptor
        PARTSFileDialog PARTSFileDialogPart PARTSFileMenu PARTSFileNotFound PARTSFileOperationContext PARTSFileProcessor PARTSFileType PARTSFileVersion PARTSFixedDecimalEntryFieldPart PARTSFloatEntryFieldPart PARTSFormattedEntryField PARTSFormGenerator PARTSFormGeneratorItem
        PARTSFramer PARTSGetExecutionContext PARTSGraphPanePart PARTSGroupPane PARTSGroupPanePart PARTSGroupPanePropertiesEditor PARTSHelpManager PARTSHelpMenu PARTSHostInterface PARTSIcon PARTSIconEditor PARTSIconEditorWindows PARTSIconPane PARTSIncorrectVersion
        PARTSInformationDialogPart PARTSIniFile PARTSIntegerEntryFieldPart PARTSInterfaceList PARTSInvalidApplication PARTSInvalidExternalDataItemSize PARTSLaunchPadPart PARTSLink PARTSLinkColorSettingsEditor PARTSLinkEditState PARTSLinkJunctionPart PARTSLinkReference
        PARTSLinkSettings PARTSListPanePart PARTSLoadContext PARTSLocalDragDropObject PARTSLocalDragDropSession PARTSMenuBar PARTSMenuBitmapItemPart PARTSMenuItemPane PARTSMenuLabelPart PARTSMenuPaneWindows PARTSMenuPart PARTSMenuSeparatorPart PARTSMenuTextItemPart
        PARTSMenuWindow PARTSMessageBox PARTSMessageNotUnderstood PARTSMirrorCopyDictionary PARTSMouseButtonsSettingsEditor PARTSMultipleChoiceListPart PARTSNestedPart PARTSNestedPartBrowser PARTSNestedPartLoadError PARTSNonvisualPart PARTSNonvisualPartPropertyDialog
        PARTSNotebook PARTSNotebookClientAreaPane PARTSNotebookPage PARTSNotebookPageAttributes PARTSNotebookPagePane PARTSNotOnSearchPath PARTSNumberHolderPart PARTSNumericField PARTSOpenDialogWindowPropertiesEditor PARTSOpenSaveFileDialog PARTSOpenWindowPropertiesEditor
        PARTSOrderedCollectionEditor PARTSOrderedCollectionHolderPart PARTSOrderedGroupPane PARTSOrderedVisualPartPropertyDialog PARTSPane PARTSPartAccessorPart PARTSPartBrowser PARTSPartFileProcessor PARTSPartPropertiesEditor PARTSPartPropertyDialog PARTSPartPropertySubdialog
        PARTSPasteObject PARTSPasteSession PARTSPathSequenceEditor PARTSPhoneNumberEntryFieldPart PARTSPictureFieldPart PARTSPictureMaskEditor PARTSPointEditor PARTSPopupWindowOS2 PARTSPopupWindowWindows PARTSPrebuiltDialog PARTSPrebuiltDialogTopPane PARTSPrebuiltMessageBox
        PARTSPrinterPart PARTSPrompter PARTSPrompterPart PARTSPropertiesEditor PARTSPropertyBinaryStyle PARTSPropertyBoolean PARTSPropertyButton PARTSPropertyButtonGroup PARTSPropertyButtonGroupWS PARTSPropertyButtonGroupWSExtended PARTSPropertyColorAndFont PARTSPropertyCreateForm
        PARTSPropertyCreateTable PARTSPropertyDateFormat PARTSPropertyDragDrop PARTSPropertyEditButton PARTSPropertyExpression PARTSPropertyFixedList PARTSPropertyFormattedString PARTSPropertyFormGeneratorButton PARTSPropertyGraphic PARTSPropertyIcon PARTSPropertyLineOfButtons
        PARTSPropertyList PARTSPropertyMenuAccelerator PARTSPropertyNumber PARTSPropertyPseudoStyle PARTSPropertySequenceChildren PARTSPropertyStaticText PARTSPropertyString PARTSPropertyStructure PARTSPropertyText PARTSPropertyUnit PARTSPropertyWindowStyle PARTSPushButtonPart
        PARTSRadioButtonPart PARTSReferenceBrowser PARTSRelativeLayoutDialog PARTSRepeatDropSession PARTSRuntimeSessionManager PARTSScenario PARTSScenarioComment PARTSScenarioEditor PARTSScenarioPairs PARTSScript PARTSScriptCompilerInterface PARTSScriptContext
        PARTSScriptDefinition PARTSScriptDictionary PARTSScriptSource PARTSScrollPane PARTSSequenceEditor PARTSSessionManager PARTSSettings PARTSSettingsEditor PARTSSettingsViewer PARTSSilentErrorHandler PARTSSimpleRichTextEditor PARTSSimpleTextEditor PARTSSizeWindowPart
        PARTSSmalltalkLibraryFileProcessor PARTSSourceFileProcessor PARTSSpeakerDLL PARTSSpeakerPart PARTSStandardBracketsMenu PARTSStandardEditMenu PARTSStandardFileMenu PARTSStandardHelpMenu PARTSStandardMenu PARTSStarterWindow PARTSStarterWindowWindows PARTSStaticGraphicPart
        PARTSStaticTextPart PARTSStoreContext PARTSStringHolderPart PARTSStringTemplate PARTSStringTemplatePart PARTSSublinkReference PARTSTabControlPagePart PARTSTabControlPart PARTSTabOrderEditor PARTSTeamVNestedPartBrowser PARTSTextIcon PARTSTextPaneErrorHandler
        PARTSTextPanePart PARTSTextWindow PARTSTimerPart PARTSTimerWindow PARTSTimeStamp PARTSToolbarButtonPart PARTSToolbarItem PARTSToolbarSeparatorPart PARTSToolbarToggleButtonPart PARTSToolboxPart PARTSToolContainer PARTSToolPane PARTSTopPane PARTSTypedValueHolder
        PARTSUpgradeObject PARTSUpgradePanePart PARTSUpgradeTablePane PARTSUpgradeVisualPart PARTSValueHolderPart PARTSVisualPartPropertyDialog PARTSWindow PARTSWindowPart PARTSWindowSizeEditor PARTSWorkbenchSessionManager PARTSWrapper PButton PButtonListBox
        PCheckBox PCheckBoxGroup PColumnListBox PComboBox PCompositePane PDrawnButton PDropDownList PEllipticSkinBox PEnhancedEntryField PEntryField PEntryFieldGroup PersonEditor PersonEditorPane PersonPane PersonPaneTester PFormattedEntryField PGenericSubpane
        PGraphPane PGroupbox PGroupBox PHeader PLinkButton PListBox PListPane PListView PMultipleSelectListBox PProgressBar PRadioButton PRadioButtonGroup PRealWidgetControl PRectangularSkinBox PRichEdit ProgressBar PropertyAccessor PropertyInterface PropertyManager
        PropertyPage PScrollBar PSpinButton PStaticBox PStaticGraphic PStaticText PStatusPane PStatusWindow PTabControl PTextEdit PTextPane PThreeStateButton PToggle PTrackBar PTreeView PUpDown PVideoPane PWBHorizontalScrollBar PWBInvisibleGroupPane PWBStaticGraphic
        PWBToolBar PWBVerticalScrollBar RadioButtonDialog RadioButtonGroup RichEdit RichEdit32DLL RichEditParagraphFormatDialog RichEditTabStopDialog SelectorPropertyAccessor SelectPersonDialog SeparatedListDialog SexPane SmalltalkLibraryBuilder SmalltalkLibraryObjects
        SmalltalkLibraryReporter SpinButton SpinButtonEntryField StatusBox StatusField StatusPane StatusWindow StylePropertyAccessor TabControl TabControlItem TabControlPage Tool Toolbar ToolbarButton ToolbarItem ToolbarSeparator ToolbarToggleButton ToolPane
        ToolTip TrackBar TreeView TreeViewItem UnknownImport UpDown UpgraderForDirectory UpgraderForFile VideoPane WaveAudio WBAboutDialog WBAbstractAddInModule WBAbstractCodeModule WBAbstractCreateViewsModule WBAbstractPrompter WBAction WBActionEditor WBActionLinkAddInModule
        WBAddInManager WBAddress WBApplicationCoordinatorMenuModule WBApplicationCoordinatorModule WBAttributeEditor WBAttributeWindow WBBasicCodeModule WBBitmapEditorCompositePane WBBitmapManager WBBitmapManagerWindow WBBitmapPool WBBitmapSubPool WBCallOutEditor
        WBCallOutModule WBChooseClassDialog WBChoosePaneDialog WBClassDefinition WBCodeGenBase WBCodeGenerator WBCodeModule WBCodePolicy WBCodeStream WBColorDialog WBComboBox WBComboEntryField WBCompositeMenuModule WBCompositePaneExampleAddInModule WBCompositePaneModule
        WBCompositePaneScratchWindow WBCompositePaneTester WBCreateBitmap WBCreateButton WBCreateClassDialog WBCreateMenuModule WBCreatePowerMenuModule WBCreatePowerViewModule WBCreatePowerViewsModule WBCreateViewModule WBCreateViewsModule WBCreateViewsStubModule
        WBDefaultCompositePaneScratchWindow WBDefaultDialogScratchWindow WBDefaultScratchWindow WBDescriptor WBDevelopmentCompositePane WBDevelopmentDialog WBDevelopmentObject WBDevelopmentSubPane WBDevelopmentWindow WBDialogEditor WBDialogScratchWindow WBDialogTopPane
        WBDisplayContext WBDrawnButton WBEditClassDialog WBEnhancedAttributeEditor WBEnhancedEntryFieldEditor WBEntryField WBEntryListPrompter WBENVYCodePolicy WBEventArgumentDescription WBEventDescription WBEventHandlerStubModule WBEventManagerWindow WBEventMap
        WBEventMessage WBEventTranslationEditor WBEventTranslator WBFileSelectorEditor WBFontEditorCompositePane WBFontManager WBFontManagerWindow WBFontPool WBFontSelectionWindow WBFontSubPool WBFramerExample WBFramingEditor WBGeometryManager WBGraphicObject
        WBGroupBox WBHandle WBHeaderEditor WBHorizontalScrollBar WBInstVarGetModule WBInstVarObject WBInstVarSetModule WBInterfaceObject WBKeyAccel WBKeyEntryField WBLayoutCodeModule WBLayoutForm WBLayoutFrameEditor WBLayoutWizard WBLinkEditor WBListBox WBListChooser
        WBListEditor WBListEntryField WBListViewEditor WBLocator WBLookPolicy WBLookPolicyOS2 WBLookPolicyWin31 WBLookPolicyWin95 WBManagedPFont WBManagedPNLSString WBManagedPValue WBMenu WBMenubarEditor WBMenuEditor WBMenuItem WBMenuItemStub WBMenuTester WBMessage
        WBMethodStubModule WBMiniBrowserExample WBModelBasicSetModule WBModelCodeModule WBModelDefinitionEditor WBModelEventsTriggeredModule WBModelGetModule WBModelInitializeModule WBModelInstVar WBModelObjectEditor WBModelSetModule WBModelTriggerEventModule
        WBMultiListChooser WBMultiToolPalette WBMultiViewAddInModule WBName WBNLSDictionaryReader WBNLSEditorCompositePane WBNLSExtractionTranslator WBNLSManager WBNLSManagerWindow WBNLSPool WBNLSReplacementTranslator WBNLSSubPool WBNLSTranslator WBObject WBOldEventHandlerStubModule
        WBOpenMethodModule WBOrderedCollection WBOutboardAttributeWindow WBOutboardWindow WBPartEvent WBPartEventsModule WBPartEventsTriggeredModule WBPartMessage WBPartMessagesModule WBPARTSEventList WBPARTSInterfaceEditor WBPARTSInterfaceList WBPARTSMessageList
        WBPartsModule WBPerson WBPlaceHolderObject WBPMenu WBPMenubar WBPMenuItem WBPool WBPoolEditorCompositePane WBPoolError WBPoolErrorAbsentKey WBPoolErrorDuplicateKey WBPoolErrorDuplicatePoolName WBPoolErrorInvalidCategory WBPoolErrorInvalidFile WBPoolErrorInvalidKey
        WBPoolErrorInvalidPool WBPoolErrorInvalidPoolName WBPoolErrorInvalidValue WBPoolManager WBPoolManagerWindow WBPowerViewAddInModule WBPrimaryModelInitializeModule WBPrimaryModelModule WBPrimaryModelOpenOnModule WBProgressBarEditor WBPropertyDescriptor
        WBPropertyEditor WBPropertyManager WBPrototype WBResizeBitmap WBResourceDescriptor WBRGBColorDialog WBRichTextEditor WBScrapbookRetrieve WBScrapbookStore WBScratchWindow WBScrollBarEditor WBScrollingPane WBStandardCodePolicy WBStaticGraphic WBStaticTextEditor
        WBStatusPaneEditor WBStatusWindowEditor WBStyleEditor WBSubPool WBSystemBitmapViewer WBTabControlEditor WBTabOrderEditor WBTabOrderLayoutForm WBTabPosition WBTargetObject WBTeamVCodePolicy WBTemplateEditor WBTextEditWindow WBTimerEditor WBTool WBToolBar
        WBToolBarEditor WBToolMenuAddInModule WBToolPalette WBTopPane WBTrackBarEditor WBTranslationChooser WBTranslator WBTreeListBox WBTreeNode WBTreeViewEditor WBUndoAction WBUndoManager WBUndoRedoDialog WBUpDownEditor WBUserInfoDialog WBVersionCodeModule
        WBVerticalScrollBar WBWindowDialog WBWindowEditor WBWindows95AddInModule WBXoteryXCodePolicy WinCharFormat WindowBuilder WindowFrameObject WinEditStream WinFormatRange WinHdItem WinHdLayout WinHdNotify WinLvColumn WinLvDispinfo WinLvItem WinLvKeydown
        WinNmListview WinNmTreeview WinParaFormat WinTbAddBitmap WinTbButton WinTbNotify WinTbSaveParams WinTcItem WinToolinfo WinTooltiptext WinTvDispinfo WinTvInsertstruct WinTvItem WinTvKeydown)
('-------------------------------------------------' )
('Tools-Browsers' Browser ChangeSetBrowser ClassBrowser ClassHierarchyBrowser CodeBrowser MethodBrowser MethodVersionBrowser SelectorBrowser SessionModel SourceChunk)
('Tools-Navigator' BrowserView ClassBasedOrganizer CodeBrowserSelection GetAndSetBuilder MethodBasedOrganizer NavigatorBrowser Organizer)
('Tools-Debuggers' ByteArrayInspector Debugger DictionaryInspector DoubleByteStringInspector FieldInspector GraphicInspector Inspector OrderedCollectionInspector)
('Tools-Development Support' ChangeLogCompressor LatestChangesExtractor MethodClassifier MethodVersion SmalltalkToolInterface)
('Tools-Code Writers & Readers' ClassReader CodeFiler CodeFilerClassWriter CodeFilerOrganizationWriter CodeWriter DigitalkClassWriter IBMSmalltalkClassWriter ParcPlaceClassReader RTFClassWriter TeamVClassWriter VisualWorksClassWriter)
('Tools-Change Sets' ChangeSet ChangeSetAddProtocolItem ChangeSetClassCommentItem ChangeSetClassDefinitionItem ChangeSetClassReorganizationItem ChangeSetEvaluateItem ChangeSetItem ChangeSetManager ChangeSetMethodHighlightItem ChangeSetMethodItem ChangeSetMethodReorganizationItem
        ChangeSetProtocolItem ChangeSetRemoveClassItem ChangeSetRemoveMethodItem ChangeSetRemoveProtocolItem ChangeSetRenameProtocolItem ClassBasedChangeSetItem NonRecordingChangeSet)
('Tools-Scintilla Pane' ExpressionEvaluator ScintillaDLL ScintillaExpressionEvaluator ScintillaFindDialog ScintillaPane ScintillaReplaceDialog ScNotification)
('--------------------------------------------------' )
('3D-Basic' BoundingBox Point3D Point4D WorldGlobal)
('---------------------------------------------------' )
('Scanner/Parser' )
('Grammar Constructor' )
('Table Constructor' )
('---------------------------------------------------' )
('Random Experimentation')
))!

"evaluate"  
CodeFiler systemOrganizer: (ClassBasedOrganizer fromArray: #(('Base-Collections' Array Array2D Bag BucketHashTable ByteArray Collection Dictionary DoubleByteString DoubleByteSymbol FixedSizeCollection HashedCollection HashTable IdentityDictionary IdentityDictionary2D IdentitySet IdentitySortedCollection IndexedCollection Interval
        LinearHashTable LinearIdentityHashTable LinearInlineHashTable LinearSymbolHashTable MethodDictionary MonitoredCollection OrderedCollection OrderedDictionary OrderedIdentityDictionary PriorityQueue Set SortedCollection SparseRectangleArray String Symbol
        SymbolSet)
('Base-Magnitudes' Association Character Date FixedPoint Float Fraction Integer LargeInteger LargeNegativeInteger LargePositiveInteger Magnitude Number Point Point3D RandomNumberStream Rectangle SmallInteger Time TimeStamp)
('Base-Streams' FileStream MixedFileStream ReadStream ReadWriteStream Stream StringDictionaryReader WriteStream)
('Base-Files' Directory File FileSearchResults FileSystemComponent FileSystemContainer FileSystemEntity FileSystemLocator FileSystemPath FileVolume NetworkFilePath)
('Base-Graphics' Bitmap Color DIB GraphicsMedium GraphicsTool IndexedColor Pen Printer RecordingPen RGBColor Screen StoredPicture TextTool)
('Base-Text' Pattern StringModel TextSelection WildPattern)
('Kernel-Objects' BlockClosure Boolean Context False HomeContext Object OneArgumentBlock True TwoArgumentBlock ZeroArgumentBlock)
('Kernel-Behaviors' Behavior Class MetaClass PoolDictionary)
('Kernel-Delegation' ContainerObject DelegationObject SelfInitializingObject)
('Kernel-Messages' ExpressionEvaluator Message MethodExecutor ScintillaExpressionEvaluator WorkspaceExpressionEvaluator)
('Kernel-Source Management' ClassInstaller DefinitionInstaller LibrarySourceReference ObjectMutator SourceChunkReference SourceManager StreamReference StringReference SystemStreamReference)
('Kernel-Processes and Events' ActionSequence CollectionAccessor ConstantAccessor EvaluableAction EventManager InputEvent KeyboardInputEvent LinkMessage Process ProcessScheduler Semaphore SharedBoolean SharedValue Timer UnregisteredEvent)
('Kernel-Exception Handling' APICallEntryPointNotFound APICallError APICallInvalidArgumentType APICallUnknownPrimitiveFailure ArithmeticError BindDuplicate BindError ClassShapeMismatch ControlError Error Exception ExceptionFilter ExceptionHandler ExceptionSet FileAlreadyExists FileError
        FileErrorWriteProtected FileSharingViolation FileSystemAccessDenied HostFileSystemError KeyboardInterrupt LoggedWarning MessageNotUnderstood Notification ProcessTermination ProgressNotification ProtectedFrameMarker RecompilationNotification TooManyOpenFiles
        UnresolvedExternal VetoAction Warning ZeroDivide)
('Kernel-Compiler Support' BlockDescription CompilationError CompilationResult CompiledInitializer CompiledMethod CompiledMethodDefinition CompilerErrorHandler CompilerInterface CompilerNameScope DictionaryScope GlobalPoolScope HaltingErrorHandler MultiplePoolScope NonInteractiveErrorHandler
        SilentErrorHandler TextPaneErrorHandler TraditionalCompilerErrorHandler VariableLocator VariableLocatorNoSource WorkspaceErrorHandler)
('Kernel-Special Objects' DeletedClass EmptySlot Ephemeron EphemeronDictionary NotificationManager ResidueObject ServiceRegistry SessionModel SystemDictionary SystemWeakRegistries UndefinedObject VirtualMachineConfiguration WeakKeyedRegistry WeakLinearHashTable WeakRegistry)
('Kernel-Host Interfaces' CallBack ClipboardManager CursorManager Font HelpManager Icon NationalLanguageSupport OperatingSystemInformation)
('Kernel-Structures' Atom CallBack16 DeviceContext ExternalAddress ExternalBuffer ExternalGlobalAddress ExternalGlobalHandle ExternalHandle ExternalHeapAddress ExternalHeapHandle ExternalLong ExternalMemoryHandle ExternalSegmentedAddress FileHandle SelfDefinedStructure Win32FindData
        WinBitmapFileHeader WinBitmapInfo WinBitmapInfoHeader WinBitmapStruct WinColorref WinDialogInfo WindowHandle WinDrawItemStruct WinFileTime WinLargeInteger WinLogBrush WinLogFont WinLogicalBrush WinLogicalObject WinLogicalPalette WinLogicalPen WinLogPalette
        WinLogPen WinMeasureItemStruct WinMemorystatus WinMessage WinMetafileheader WinMetafilepict WinMetaheader WinMinmaxinfo WinNmhdr WinOfstruct WinPaintStructure WinPaletteEntry WinPoint WinRectangle WinStructArray WinSystemTime WinTextMetrics WinWindowClass
        WinWindowPlacement)
('Kernel-DLLs' CommonControlsDLL CommonDialogDLL DynamicLinkLibrary DynamicLinkLibrary16 GDIDLL KernelDLL KernelDLL16 ShellDLL ThunkWin32sDLL ThunkWin95DLL UserDLL VirtualMachineDLL VirtualMachineExe WNetDLL)
('Kernel-Object Libraries' ObjectStore ObjectStoreExternal ObjectStoreReader SmalltalkLibrary SmalltalkLibraryBinder)
('Windows-Views' ApplicationCoordinator ApplicationWindow ControlWindow DialogCoordinator DialogTopPane DialogWindow ListChooser MainWindow MenuWindow ObjectWindow SystemWindow TersecriptWindow TextWindow TopPane TranscriptWindow ViewManager WalkbackWindow Window)
('Windows-SubPanes' AutoSelectComboBox AutoSelectComboEntryField Button CheckBox ColorMultipleSelectListBox ComboBox ComboEntryField ControlPane DrawnButton DropDownList EllipticSkinBox EntryField GraphPane GroupBox GroupPane ListBox ListPane MultipleSelectListBox PagedRangeControl
        RadioButton RangeControl RectangularSkinBox ScrollBar StaticBox StaticGraphic StaticPane StaticText SubPane TextEdit TextPane TextPaneControl ThreeStateButton Toggle Window)
('Windows-Dialogs' AboutDialog ChooseManyDialog ChooseOneDialog ColorDialog CommonSystemDialog DialogBox FileDialog FindReplaceDialog FontDialog MessageBox NewSubclassDialog PrintAbortDialog PrintDialog ProgressIndicatorDialog ProgressIndicatorDialogThatWorks Prompter PrompterDialog
        SaveImageAsDialog SaveImageDialog WindowDialog)
('Windows-Support' CompositeLayout ComputedLayout DialogLayoutFrame DragDropObject DragDropSession LayoutFrame LayoutUnit LocalDragDropObject LocalDragDropSession Menu MenuItem NoMenusWindowPolicy SmalltalkWindowPolicy StandardWindowPolicy WindowPolicy)
('Services-Service Manager' InitializationFile InitializationFileSection Service ServiceManager ServiceManagerWindow)
('PARTS and Others' AboutToReplaceFile ActionButton AddressEditorPane AddressPane AddressPaneTester AviVideo BitEditor ButtonEditor ButtonListBox ButtonListBoxItem CdAudio CheckBoxGroup CodeGenerationPrivateServices ColumnListBox CompositeFrameObject CompositePane DictionaryEditorPane
        EnhancedEntryField EntryFieldGroup ExtendedListBox FrameObject FramingParameters GroupPropertyAccessor Header HeaderItem HeaderTester ImageList LinkButton LinkPropertyAccessor ListConnectionPane ListDialog ListEditorPane ListItem ListView ListViewItem
        MaskedStylePropertyAccessor MciDevice MciFileStream MciStream ModelObjectTest MultimediaDLL MultiSelectListDialog NamePane ObjectChangeMap ObjectDumper ObjectFiler ObjectLibrary ObjectLoadDialog ObjectLoader ObjectPropertyAccessor ObjectReference ObjectStoreFile
        ObjectStoreFileExternal ObjectStoreFileObjects ObjectStoreFileWithVersion ObjectStoreObject ObjectStoreObjects ObjectStoreRoot ObjectStoreSpace ObjectStoreSpaceExternals ObjectStoreWithClient ObjectStoreWriter OkCancelPane PActionButton PaneTester PAnimationPane
        PARTSAddObject PARTSAddObjectDialog PARTSAddPartObject PARTSAddPartSession PARTSAliasLink PARTSAliasMessage PARTSAlphabeticEntryFieldPart PARTSAnyFileDialog PARTSAnyFileDialogPart PARTSApplication PARTSApplicationCoordinator PARTSApplicationHolder PARTSApplicationLoadError
        PARTSApplicationProperty PARTSArrayEditor PARTSArrayHolderPart PARTSBackgroundColorSettingsEditor PARTSBaseNotebook PARTSBitEditor PARTSCatalog PARTSCatalogDragSession PARTSCheckBoxPart PARTSChooseFileDialog PARTSClipboardAccessorPart PARTSCodeGeneratorInterface
        PARTSCodeGeneratorReaderInterface PARTSCodeGeneratorWriterInterface PARTSCollectionHolder PARTSComboBoxPart PARTSComboEntryField PARTSCommonPropertiesEditor PARTSComparisonPart PARTSComputationPart PARTSConfirmerPart PARTSConfirmerWithCancelPart PARTSContentsEditor
        PARTSConversionPart PARTSCurrencyEntryFieldPart PARTSCursorManager PARTSCyclicReference PARTSDateEntryFieldPart PARTSDeveloperDebugger PARTSDevelopmentSessionManager PARTSDial PARTSDialEditor PARTSDialog PARTSDialogTopPane PARTSDialogWindowPart PARTSDialPanePart
        PARTSDictionaryEditor PARTSDictionaryHolderPart PARTSDiskAccessorPart PARTSDosDirectory PARTSDosFileDescriptor PARTSDragDropSpec PARTSDragResult PARTSDragSession PARTSDrawnButtonPart PARTSDropDownListPart PARTSEditMenu PARTSEditor PARTSEditorMoveObject
        PARTSEditorMoveSession PARTSEditorState PARTSEmptyFile PARTSEntryFieldPart PARTSException PARTSExecutablePartFileProcessor PARTSExeFileProcessor PARTSExpressionEntryField PARTSExtentEditor PARTSFieldOrderDialog PARTSFile PARTSFileAccessorPart PARTSFileDescriptor
        PARTSFileDialog PARTSFileDialogPart PARTSFileMenu PARTSFileNotFound PARTSFileOperationContext PARTSFileProcessor PARTSFileType PARTSFileVersion PARTSFixedDecimalEntryFieldPart PARTSFloatEntryFieldPart PARTSFormattedEntryField PARTSFormGenerator PARTSFormGeneratorItem
        PARTSFramer PARTSGetExecutionContext PARTSGraphPanePart PARTSGroupPane PARTSGroupPanePart PARTSGroupPanePropertiesEditor PARTSHelpManager PARTSHelpMenu PARTSHostInterface PARTSIcon PARTSIconEditor PARTSIconEditorWindows PARTSIconPane PARTSIncorrectVersion
        PARTSInformationDialogPart PARTSIniFile PARTSIntegerEntryFieldPart PARTSInterfaceList PARTSInvalidApplication PARTSInvalidExternalDataItemSize PARTSLaunchPadPart PARTSLink PARTSLinkColorSettingsEditor PARTSLinkEditState PARTSLinkJunctionPart PARTSLinkReference
        PARTSLinkSettings PARTSListPanePart PARTSLoadContext PARTSLocalDragDropObject PARTSLocalDragDropSession PARTSMenuBar PARTSMenuBitmapItemPart PARTSMenuItemPane PARTSMenuLabelPart PARTSMenuPaneWindows PARTSMenuPart PARTSMenuSeparatorPart PARTSMenuTextItemPart
        PARTSMenuWindow PARTSMessageBox PARTSMessageNotUnderstood PARTSMirrorCopyDictionary PARTSMouseButtonsSettingsEditor PARTSMultipleChoiceListPart PARTSNestedPart PARTSNestedPartBrowser PARTSNestedPartLoadError PARTSNonvisualPart PARTSNonvisualPartPropertyDialog
        PARTSNotebook PARTSNotebookClientAreaPane PARTSNotebookPage PARTSNotebookPageAttributes PARTSNotebookPagePane PARTSNotOnSearchPath PARTSNumberHolderPart PARTSNumericField PARTSOpenDialogWindowPropertiesEditor PARTSOpenSaveFileDialog PARTSOpenWindowPropertiesEditor
        PARTSOrderedCollectionEditor PARTSOrderedCollectionHolderPart PARTSOrderedGroupPane PARTSOrderedVisualPartPropertyDialog PARTSPane PARTSPartAccessorPart PARTSPartBrowser PARTSPartFileProcessor PARTSPartPropertiesEditor PARTSPartPropertyDialog PARTSPartPropertySubdialog
        PARTSPasteObject PARTSPasteSession PARTSPathSequenceEditor PARTSPhoneNumberEntryFieldPart PARTSPictureFieldPart PARTSPictureMaskEditor PARTSPointEditor PARTSPopupWindowOS2 PARTSPopupWindowWindows PARTSPrebuiltDialog PARTSPrebuiltDialogTopPane PARTSPrebuiltMessageBox
        PARTSPrinterPart PARTSPrompter PARTSPrompterPart PARTSPropertiesEditor PARTSPropertyBinaryStyle PARTSPropertyBoolean PARTSPropertyButton PARTSPropertyButtonGroup PARTSPropertyButtonGroupWS PARTSPropertyButtonGroupWSExtended PARTSPropertyColorAndFont PARTSPropertyCreateForm
        PARTSPropertyCreateTable PARTSPropertyDateFormat PARTSPropertyDragDrop PARTSPropertyEditButton PARTSPropertyExpression PARTSPropertyFixedList PARTSPropertyFormattedString PARTSPropertyFormGeneratorButton PARTSPropertyGraphic PARTSPropertyIcon PARTSPropertyLineOfButtons
        PARTSPropertyList PARTSPropertyMenuAccelerator PARTSPropertyNumber PARTSPropertyPseudoStyle PARTSPropertySequenceChildren PARTSPropertyStaticText PARTSPropertyString PARTSPropertyStructure PARTSPropertyText PARTSPropertyUnit PARTSPropertyWindowStyle PARTSPushButtonPart
        PARTSRadioButtonPart PARTSReferenceBrowser PARTSRelativeLayoutDialog PARTSRepeatDropSession PARTSRuntimeSessionManager PARTSScenario PARTSScenarioComment PARTSScenarioEditor PARTSScenarioPairs PARTSScript PARTSScriptCompilerInterface PARTSScriptContext
        PARTSScriptDefinition PARTSScriptDictionary PARTSScriptSource PARTSScrollPane PARTSSequenceEditor PARTSSessionManager PARTSSettings PARTSSettingsEditor PARTSSettingsViewer PARTSSilentErrorHandler PARTSSimpleRichTextEditor PARTSSimpleTextEditor PARTSSizeWindowPart
        PARTSSmalltalkLibraryFileProcessor PARTSSourceFileProcessor PARTSSpeakerDLL PARTSSpeakerPart PARTSStandardBracketsMenu PARTSStandardEditMenu PARTSStandardFileMenu PARTSStandardHelpMenu PARTSStandardMenu PARTSStarterWindow PARTSStarterWindowWindows PARTSStaticGraphicPart
        PARTSStaticTextPart PARTSStoreContext PARTSStringHolderPart PARTSStringTemplate PARTSStringTemplatePart PARTSSublinkReference PARTSTabControlPagePart PARTSTabControlPart PARTSTabOrderEditor PARTSTeamVNestedPartBrowser PARTSTextIcon PARTSTextPaneErrorHandler
        PARTSTextPanePart PARTSTextWindow PARTSTimerPart PARTSTimerWindow PARTSTimeStamp PARTSToolbarButtonPart PARTSToolbarItem PARTSToolbarSeparatorPart PARTSToolbarToggleButtonPart PARTSToolboxPart PARTSToolContainer PARTSToolPane PARTSTopPane PARTSTypedValueHolder
        PARTSUpgradeObject PARTSUpgradePanePart PARTSUpgradeTablePane PARTSUpgradeVisualPart PARTSValueHolderPart PARTSVisualPartPropertyDialog PARTSWindow PARTSWindowPart PARTSWindowSizeEditor PARTSWorkbenchSessionManager PARTSWrapper PButton PButtonListBox
        PCheckBox PCheckBoxGroup PColumnListBox PComboBox PCompositePane PDrawnButton PDropDownList PEllipticSkinBox PEnhancedEntryField PEntryField PEntryFieldGroup PersonEditor PersonEditorPane PersonPane PersonPaneTester PFormattedEntryField PGenericSubpane
        PGraphPane PGroupbox PGroupBox PHeader PLinkButton PListBox PListPane PListView PMultipleSelectListBox PProgressBar PRadioButton PRadioButtonGroup PRealWidgetControl PRectangularSkinBox PRichEdit ProgressBar PropertyAccessor PropertyInterface PropertyManager
        PropertyPage PScrollBar PSpinButton PStaticBox PStaticGraphic PStaticText PStatusPane PStatusWindow PTabControl PTextEdit PTextPane PThreeStateButton PToggle PTrackBar PTreeView PUpDown PVideoPane PWBHorizontalScrollBar PWBInvisibleGroupPane PWBStaticGraphic
        PWBToolBar PWBVerticalScrollBar RadioButtonDialog RadioButtonGroup RichEdit RichEdit32DLL RichEditParagraphFormatDialog RichEditTabStopDialog SelectorPropertyAccessor SelectPersonDialog SeparatedListDialog SexPane SmalltalkLibraryBuilder SmalltalkLibraryObjects
        SmalltalkLibraryReporter SpinButton SpinButtonEntryField StatusBox StatusField StatusPane StatusWindow StylePropertyAccessor TabControl TabControlItem TabControlPage Tool Toolbar ToolbarButton ToolbarItem ToolbarSeparator ToolbarToggleButton ToolPane
        ToolTip TrackBar TreeView TreeViewItem UnknownImport UpDown UpgraderForDirectory UpgraderForFile VideoPane WaveAudio WBAboutDialog WBAbstractAddInModule WBAbstractCodeModule WBAbstractCreateViewsModule WBAbstractPrompter WBAction WBActionEditor WBActionLinkAddInModule
        WBAddInManager WBAddress WBApplicationCoordinatorMenuModule WBApplicationCoordinatorModule WBAttributeEditor WBAttributeWindow WBBasicCodeModule WBBitmapEditorCompositePane WBBitmapManager WBBitmapManagerWindow WBBitmapPool WBBitmapSubPool WBCallOutEditor
        WBCallOutModule WBChooseClassDialog WBChoosePaneDialog WBClassDefinition WBCodeGenBase WBCodeGenerator WBCodeModule WBCodePolicy WBCodeStream WBColorDialog WBComboBox WBComboEntryField WBCompositeMenuModule WBCompositePaneExampleAddInModule WBCompositePaneModule
        WBCompositePaneScratchWindow WBCompositePaneTester WBCreateBitmap WBCreateButton WBCreateClassDialog WBCreateMenuModule WBCreatePowerMenuModule WBCreatePowerViewModule WBCreatePowerViewsModule WBCreateViewModule WBCreateViewsModule WBCreateViewsStubModule
        WBDefaultCompositePaneScratchWindow WBDefaultDialogScratchWindow WBDefaultScratchWindow WBDescriptor WBDevelopmentCompositePane WBDevelopmentDialog WBDevelopmentObject WBDevelopmentSubPane WBDevelopmentWindow WBDialogEditor WBDialogScratchWindow WBDialogTopPane
        WBDisplayContext WBDrawnButton WBEditClassDialog WBEnhancedAttributeEditor WBEnhancedEntryFieldEditor WBEntryField WBEntryListPrompter WBENVYCodePolicy WBEventArgumentDescription WBEventDescription WBEventHandlerStubModule WBEventManagerWindow WBEventMap
        WBEventMessage WBEventTranslationEditor WBEventTranslator WBFileSelectorEditor WBFontEditorCompositePane WBFontManager WBFontManagerWindow WBFontPool WBFontSelectionWindow WBFontSubPool WBFramerExample WBFramingEditor WBGeometryManager WBGraphicObject
        WBGroupBox WBHandle WBHeaderEditor WBHorizontalScrollBar WBInstVarGetModule WBInstVarObject WBInstVarSetModule WBInterfaceObject WBKeyAccel WBKeyEntryField WBLayoutCodeModule WBLayoutForm WBLayoutFrameEditor WBLayoutWizard WBLinkEditor WBListBox WBListChooser
        WBListEditor WBListEntryField WBListViewEditor WBLocator WBLookPolicy WBLookPolicyOS2 WBLookPolicyWin31 WBLookPolicyWin95 WBManagedPFont WBManagedPNLSString WBManagedPValue WBMenu WBMenubarEditor WBMenuEditor WBMenuItem WBMenuItemStub WBMenuTester WBMessage
        WBMethodStubModule WBMiniBrowserExample WBModelBasicSetModule WBModelCodeModule WBModelDefinitionEditor WBModelEventsTriggeredModule WBModelGetModule WBModelInitializeModule WBModelInstVar WBModelObjectEditor WBModelSetModule WBModelTriggerEventModule
        WBMultiListChooser WBMultiToolPalette WBMultiViewAddInModule WBName WBNLSDictionaryReader WBNLSEditorCompositePane WBNLSExtractionTranslator WBNLSManager WBNLSManagerWindow WBNLSPool WBNLSReplacementTranslator WBNLSSubPool WBNLSTranslator WBObject WBOldEventHandlerStubModule
        WBOpenMethodModule WBOrderedCollection WBOutboardAttributeWindow WBOutboardWindow WBPartEvent WBPartEventsModule WBPartEventsTriggeredModule WBPartMessage WBPartMessagesModule WBPARTSEventList WBPARTSInterfaceEditor WBPARTSInterfaceList WBPARTSMessageList
        WBPartsModule WBPerson WBPlaceHolderObject WBPMenu WBPMenubar WBPMenuItem WBPool WBPoolEditorCompositePane WBPoolError WBPoolErrorAbsentKey WBPoolErrorDuplicateKey WBPoolErrorDuplicatePoolName WBPoolErrorInvalidCategory WBPoolErrorInvalidFile WBPoolErrorInvalidKey
        WBPoolErrorInvalidPool WBPoolErrorInvalidPoolName WBPoolErrorInvalidValue WBPoolManager WBPoolManagerWindow WBPowerViewAddInModule WBPrimaryModelInitializeModule WBPrimaryModelModule WBPrimaryModelOpenOnModule WBProgressBarEditor WBPropertyDescriptor
        WBPropertyEditor WBPropertyManager WBPrototype WBResizeBitmap WBResourceDescriptor WBRGBColorDialog WBRichTextEditor WBScrapbookRetrieve WBScrapbookStore WBScratchWindow WBScrollBarEditor WBScrollingPane WBStandardCodePolicy WBStaticGraphic WBStaticTextEditor
        WBStatusPaneEditor WBStatusWindowEditor WBStyleEditor WBSubPool WBSystemBitmapViewer WBTabControlEditor WBTabOrderEditor WBTabOrderLayoutForm WBTabPosition WBTargetObject WBTeamVCodePolicy WBTemplateEditor WBTextEditWindow WBTimerEditor WBTool WBToolBar
        WBToolBarEditor WBToolMenuAddInModule WBToolPalette WBTopPane WBTrackBarEditor WBTranslationChooser WBTranslator WBTreeListBox WBTreeNode WBTreeViewEditor WBUndoAction WBUndoManager WBUndoRedoDialog WBUpDownEditor WBUserInfoDialog WBVersionCodeModule
        WBVerticalScrollBar WBWindowDialog WBWindowEditor WBWindows95AddInModule WBXoteryXCodePolicy WinCharFormat WindowBuilder WindowFrameObject WinEditStream WinFormatRange WinHdItem WinHdLayout WinHdNotify WinLvColumn WinLvDispinfo WinLvItem WinLvKeydown
        WinNmListview WinNmTreeview WinParaFormat WinTbAddBitmap WinTbButton WinTbNotify WinTbSaveParams WinTcItem WinToolinfo WinTooltiptext WinTvDispinfo WinTvInsertstruct WinTvItem WinTvKeydown)
('-------------------------------------------------' )
('Tools-Browsers' Browser ChangeSetBrowser ClassBrowser ClassHierarchyBrowser CodeBrowser MethodBrowser MethodVersionBrowser SelectorBrowser SessionModel SourceChunk)
('Tools-Navigator' BrowserView ClassBasedOrganizer CodeBrowserSelection GetAndSetBuilder MethodBasedOrganizer NavigatorBrowser Organizer)
('Tools-Debuggers' ByteArrayInspector Debugger DictionaryInspector DoubleByteStringInspector FieldInspector GraphicInspector Inspector OrderedCollectionInspector)
('Tools-Development Support' ChangeLogCompressor LatestChangesExtractor MethodClassifier MethodVersion SmalltalkToolInterface)
('Tools-Code Writers & Readers' ClassReader CodeFiler CodeFilerClassWriter CodeFilerOrganizationWriter CodeWriter DigitalkClassWriter IBMSmalltalkClassWriter ParcPlaceClassReader RTFClassWriter TeamVClassWriter VisualWorksClassWriter)
('Tools-Change Sets' ChangeSet ChangeSetAddProtocolItem ChangeSetClassCommentItem ChangeSetClassDefinitionItem ChangeSetClassReorganizationItem ChangeSetEvaluateItem ChangeSetItem ChangeSetManager ChangeSetMethodHighlightItem ChangeSetMethodItem ChangeSetMethodReorganizationItem
        ChangeSetProtocolItem ChangeSetRemoveClassItem ChangeSetRemoveMethodItem ChangeSetRemoveProtocolItem ChangeSetRenameProtocolItem ClassBasedChangeSetItem NonRecordingChangeSet)
('Tools-Scintilla Pane' ExpressionEvaluator ScintillaDLL ScintillaExpressionEvaluator ScintillaFindDialog ScintillaPane ScintillaReplaceDialog ScNotification)
('--------------------------------------------------' )
('3D-Basic' BoundingBox Point3D Point4D WorldGlobal)
('---------------------------------------------------' )
('Scanner/Parser' )
('Grammar Constructor' )
('Table Constructor' )
('---------------------------------------------------' )
('Random Experimentation' )
))!

"evaluate" 
(CodeFiler systemOrganizer addCategory: '''---------------------------------------------------'' ' before: 'Random Experimentation')!

"evaluate"   
CodeFiler systemOrganizer: (ClassBasedOrganizer fromArray: #(('Base-Collections' Array Array2D Bag BucketHashTable ByteArray Collection Dictionary DoubleByteString DoubleByteSymbol FixedSizeCollection HashedCollection HashTable IdentityDictionary IdentityDictionary2D IdentitySet IdentitySortedCollection IndexedCollection Interval
        LinearHashTable LinearIdentityHashTable LinearInlineHashTable LinearSymbolHashTable MethodDictionary MonitoredCollection OrderedCollection OrderedDictionary OrderedIdentityDictionary PriorityQueue Set SortedCollection SparseRectangleArray String Symbol
        SymbolSet)
('Base-Magnitudes' Association Character Date FixedPoint Float Fraction Integer LargeInteger LargeNegativeInteger LargePositiveInteger Magnitude Number Point Point3D RandomNumberStream Rectangle SmallInteger Time TimeStamp)
('Base-Streams' FileStream MixedFileStream ReadStream ReadWriteStream Stream StringDictionaryReader WriteStream)
('Base-Files' Directory File FileSearchResults FileSystemComponent FileSystemContainer FileSystemEntity FileSystemLocator FileSystemPath FileVolume NetworkFilePath)
('Base-Graphics' Bitmap Color DIB GraphicsMedium GraphicsTool IndexedColor Pen Printer RecordingPen RGBColor Screen StoredPicture TextTool)
('Base-Text' Pattern StringModel TextSelection WildPattern)
('Kernel-Objects' BlockClosure Boolean Context False HomeContext Object OneArgumentBlock True TwoArgumentBlock ZeroArgumentBlock)
('Kernel-Behaviors' Behavior Class MetaClass PoolDictionary)
('Kernel-Delegation' ContainerObject DelegationObject SelfInitializingObject)
('Kernel-Messages' ExpressionEvaluator Message MethodExecutor ScintillaExpressionEvaluator WorkspaceExpressionEvaluator)
('Kernel-Source Management' ClassInstaller DefinitionInstaller LibrarySourceReference ObjectMutator SourceChunkReference SourceManager StreamReference StringReference SystemStreamReference)
('Kernel-Processes and Events' ActionSequence CollectionAccessor ConstantAccessor EvaluableAction EventManager InputEvent KeyboardInputEvent LinkMessage Process ProcessScheduler Semaphore SharedBoolean SharedValue Timer UnregisteredEvent)
('Kernel-Exception Handling' APICallEntryPointNotFound APICallError APICallInvalidArgumentType APICallUnknownPrimitiveFailure ArithmeticError BindDuplicate BindError ClassShapeMismatch ControlError Error Exception ExceptionFilter ExceptionHandler ExceptionSet FileAlreadyExists FileError
        FileErrorWriteProtected FileSharingViolation FileSystemAccessDenied HostFileSystemError KeyboardInterrupt LoggedWarning MessageNotUnderstood Notification ProcessTermination ProgressNotification ProtectedFrameMarker RecompilationNotification TooManyOpenFiles
        UnresolvedExternal VetoAction Warning ZeroDivide)
('Kernel-Compiler Support' BlockDescription CompilationError CompilationResult CompiledInitializer CompiledMethod CompiledMethodDefinition CompilerErrorHandler CompilerInterface CompilerNameScope DictionaryScope GlobalPoolScope HaltingErrorHandler MultiplePoolScope NonInteractiveErrorHandler
        SilentErrorHandler TextPaneErrorHandler TraditionalCompilerErrorHandler VariableLocator VariableLocatorNoSource WorkspaceErrorHandler)
('Kernel-Special Objects' DeletedClass EmptySlot Ephemeron EphemeronDictionary NotificationManager ResidueObject ServiceRegistry SessionModel SystemDictionary SystemWeakRegistries UndefinedObject VirtualMachineConfiguration WeakKeyedRegistry WeakLinearHashTable WeakRegistry)
('Kernel-Host Interfaces' CallBack ClipboardManager CursorManager Font HelpManager Icon NationalLanguageSupport OperatingSystemInformation)
('Kernel-Structures' Atom CallBack16 DeviceContext ExternalAddress ExternalBuffer ExternalGlobalAddress ExternalGlobalHandle ExternalHandle ExternalHeapAddress ExternalHeapHandle ExternalLong ExternalMemoryHandle ExternalSegmentedAddress FileHandle SelfDefinedStructure Win32FindData
        WinBitmapFileHeader WinBitmapInfo WinBitmapInfoHeader WinBitmapStruct WinColorref WinDialogInfo WindowHandle WinDrawItemStruct WinFileTime WinLargeInteger WinLogBrush WinLogFont WinLogicalBrush WinLogicalObject WinLogicalPalette WinLogicalPen WinLogPalette
        WinLogPen WinMeasureItemStruct WinMemorystatus WinMessage WinMetafileheader WinMetafilepict WinMetaheader WinMinmaxinfo WinNmhdr WinOfstruct WinPaintStructure WinPaletteEntry WinPoint WinRectangle WinStructArray WinSystemTime WinTextMetrics WinWindowClass
        WinWindowPlacement)
('Kernel-DLLs' CommonControlsDLL CommonDialogDLL DynamicLinkLibrary DynamicLinkLibrary16 GDIDLL KernelDLL KernelDLL16 ShellDLL ThunkWin32sDLL ThunkWin95DLL UserDLL VirtualMachineDLL VirtualMachineExe WNetDLL)
('Kernel-Object Libraries' ObjectStore ObjectStoreExternal ObjectStoreReader SmalltalkLibrary SmalltalkLibraryBinder)
('Windows-Views' ApplicationCoordinator ApplicationWindow ControlWindow DialogCoordinator DialogTopPane DialogWindow ListChooser MainWindow MenuWindow ObjectWindow SystemWindow TersecriptWindow TextWindow TopPane TranscriptWindow ViewManager WalkbackWindow Window)
('Windows-SubPanes' AutoSelectComboBox AutoSelectComboEntryField Button CheckBox ColorMultipleSelectListBox ComboBox ComboEntryField ControlPane DrawnButton DropDownList EllipticSkinBox EntryField GraphPane GroupBox GroupPane ListBox ListPane MultipleSelectListBox PagedRangeControl
        RadioButton RangeControl RectangularSkinBox ScrollBar StaticBox StaticGraphic StaticPane StaticText SubPane TextEdit TextPane TextPaneControl ThreeStateButton Toggle Window)
('Windows-Dialogs' AboutDialog ChooseManyDialog ChooseOneDialog ColorDialog CommonSystemDialog DialogBox FileDialog FindReplaceDialog FontDialog MessageBox NewSubclassDialog PrintAbortDialog PrintDialog ProgressIndicatorDialog ProgressIndicatorDialogThatWorks Prompter PrompterDialog
        SaveImageAsDialog SaveImageDialog WindowDialog)
('Windows-Support' CompositeLayout ComputedLayout DialogLayoutFrame DragDropObject DragDropSession LayoutFrame LayoutUnit LocalDragDropObject LocalDragDropSession Menu MenuItem NoMenusWindowPolicy SmalltalkWindowPolicy StandardWindowPolicy WindowPolicy)
('Services-Service Manager' InitializationFile InitializationFileSection Service ServiceManager ServiceManagerWindow)
('PARTS and Others' AboutToReplaceFile ActionButton AddressEditorPane AddressPane AddressPaneTester AviVideo BitEditor ButtonEditor ButtonListBox ButtonListBoxItem CdAudio CheckBoxGroup CodeGenerationPrivateServices ColumnListBox CompositeFrameObject CompositePane DictionaryEditorPane
        EnhancedEntryField EntryFieldGroup ExtendedListBox FrameObject FramingParameters GroupPropertyAccessor Header HeaderItem HeaderTester ImageList LinkButton LinkPropertyAccessor ListConnectionPane ListDialog ListEditorPane ListItem ListView ListViewItem
        MaskedStylePropertyAccessor MciDevice MciFileStream MciStream ModelObjectTest MultimediaDLL MultiSelectListDialog NamePane ObjectChangeMap ObjectDumper ObjectFiler ObjectLibrary ObjectLoadDialog ObjectLoader ObjectPropertyAccessor ObjectReference ObjectStoreFile
        ObjectStoreFileExternal ObjectStoreFileObjects ObjectStoreFileWithVersion ObjectStoreObject ObjectStoreObjects ObjectStoreRoot ObjectStoreSpace ObjectStoreSpaceExternals ObjectStoreWithClient ObjectStoreWriter OkCancelPane PActionButton PaneTester PAnimationPane
        PARTSAddObject PARTSAddObjectDialog PARTSAddPartObject PARTSAddPartSession PARTSAliasLink PARTSAliasMessage PARTSAlphabeticEntryFieldPart PARTSAnyFileDialog PARTSAnyFileDialogPart PARTSApplication PARTSApplicationCoordinator PARTSApplicationHolder PARTSApplicationLoadError
        PARTSApplicationProperty PARTSArrayEditor PARTSArrayHolderPart PARTSBackgroundColorSettingsEditor PARTSBaseNotebook PARTSBitEditor PARTSCatalog PARTSCatalogDragSession PARTSCheckBoxPart PARTSChooseFileDialog PARTSClipboardAccessorPart PARTSCodeGeneratorInterface
        PARTSCodeGeneratorReaderInterface PARTSCodeGeneratorWriterInterface PARTSCollectionHolder PARTSComboBoxPart PARTSComboEntryField PARTSCommonPropertiesEditor PARTSComparisonPart PARTSComputationPart PARTSConfirmerPart PARTSConfirmerWithCancelPart PARTSContentsEditor
        PARTSConversionPart PARTSCurrencyEntryFieldPart PARTSCursorManager PARTSCyclicReference PARTSDateEntryFieldPart PARTSDeveloperDebugger PARTSDevelopmentSessionManager PARTSDial PARTSDialEditor PARTSDialog PARTSDialogTopPane PARTSDialogWindowPart PARTSDialPanePart
        PARTSDictionaryEditor PARTSDictionaryHolderPart PARTSDiskAccessorPart PARTSDosDirectory PARTSDosFileDescriptor PARTSDragDropSpec PARTSDragResult PARTSDragSession PARTSDrawnButtonPart PARTSDropDownListPart PARTSEditMenu PARTSEditor PARTSEditorMoveObject
        PARTSEditorMoveSession PARTSEditorState PARTSEmptyFile PARTSEntryFieldPart PARTSException PARTSExecutablePartFileProcessor PARTSExeFileProcessor PARTSExpressionEntryField PARTSExtentEditor PARTSFieldOrderDialog PARTSFile PARTSFileAccessorPart PARTSFileDescriptor
        PARTSFileDialog PARTSFileDialogPart PARTSFileMenu PARTSFileNotFound PARTSFileOperationContext PARTSFileProcessor PARTSFileType PARTSFileVersion PARTSFixedDecimalEntryFieldPart PARTSFloatEntryFieldPart PARTSFormattedEntryField PARTSFormGenerator PARTSFormGeneratorItem
        PARTSFramer PARTSGetExecutionContext PARTSGraphPanePart PARTSGroupPane PARTSGroupPanePart PARTSGroupPanePropertiesEditor PARTSHelpManager PARTSHelpMenu PARTSHostInterface PARTSIcon PARTSIconEditor PARTSIconEditorWindows PARTSIconPane PARTSIncorrectVersion
        PARTSInformationDialogPart PARTSIniFile PARTSIntegerEntryFieldPart PARTSInterfaceList PARTSInvalidApplication PARTSInvalidExternalDataItemSize PARTSLaunchPadPart PARTSLink PARTSLinkColorSettingsEditor PARTSLinkEditState PARTSLinkJunctionPart PARTSLinkReference
        PARTSLinkSettings PARTSListPanePart PARTSLoadContext PARTSLocalDragDropObject PARTSLocalDragDropSession PARTSMenuBar PARTSMenuBitmapItemPart PARTSMenuItemPane PARTSMenuLabelPart PARTSMenuPaneWindows PARTSMenuPart PARTSMenuSeparatorPart PARTSMenuTextItemPart
        PARTSMenuWindow PARTSMessageBox PARTSMessageNotUnderstood PARTSMirrorCopyDictionary PARTSMouseButtonsSettingsEditor PARTSMultipleChoiceListPart PARTSNestedPart PARTSNestedPartBrowser PARTSNestedPartLoadError PARTSNonvisualPart PARTSNonvisualPartPropertyDialog
        PARTSNotebook PARTSNotebookClientAreaPane PARTSNotebookPage PARTSNotebookPageAttributes PARTSNotebookPagePane PARTSNotOnSearchPath PARTSNumberHolderPart PARTSNumericField PARTSOpenDialogWindowPropertiesEditor PARTSOpenSaveFileDialog PARTSOpenWindowPropertiesEditor
        PARTSOrderedCollectionEditor PARTSOrderedCollectionHolderPart PARTSOrderedGroupPane PARTSOrderedVisualPartPropertyDialog PARTSPane PARTSPartAccessorPart PARTSPartBrowser PARTSPartFileProcessor PARTSPartPropertiesEditor PARTSPartPropertyDialog PARTSPartPropertySubdialog
        PARTSPasteObject PARTSPasteSession PARTSPathSequenceEditor PARTSPhoneNumberEntryFieldPart PARTSPictureFieldPart PARTSPictureMaskEditor PARTSPointEditor PARTSPopupWindowOS2 PARTSPopupWindowWindows PARTSPrebuiltDialog PARTSPrebuiltDialogTopPane PARTSPrebuiltMessageBox
        PARTSPrinterPart PARTSPrompter PARTSPrompterPart PARTSPropertiesEditor PARTSPropertyBinaryStyle PARTSPropertyBoolean PARTSPropertyButton PARTSPropertyButtonGroup PARTSPropertyButtonGroupWS PARTSPropertyButtonGroupWSExtended PARTSPropertyColorAndFont PARTSPropertyCreateForm
        PARTSPropertyCreateTable PARTSPropertyDateFormat PARTSPropertyDragDrop PARTSPropertyEditButton PARTSPropertyExpression PARTSPropertyFixedList PARTSPropertyFormattedString PARTSPropertyFormGeneratorButton PARTSPropertyGraphic PARTSPropertyIcon PARTSPropertyLineOfButtons
        PARTSPropertyList PARTSPropertyMenuAccelerator PARTSPropertyNumber PARTSPropertyPseudoStyle PARTSPropertySequenceChildren PARTSPropertyStaticText PARTSPropertyString PARTSPropertyStructure PARTSPropertyText PARTSPropertyUnit PARTSPropertyWindowStyle PARTSPushButtonPart
        PARTSRadioButtonPart PARTSReferenceBrowser PARTSRelativeLayoutDialog PARTSRepeatDropSession PARTSRuntimeSessionManager PARTSScenario PARTSScenarioComment PARTSScenarioEditor PARTSScenarioPairs PARTSScript PARTSScriptCompilerInterface PARTSScriptContext
        PARTSScriptDefinition PARTSScriptDictionary PARTSScriptSource PARTSScrollPane PARTSSequenceEditor PARTSSessionManager PARTSSettings PARTSSettingsEditor PARTSSettingsViewer PARTSSilentErrorHandler PARTSSimpleRichTextEditor PARTSSimpleTextEditor PARTSSizeWindowPart
        PARTSSmalltalkLibraryFileProcessor PARTSSourceFileProcessor PARTSSpeakerDLL PARTSSpeakerPart PARTSStandardBracketsMenu PARTSStandardEditMenu PARTSStandardFileMenu PARTSStandardHelpMenu PARTSStandardMenu PARTSStarterWindow PARTSStarterWindowWindows PARTSStaticGraphicPart
        PARTSStaticTextPart PARTSStoreContext PARTSStringHolderPart PARTSStringTemplate PARTSStringTemplatePart PARTSSublinkReference PARTSTabControlPagePart PARTSTabControlPart PARTSTabOrderEditor PARTSTeamVNestedPartBrowser PARTSTextIcon PARTSTextPaneErrorHandler
        PARTSTextPanePart PARTSTextWindow PARTSTimerPart PARTSTimerWindow PARTSTimeStamp PARTSToolbarButtonPart PARTSToolbarItem PARTSToolbarSeparatorPart PARTSToolbarToggleButtonPart PARTSToolboxPart PARTSToolContainer PARTSToolPane PARTSTopPane PARTSTypedValueHolder
        PARTSUpgradeObject PARTSUpgradePanePart PARTSUpgradeTablePane PARTSUpgradeVisualPart PARTSValueHolderPart PARTSVisualPartPropertyDialog PARTSWindow PARTSWindowPart PARTSWindowSizeEditor PARTSWorkbenchSessionManager PARTSWrapper PButton PButtonListBox
        PCheckBox PCheckBoxGroup PColumnListBox PComboBox PCompositePane PDrawnButton PDropDownList PEllipticSkinBox PEnhancedEntryField PEntryField PEntryFieldGroup PersonEditor PersonEditorPane PersonPane PersonPaneTester PFormattedEntryField PGenericSubpane
        PGraphPane PGroupbox PGroupBox PHeader PLinkButton PListBox PListPane PListView PMultipleSelectListBox PProgressBar PRadioButton PRadioButtonGroup PRealWidgetControl PRectangularSkinBox PRichEdit ProgressBar PropertyAccessor PropertyInterface PropertyManager
        PropertyPage PScrollBar PSpinButton PStaticBox PStaticGraphic PStaticText PStatusPane PStatusWindow PTabControl PTextEdit PTextPane PThreeStateButton PToggle PTrackBar PTreeView PUpDown PVideoPane PWBHorizontalScrollBar PWBInvisibleGroupPane PWBStaticGraphic
        PWBToolBar PWBVerticalScrollBar RadioButtonDialog RadioButtonGroup RichEdit RichEdit32DLL RichEditParagraphFormatDialog RichEditTabStopDialog SelectorPropertyAccessor SelectPersonDialog SeparatedListDialog SexPane SmalltalkLibraryBuilder SmalltalkLibraryObjects
        SmalltalkLibraryReporter SpinButton SpinButtonEntryField StatusBox StatusField StatusPane StatusWindow StylePropertyAccessor TabControl TabControlItem TabControlPage Tool Toolbar ToolbarButton ToolbarItem ToolbarSeparator ToolbarToggleButton ToolPane
        ToolTip TrackBar TreeView TreeViewItem UnknownImport UpDown UpgraderForDirectory UpgraderForFile VideoPane WaveAudio WBAboutDialog WBAbstractAddInModule WBAbstractCodeModule WBAbstractCreateViewsModule WBAbstractPrompter WBAction WBActionEditor WBActionLinkAddInModule
        WBAddInManager WBAddress WBApplicationCoordinatorMenuModule WBApplicationCoordinatorModule WBAttributeEditor WBAttributeWindow WBBasicCodeModule WBBitmapEditorCompositePane WBBitmapManager WBBitmapManagerWindow WBBitmapPool WBBitmapSubPool WBCallOutEditor
        WBCallOutModule WBChooseClassDialog WBChoosePaneDialog WBClassDefinition WBCodeGenBase WBCodeGenerator WBCodeModule WBCodePolicy WBCodeStream WBColorDialog WBComboBox WBComboEntryField WBCompositeMenuModule WBCompositePaneExampleAddInModule WBCompositePaneModule
        WBCompositePaneScratchWindow WBCompositePaneTester WBCreateBitmap WBCreateButton WBCreateClassDialog WBCreateMenuModule WBCreatePowerMenuModule WBCreatePowerViewModule WBCreatePowerViewsModule WBCreateViewModule WBCreateViewsModule WBCreateViewsStubModule
        WBDefaultCompositePaneScratchWindow WBDefaultDialogScratchWindow WBDefaultScratchWindow WBDescriptor WBDevelopmentCompositePane WBDevelopmentDialog WBDevelopmentObject WBDevelopmentSubPane WBDevelopmentWindow WBDialogEditor WBDialogScratchWindow WBDialogTopPane
        WBDisplayContext WBDrawnButton WBEditClassDialog WBEnhancedAttributeEditor WBEnhancedEntryFieldEditor WBEntryField WBEntryListPrompter WBENVYCodePolicy WBEventArgumentDescription WBEventDescription WBEventHandlerStubModule WBEventManagerWindow WBEventMap
        WBEventMessage WBEventTranslationEditor WBEventTranslator WBFileSelectorEditor WBFontEditorCompositePane WBFontManager WBFontManagerWindow WBFontPool WBFontSelectionWindow WBFontSubPool WBFramerExample WBFramingEditor WBGeometryManager WBGraphicObject
        WBGroupBox WBHandle WBHeaderEditor WBHorizontalScrollBar WBInstVarGetModule WBInstVarObject WBInstVarSetModule WBInterfaceObject WBKeyAccel WBKeyEntryField WBLayoutCodeModule WBLayoutForm WBLayoutFrameEditor WBLayoutWizard WBLinkEditor WBListBox WBListChooser
        WBListEditor WBListEntryField WBListViewEditor WBLocator WBLookPolicy WBLookPolicyOS2 WBLookPolicyWin31 WBLookPolicyWin95 WBManagedPFont WBManagedPNLSString WBManagedPValue WBMenu WBMenubarEditor WBMenuEditor WBMenuItem WBMenuItemStub WBMenuTester WBMessage
        WBMethodStubModule WBMiniBrowserExample WBModelBasicSetModule WBModelCodeModule WBModelDefinitionEditor WBModelEventsTriggeredModule WBModelGetModule WBModelInitializeModule WBModelInstVar WBModelObjectEditor WBModelSetModule WBModelTriggerEventModule
        WBMultiListChooser WBMultiToolPalette WBMultiViewAddInModule WBName WBNLSDictionaryReader WBNLSEditorCompositePane WBNLSExtractionTranslator WBNLSManager WBNLSManagerWindow WBNLSPool WBNLSReplacementTranslator WBNLSSubPool WBNLSTranslator WBObject WBOldEventHandlerStubModule
        WBOpenMethodModule WBOrderedCollection WBOutboardAttributeWindow WBOutboardWindow WBPartEvent WBPartEventsModule WBPartEventsTriggeredModule WBPartMessage WBPartMessagesModule WBPARTSEventList WBPARTSInterfaceEditor WBPARTSInterfaceList WBPARTSMessageList
        WBPartsModule WBPerson WBPlaceHolderObject WBPMenu WBPMenubar WBPMenuItem WBPool WBPoolEditorCompositePane WBPoolError WBPoolErrorAbsentKey WBPoolErrorDuplicateKey WBPoolErrorDuplicatePoolName WBPoolErrorInvalidCategory WBPoolErrorInvalidFile WBPoolErrorInvalidKey
        WBPoolErrorInvalidPool WBPoolErrorInvalidPoolName WBPoolErrorInvalidValue WBPoolManager WBPoolManagerWindow WBPowerViewAddInModule WBPrimaryModelInitializeModule WBPrimaryModelModule WBPrimaryModelOpenOnModule WBProgressBarEditor WBPropertyDescriptor
        WBPropertyEditor WBPropertyManager WBPrototype WBResizeBitmap WBResourceDescriptor WBRGBColorDialog WBRichTextEditor WBScrapbookRetrieve WBScrapbookStore WBScratchWindow WBScrollBarEditor WBScrollingPane WBStandardCodePolicy WBStaticGraphic WBStaticTextEditor
        WBStatusPaneEditor WBStatusWindowEditor WBStyleEditor WBSubPool WBSystemBitmapViewer WBTabControlEditor WBTabOrderEditor WBTabOrderLayoutForm WBTabPosition WBTargetObject WBTeamVCodePolicy WBTemplateEditor WBTextEditWindow WBTimerEditor WBTool WBToolBar
        WBToolBarEditor WBToolMenuAddInModule WBToolPalette WBTopPane WBTrackBarEditor WBTranslationChooser WBTranslator WBTreeListBox WBTreeNode WBTreeViewEditor WBUndoAction WBUndoManager WBUndoRedoDialog WBUpDownEditor WBUserInfoDialog WBVersionCodeModule
        WBVerticalScrollBar WBWindowDialog WBWindowEditor WBWindows95AddInModule WBXoteryXCodePolicy WinCharFormat WindowBuilder WindowFrameObject WinEditStream WinFormatRange WinHdItem WinHdLayout WinHdNotify WinLvColumn WinLvDispinfo WinLvItem WinLvKeydown
        WinNmListview WinNmTreeview WinParaFormat WinTbAddBitmap WinTbButton WinTbNotify WinTbSaveParams WinTcItem WinToolinfo WinTooltiptext WinTvDispinfo WinTvInsertstruct WinTvItem WinTvKeydown)
('-------------------------------------------------' )
('Tools-Browsers' Browser ChangeSetBrowser ClassBrowser ClassHierarchyBrowser CodeBrowser MethodBrowser MethodVersionBrowser SelectorBrowser SessionModel SourceChunk)
('Tools-Navigator' BrowserView ClassBasedOrganizer CodeBrowserSelection GetAndSetBuilder MethodBasedOrganizer NavigatorBrowser Organizer)
('Tools-Debuggers' ByteArrayInspector Debugger DictionaryInspector DoubleByteStringInspector FieldInspector GraphicInspector Inspector OrderedCollectionInspector)
('Tools-Development Support' ChangeLogCompressor LatestChangesExtractor MethodClassifier MethodVersion SmalltalkToolInterface)
('Tools-Code Writers & Readers' ClassReader CodeFiler CodeFilerClassWriter CodeFilerOrganizationWriter CodeWriter DigitalkClassWriter IBMSmalltalkClassWriter ParcPlaceClassReader RTFClassWriter TeamVClassWriter VisualWorksClassWriter)
('Tools-Change Sets' ChangeSet ChangeSetAddProtocolItem ChangeSetClassCommentItem ChangeSetClassDefinitionItem ChangeSetClassReorganizationItem ChangeSetEvaluateItem ChangeSetItem ChangeSetManager ChangeSetMethodHighlightItem ChangeSetMethodItem ChangeSetMethodReorganizationItem
        ChangeSetProtocolItem ChangeSetRemoveClassItem ChangeSetRemoveMethodItem ChangeSetRemoveProtocolItem ChangeSetRenameProtocolItem ClassBasedChangeSetItem NonRecordingChangeSet)
('Tools-Scintilla Pane' ExpressionEvaluator ScintillaDLL ScintillaExpressionEvaluator ScintillaFindDialog ScintillaPane ScintillaReplaceDialog ScNotification)
('--------------------------------------------------' )
('3D-Basic' BoundingBox Point3D Point4D WorldGlobal)
('---------------------------------------------------' )
('Scanner/Parser' )
('Grammar Constructor' )
('Table Constructor' )
('---------------------------------------------------' )
('Random Experimentation' )
))!

"evaluate" 
(CodeFiler systemOrganizer addCategory: '----------------------------------------------------' before: 'Random Experimentation')!

"evaluate"   
"*** saved image on: December 13, 2019 01:11:25 PM ***"!  
"*** Image started on: December 13, 2019 01:37:05 PM ***"!
"*** Image started on: December 16, 2019 02:10:23 PM ***"!
"*** Image started on: December 16, 2019 02:21:35 PM ***"!
"*** Image started on: January 4, 2020 10:09:57 AM ***"!

"evaluate"
"*** saved image on: January 4, 2020 10:11:17 AM ***"!
"*** Image started on: January 6, 2020 03:21:07 PM ***"!  
"*** Image started on: February 3, 2020 09:58:32 PM ***"! 
"*** Image started on: May 31, 2020 08:00:13 PM ***"!

 
'Behavior class superclass'!

  
'Class class superclass'!

 
'MetaClass class superclass '!


'Object class superclass'!


'Class class'!


'
MetaClass class '! 
"*** Image started on: November 22, 2020 03:10:09 PM ***"!
"*** Image started on: December 28, 2020 12:32:14 PM ***"!

!Date class methods !   
monthIndexFromString: aString
   "Returns 1 through 12 if it is a day name; otherwise 0."
   | prefix |
   prefix := (aString prefix: 3) asLowercase.
   #('jun' 'jul') indexedDo: [:index :month |
        month = prefix ifTrue: [^index + 5]].
   prefix := prefix prefix: 2.
   #('ja' 'fe' 'ma' 'ap' 'ma' 'ju' 'ju' 'au' 'se' 'oc' 'no' 'de') indexedDo: [:index :month |
        month = prefix ifTrue: [^index]].
   ^0!    ! 
#('December 28, 2020' '12:34:55 PM' 1295788)!

(CodeFiler organizerFor: Date class) reorganizeFrom: #(
('recent addition' monthIndexFromString: )) !

(CodeFiler organizerFor: Date class) reorganizeFrom: #(
('recent addition' monthIndexFromString: )) !


!Date class methods !  
dayIndexFromString: aString
   "Returns 1 through 7 if it is a day name; otherwise 0."
   | prefix |
   prefix := (aString prefix: 2) asLowercase.
   #('mo' 'tu' 'we' 'th' 'fr' 'sa' 'su') indexedDo: [:index :day |
        day = prefix ifTrue: [^index]].
   ^0!  ! 
#('December 28, 2020' '12:35:58 PM' 1298364)!

(CodeFiler organizerFor: Date class) reorganizeFrom: #(
('recent addition' dayIndexFromString: )) !

(CodeFiler organizerFor: Date class) reorganizeFrom: #(
('recent addition' dayIndexFromString: )) !


"evaluate" 
"*** saved image on: December 28, 2020 12:36:43 PM ***"!  
"*** Image started on: December 28, 2020 01:29:21 PM ***"!


!WalkbackWindow methods ! 
openOn: aDebugger label: labelString
        "Create the panes for the receiver, initialize,
         and display."
    | groupHeight groupPane pane |
    debugger := aDebugger.
    groupHeight := SysFont height * 3.
    self
        addView: ( ( pane := self topPaneClass new )
            label: labelString;
            foreColor: Color white;
            backColor: Color red;
            owner: self;
            when: #closed send: #close: to: self with: pane;
            noSmalltalkMenuBar ).
    self
        addSubpane: ( self textPaneClass new
            foreColor: Color white;
            backColor: Color red;
            setName: #text;
            contents: String new;
            framingBlock: [ :box | box leftTop
                extentFromLeftTop: box width @ ( box height - groupHeight ) ] ).
    self
        addSubpane: ( groupPane := GroupPane new
            foreColor: Color white;
            backColor: Color red;
            framingBlock: [ :box | ( box leftTop down: ( box height - groupHeight ) )
                extentFromLeftTop: box width @ groupHeight ] ).
    groupPane
        addSubpane: ( ( pane := Button new )
            setName: #debug;
            owner: self;
            contents: '\uDebug' replaceEscapeCharacters;
            when: #clicked send: #debug: to: self with: pane;
            framingBlock: [ :box | ( box leftTop rightAndDown: 2 * SysFont width @ ( SysFont height // 2 ) )
                extentFromLeftTop: 10 * SysFont width @ ( 3 * SysFont height // 2 ) ] );
        addSubpane: ( ( pane := Button new )
            setName: #resume;
            owner: self;
            contents: '\uResume' replaceEscapeCharacters;
            when: #clicked send: #resume: to: self with: pane;
            framingBlock: [ :box | ( box leftTop rightAndDown: 14 * SysFont width @ ( SysFont height // 2 ) )
                extentFromLeftTop: 10 * SysFont width @ ( 3 * SysFont height // 2 ) ] );
        addSubpane: ( ( pane := Button new )
            setName: #terminate;
            owner: self;
            contents: '\uTerminate' replaceEscapeCharacters;
            when: #clicked send: #terminate: to: self with: pane;
            framingBlock: [ :box | ( box leftTop rightAndDown: 26 * SysFont width @ ( SysFont height // 2 ) )
                extentFromLeftTop: 16 * SysFont width @ ( 3 * SysFont height // 2 ) ] ).
    self mainView subPaneWithFocus: ( self paneAt: #debug ).
    self openWindow!    ! 
#('December 28, 2020' '01:31:42 PM' nil)!

(CodeFiler organizerFor: WalkbackWindow) reorganizeFrom: #(
('no category methods' openOn:label: )) !


!WalkbackWindow methods !
openOn: aDebugger label: labelString
        "Create the panes for the receiver, initialize,
         and display."
    | groupHeight groupPane pane |
    debugger := aDebugger.
    groupHeight := SysFont height * 3.
    self
        addView: ( ( pane := self topPaneClass new )
            label: labelString;
            foreColor: Color white;
            backColor: Color red;
            owner: self;
            when: #closed send: #close: to: self with: pane;
            noSmalltalkMenuBar ).
    self
        addSubpane: ( self textPaneClass new
            foreColor: Color white;
            backColor: Color red;
            setName: #text;
            contents: String new;
            framingBlock: [ :box | box leftTop
                extentFromLeftTop: box width @ ( box height - groupHeight ) ] ).
    self
        addSubpane: ( groupPane := GroupPane new
            foreColor: Color white;
            backColor: Color red;
            framingBlock: [ :box | ( box leftTop down: ( box height - groupHeight ) )
                extentFromLeftTop: box width @ groupHeight ] ).
    groupPane
        addSubpane: ( ( pane := Button new )
            setName: #debug;
            owner: self;
            contents: '\uDebug' replaceEscapeCharacters;
            when: #clicked send: #debug: to: self with: pane;
            framingBlock: [ :box | ( box leftTop rightAndDown: 2 * SysFont width @ ( SysFont height // 2 ) )
                extentFromLeftTop: 12 * SysFont width @ ( 3 * SysFont height // 2 ) ] ); "10=>12"
        addSubpane: ( ( pane := Button new )
            setName: #resume;
            owner: self;
            contents: '\uResume' replaceEscapeCharacters;
            when: #clicked send: #resume: to: self with: pane;
            framingBlock: [ :box | ( box leftTop rightAndDown: 16 * SysFont width @ ( SysFont height // 2 ) ) "14=>16"
                extentFromLeftTop: 14 * SysFont width @ ( 3 * SysFont height // 2 ) ] ); "10=>14"
        addSubpane: ( ( pane := Button new )
            setName: #terminate;
            owner: self;
            contents: '\uTerminate' replaceEscapeCharacters;
            when: #clicked send: #terminate: to: self with: pane;
            framingBlock: [ :box | ( box leftTop rightAndDown: 32 * SysFont width @ ( SysFont height // 2 ) ) "26=>32"
                extentFromLeftTop: 18 * SysFont width @ ( 3 * SysFont height // 2 ) ] ). "16=>18"
    self mainView subPaneWithFocus: ( self paneAt: #debug ).
    self openWindow!   ! 
#('December 28, 2020' '01:31:42 PM' 1366920)!

(CodeFiler organizerFor: WalkbackWindow) reorganizeFrom: #(
('no category methods' openOn:label: )) !


"define class"   

WindowDialog subclass: #GetAndSetBuilder
  instanceVariableNames: 
    ' editedClass typeMap instVar types newInitializeFlag sourceManager '
  classVariableNames: ''
  poolDictionaries: ''!


!GetAndSetBuilder methods !  
initWindowSize

    "^WindowDialog inDialogUnits: 384@324"
    ^WindowDialog inDialogUnits: 800@600! !

"evaluate"   
(CodeFiler organizerFor: GetAndSetBuilder) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: GetAndSetBuilder) reorganizeFrom: #(
('initializing' initWindowSize )) !

(CodeFiler organizerFor: GetAndSetBuilder) reorganizeFrom: #(
('initializing' initWindowSize )) !



!GetAndSetBuilder methods !
typeMap
    ^typeMap!  !

!GetAndSetBuilder methods !  
sourceManager: aSourceManager
    sourceManager := aSourceManager! !

!GetAndSetBuilder methods !  
sourceManager
    ^sourceManager!  !

!GetAndSetBuilder methods !  
instVar

    ^instVar!    !

!GetAndSetBuilder methods !  
editedClass: aPlane
    editedClass := aPlane! !

!GetAndSetBuilder methods !  
editedClass
    ^editedClass!  !

!GetAndSetBuilder methods !  
newInitializeFlag: aTest
    newInitializeFlag := aTest!   !

!GetAndSetBuilder methods !  
newInitializeFlag
    ^newInitializeFlag!  !

!GetAndSetBuilder methods !  
types

    ^types!    !

!GetAndSetBuilder methods !  
types: aCollection

    types := aCollection! !

!GetAndSetBuilder methods !  
typeMap: aBoolean
    typeMap := aBoolean! !
(CodeFiler organizerFor: GetAndSetBuilder) reorganizeFrom: #(
('get/set' typeMap sourceManager: sourceManager instVar editedClass: editedClass newInitializeFlag: newInitializeFlag types types: typeMap: )) !

(CodeFiler organizerFor: GetAndSetBuilder) reorganizeFrom: #(
('get/set' typeMap sourceManager: sourceManager instVar editedClass: editedClass newInitializeFlag: newInitializeFlag types types: typeMap: )) !



!GetAndSetBuilder methods !  
currentType
    ^typeMap at: self instVar ifAbsent: [nil]! !
(CodeFiler organizerFor: GetAndSetBuilder) reorganizeFrom: #(
('querying' currentType )) !

(CodeFiler organizerFor: GetAndSetBuilder) reorganizeFrom: #(
('querying' currentType )) !



!GetAndSetBuilder methods !  
addGetAndSetFor: aCollection in: aClass on: stream
    "Add get and set methods for the instance variables in aCollection, which is a collection of two-element arrays.
    The first element is the symbol for the instance variable name, the second is a symbol for the type."

    | instVarName instVarType type |
    stream
        nextPut: $!!;
        nextPutAll: aClass name;
        nextPutAll: ' methodsFor: ''get/set'' !!'.

    aCollection do: [:pair |
        instVarName := pair first asString.
        instVarType := pair last asString.
        instVarType at: 1 put: (instVarType first asUpperCase).
        type := (instVarType first isVowel
            ifTrue: ['an']
            ifFalse: ['a']), instVarType.
        (aClass instVarNames includes: instVarName)
            ifFalse: [self error: 'Bad instance variable name.'].
        stream
            cr; cr;
            nextPutAll: instVarName;
            cr;
            nextPutAll: '    ^';
            nextPutAll: instVarName;
            nextPut: $!!;
            cr; cr;
            nextPutAll: instVarName;
            nextPutAll: ': ';
            nextPutAll: type;
            cr;
            nextPutAll: '    ';
            nextPutAll: instVarName;
            nextPutAll: ' := ';
            nextPutAll: type;
            nextPut: $!!].

    stream nextPutAll: ' !!'!  !

!GetAndSetBuilder methods !  
addNewInitializeFor: aCollection in: aClass on: stream
    "Add a new and an initialize method for aClass. aCollection is a collection of two-element arrays.
    The first element is the symbol for the instance variable name, the second is a symbol for the type."

    | instVarName instVarType |
    stream
        nextPut: $!!;
        nextPutAll: aClass name;
        nextPutAll: ' methodsFor: ''initializing'' !!';
        cr; cr;
        nextPutAll: 'initialize';
        cr; cr;
        nextPutAll: '    self';
        cr.
    aCollection do: [:pair |
        instVarName := pair first asString.
        instVarType := pair last asSymbol.
        stream
            nextPutAll: '        ';
            nextPutAll: instVarName;
            nextPutAll: ': '.
        stream nextPutAll: ((Smalltalk includesKey: instVarType)
            ifTrue: [instVarType, ' new']
            ifFalse: ['nil']).
        pair == aCollection last
            ifFalse: [
                stream
                    nextPut: $;;
                    cr]].
    stream
        nextPutAll: '!! !!';
        cr; cr;
        nextPut: $!!;
        nextPutAll: aClass class name;
        nextPutAll: ' methodsFor: ''instance creation'' !!';
        cr; cr;
        nextPutAll: 'new';
        cr; cr;
        nextPutAll: '    ^super new initialize!! !!';
        cr; cr!    !

!GetAndSetBuilder methods !  
addGetAndSetFor: aCollection in: aClass withNewInitialize: aBoolean
    "Add get and set methods for the instance variables in aCollection, which is a collection of two-element arrays.
    The first element is the symbol for the instance variable name, the second is a symbol for the type.
    If aBoolean is true, also add a new-initialize pair of methods.
    Example usage:
        self addGetAndSetFor: #((x Integer) (y Integer)) in: Point withNewInitialize: false."

    | stream |
    stream := ReadWriteStream on: (String new: 100).
    aBoolean
        ifTrue: [self addNewInitializeFor: aCollection in: aClass on: stream].
    self addGetAndSetFor: aCollection in: aClass on: stream.
    "
    stream
        position: 0;
        fileIn
    "
    stream position: 0.
    self sourceManager fileInFrom: stream!    !

!GetAndSetBuilder methods !  
buildTypeMap

    self editedClass instVarNames do: [:name |
        self typeMap at: name put: nil]!    !
(CodeFiler organizerFor: GetAndSetBuilder) reorganizeFrom: #(
('building' addGetAndSetFor:in:on: addNewInitializeFor:in:on: addGetAndSetFor:in:withNewInitialize: buildTypeMap )) !

(CodeFiler organizerFor: GetAndSetBuilder) reorganizeFrom: #(
('building' addGetAndSetFor:in:on: addNewInitializeFor:in:on: addGetAndSetFor:in:withNewInitialize: buildTypeMap )) !



!GetAndSetBuilder methods !
defaultInstVar: aString
    instVar := aString!    !

!GetAndSetBuilder methods !  
defaultTypeList
    ^#('Boolean' 'Integer' 'Float' 'Number' 'String' 'Symbol'
        'Collection' 'Array' 'OrderedCollection' 'Dictionary') asOrderedCollection! !
(CodeFiler organizerFor: GetAndSetBuilder) reorganizeFrom: #(
('defaults' defaultInstVar: defaultTypeList )) !

(CodeFiler organizerFor: GetAndSetBuilder) reorganizeFrom: #(
('defaults' defaultInstVar: defaultTypeList )) !



!GetAndSetBuilder methods !  
buttonPushedBuild: aPane

    | collection |

    collection := OrderedCollection new.
    self typeMap associationsDo: [:pair |
        pair value isNil
            ifFalse: [collection add: (Array with: pair key with: pair value)]].
    self
        addGetAndSetFor: collection in: self editedClass withNewInitialize: newInitializeFlag.

    super close! !

!GetAndSetBuilder methods !  
listPaneNeedsInstanceVariables: aPane
    aPane
        contents: self editedClass instVarNames;
        selection: instVar! !

!GetAndSetBuilder methods !  
listPaneSelectedType: aPane
    "Note that this executes ONLY WHEN we are clicking on a NEW selection"

    | selection |
    selection := aPane selectedItem. "This is the OLD selection"
    selection = self currentType
        ifTrue: [self instVar notNil ifTrue: [self typeMap at: self instVar put: nil]]
        ifFalse: [
            self instVar notNil ifTrue: [self typeMap at: self instVar put: selection].
            (types includes: selection) ifFalse: [self types add: selection]].
    self updateNewTypePane.! !

!GetAndSetBuilder methods !  
doNothing: aPane
    "I mean really do nothing."

    self entryFieldChangedText: (self paneNamed: #newTypePane)!    !

!GetAndSetBuilder methods !  
checkBoxClickedNewInitialize: aPane

    newInitializeFlag := aPane selection!    !

!GetAndSetBuilder methods !  
buttonClickedExit: aPane
    super close!  !

!GetAndSetBuilder methods !  
listPaneClickedType: aPane
    "Note that this executes whether or not the we are clicking on the current selection"
    self currentType = aPane selectedItem ifTrue: [
        "Deselect the item. "
        self instVar notNil ifTrue: [self typeMap at: self instVar put: nil].
        (self paneNamed: #typesPane) selectItem: nil.
        self updateTypesPane; updateNewTypePane]!  !

!GetAndSetBuilder methods !  
listPaneNeedsTypes: aPane

    aPane
        contents: self types "asSortedCollection";
        selection: self currentType!    !

!GetAndSetBuilder methods !  
entryFieldChangedText: aPane

    | aString |
    aString := aPane contents capitalizedWithoutSpaces.
    aString = (self typeMap at: self instVar ifAbsent: [nil]) "self dontUseString"
        ifTrue: [self typeMap at: self instVar put: nil]
        ifFalse: [
            self instVar notNil ifTrue: [self typeMap at: self instVar put: aString].
            (types includes: aString) ifFalse: [self types addFirst: aString]].
    self updateTypesPane.!  !

!GetAndSetBuilder methods !  
entryFieldNeedsText: aPane

    aPane contents: (self currentType isNil ifTrue: ['** New Name **'] ifFalse: [self currentType])!  !

!GetAndSetBuilder methods !  
listPaneSelectedInstanceVariable: aPane

    instVar := aPane selectedItem.
    self updateTypesPane; updateNewTypePane! !
(CodeFiler organizerFor: GetAndSetBuilder) reorganizeFrom: #(
('pane events' buttonPushedBuild: listPaneNeedsInstanceVariables: listPaneSelectedType: doNothing: checkBoxClickedNewInitialize: buttonClickedExit: listPaneClickedType: listPaneNeedsTypes: entryFieldChangedText: entryFieldNeedsText: listPaneSelectedInstanceVariable: )) !

(CodeFiler organizerFor: GetAndSetBuilder) reorganizeFrom: #(
('pane events' buttonPushedBuild: listPaneNeedsInstanceVariables: listPaneSelectedType: doNothing: checkBoxClickedNewInitialize: buttonClickedExit: listPaneClickedType: listPaneNeedsTypes: entryFieldChangedText: entryFieldNeedsText: listPaneSelectedInstanceVariable: )) !



!GetAndSetBuilder methods !
openOn: aClass

    | theClass thisPane  font boldFont theClassNamePane |
    theClass := aClass.
    theClass isNil | theClass isBehavior not
        ifTrue: [theClass := self class].
    theClass instVarNames isEmpty
        ifTrue: [^MessageBox message: 'No instance variables for ', theClass name].

    newInitializeFlag := false.
    font := TextFont.
    boldFont := (Font fromFont: TextFont graphicsMedium: Display)
        bold: true;
        makeFont;
        yourself.

    self
        editedClass: theClass;
        defaultInstVar: theClass instVarNames first;
        typeMap: Dictionary new;
        types: self defaultTypeList;
        buildTypeMap;

        label: 'Get & Set Builder';
        owner: self;

        addSubpane: (StaticText new
            font: font;
            contents: 'Class:';
            framingRatio: (1/16 @ (1/16) extent: 3/16 @ (1/16)));

        addSubpane: (StaticText new
            contents: self editedClass name;
            font: boldFont;
            framingRatio: (1/4 @ (1/16) extent: 11/16 @ (1/16)));

        addSubpane: (StaticText new
            font: font;
            contents: 'Instance Variable:';
            framingRatio: (1/16 @ (3/16) extent: 1/2 @ (1/16)));

        addSubpane: (StaticText new
            font: font;
            contents: 'Type:';
            framingRatio: (5/8 @ (3/16) extent: 5/16 @ (1/16)));

        addSubpane: ((thisPane := ListBox new)
            setName: #instanceVariablesPane;
            font: font;
            when: #needsContents send: #listPaneNeedsInstanceVariables: to: self with: thisPane;
            when: #changed: send: #listPaneSelectedInstanceVariable: to: self with: thisPane;
            framingRatio: (1/16 @ (5/16) extent: 1/2 @ (1/2)));

        addSubpane: ((thisPane := Button new)
            setName: #invisiblePane;
            font: font;
            contents: '';
            defaultPushButton;
            when: #clicked send: #doNothing: to: self with: thisPane;
            framingRatio: (1/2 @ (5/16) extent: 0@0));

        addSubpane: ((thisPane := EntryField new)
            setName: #newTypePane;
            font: font;
            when: #needsContents send: #entryFieldNeedsText: to: self with: thisPane;
            when: #changed: send: #entryFieldChangedText: to: self with: thisPane;
            framingRatio: (5/8 @ (5/16) extent: 5/16 @ (5/64)));

        addSubpane: ((thisPane := ListBox new)
            setName: #typesPane;
            font: font;
            when: #clicked: send: #listPaneClickedType: to: self with: thisPane; "So we can unselect"
            when: #needsContents send: #listPaneNeedsTypes: to: self with: thisPane;
            when: #changed: send: #listPaneSelectedType: to: self with: thisPane;
            framingRatio: (5/8 @ (7/16) extent: 5/16 @ (3/8)));

        addSubpane: ((thisPane := Button new)
            font: font;
            contents: 'Build';
            "defaultPushButton;"
            when: #clicked send: #buttonPushedBuild: to: self with: thisPane;
            framingRatio: ((1/16 @ (7/8) extent: 1/4 @ (1/16)) expandBy: 0 @ (1/64)));

        addSubpane: ((thisPane := CheckBox new)
            font: font;
            contents: 'New/Initialize';
            when: #clicked: send: #checkBoxClickedNewInitialize: to: self with: thisPane;
            framingRatio: ((3/8 @ (7/8) extent: 5/16 @ (1/16)) expandBy: 0 @ (1/64)));

        addSubpane: ((thisPane := Button new)
            font: font;
            contents: 'Cancel';
            when: #clicked send: #buttonClickedExit: to: self with: thisPane;
            framingRatio: ((11/16 @ (7/8) extent: 1/4 @ (1/16)) expandBy: 0 @ (1/64)));

        openWindow.!   !
(CodeFiler organizerFor: GetAndSetBuilder) reorganizeFrom: #(
('scheduling' openOn: )) !

(CodeFiler organizerFor: GetAndSetBuilder) reorganizeFrom: #(
('scheduling' openOn: )) !



!GetAndSetBuilder methods !  
updateTypesPane
    (self paneAt: #typesPane) update!  !

!GetAndSetBuilder methods !  
updateNewTypePane
    (self paneAt: #newTypePane) update!  !
(CodeFiler organizerFor: GetAndSetBuilder) reorganizeFrom: #(
('updating' updateTypesPane updateNewTypePane )) !

(CodeFiler organizerFor: GetAndSetBuilder) reorganizeFrom: #(
('updating' updateTypesPane updateNewTypePane )) !
CodeFiler setCommentFor: GetAndSetBuilder to: ''!


"evaluate"  
"*** saved image on: December 28, 2020 01:32:56 PM ***"!

  
' i := 1'!


'
 i
'!

 
'''hi'' == ''hi'''!

   
' i := ''hi'' == ''hi'''!

 
' i := ''hi'' == ''hi'''!

 
'Smalltalk'!

  
'Smalltalk'!

  
'[]'!

 
'

'!

   
'

'!

   
'"hi"'!

   
'1+2;+3'!

 
'a := b := 0.
        4 > 3 ifTrue: [a := 10. b := 20.]
'!

  
'a'!

  
'b'!

  
'    | aCollection |
            aCollection := OrderedCollection new.
            aCollection add: 10.
            aCollection add: 20.
            aCollection add: 30.
            ^aCollection "This returns the collection"
'!

 
'
^Dictionary new at: #red put: #rouge; at: #green put: #vert; yourself'!


'   Transcript << ''Hi there'''!

  
'
Transcript << ''The sum of 1 and 3 is ''; << (1+3).'!

  
'Transcript'!

 
'true asString'!

  
'
(OrderedCollection new add: 10; add: 20; add: 30; yourself) printString
'!


'
(OrderedCollection new add: 10; add: 20; add: 30; yourself) storeString
'!
"*** Image started on: December 29, 2020 09:16:12 AM ***"!


' o1 := Object new.
 o2:= Object new.
 o3 := Object new.
d := IdentityDictionary new.
d at: o1 put: #Object1.
d at: o2 put: #Object2.
d at: o3 put: #Object3.
d at: o1.
'!


'd at: o1.'!

  
'd at: o2'!

   
' o1 := Object new.
 o2:= Object new.
 o3 := Object new.
d := Dictionary new.
d at: o1 put: #Object1.
d at: o2 put: #Object2.
d at: o3 put: #Object3.
d at: o1.
'!


'd at: o2.'!

  
'o1 := ''hi''.
 o2:= o1 copy.
 o3 := o1 copy.
d := Dictionary new.
d at: o1 put: #Object1.
d at: o2 put: #Object2.
d at: o3 put: #Object3.
d at: o1.
'!

   
'd at: o2. '!

 
'#( 1 2 3) indexOf: 4'!

   
'            #(10 20 ''hi'' ''hi'' #(big barn) @W) indexOfIdentical: 50 ifAbsent: [-100+1]'!

  
'OrderedCollection new addIfAbsent: #(10 20 10 10)'!

  
'OrderedCollection new addAllIfAbsent: #(10 20 10 10)'!

   
'(Dictionary new at: 10 put: #hi; at: 20 put: #bye; at: 30 put: #ok; yourself) do: [:object | 
			Transcript cr; << ''Object is ''; << object].'!

!BoundingBox methods !  
center
    self isUnknown ifTrue: [^Point3D zero]. 
    center isNil ifTrue: [self update].
    ^center! ! 
#('December 29, 2020' '06:20:40 PM' 31456)!

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('get/set' center )) !

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('get/set' center )) !


 
'BoundingBox new'!


'BoundingBox unitBox'!


'BoundingBox new'!


'BoundingBox new'!

"define class"  

Object subclass: #BoundingBox
  instanceVariableNames: 
    ' maximum minimum center radius junk1 junk2 '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: BoundingBox to: ''!


"evaluate"  

Object subclass: #BoundingBox
  instanceVariableNames: 
    ' maximum minimum center radius junk1 junk2'
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( '3D-Basic' )
  comment: ''!


!BoundingBox methods ! 
junk1
    ^junk1!  !

!BoundingBox methods !   
junk1: anInteger
    junk1 := anInteger!   !

!BoundingBox methods !   
junk2
    ^junk2!  !

!BoundingBox methods !   
junk2: anArdvark
    junk2 := anArdvark!   !
(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('get/set' junk1: junk1 junk2: junk2 )) !

(CodeFiler organizerFor: BoundingBox) reorganizeFrom: #(
('get/set' junk1: junk1 junk2: junk2 )) !


"define class" 

Object subclass: #BoundingBox
  instanceVariableNames: 
    ' maximum minimum center radius '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: BoundingBox to: ''!


"evaluate"  

Object subclass: #BoundingBox
  instanceVariableNames: 
    ' maximum minimum center radius '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( '3D-Basic' )
  comment: ''!

"define class"  

Object subclass: #BoundingBox
  instanceVariableNames: 
    ' maximum minimum center radius '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: BoundingBox to: ''!


"evaluate"  

Object subclass: #BoundingBox
  instanceVariableNames: 
    ' maximum minimum center radius '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( '3D-Basic' 'Gaming')
  comment: ''!
"*** Image started on: December 30, 2020 10:35:46 AM ***"!

"define class"  

Object subclass: #Temperature
  instanceVariableNames: 
    ' centigrade '
  classVariableNames: ''
  poolDictionaries: ''!

"evaluate"   

Object subclass: #Temperature
  instanceVariableNames: 'centigrade'
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Random Experimentation' )!


!Temperature methods !
centigrade
    ^centigrade!    !

!Temperature methods !   
centigrade: aFloat
    centigrade := aFloat!   !

"evaluate"   
(CodeFiler organizerFor: Temperature) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Temperature) reorganizeFrom: #(
('get/set' centigrade: centigrade )) !

(CodeFiler organizerFor: Temperature) reorganizeFrom: #(
('get/set' centigrade: centigrade )) !


"evaluate"
(CodeFiler organizerFor: 'Temperature class')  addCategory: 'instance creation' before: nil!

"evaluate"
(CodeFiler organizerFor: Temperature class) removeCategory: 'no category methods' ifAbsent: [nil]!

!Temperature class methods !
create! ! 
#('December 30, 2020' '12:16:56 PM' nil)!

(CodeFiler organizerFor: Temperature class) reorganizeFrom: #(
('instance creation' create )) !


!Temperature class methods !   
createAgain!    ! 
#('December 30, 2020' '12:18:39 PM' nil)!

(CodeFiler organizerFor: Temperature class) reorganizeFrom: #(
('instance creation' createAgain )) !


!Temperature class methods !  
centigrade: aFloat
    ^self new centigrade: aFloat!   ! 
#('December 30, 2020' '01:25:45 PM' nil)!

(CodeFiler organizerFor: Temperature class) reorganizeFrom: #(
('instance creation' centigrade: )) !


"evaluate"
(CodeFiler organizerFor: 'Temperature class')  addCategory: 'examples' before: nil!

!Temperature class methods !   
example1
            "Temperature example1"
            | dictionary |
            dictionary := Dictionary new
            at: (Temperature centigrade: 30.0) put: #Hi;
            at: (Temperature centigrade: 20.0) put: #Medium;
            at: (Temperature centigrade: 0.0) put: #Low;
                yourself.
            ^dictionary at: (Temperature centigrade: 30.0)!    ! 
#('December 30, 2020' '01:32:51 PM' nil)!

(CodeFiler organizerFor: Temperature class) reorganizeFrom: #(
('examples' example1 )) !


"evaluate"
(CodeFiler organizerFor: 'Temperature')  addCategory: 'comparing' before: nil!

!Temperature methods !  
= anObject
            ^self centigrade = anObject centigrade! ! 
#('December 30, 2020' '01:47:42 PM' nil)!

(CodeFiler organizerFor: Temperature) reorganizeFrom: #(
('comparing' = )) !


!Temperature class methods !  
example2
            "Temperature example2"
            ^(Temperature centigrade: 30.0) = (Temperature centigrade: 30.0)! ! 
#('December 30, 2020' '01:48:41 PM' nil)!

(CodeFiler organizerFor: Temperature class) reorganizeFrom: #(
('examples' example2 )) !


  
'Temperature example2'!

!Temperature class methods !   
example2
            "Temperature example2"
            ^(Temperature centigrade: 30.0) = (Temperature centigrade: 30.0)! ! 
#('December 30, 2020' '02:01:44 PM' 1394484)!

(CodeFiler organizerFor: Temperature class) reorganizeFrom: #(
('examples' example2 )) !

(CodeFiler organizerFor: Temperature class) reorganizeFrom: #(
('examples' example2 )) !


!Temperature methods !   
= anObject
            anObject class = Temperature ifFalse: [^false].
            ^self centigrade = anObject centigrade!    ! 
#('December 30, 2020' '02:02:01 PM' nil)!

(CodeFiler organizerFor: Temperature) reorganizeFrom: #(
('comparing' = )) !

(CodeFiler organizerFor: Temperature) reorganizeFrom: #(
('comparing' = )) !


 
'2021 hash '!

 
'2021000 hash  '!

 
'20210000000 hash '!

  
'20210000000 hash  '!

 
'''hello'' hash'!

 
'2021.0 hash'!


'#hello hash'!


'#hello hash'!


'#(10 20 30) hash'!

   
'(Temperature centigrade: 5.0) hash'!

 
'(Temperature centigrade: 5.0) hash'!

 
'(Temperature centigrade: 5.0) hash'!

!Temperature methods !   
hash
    ^centigrade hash! ! 
#('December 30, 2020' '02:43:17 PM' nil)!

(CodeFiler organizerFor: Temperature) reorganizeFrom: #(
('comparing' hash )) !


   
'Temperature example1'!

   
'
	#(1 2) select: [:o | o odd]'!

 
' 10 even'!   
"*** Image started on: December 31, 2020 12:57:44 PM ***"!


'[]'!

 
'[]'!

 
' [:integer | integer + 1]'!

  
'[:integer | integer + 1]'!

   
'Dictionary new asArray'! 
"*** Image started on: January 6, 2021 12:41:39 PM ***"!  
Point4D rename: #Point4DOK!

!Point3D methods ! 
@ aNumber
    ^Point4DOK x: self x y: self y z: self z w: aNumber! ! 
#('January 6, 2021' '12:44:13 PM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('converting' @ )) !
   
Point4DOK rename: #Point4D!

!Point3D methods ! 
@ aNumber
    ^Point4D x: self x y: self y z: self z w: aNumber!   ! 
#('January 6, 2021' '12:48:50 PM' nil)!

(CodeFiler organizerFor: Point3D) reorganizeFrom: #(
('converting' @ )) !
   
"*** Image started on: January 26, 2021 01:13:25 AM ***"! 
"*** Image started on: January 26, 2021 01:14:51 AM ***"!

"define class"   

Object subclass: #Transducer
  instanceVariableNames: 
    ' sponsor tables '
  classVariableNames: ''
  poolDictionaries: ''!

"evaluate"

Object subclass: #Transducer
  instanceVariableNames: 
    ' sponsor tables '
  classVariableNames: ''
  poolDictionaries: ''
  category: 'Scanner/Parser'!

"define class"  

Transducer subclass: #Parser
  instanceVariableNames: 
    ' scanner screener tokenStack tableNumberStack treeStack left right tableNumber newTree '
  classVariableNames: ''
  poolDictionaries: ''!

"evaluate" 

Transducer subclass: #Parser
  instanceVariableNames: 
    ' scanner screener tokenStack tableNumberStack treeStack left right tableNumber newTree '
  classVariableNames: ''
  poolDictionaries: ''
  category: 'Scanner/Parser'!

"evaluate"   
Parser removeFromSystem!

"evaluate"
CodeFiler removeOrganizerFor: #Parser!

"evaluate"  
CodeFiler removeOrganizerFor: #'Parser class'!

"evaluate"  
Transducer removeFromSystem!

"evaluate"
CodeFiler removeOrganizerFor: #Transducer!

"evaluate"  
CodeFiler removeOrganizerFor: #'Transducer class'!

"define class"  

Object subclass: #Table
  instanceVariableNames: 
    ' transducer '
  classVariableNames: ''
  poolDictionaries: ''!

"evaluate" 

Object subclass: #Table
  instanceVariableNames: 
    ' transducer '
  classVariableNames: ''
  poolDictionaries: ''
  category: 'Scanner/Parser'!

"define class"   

Object subclass: #Transducer
  instanceVariableNames: 
    ' sponsor tables '
  classVariableNames: ''
  poolDictionaries: ''!

"evaluate"

Object subclass: #Transducer
  instanceVariableNames:
    ' sponsor tables '
  classVariableNames: ''
  poolDictionaries: ''
  category: 'Scanner/Parser'!

"define class"   

Table subclass: #TableWithTransitions
  instanceVariableNames: 
    ' transitions '
  classVariableNames: ''
  poolDictionaries: ''!

"evaluate"  

Table subclass: #TableWithTransitions
  instanceVariableNames:
    ' transitions '
  classVariableNames: ''
  poolDictionaries: ''
  category: 'Scanner/Parser'!

"define class" 

Table subclass: #AcceptTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

"evaluate"  

Table subclass: #AcceptTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  category: 'Scanner/Parser'!

"define class"

Object subclass: #Tree
  instanceVariableNames: 
    ' label children '
  classVariableNames: ''
  poolDictionaries: ''!

"evaluate"  

Object subclass: #Tree
  instanceVariableNames: 
    ' label children '
  classVariableNames: ''
  poolDictionaries: ''
  category: 'Scanner/Parser'!

"define class"

TableWithTransitions subclass: #ScannerReadaheadTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

"evaluate" 

TableWithTransitions subclass: #ScannerReadaheadTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  category: 'Scanner/Parser'!

"define class"   

TableWithTransitions subclass: #ReadaheadTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

"evaluate"

TableWithTransitions subclass: #ReadaheadTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  category: 'Scanner/Parser'!

"define class"  

TableWithTransitions subclass: #ReadbackTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

"evaluate" 

TableWithTransitions subclass: #ReadbackTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  category: 'Scanner/Parser'!

"define class"   

Transducer subclass: #Screener
  instanceVariableNames: 
    ' keywords '
  classVariableNames: ''
  poolDictionaries: ''!

"evaluate"

Transducer subclass: #Screener
  instanceVariableNames: 
    ' keywords '
  classVariableNames: ''
  poolDictionaries: ''
  category: 'Scanner/Parser'!

"define class"  

Table subclass: #SemanticTable
  instanceVariableNames: 
    ' action parameters goto '
  classVariableNames: ''
  poolDictionaries: ''!

"evaluate"  

Table subclass: #SemanticTable
  instanceVariableNames: 
    ' action parameters goto '
  classVariableNames: ''
  poolDictionaries: ''
  category: 'Scanner/Parser'!

"define class"

Transducer subclass: #Parser
  instanceVariableNames: 
    ' scanner screener tokenStack tableNumberStack treeStack left right tableNumber newTree '
  classVariableNames: ''
  poolDictionaries: ''!

"evaluate" 

Transducer subclass: #Parser
  instanceVariableNames: 
    ' scanner screener tokenStack tableNumberStack treeStack left right tableNumber newTree '
  classVariableNames: ''
  poolDictionaries: ''
  category: 'Scanner/Parser'!

"define class"   

TableWithTransitions subclass: #ReduceTable
  instanceVariableNames: 
    ' nonterminal '
  classVariableNames: ''
  poolDictionaries: ''!

"evaluate"

TableWithTransitions subclass: #ReduceTable
  instanceVariableNames: 
    ' nonterminal '
  classVariableNames: ''
  poolDictionaries: ''
  category: 'Scanner/Parser'!

"define class"  

Transducer subclass: #Scanner
  instanceVariableNames: 
    ' input token keptCharacters '
  classVariableNames: ''
  poolDictionaries: ''!

"evaluate"   

Transducer subclass: #Scanner
  instanceVariableNames: 
    ' input token keptCharacters '
  classVariableNames: ''
  poolDictionaries: ''
  category: 'Scanner/Parser'!

"define class" 

Object subclass: #Token
  instanceVariableNames: 
    ' label symbol '
  classVariableNames: ''
  poolDictionaries: ''!

"evaluate"   

Object subclass: #Token
  instanceVariableNames: 
    ' label symbol '
  classVariableNames: ''
  poolDictionaries: ''
  category: 'Scanner/Parser'!

"define class" 

Table subclass: #ShiftbackTable
  instanceVariableNames: 
    ' shift goto '
  classVariableNames: ''
  poolDictionaries: ''!

"evaluate" 

Table subclass: #ShiftbackTable
  instanceVariableNames: 
    ' shift goto '
  classVariableNames: ''
  poolDictionaries: ''
  category: 'Scanner/Parser'!

"define class"   

Object subclass: #Table
  instanceVariableNames: 
    ' transducer '
  classVariableNames: ''
  poolDictionaries: ''!

"evaluate" 

Object subclass: #Table
  instanceVariableNames: 
    ' transducer '
  classVariableNames: ''
  poolDictionaries: ''
  category: 'Scanner/Parser'!

"define class"   

Object subclass: #SampleTranslator
  instanceVariableNames: 
    ' parser tree codeIfCompiler expressionsIfEvaluator compilationOperatorMap evaluationOperatorMap '
  classVariableNames: ''
  poolDictionaries: ''!

"evaluate"  

Object subclass: #SampleTranslator
  instanceVariableNames: 
    ' parser tree codeIfCompiler expressionsIfEvaluator compilationOperatorMap evaluationOperatorMap '
  classVariableNames: ''
  poolDictionaries: ''
  category: 'Example Parser Users'!
"*** Image started on: January 26, 2021 01:49:40 AM ***"! 
"*** Image started on: January 26, 2021 02:00:02 AM ***"! 
"*** Image started on: January 26, 2021 02:01:13 AM ***"! 
"*** Image started on: January 26, 2021 02:04:36 AM ***"! 
"*** Image started on: January 26, 2021 02:05:23 AM ***"! 
"*** Image started on: January 26, 2021 02:06:07 AM ***"! 
"*** Image started on: January 26, 2021 02:07:34 AM ***"! 
"*** Image started on: January 26, 2021 02:08:27 AM ***"! 
"*** Image started on: January 26, 2021 02:10:47 AM ***"! 
"*** Image started on: January 26, 2021 02:17:09 AM ***"! 
"*** Image started on: January 26, 2021 02:17:54 AM ***"! 
"*** Image started on: January 26, 2021 02:18:46 AM ***"! 
"*** Image started on: January 26, 2021 02:21:02 AM ***"! 
"*** Image started on: January 26, 2021 02:28:39 AM ***"!

!Exception methods ! 
defaultAction
        "This is the action that is performed if this exception is
        signaled and there is no active handler for it."

    Process
        queueWalkback: self description
        makeUserIF: CurrentProcess isUserIF
        resumable: ( self isResumable ifTrue: [ 2 ] ifFalse: [ 1 ] )! ! 
#('January 26, 2021' '02:31:40 AM' nil)!

(CodeFiler organizerFor: Exception) reorganizeFrom: #(
('no category methods' defaultAction )) !


!Exception methods !   
defaultAction
        "This is the action that is performed if this exception is
        signaled and there is no active handler for it."

    Process
        queueWalkback: self description
        makeUserIF: CurrentProcess isUserIF
        resumable: ( self isResumable ifTrue: [ 2 ] ifFalse: [ 2 ] )! ! 
#('January 26, 2021' '02:31:40 AM' 1404980)!

(CodeFiler organizerFor: Exception) reorganizeFrom: #(
('no category methods' defaultAction )) !


!Exception methods !   
defaultAction
        "This is the action that is performed if this exception is
        signaled and there is no active handler for it."

    Process
        queueWalkback: self description
        makeUserIF: CurrentProcess isUserIF
        resumable: ( self isResumable ifTrue: [ 2 ] ifFalse: [ 1 ] )! ! 
#('January 26, 2021' '02:32:17 AM' 1405468)!

(CodeFiler organizerFor: Exception) reorganizeFrom: #(
('no category methods' defaultAction )) !


!FileDialog methods !  
open
        "Brings up the open file dialog."
    | error |
    hLibrary := CommonDialogDLL current.
    self copyStruct.
    parent isWindow ifFalse: [
        parent := Notifier findWindow: WindowHandle queryActive.
        openFileNameStruct hwndOwner: parent asParameter ].
    style notNil ifTrue: [ openFileNameStruct flags: style ].
    ( hLibrary getOpenFilename: openFileNameStruct asParameter )
        ifTrue: [ self checkFlags ]
        ifFalse: [
            fileName := nil.
            error := ( ExternalLong fromString: hLibrary commDlgExtendedError ) asInteger.
            error ~= 0 ifTrue: [
                self cleanUp.
                ^self osError: error ] ].
    self cleanUp.!   ! 
#('January 26, 2021' '02:33:09 AM' nil)!

(CodeFiler organizerFor: FileDialog) reorganizeFrom: #(
('no category methods' open )) !


!FileDialog methods !  
open
        "Brings up the open file dialog."
    | error |
    hLibrary := CommonDialogDLL current.
    self copyStruct.
    parent isWindow ifFalse: [
        parent := Notifier findWindow: WindowHandle queryActive.
        openFileNameStruct hwndOwner: parent asParameter ].
    style notNil ifTrue: [ openFileNameStruct flags: style ].
    ( hLibrary getOpenFilename: openFileNameStruct asParameter )
        ifTrue: [ self checkFlags ]!    ! 
#('January 26, 2021' '02:33:09 AM' 1406452)!

(CodeFiler organizerFor: FileDialog) reorganizeFrom: #(
('no category methods' open )) !


!FileDialog methods !  
open
        "Brings up the open file dialog."
    | error |
    hLibrary := CommonDialogDLL current.
    self copyStruct.
    parent isWindow ifFalse: [
        parent := Notifier findWindow: WindowHandle queryActive.
        openFileNameStruct hwndOwner: parent asParameter ].
    style notNil ifTrue: [ openFileNameStruct flags: style ].
    ( hLibrary getOpenFilename: openFileNameStruct asParameter )
        ifTrue: [ self checkFlags ]
        ifFalse: [
            fileName := nil.
            error := ( ExternalLong fromString: hLibrary commDlgExtendedError ) asInteger.
            error ~= 0 ifTrue: [
                self cleanUp.
                ^self osError: error ] ].
    self cleanUp.!   ! 
#('January 26, 2021' '02:33:55 AM' 1407344)!

(CodeFiler organizerFor: FileDialog) reorganizeFrom: #(
('no category methods' open )) !


"define class" 

Object subclass: #Table
  instanceVariableNames: 
    ' transducer '
  classVariableNames: ''
  poolDictionaries: ''!

"define class" 

Object subclass: #Transducer
  instanceVariableNames: 
    ' sponsor tables '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"

Table subclass: #TableWithTransitions
  instanceVariableNames: 
    ' transitions '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"  

Table subclass: #AcceptTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

"define class"  

Object subclass: #Tree
  instanceVariableNames: 
    ' label children '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"  

TableWithTransitions subclass: #ScannerReadaheadTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

"define class" 

TableWithTransitions subclass: #ReadaheadTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

"define class"

TableWithTransitions subclass: #ReadbackTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

"define class" 

Transducer subclass: #Screener
  instanceVariableNames: 
    ' keywords '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"

Table subclass: #SemanticTable
  instanceVariableNames: 
    ' action parameters goto '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"  

Transducer subclass: #Parser
  instanceVariableNames: 
    ' scanner screener tokenStack tableNumberStack treeStack left right tableNumber newTree '
  classVariableNames: ''
  poolDictionaries: ''!

"define class" 

TableWithTransitions subclass: #ReduceTable
  instanceVariableNames: 
    ' nonterminal '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"

Transducer subclass: #Scanner
  instanceVariableNames: 
    ' input token keptCharacters '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"   

Object subclass: #Token
  instanceVariableNames: 
    ' label symbol '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"   

Table subclass: #ShiftbackTable
  instanceVariableNames: 
    ' shift goto '
  classVariableNames: ''
  poolDictionaries: ''!

"define class" 

Object subclass: #Table
  instanceVariableNames: 
    ' transducer '
  classVariableNames: ''
  poolDictionaries: ''!

"define class" 

Object subclass: #SampleTranslator
  instanceVariableNames: 
    ' parser tree codeIfCompiler expressionsIfEvaluator compilationOperatorMap evaluationOperatorMap '
  classVariableNames: ''
  poolDictionaries: ''!


!Table methods !  
transducer: aTransducer
    transducer := aTransducer! !

!Table methods ! 
transducer
    ^transducer!    !

"evaluate"   
(CodeFiler organizerFor: Table) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Table) reorganizeFrom: #(
('get/set' transducer: transducer )) !

(CodeFiler organizerFor: Table) reorganizeFrom: #(
('get/set' transducer: transducer )) !
CodeFiler setCommentFor: Table to: ''!



!AcceptTable methods !
table: aTable
    "Do nothing."!   !

"evaluate"   
(CodeFiler organizerFor: AcceptTable) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: AcceptTable) reorganizeFrom: #(
('get/set' table: )) !

(CodeFiler organizerFor: AcceptTable) reorganizeFrom: #(
('get/set' table: )) !



!AcceptTable methods !  
run
    ^nil "Ensure that parsing does not continue..."!   !
(CodeFiler organizerFor: AcceptTable) reorganizeFrom: #(
('running' run )) !

(CodeFiler organizerFor: AcceptTable) reorganizeFrom: #(
('running' run )) !
CodeFiler setCommentFor: AcceptTable to: ''!



!Tree class methods !  
fromOldStyleArray: anObject
    "This assumes the array encode the tree in LISP notation; e.g. (root child1 child2 child3 ...)."
    (anObject isKindOf: Array) ifTrue: [^Tree new label: anObject first; children: (anObject rest collect: [:object | self fromArray: object])].
    (anObject isKindOf: Number) ifTrue: [^Token new label: #Integer; symbol: anObject printString].
    (anObject isKindOf: Character) ifTrue: [^Token new label: #Character; symbol: (String with: anObject)].
    (anObject isKindOf: Symbol) ifTrue: [^Token new label: #Identifier; symbol: anObject]. "or Symbol"
    (anObject isKindOf: String) ifTrue: [^Token new label: #SingleQuotedString; symbol: anObject].
    
    "We can't distinguish a symbol from an identifier because all identifiers become symbols in array literals."
    "We can't distinguish a SingleQuotedString from a DoubleQuotedString because all strings are single quoted in Smalltalk"
    
    ^self halt: 'Tree fromArray: did not expects the objects ', anObject printString!    !

!Tree class methods !
new

    ^super new initialize!   !

!Tree class methods !
fromArray: anObject
    "This assumes the array encode the tree in LISP notation; e.g. (root child1 child2 child3 ...)."
    (anObject isKindOf: Array) ifTrue: [^Tree new label: anObject first; children: (anObject rest collect: [:object | self fromArray: object])].
    (anObject isKindOf: Integer) ifTrue: [^Token new label: #walkInteger; symbol: anObject printString].
    (anObject isKindOf: Character) ifTrue: [^Token new label: #walkCharacter; symbol: (String with: anObject)].
    (anObject isKindOf: Symbol) ifTrue: [^Token new label: #walkIdentifier; symbol: anObject]. "or Symbol"
    (anObject isKindOf: String) ifTrue: [^Token new label: #walkString; symbol: anObject].
    
    "We can't distinguish a symbol from an identifier because all identifiers become symbols in array literals."
    ^self halt: 'Tree fromArray: did not expects the object ', anObject printString!    !

"evaluate"   
(CodeFiler organizerFor: Tree class) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Tree class) reorganizeFrom: #(
('instance creation' fromOldStyleArray: new fromArray: )) !

(CodeFiler organizerFor: Tree class) reorganizeFrom: #(
('instance creation' fromOldStyleArray: new fromArray: )) !



!Tree methods !  
initialize
    children := OrderedCollection new.! !

"evaluate"   
(CodeFiler organizerFor: Tree) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('initializing' initialize )) !



!Tree methods !
children
    ^children!    !

!Tree methods !  
label: aSymbol
    label := aSymbol!   !

!Tree methods !  
label
    ^label!  !

!Tree methods !  
child: index
    ^children at: index!  !

!Tree methods !  
children: aCollection
    children := aCollection! !
(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('get/set' children label: label child: children: )) !

(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('get/set' children label: label child: children: )) !



!Tree methods !  
addChild: aTree
    children add: aTree!   !
(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('modifying' addChild: )) !

(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('modifying' addChild: )) !



!Tree methods !
printOn: aStream
    self printOn: aStream tabs: 0.!   !

!Tree methods !  
printOn: aStream tabs: tabs
    aStream cr.
    tabs timesRepeat: [aStream << '   '].
    aStream << self label.
    children do: [:child | child printOn: aStream tabs: tabs + 1]! !
(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('printing' printOn: printOn:tabs: )) !

(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('printing' printOn: printOn:tabs: )) !
CodeFiler setCommentFor: Tree to: ''!



!ScannerReadaheadTable methods !
table: anArray
    "Record the triples: an integer or character collection, attributes, and goto. The integers
    are unprintable characters or the end of file integer 256, the attributes are $R for read 
    ($L for stack) and $K for keep. It's particularly important here to store the data so that
    given a character or 256, you can perform a fast lookup to find the triple."
    
    transitions := Dictionary new.
    anArray do: [:triple |
        triple first do: [:characterOrInteger | transitions at: characterOrInteger asInteger put: triple rest]]
        
    "OLD WAY:
    anArray groupsDo: [:item :attributes :goto |
        item isString 
                ifTrue: [item do: [:character | transitions at: character asInteger put: (Array with: attributes with: goto)]]
                ifFalse: [item do: [:integer | transitions at: integer put: (Array with: attributes with: goto)]]]
    "! !

"evaluate"   
(CodeFiler organizerFor: ScannerReadaheadTable) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: ScannerReadaheadTable) reorganizeFrom: #(
('get/set' table: )) !

(CodeFiler organizerFor: ScannerReadaheadTable) reorganizeFrom: #(
('get/set' table: )) !



!ScannerReadaheadTable methods !  
printables
    "The last three printable characters are single quote (represented as two single quotest in a row; i.e. ''),
    double quote (represented as one double quote; the end of comment is a double quote), and a space.
    Note: that it's hard to see the difference between two single quotes and one double quote."
    
    ^'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!!,+-/\*~=@%&?|<>[]{}()^;#:.$_''" '.!  !

!ScannerReadaheadTable methods ! 
run
    | character isKeep isRead pair |

    "Consider the next input character or integer (it could be 256 for endOfFile).
    Search the transitions for the triple that matches it. Remember: the original
    data was triples: an integer or character collection, attributes, and goto. But
    for fast lookup, you want to just be able to look up the triple using the next
    input as a key... When you find it, the read attribute ($R as opposed to $L)
    indicates that you need to remove it from the input. Otherwise, it stays for future 
    use. If it has the keep attribute ($K), you need to append the character to
    'keptCharacters'. If you can't find it, it a lexical error (see reportLexicalError).
    When you are done, return the goto table."
    
    character := transducer peekInput.
    pair := transitions at: character asInteger ifAbsent: [nil].
    pair notNil ifTrue: [
        pair groupDo: [:attributes :goto |
            isRead := attributes includes: $R.
            isKeep := attributes includes: $K.
            isRead ifFalse: [^goto].
            isKeep ifTrue: [transducer keptCharacters: (transducer keptCharacters, character asString)].
            transducer discardInput.
            ^goto]].
            
    self reportLexicalError!   !

!ScannerReadaheadTable methods ! 
reportLexicalError
    | characterAsInteger character printables |

    characterAsInteger := transducer peekInput.
    characterAsInteger = 256 ifTrue: [self error: 'Lexical error: End of the file encountered unexpectedly'].
    character := characterAsInteger asCharacter.
    
    (self printables includes: character) 
        ifTrue: [self error: 'Lexical error, encountered unexpected character ', character asString]
        ifFalse: [
            self error: 'Lexical error, encountered unexpected unprintable character',
                ' hex ', (character asNumber printStringRadix: 16),
                ' decimal ', character asNumber printString]! !
(CodeFiler organizerFor: ScannerReadaheadTable) reorganizeFrom: #(
('running' printables run reportLexicalError )) !

(CodeFiler organizerFor: ScannerReadaheadTable) reorganizeFrom: #(
('running' printables run reportLexicalError )) !
CodeFiler setCommentFor: ScannerReadaheadTable to: ''!



"evaluate"   
(CodeFiler organizerFor: ReadaheadTable) removeCategory: 'no category methods' ifAbsent: [nil]!


!ReadaheadTable methods !
reportSyntaxError
    | token inputTokens inputText position |
            
    token := transducer peekScannerToken.
    inputTokens := transducer tokenStack rest. "Skip start stack information."
    
    Transcript cr; << 'Syntax error...'. 
    inputTokens isEmpty 
        ifTrue: [Transcript cr; << 'Did not expect input to start with '. Transcript << token]
        ifFalse: [
            Transcript cr; << 'DID NOT EXPECT'; << (inputTokens size > 6 ifTrue: [' ...'] ifFalse: ['']).
            inputTokens := inputTokens suffix: 6.
            inputTokens do: [:token | Transcript << ' '; << token].
            Transcript cr; << 'TO BE FOLLOWED BY '; << token.
            inputText := transducer scanner input collection. position := transducer scanner input position.
            Transcript << (inputText copyFrom: (position + 1 max: 1) to: (position + 100 min: inputText size))].
    self error: ('Syntax error: Illegal symbol: ', token label)! !

!ReadaheadTable methods !
run
    | token tokenLabel transition isRead isNode isStack |

    "Peek at the next token label..."
    tokenLabel := (token := transducer peekScannerToken) label asSymbol.

    "and then use the transition that matches it if there is one. Use the attributes to determine
    what to do. If there isn't one, it's a syntax error. Remember $R means read ($L look), $N
    means make the token part of a tree, and $S means stack. If we stack, we also need 'right'
    to refer to the last entry and 'left' to be one more to the right. Finally, returns the corresponding
    goto state."

    transition := transitions at: tokenLabel ifAbsent: [^self reportSyntaxError].
    transition groupDo: [:attributes :goto |
        isRead := attributes includes: $R.
        isNode := attributes includes: $N.
        isStack := attributes includes: $S.
        isRead ifFalse: [^goto].
        transducer discardScannerToken.
        isStack ifTrue: [
            transducer tokenStack add: token.
            transducer tableNumberStack add: goto.
            transducer treeStack add: (isNode ifTrue: [token] ifFalse: [nil]).
            transducer right: transducer tokenStack size.
            transducer left: transducer right + 1].
        ^goto].!   !
(CodeFiler organizerFor: ReadaheadTable) reorganizeFrom: #(
('running' reportSyntaxError run )) !

(CodeFiler organizerFor: ReadaheadTable) reorganizeFrom: #(
('running' reportSyntaxError run )) !



!ReadaheadTable methods !  
runUNUSEDVersionThatSearches
    | token tokenLabel isRead isNode isStack |

    "Peek at the next token label..."
    tokenLabel := (token := transducer peekScannerToken) label asSymbol.

    "and then search for a transition that matches it. When found, use the attributes to determine
    what to do. If you don't find it, it's a syntax error. Remember $R means read ($L look), $N
    means make the token part of a tree, and $S means stack. If we stack, we also need 'right'
    to refer to the last entry and 'left' to be one more to the right. Finally, returns the corresponding
    goto state."

    transitions groupsDo: [:symbol :attributes :goto |
        tokenLabel == symbol ifTrue: [
            isRead := attributes includes: $R.
            isNode := attributes includes: $N.
            isStack := attributes includes: $S.
            isRead ifFalse: [^goto].
            transducer discardScannerToken.
            isStack ifTrue: [
                transducer tokenStack add: token.
                transducer tableNumberStack add: goto.
                transducer treeStack add: (isNode ifTrue: [token] ifFalse: [nil]).
                transducer right: transducer tokenStack size.
                transducer left: transducer right + 1].
            ^goto]].

    self reportSyntaxError!    !

!ReadaheadTable methods !
tableUNUSEDVersionThatSearches: anArray
    "Record the data unmodified so you can later perform a fast search."
    transitions := anArray!  !
(CodeFiler organizerFor: ReadaheadTable) reorganizeFrom: #(
('unused' runUNUSEDVersionThatSearches tableUNUSEDVersionThatSearches: )) !

(CodeFiler organizerFor: ReadaheadTable) reorganizeFrom: #(
('unused' runUNUSEDVersionThatSearches tableUNUSEDVersionThatSearches: )) !
CodeFiler setCommentFor: ReadaheadTable to: ''!



!TableWithTransitions methods !   
table: anArray
    "Record the data so you can later perform a fast lookup."
    transitions := Dictionary new.
    anArray do: [:triple | transitions at: triple first put: triple rest]!   !

"evaluate"   
(CodeFiler organizerFor: TableWithTransitions) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: TableWithTransitions) reorganizeFrom: #(
('get/set' table: )) !

(CodeFiler organizerFor: TableWithTransitions) reorganizeFrom: #(
('get/set' table: )) !
CodeFiler setCommentFor: TableWithTransitions to: ''!



"evaluate"
(CodeFiler organizerFor: ReadbackTable) removeCategory: 'no category methods' ifAbsent: [nil]!


!ReadbackTable methods !  
run
    | pair transition isRead |
    "Readback considers the token label in the token stack and the state number in the table number at position 'left - 1'
    and then uses the transition that matches it. If there isn't one it's a design error. Otherwise, it then uses the attribute $R for read, $L for look to
    decide what to do. If it's read, it decrements 'left'. Finally it returns the goto state."

    pair := Array with: (transducer tokenStack at: transducer left - 1) label with: (transducer tableNumberStack at: transducer left - 1).
    transition := transitions at: pair ifAbsent: [^self reportDesignError].
    transition groupDo: [:attributes :goto |
        isRead := attributes  includes: $R.
        isRead ifTrue: [transducer left: transducer left - 1].
        ^goto].!    !

!ReadbackTable methods ! 
reportDesignError
    self error: 'Design error: reached end of ReadbackTable without having found a suitable transition'! !
(CodeFiler organizerFor: ReadbackTable) reorganizeFrom: #(
('running' run reportDesignError )) !

(CodeFiler organizerFor: ReadbackTable) reorganizeFrom: #(
('running' run reportDesignError )) !



!ReadbackTable methods ! 
tableUNUSEDVersionThatSearches: anArray
    "Store the data, old state number/symbol/new state number triples for search in run."
    | pair |
    transitions := anArray collect: [:triple |
        pair := triple first.
        Array with: (Array with: pair first asSymbol with: pair second) with: triple second with: triple third]!   !

!ReadbackTable methods ! 
runUNUSEDVersionThatSearches
    | pair isRead |
    "Readback considers the token label in the token stack and the state number in the table number at position 'left - 1'
    and then finds the transition that matches it. When it finds it, it then uses the attribute $R for read, $L for look to
    decide what to do. If it's read, it decrements 'left'. Finally it returns the goto state."
    
    pair := Array with: (transducer tokenStack at: transducer left - 1) label with: (transducer tableNumberStack at: transducer left - 1).
    transitions groupsDo: [:nextPair :attributes :goto |
        pair = nextPair ifTrue:[
            isRead := attributes  includes: $R.
            isRead ifTrue: [transducer left: transducer left - 1].
            ^goto]].
    self reportDesignError!    !
(CodeFiler organizerFor: ReadbackTable) reorganizeFrom: #(
('unused' tableUNUSEDVersionThatSearches: runUNUSEDVersionThatSearches )) !

(CodeFiler organizerFor: ReadbackTable) reorganizeFrom: #(
('unused' tableUNUSEDVersionThatSearches: runUNUSEDVersionThatSearches )) !
CodeFiler setCommentFor: ReadbackTable to: ''!



"evaluate"   
(CodeFiler organizerFor: Screener class) removeCategory: 'no category methods' ifAbsent: [nil]!


!Screener methods !  
keywords
    ^keywords!    !

!Screener methods !  
keywords: aCollection
    keywords := aCollection! !

"evaluate"   
(CodeFiler organizerFor: Screener) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Screener) reorganizeFrom: #(
('get/set' keywords keywords: )) !

(CodeFiler organizerFor: Screener) reorganizeFrom: #(
('get/set' keywords keywords: )) !



!Screener methods !  
screen: aToken
    "Older name is #Identifier, newer name is #walkIdentifier:"
    (aToken label = #Identifier) | (aToken label = #walkIdentifier:) ifFalse: [^aToken]. 
    (self keywords includes: aToken symbol) ifFalse: [^aToken].
    ^Token new label: aToken symbol; symbol: aToken symbol.!   !
(CodeFiler organizerFor: Screener) reorganizeFrom: #(
('screening' screen: )) !

(CodeFiler organizerFor: Screener) reorganizeFrom: #(
('screening' screen: )) !
CodeFiler setCommentFor: Screener to: ''!



!SemanticTable methods !
table: aTable
    action := aTable first.
    parameters := aTable copyFrom: 2 to: aTable size - 1.
    goto := aTable last! !

!SemanticTable methods ! 
action: aSymbol
    action := aSymbol! !

!SemanticTable methods ! 
parameters
    ^parameters!    !

!SemanticTable methods ! 
goto
    ^goto!    !

!SemanticTable methods ! 
parameters: aCollection
    parameters := aCollection! !

!SemanticTable methods ! 
goto: aNumber
    goto := aNumber! !

!SemanticTable methods ! 
action
    ^action!    !

"evaluate"   
(CodeFiler organizerFor: SemanticTable) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: SemanticTable) reorganizeFrom: #(
('get/set' table: action: parameters goto parameters: goto: action )) !

(CodeFiler organizerFor: SemanticTable) reorganizeFrom: #(
('get/set' table: action: parameters goto parameters: goto: action )) !



!SemanticTable methods !
run
    | recipient |
    recipient := (transducer class canUnderstand: action) ifTrue: [transducer] ifFalse: [transducer sponsor].
    recipient perform: action withArguments: parameters.
    ^goto! !
(CodeFiler organizerFor: SemanticTable) reorganizeFrom: #(
('running' run )) !

(CodeFiler organizerFor: SemanticTable) reorganizeFrom: #(
('running' run )) !
CodeFiler setCommentFor: SemanticTable to: ''!



!Parser class methods !  
for: aSponsor parserTables: parserTables scannerTables: scannerTables
    | parser |
    parser := self new.
    
    "Set up the user (or sponsor) of the scanner and parser."
    parser sponsor: aSponsor. parser scanner sponsor: aSponsor.
    
    "Give the keywords to the screener and the remaining tables to the parser..."
    parser tables: parserTables rest; screener: (Screener new keywords: parserTables first rest).
    
    "Give the entire set of scanner tables to the scanner..."
    parser scanner tables: scannerTables.
    
    ^parser!    !

"evaluate"   
(CodeFiler organizerFor: Parser class) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Parser class) reorganizeFrom: #(
('instance creation' for:parserTables:scannerTables: )) !

(CodeFiler organizerFor: Parser class) reorganizeFrom: #(
('instance creation' for:parserTables:scannerTables: )) !



!Parser methods !  
initialize
    scanner := Scanner new. screener := Screener new.
    tokenStack := OrderedCollection new add: (Token new label: #'|-'; symbol: #'|-'); yourself.
    treeStack := OrderedCollection new add: nil; yourself.
    tableNumberStack := OrderedCollection new add: 1; yourself.
    left := 1. right := 1.!    !

"evaluate"   
(CodeFiler organizerFor: Parser) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('initializing' initialize )) !



!Parser methods !
screener: aScreener
    screener := aScreener! !

!Parser methods !
screener
    ^screener!    !

!Parser methods !
right
    ^right!  !

!Parser methods !
tokenStack: aCollection
    tokenStack := aCollection! !

!Parser methods !
treeStack
    ^treeStack!  !

!Parser methods !
left: aNumber
    left := aNumber! !

!Parser methods !
tableNumberStack: aCollection
    tableNumberStack := aCollection! !

!Parser methods !
tokenStack
    ^tokenStack!    !

!Parser methods !
tableNumberStack
    ^tableNumberStack!    !

!Parser methods !
tables: aCollection
    "Store the collection of all table objects in tables. Moreover, each type of table will store it's data
    in its own way. So, you had better let the object store it. Note: The collection contains the NAMES for the types
    of table objects, they are not table objects. Also, whoever sent this message had better not have 
    included an entry for a keyword list since that was supposed to have been given to the screener.
    IN OTHER WORDS: Create the appropriate kind of table object, give the table data to that object, and 
    then store that object in the parser's tables."
    
    "HINT: 'Smalltalk at: x' where x is a variable containing the symbol #Apple returns the class object called
    Apple. Once you have a class object, you can say new to it."
    
    tables := aCollection collect:[ :element |     
        "Each table is of the form (tableType tableNumber ...)."
        "Get the class name for the type, then make a new instance, then give it the table and tell it that I'm it's transducer."
        (Smalltalk at: element first) new table: (element copyFrom: 3); transducer: self ].!    !

!Parser methods !
newTree
    ^newTree!  !

!Parser methods !
scanner
    ^scanner!  !

!Parser methods !
right: aNumber
    right := aNumber!   !

!Parser methods !
treeStack: aCollection
    treeStack := aCollection!   !

!Parser methods !
tables
    ^tables!    !

!Parser methods !
left
    ^left!    !

!Parser methods !
newTree: aTree
    newTree := aTree!   !

!Parser methods !
scanner: aScanner
    scanner := aScanner! !
(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('get/set' screener: tokenStack: screener tables: treeStack left: tokenStack tableNumberStack: tableNumberStack right newTree scanner right: treeStack: tables left newTree: scanner: )) !

(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('get/set' screener: tokenStack: screener tables: treeStack left: tokenStack tableNumberStack: tableNumberStack right newTree scanner right: treeStack: tables left newTree: scanner: )) !



!Parser methods !
parse: text
    "To parse the text, you have to give it to the scanner (say via scan: text).
    It in turn should have the first token set up for you. Next you need
    to execute tables starting from table 1 until you reach an Accept table.
    Once that happen, the tree that was built should be on top of the tree
    stack. Just return it. If you look at the Accept table, you will see
    that it of all the tables, it is the only one that returns nil. You can
    use that information to stop your loop."
    | table |
    
    scanner scan: text.
    tableNumber := 1. table := tables at: tableNumber.
    [table class = AcceptTable ] whileFalse: [
        self log. "<---for debugging. You might want to comment this out for now"
        tableNumber := table run.
        table := tables at: tableNumber.].
    ^treeStack last!    !
(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('parsing' parse: )) !

(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('parsing' parse: )) !



!Parser methods !
discardScannerToken
    scanner discardToken.! !

!Parser methods !
peekScannerToken
    ^screener screen: scanner peekToken.! !
(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('streaming' discardScannerToken peekScannerToken )) !

(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('streaming' discardScannerToken peekScannerToken )) !



!Parser methods !
buildTreeFromIndex: index
    "Index is positive (1, 2, 3, ...) => label is in the token relative to the left end; i.e., to the right of left end."
    "index is negative (-1, -2, -3...) => label is in the token relative to the right end; i.e., to the left of right end."
    | children |    
    children := (left to: right) collect: [:index | treeStack at: index] when: [:index | (treeStack at: index) notNil].
    newTree := Tree new 
        label:  (index isPositive ifTrue: [tokenStack at: left + index - 1] ifFalse: [tokenStack at: right + index + 1]) symbol
        children: children.!   !

!Parser methods !
buildTree: rootNode
    "Pick up the children from the tree stack between left and     right inclusive (provided they're not nil) and 
    build a tree with the given label. Store it in instance variable newTree so a reduce table can use it."
    
    | children |
    children := (left to: right) collect: [:index | treeStack at: index] when: [:index | (treeStack at: index) notNil].
    newTree := Tree new label: rootNode; children: children.!    !
(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('semanticActions' buildTreeFromIndex: buildTree: )) !

(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('semanticActions' buildTreeFromIndex: buildTree: )) !



!Parser methods !
log
    | table useTerseTree whichCharacterToStartLogging |
    true ifTrue: [^self]. "currently disabled"
    whichCharacterToStartLogging := 4040.
    scanner input position < whichCharacterToStartLogging ifTrue: [^self].
    useTerseTree := true. "Set to false if more details are wanted..."
    table := tables at: tableNumber.

    "Log a preliminary heading..."
    Transcript cr; << 'At '; << scanner input position; << self peekScannerToken; << ' | left '; << left; << ' right '; << right; << ' |'; << ' Table '; << tableNumber; space; << table.

    "Log state specific information..."
    table class = ReadaheadTable ifTrue: [Transcript << ' SEARCHING FOR '; << self peekScannerToken label].
    table class = ReadbackTable ifTrue: [Transcript << ' SEARCHING FOR ';
        << '['; << (tokenStack at: left - 1) label; << ' '; << (tableNumberStack at: left - 1); << ']'].
    table class = ReduceTable ifTrue: [Transcript space; << table nonterminal; << ' SEARCHING FOR ';
        << (tableNumberStack at: left - 1)].
    table class = ShiftbackTable ifTrue: [Transcript << ' SHIFT '; << table shift; << ' GOTO '; << table goto].
    (table class = SemanticTable) ifTrue: [
        Transcript space; << table action. table parameters do: [:parameter | Transcript space; << parameter].
        Transcript << ' GOTO '; << table goto].

    "Log information in the stacks..."
    self treeStack indexedDo: [:index :tree |
        (index = left and: [left <= right]) ifTrue: [Transcript cr; << '       ---------------------------'].
        Transcript cr; << '       '; << index; << ' ['; << (self tokenStack at: index); << ' '; << (self tableNumberStack at: index); << '] '.
        tree isNil ifFalse:[useTerseTree ifTrue: [Transcript << ' Tree ('; << tree label; << ' ...)'] ifFalse: [tree printOn: Transcript tabs: 3]].
        (index = right and: [left > right]) ifTrue: [Transcript cr; << '       ---------------------------'].
        index = right ifTrue: [Transcript cr; << '       ---------------------------'].].!  !
(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('debugging' log )) !

(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('debugging' log )) !
CodeFiler setCommentFor: Parser to: ''!



!ReduceTable methods !
nonterminal: aSymbol
    nonterminal := aSymbol!   !

!ReduceTable methods !   
nonterminal
    ^nonterminal!  !

!ReduceTable methods !   
table: anArray
    "Store the data; namely a nonterminal and a bunch of transition information; triples
    with a 'from table numer', attributes, and a 'to table number'."
    nonterminal := anArray first.
    super table: anArray rest!   !

"evaluate"   
(CodeFiler organizerFor: ReduceTable) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: ReduceTable) reorganizeFrom: #(
('get/set' nonterminal: nonterminal table: )) !

(CodeFiler organizerFor: ReduceTable) reorganizeFrom: #(
('get/set' nonterminal: nonterminal table: )) !



!ReduceTable methods !
run
    "This is a 'Reduce to A' table where A is the nonterminal to reduce to. Pick up the new tree
    and simulate a readahead of A where the new tree is associated with A"

    | transition children tree tableNumber isStack isNode  |
    "Pick up the new tree if there is one OR bubble up the one tree in the stack between
    'left' and 'right' or nil if there isn't one. There better not be 2 or more."
    transducer newTree notNil
        ifTrue: [
            tree := transducer newTree. transducer newTree: nil]
        ifFalse: [
            "Just capture the one subtree (if any) and have it ready for stacking."
            children := (transducer treeStack copyFrom: transducer left to: transducer right) withoutNils.
            children size = 0 ifTrue: [tree := nil] ifFalse: [
            children size = 1 ifTrue: [tree := children first] ifFalse: [
            self halt: 'Design error: more than 1 child in ReduceTable'. tree := children last]]].

    "Clear the stacks between left and right (inclusive)."
    (transducer left to: transducer right) do: [:index |
        transducer tokenStack removeLast.
        transducer tableNumberStack removeLast.
        transducer treeStack removeLast].

    "Use the top table number on the stack (the 'from table number') to locate the pair (attributes, 'to table number);
    it's a design error if you can't find it. The other table number is to be returned when you're done. Also use the
    attributes in the same manner as you did for a readahead table but this time, instead of using the next token,
    use a new token you create using the nonterminal as it's symbol. Don't forget to adjust 'right' and 'left' like you
    did for the readahead table."

    tableNumber := transducer tableNumberStack last.
    transition := transitions at: tableNumber ifAbsent: [^self reportDesignError].
    transition groupDo: [:attributes :goto |
        isStack := attributes includes: $S. isNode := attributes includes: $N.
        isStack ifTrue: [
            transducer tokenStack add: (Token new label: nonterminal; symbol: nonterminal).
            transducer tableNumberStack add: goto.
            transducer treeStack add: (isNode ifTrue: [tree] ifFalse: [nil])].
        transducer right: transducer treeStack size.
        transducer left: transducer right + 1.
        ^goto].!   !

!ReduceTable methods !   
reportDesignError
    self error: 'Design error: reached end of ReduceTable without having found a suitable transition'!   !
(CodeFiler organizerFor: ReduceTable) reorganizeFrom: #(
('running' run reportDesignError )) !

(CodeFiler organizerFor: ReduceTable) reorganizeFrom: #(
('running' run reportDesignError )) !



!ReduceTable methods !   
runUNUSEDVersionThatSearches
    "This is a 'Reduce to A' table where A is the nonterminal to reduce to. Pick up the new tree
    and simulate a readahead of A where the new tree is associated with A"

    | stack children tree tableNumber isStack isNode token |
    "Pick up the new tree if there is one OR bubble up the one tree in the stack between
    'left' and 'right' or nil if there isn't one. There better not be 2 or more."
    transducer newTree notNil
        ifTrue: [
            tree := transducer newTree. transducer newTree: nil]
        ifFalse: [
            "Just capture the one subtree (if any) and have it ready for stacking."
            children := (transducer treeStack copyFrom: transducer left to: transducer right) withoutNils.
            children size = 0 ifTrue: [tree := nil] ifFalse: [
            children size = 1 ifTrue: [tree := children first] ifFalse: [
            self halt: 'Design error: more than 1 child in ReduceTable'. tree := children last]]].

    "Clear the stacks between left and right (inclusive)."
    (transducer left to: transducer right) do: [:index |
        transducer tokenStack removeLast.
        transducer tableNumberStack removeLast.
        transducer treeStack removeLast].

    "Using the top table number on the stack, search the triples ('from table number, attributes,
    'to table number) and find the one that matches 'from table number'; it's a design error if you can't
    find it. The other table number is to be returned when you're done. Also use the attributes in the
    same manner as you did for a readahead table but this time, instead of using the next token,
    use a new token you create using the nonterminal as it's symbol. Don't forget to adjust
    'right' and 'left' like you did for the readahead table."

    tableNumber := transducer tableNumberStack last.
    transitions groupsDo: [:candidateTableNumber :attributes :goto |
        tableNumber = candidateTableNumber ifTrue: [
            isStack := attributes includes: $S. isNode := attributes includes: $N.
            isStack ifTrue: [
                transducer tokenStack add: (Token new label: nonterminal; symbol: nonterminal).
                transducer tableNumberStack add: goto.
                transducer treeStack add: (isNode ifTrue: [tree] ifFalse: [nil])].
            transducer right: transducer treeStack size.
            transducer left: transducer right + 1.
            ^goto]].

    self reportDesignError! !

!ReduceTable methods !   
tableUNUSEDVersionThatSearches: anArray
    "Store the data; namely a nonterminal and a bunch of transition information; triples
    with a 'from table numer', attributes, and a 'to table number'."
    nonterminal := anArray first.
    super table: anArray rest!  !
(CodeFiler organizerFor: ReduceTable) reorganizeFrom: #(
('unused' runUNUSEDVersionThatSearches tableUNUSEDVersionThatSearches: )) !

(CodeFiler organizerFor: ReduceTable) reorganizeFrom: #(
('unused' runUNUSEDVersionThatSearches tableUNUSEDVersionThatSearches: )) !
CodeFiler setCommentFor: ReduceTable to: ''!



!Scanner methods ! 
initialize
    token := nil.
    keptCharacters := ''.!   !

"evaluate"   
(CodeFiler organizerFor: Scanner) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('initializing' initialize )) !



!Scanner methods !
tables
    ^tables!    !

!Scanner methods !   
tables: aCollection
    "Store the collection of all table objects in tables. Moreover, each type of table will store it's data
    in its own way. So, you had better let the object store it. Note: The Collection contains the NAMES of the 
    types of table objects, they are not table objects. IN OTHER WORDS: Create the appropriate kind of table
    object, give the table data to that object, and then store that object in the scanner's tables."
    
    "HINT: 'Smalltalk at: x' where x is a variable containing the symbol #Apple returns the class object called
    Apple. Once you have a class object, you can say new to it."
    
    tables := aCollection collect: [:element | 
        "Each table is of the form (tableType tableNumber ...)."
        "Get the class name for the type, then make a new instance, then give it the table and tell it that I'm it's transducer."
        (Smalltalk at: element first) new table: (element copyFrom: 3); transducer: self]!  !

!Scanner methods !   
keptCharacters
    ^keptCharacters!    !

!Scanner methods !   
keptCharacters: aString
    keptCharacters := aString! !

!Scanner methods !   
input: aStream
    input := aStream!   !

!Scanner methods !   
input
    ^input!  !
(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('get/set' tables tables: keptCharacters keptCharacters: input: input )) !

(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('get/set' tables tables: keptCharacters keptCharacters: input: input )) !



!Scanner methods ! 
scan: text
    self input: (ReadStream on: text).
    self discardToken!  !
(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('scanning' scan: )) !

(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('scanning' scan: )) !



!Scanner methods ! 
peekInput
    ^input atEnd ifTrue:[256] ifFalse:[input peek]!  !

!Scanner methods !   
peekToken
    ^token!  !

!Scanner methods !   
discardToken
    "To discard the current token, set token to nil and execute the tables
    in a loop starting with table 1 until token is no longer nil. Then return 
    nothing. Somewhere during this execution, the semantic action buildToken:
    will execute putting something into variable 'token'."
    
    | tableNumber table |
    tableNumber := 1. token := nil.
    [token isNil] whileTrue: [
        table := tables at: tableNumber.
        tableNumber := table run].
    ^nil "We now have a token"!    !

!Scanner methods !   
discardInput
    ^input next!  !
(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('streaming' peekInput discardToken discardInput peekToken )) !

(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('streaming' peekInput discardToken discardInput peekToken )) !



!Scanner methods !   
buildToken: label
    "Create a token with the supplied label and the characters in keptCharacters
    and put the result in token so peek can return it when requested.
    Reset keptCharacters to an empty string so the process can repeat."
    
    token := Token new label: label asSymbol; symbol: keptCharacters asSymbol.
    keptCharacters := ''.!   !
(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('semantic actions' buildToken: )) !

(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('semantic actions' buildToken: )) !
CodeFiler setCommentFor: Scanner to: ''!



!Token methods ! 
label: aLabel
    label := aLabel! !

!Token methods ! 
label
    ^label!  !

!Token methods ! 
symbol
    ^symbol!    !

!Token methods ! 
symbol: aSymbol
    symbol := aSymbol! !

"evaluate"   
(CodeFiler organizerFor: Token) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Token) reorganizeFrom: #(
('get/set' label: label symbol symbol: )) !

(CodeFiler organizerFor: Token) reorganizeFrom: #(
('get/set' label: label symbol symbol: )) !



!Token methods !
printOn: aStream
    "Make label #Identifier with symbol #hello look like Identifier: hello 
    whereas label #keyword with symbol #keyword looks like keyword."
    self label == self symbol 
        ifTrue: [aStream << self label]
        ifFalse: [aStream << self label; << ': '; << self symbol].!   !

!Token methods ! 
printOn: aStream tabs: tabs
    aStream cr.
    tabs timesRepeat: [ aStream << '   '].
    aStream << self label; << ' ('; << self symbol; << ')'.!  !
(CodeFiler organizerFor: Token) reorganizeFrom: #(
('printing' printOn: printOn:tabs: )) !

(CodeFiler organizerFor: Token) reorganizeFrom: #(
('printing' printOn: printOn:tabs: )) !



!Token methods ! 
= anObject
    self class = anObject class ifFalse: [^false].
    ^self label = anObject label and: [self symbol = anObject symbol]!  !

!Token methods ! 
hash
    ^label hash + symbol hash!    !
(CodeFiler organizerFor: Token) reorganizeFrom: #(
('comparing' = hash )) !

(CodeFiler organizerFor: Token) reorganizeFrom: #(
('comparing' = hash )) !
CodeFiler setCommentFor: Token to: ''!



!ShiftbackTable methods !  
table: aTable
    "Record the data it needs."
    shift := aTable first. goto := aTable second!   !

!ShiftbackTable methods !
goto
    ^goto!    !

!ShiftbackTable methods !
goto: aNumber
    goto := aNumber! !

!ShiftbackTable methods !
shift: aNumber
    shift := aNumber!   !

!ShiftbackTable methods !
shift
    ^shift!  !

"evaluate"   
(CodeFiler organizerFor: ShiftbackTable) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: ShiftbackTable) reorganizeFrom: #(
('get/set' goto table: goto: shift: shift )) !

(CodeFiler organizerFor: ShiftbackTable) reorganizeFrom: #(
('get/set' goto table: goto: shift: shift )) !



!ShiftbackTable methods !  
run
    "Adjust left by the amount specified and return the goto table."
    transducer left: transducer left - shift.
    ^goto!    !
(CodeFiler organizerFor: ShiftbackTable) reorganizeFrom: #(
('running' run )) !

(CodeFiler organizerFor: ShiftbackTable) reorganizeFrom: #(
('running' run )) !
CodeFiler setCommentFor: ShiftbackTable to: ''!



!Table methods !  
transducer: aTransducer
    transducer := aTransducer! !

!Table methods ! 
transducer
    ^transducer!    !
(CodeFiler organizerFor: Table) reorganizeFrom: #(
('get/set' transducer: transducer )) !

(CodeFiler organizerFor: Table) reorganizeFrom: #(
('get/set' transducer: transducer )) !
CodeFiler setCommentFor: Table to: ''!



!Transducer class methods !
new

    ^super new initialize!   !

"evaluate"   
(CodeFiler organizerFor: Transducer class) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Transducer class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: Transducer class) reorganizeFrom: #(
('instance creation' new )) !



!Transducer methods !  
tables: aCollection
    tables := aCollection! !

!Transducer methods !
tables
    ^tables!    !

!Transducer methods !
sponsor
    ^sponsor!  !

!Transducer methods !
sponsor: anObject
    sponsor := anObject! !

"evaluate"   
(CodeFiler organizerFor: Transducer) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Transducer) reorganizeFrom: #(
('get/set' tables: tables sponsor sponsor: )) !

(CodeFiler organizerFor: Transducer) reorganizeFrom: #(
('get/set' tables: tables sponsor sponsor: )) !
CodeFiler setCommentFor: Transducer to: ''!



!SampleTranslator class methods !   
new

    ^super new initialize!   !

"evaluate"   
(CodeFiler organizerFor: SampleTranslator class) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('instance creation' new )) !



!SampleTranslator class methods !
rawParserTables
    "Tables generated from GrammarBuilder class>>parserGrammar"
    ^
#(
   (keywords where)
   (ReadaheadTable 1 (Integer 'RSN' 28) (Identifier 'RSN' 4) (#'(' 'RS' 5))
   (ReadaheadTable 2 (#'+' 'RS' 6) (#'-|' 'L' 25))
   (ReadaheadTable 3 (#'*' 'RS' 7) (#'+' 'L' 26) (#'-|' 'L' 26) (#';' 'L' 26) (#')' 'L' 26) (#',' 'L' 26))
   (ReadaheadTable 4 (#'(' 'RS' 8) (#'=' 'RS' 9) (#'+' 'L' 28) (#'*' 'L' 28) (#'-|' 'L' 28) (#';' 'L' 28) (#')' 'L' 28) (#',' 'L' 28))
   (ReadaheadTable 5 (Integer 'RSN' 28) (Identifier 'RSN' 11) (#'(' 'RS' 5))
   (ReadaheadTable 6 (Identifier 'RSN' 11) (#'(' 'RS' 5) (Integer 'RSN' 28))
   (ReadaheadTable 7 (Identifier 'RSN' 11) (#'(' 'RS' 5) (Integer 'RSN' 28))
   (ReadaheadTable 8 (#')' 'RS' 32) (Integer 'RSN' 28) (Identifier 'RSN' 11) (#'(' 'RS' 5))
   (ReadaheadTable 9 (Integer 'RSN' 28) (Identifier 'RSN' 11) (#'(' 'RS' 5))
   (ReadaheadTable 10 (#')' 'RS' 29) (#'+' 'RS' 6))
   (ReadaheadTable 11 (#'(' 'RS' 8) (#'+' 'L' 28) (#'*' 'L' 28) (#'-|' 'L' 28) (#';' 'L' 28) (#')' 'L' 28) (#',' 'L' 28))
   (ReadaheadTable 12 (#'*' 'RS' 7) (#'+' 'L' 30) (#'-|' 'L' 30) (#';' 'L' 30) (#')' 'L' 30) (#',' 'L' 30))
   (ReadaheadTable 13 (#'+' 'RS' 6) (#',' 'RS' 15) (#')' 'RS' 32))
   (ReadaheadTable 14 (#'+' 'RS' 6) (#';' 'RS' 16))
   (ReadaheadTable 15 (Integer 'RSN' 28) (Identifier 'RSN' 11) (#'(' 'RS' 5))
   (ReadaheadTable 16 (Identifier 'RSN' 18) (#'-|' 'L' 33))
   (ReadaheadTable 17 (#'+' 'RS' 6) (#',' 'RS' 15) (#')' 'RS' 32))
   (ReadaheadTable 18 (#'=' 'RS' 9))
   (ReadbackTable 19 ((#'(' 8) 'RS' 22) ((Expression 13) 'RSN' 34) ((Expression 17) 'RSN' 35))
   (ReadbackTable 20 ((Expression 10) 'RSN' 40) ((Expression 17) 'RSN' 40) ((Expression 2) 'RSN' 40) ((Expression 13) 'RSN' 40) ((Expression 14) 'RSN' 40))
   (ReadbackTable 21 ((Term 12) 'RSN' 41) ((Term 3) 'RSN' 41))
   (ReadbackTable 22 ((Identifier 4) 'RSN' 42) ((Identifier 11) 'RSN' 42))
   (ReadbackTable 23 ((Expression 13) 'RSN' 34) ((Expression 17) 'RSN' 35))
   (ReadbackTable 24 ((Identifier 4) 'RSN' 43) ((Identifier 18) 'RSN' 33))
   (ShiftbackTable 25 1 37)
   (ShiftbackTable 26 1 36)
   (ShiftbackTable 27 1 38)
   (ShiftbackTable 28 1 39)
   (ShiftbackTable 29 3 39)
   (ShiftbackTable 30 2 20)
   (ShiftbackTable 31 2 21)
   (ShiftbackTable 32 1 19)
   (ShiftbackTable 33 3 24)
   (ShiftbackTable 34 1 22)
   (ShiftbackTable 35 1 23)
   (ReduceTable 36 Expression (1 'RSN' 2)(5 'RSN' 10)(8 'RSN' 13)(9 'RSN' 14)(15 'RSN' 17))
   (ReduceTable 37 Grammar (1 'RSN' 44))
   (ReduceTable 38 Term (1 'RSN' 3)(5 'RSN' 3)(6 'RSN' 12)(8 'RSN' 3)(9 'RSN' 3)(15 'RSN' 3))
   (ReduceTable 39 Primary (1 'RSN' 27)(5 'RSN' 27)(6 'RSN' 27)(7 'RSN' 31)(8 'RSN' 27)(9 'RSN' 27)(15 'RSN' 27))
   (SemanticTable 40 buildTree: '+' 36)
   (SemanticTable 41 buildTree: '*' 38)
   (SemanticTable 42 buildTree: send 39)
   (SemanticTable 43 buildTree: '<-' 37)
   (AcceptTable 44))!   !

!SampleTranslator class methods !
rawScannerTables
    "Scanner rawScannerTables"

    "EndOfFileCharacter is 256"
    ^
#(
   (ScannerReadaheadTable 1 ((256) 'L' 5) (')' 'RK' 7) ('*' 'RK' 8) ('+' 'RK' 9) (',' 'RK' 10) ('0123456789' 'RK' 2) ('(' 'RK' 6) (';' 'RK' 12) ('=' 'RK' 13) ('ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz' 'RK' 3) ((9 10 12 13) 'R' 4) (' ' 'R' 4))
   (ScannerReadaheadTable 2 ((9 10 12 13 256) 'L' 11) ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_+*=[]{}()^;#:.$ ' 'L' 11) ('0123456789' 'RK' 2))
   (ScannerReadaheadTable 3 ((9 10 12 13 256) 'L' 14) ('+*=[]{}()^;#:.$ ' 'L' 14) ('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz' 'RK' 3))
   (ScannerReadaheadTable 4 ((256) 'L' 1) ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_0123456789+*=[]{}()^;#:.$' 'L' 1) ((9 10 12 13) 'R' 4) (' ' 'R' 4))
   (SemanticTable 5 buildToken: '-|' 1)
   (SemanticTable 6 buildToken: '(' 1)
   (SemanticTable 7 buildToken: ')' 1)
   (SemanticTable 8 buildToken: '*' 1)
   (SemanticTable 9 buildToken: '+' 1)
   (SemanticTable 10 buildToken: ',' 1)
   (SemanticTable 11 buildToken: Integer 1)
   (SemanticTable 12 buildToken: ';' 1)
   (SemanticTable 13 buildToken: '=' 1)
   (SemanticTable 14 buildToken: Identifier 1))! !
(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('raw tables' rawParserTables rawScannerTables )) !

(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('raw tables' rawParserTables rawScannerTables )) !



!SampleTranslator class methods !  
evaluateExample1
    "SampleTranslator evaluateExample1"
    ^SampleTranslator new evaluate: '1+ 2*3'!    !

!SampleTranslator class methods !
compileExample1
    "SampleTranslator compileExample1"
    ^SampleTranslator new compile: '1+ 2*3'!   !

!SampleTranslator class methods !
promptForCompilation
    "SampleTranslator promptForCompilation"
    ^SampleTranslator new 
        compile: (Prompter prompt: 'Expression to compile' default: '1+2*3')!    !

!SampleTranslator class methods !
promptForEvaluation
    "SampleTranslator promptForEvaluation"
    ^SampleTranslator new 
        evaluate: (Prompter prompt: 'Expression to evaluate' default: '1+2*3')!    !
(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('examples' evaluateExample1 promptForEvaluation compileExample1 promptForCompilation )) !

(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('examples' evaluateExample1 promptForEvaluation compileExample1 promptForCompilation )) !



!SampleTranslator methods !  
initialize
    parser := Parser 
        for: self 
        parserTables: self class rawParserTables 
        scannerTables: self class rawScannerTables.
    codeIfCompiler := WriteStream on: (String new: 1000).
    expressionsIfEvaluator := Dictionary new. "each key is a variable"
    compilationOperatorMap := Dictionary new
        at: #+ put: #compilePlus:;
        at: #- put: #compileMinus:;
        at: #* put: #compileMultiply:;
        at: #/ put: #compileDivide:;
        at: #'<-' put: #compileAssign:;
        at: #'Identifier' put: #compileIdentifier:;
        at: #'Integer' put: #compileInteger:;
        at: #'send' put: #compileFunctionCall:;
        at: #'where' put: #compileWhere:;
        yourself.
    evaluationOperatorMap := Dictionary new
        at: #+ put: #evaluatePlus:;
        at: #- put: #evaluateMinus:;
        at: #* put: #evaluateMultiply:;
        at: #/ put: #evaluateDivide:;
        at: #'<-' put: #evaluateAssign:;
        at: #'Identifier' put: #evaluateIdentifier:;
        at: #'Integer' put: #evaluateInteger:;
        at: #'send' put: #evaluateFunctionCall:;
        at: #'where' put: #evaluateWhere:;
        yourself!  !

"evaluate"   
(CodeFiler organizerFor: SampleTranslator) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('initializing' initialize )) !



!SampleTranslator methods !
parser: aParser
    parser := aParser! !

!SampleTranslator methods !  
tree
    ^tree!    !

!SampleTranslator methods !  
tree: aTree
    tree := aTree! !

!SampleTranslator methods !  
parser
    ^parser!    !
(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('get/set' parser: tree tree: parser )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('get/set' parser: tree tree: parser )) !



!SampleTranslator methods !
evaluate: text
    | result |
    "If no variables are set up, just return the expression; otherwise, a dictionary of variables."
    tree := parser parse: text.
    self halt: 'See tree returned by parser'.
    result := self evaluateExpressionFor: tree.
    self halt: 'See result and variable dictionary'.
    expressionsIfEvaluator size = 0 ifTrue: [^result] ifFalse: [^expressionsIfEvaluator]!   !

!SampleTranslator methods !  
evaluateExpressionFor: tree
    ^self perform: (evaluationOperatorMap at: tree label asSymbol) with: tree! !

!SampleTranslator methods !  
compileExpressionFor: tree
    self perform: (compilationOperatorMap at: tree label asSymbol) with: tree!  !

!SampleTranslator methods !  
compile: text
    tree := parser parse: text.
    self compileExpressionFor: tree.
    ^codeIfCompiler contents! !
(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compiling/evaluating' evaluate: compileExpressionFor: compile: evaluateExpressionFor: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compiling/evaluating' evaluate: compileExpressionFor: compile: evaluateExpressionFor: )) !



!SampleTranslator methods !  
generate: instruction
    codeIfCompiler cr; << instruction!   !

!SampleTranslator methods !  
generate: instruction with: operand
    codeIfCompiler cr; << instruction; << ' '; << operand! !
(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compilation support' generate: generate:with: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compilation support' generate: generate:with: )) !




!SampleTranslator methods !
compileAssign: tree
    1 to: tree children size by: 2 do: [:index |
            self compileExpressionFor: (tree child: index + 1).
            self generate: 'POP' with: (tree child: index) symbol]! !

!SampleTranslator methods !  
compileFunctionCall: tree
    tree children rest do: [:child | self compileExpressionFor: child]. 
    self generate: 'FUNCTION_CALL' with: (tree child: 1) symbol!   !

!SampleTranslator methods !  
compilePlus: tree
    self compileExpressionFor: (tree child: 1).
    self compileExpressionFor: (tree child: 2).
    self generate: 'ADD'.! !

!SampleTranslator methods !  
compileDivide: tree
    self compileExpressionFor: (tree child: 1).
    self compileExpressionFor: (tree child: 2).
    self generate: 'DIVIDE'.!    !

!SampleTranslator methods !  
compileWhere: tree
    "Not currently implementing where properly since ignoring other children."
    self halt: 'compile WHERE'.
    self compileExpressionFor: (tree child: 1).!   !

!SampleTranslator methods !  
compileMultiply: tree
    self compileExpressionFor: (tree child: 1).
    self compileExpressionFor: (tree child: 2).
    self generate: 'MULTIPLY'.!    !

!SampleTranslator methods !  
compileInteger: token
    self generate: 'PUSH' with: token symbol asInteger!  !

!SampleTranslator methods !  
compileIdentifier: token
    self generate: 'PUSH' with: token symbol! !

!SampleTranslator methods !  
compileMinus: tree
    self halt: 'compile MINUS'.!    !
(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compilation details' compileAssign: compileFunctionCall: compilePlus: compileDivide: compileWhere: compileMultiply: compileInteger: compileIdentifier: compileMinus: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compilation details' compileAssign: compileFunctionCall: compilePlus: compileDivide: compileWhere: compileMultiply: compileInteger: compileIdentifier: compileMinus: )) !



!SampleTranslator methods !
evaluatePlus: aTree
    ^(self evaluateExpressionFor: (aTree child: 1)) + (self evaluateExpressionFor: (aTree child: 2))!  !

!SampleTranslator methods !  
evaluateInteger: token
    ^token symbol asInteger!    !

!SampleTranslator methods !  
evaluateDivide: tree
    | expression1 expression2 |
    expression1 := self evaluateExpressionFor: (tree child: 1).
    expression2 := self evaluateExpressionFor: (tree child: 2).
    ^expression1 / expression2!    !

!SampleTranslator methods !  
evaluateWhere: tree
    "Evaluate all but the first expression to obtain the values for individual variables,
    then store them in expressionsIfEvaluator and finally evaluate the first expression."
    self halt: 'evaluate WHERE'! !

!SampleTranslator methods !  
evaluateMinus: tree
   self halt: 'evaluate MINUS'!    !

!SampleTranslator methods !  
evaluateAssign: token
    | expression |
    expression := self evaluateExpressionFor: (tree child: 2).
    expressionsIfEvaluator at: (tree child: 1) symbol put: expression!   !

!SampleTranslator methods !  
evaluateFunctionCall: tree
    | function parameters |
    function := (tree child: 1) label.
    parameters := tree children rest collect: [:child | self evaluateExpressionFor: child].  
    
    function = #tan ifTrue: [^parameters first tan] ifFalse: [
    function = #abs ifTrue: [^parameters first abs]].
    
    self halt: 'Function ', function printString, ' not yet handled'!    !

!SampleTranslator methods !  
evaluateIdentifier: token
    | identifier |
    identifier := token symbol.
    ^expressionsIfEvaluator at: identifier ifAbsent: [self halt: 'Identifier ', identifier printString, ' is not defined'].!    !

!SampleTranslator methods !  
evaluateMultiply: tree
    | expression1 expression2 |
    expression1 := self evaluateExpressionFor: (tree child: 1).
    expression2 := self evaluateExpressionFor: (tree child: 2).
    ^expression1 * expression2!  !
(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('evaluation details' evaluatePlus: evaluateInteger: evaluateDivide: evaluateWhere: evaluateMinus: evaluateAssign: evaluateFunctionCall: evaluateIdentifier: evaluateMultiply: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('evaluation details' evaluatePlus: evaluateInteger: evaluateDivide: evaluateWhere: evaluateMinus: evaluateAssign: evaluateFunctionCall: evaluateIdentifier: evaluateMultiply: )) !

CodeFiler setCommentFor: SampleTranslator to: ''!


"evaluate"  
Tree removeFromSystem!

"evaluate"  
CodeFiler removeOrganizerFor: #Tree!

"evaluate"
CodeFiler removeOrganizerFor: #'Tree class'!

"evaluate"
Screener removeFromSystem!

"evaluate"  
CodeFiler removeOrganizerFor: #Screener!

"evaluate"
CodeFiler removeOrganizerFor: #'Screener class'!

"evaluate"
Scanner removeFromSystem!

"evaluate"   
CodeFiler removeOrganizerFor: #Scanner!

"evaluate" 
CodeFiler removeOrganizerFor: #'Scanner class'!

"evaluate" 
Parser removeFromSystem!

"evaluate"
CodeFiler removeOrganizerFor: #Parser!

"evaluate"  
CodeFiler removeOrganizerFor: #'Parser class'!

"evaluate"  
Transducer removeFromSystem!

"evaluate"
CodeFiler removeOrganizerFor: #Transducer!

"evaluate"  
CodeFiler removeOrganizerFor: #'Transducer class'!

"evaluate"  
Token removeFromSystem!

"evaluate" 
CodeFiler removeOrganizerFor: #Token!

"evaluate"   
CodeFiler removeOrganizerFor: #'Token class'!

"evaluate"   
ScannerReadaheadTable removeFromSystem!

"evaluate" 
CodeFiler removeOrganizerFor: #ScannerReadaheadTable!

"evaluate"   
CodeFiler removeOrganizerFor: #'ScannerReadaheadTable class'!

"evaluate"   
ReduceTable removeFromSystem!

"evaluate"   
CodeFiler removeOrganizerFor: #ReduceTable!

"evaluate" 
CodeFiler removeOrganizerFor: #'ReduceTable class'!

"evaluate" 
ReadbackTable removeFromSystem!

"evaluate" 
CodeFiler removeOrganizerFor: #ReadbackTable!

"evaluate"   
CodeFiler removeOrganizerFor: #'ReadbackTable class'!

"evaluate"   
ReadaheadTable removeFromSystem!

"evaluate"
CodeFiler removeOrganizerFor: #ReadaheadTable!

"evaluate"  
CodeFiler removeOrganizerFor: #'ReadaheadTable class'!

"evaluate"  
TableWithTransitions removeFromSystem!

"evaluate"  
CodeFiler removeOrganizerFor: #TableWithTransitions!

"evaluate"
CodeFiler removeOrganizerFor: #'TableWithTransitions class'!

"evaluate"
ShiftbackTable removeFromSystem!

"evaluate"
CodeFiler removeOrganizerFor: #ShiftbackTable!

"evaluate"  
CodeFiler removeOrganizerFor: #'ShiftbackTable class'!

"evaluate"  
SemanticTable removeFromSystem!

"evaluate" 
CodeFiler removeOrganizerFor: #SemanticTable!

"evaluate"   
CodeFiler removeOrganizerFor: #'SemanticTable class'!

"evaluate"   
AcceptTable removeFromSystem!

"evaluate"   
CodeFiler removeOrganizerFor: #AcceptTable!

"evaluate" 
CodeFiler removeOrganizerFor: #'AcceptTable class'!

"evaluate" 
Table removeFromSystem!

"evaluate" 
CodeFiler removeOrganizerFor: #Table!

"evaluate"   
CodeFiler removeOrganizerFor: #'Table class'!

"define class"   

Object subclass: #Table
  instanceVariableNames: 
    ' transducer '
  classVariableNames: ''
  poolDictionaries: ''!

"define class" 

Object subclass: #Transducer
  instanceVariableNames: 
    ' sponsor tables '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"

Table subclass: #TableWithTransitions
  instanceVariableNames: 
    ' transitions '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"  

Table subclass: #AcceptTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

"define class"  

Object subclass: #Tree
  instanceVariableNames: 
    ' label children '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"  

TableWithTransitions subclass: #ScannerReadaheadTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

"define class" 

TableWithTransitions subclass: #ReadaheadTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

"define class"

TableWithTransitions subclass: #ReadbackTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

"define class" 

Transducer subclass: #Screener
  instanceVariableNames: 
    ' keywords '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"

Table subclass: #SemanticTable
  instanceVariableNames: 
    ' action parameters goto '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"  

Transducer subclass: #Parser
  instanceVariableNames: 
    ' scanner screener tokenStack tableNumberStack treeStack left right tableNumber newTree '
  classVariableNames: ''
  poolDictionaries: ''!

"define class" 

TableWithTransitions subclass: #ReduceTable
  instanceVariableNames: 
    ' nonterminal '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"

Transducer subclass: #Scanner
  instanceVariableNames: 
    ' input token keptCharacters '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"   

Object subclass: #Token
  instanceVariableNames: 
    ' label symbol '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"   

Table subclass: #ShiftbackTable
  instanceVariableNames: 
    ' shift goto '
  classVariableNames: ''
  poolDictionaries: ''!

"define class" 

Object subclass: #Table
  instanceVariableNames: 
    ' transducer '
  classVariableNames: ''
  poolDictionaries: ''!

"define class" 

Object subclass: #SampleTranslator
  instanceVariableNames: 
    ' parser tree codeIfCompiler expressionsIfEvaluator compilationOperatorMap evaluationOperatorMap '
  classVariableNames: ''
  poolDictionaries: ''!


!Table methods !  
transducer: aTransducer
    transducer := aTransducer! !

!Table methods ! 
transducer
    ^transducer!    !

"evaluate"   
(CodeFiler organizerFor: Table) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Table) reorganizeFrom: #(
('get/set' transducer: transducer )) !

(CodeFiler organizerFor: Table) reorganizeFrom: #(
('get/set' transducer: transducer )) !
CodeFiler setCommentFor: Table to: ''!



!AcceptTable methods !
table: aTable
    "Do nothing."!   !

"evaluate"   
(CodeFiler organizerFor: AcceptTable) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: AcceptTable) reorganizeFrom: #(
('get/set' table: )) !

(CodeFiler organizerFor: AcceptTable) reorganizeFrom: #(
('get/set' table: )) !



!AcceptTable methods !  
run
    ^nil "Ensure that parsing does not continue..."!   !
(CodeFiler organizerFor: AcceptTable) reorganizeFrom: #(
('running' run )) !

(CodeFiler organizerFor: AcceptTable) reorganizeFrom: #(
('running' run )) !
CodeFiler setCommentFor: AcceptTable to: ''!



!Tree class methods !  
fromOldStyleArray: anObject
    "This assumes the array encode the tree in LISP notation; e.g. (root child1 child2 child3 ...)."
    (anObject isKindOf: Array) ifTrue: [^Tree new label: anObject first; children: (anObject rest collect: [:object | self fromArray: object])].
    (anObject isKindOf: Number) ifTrue: [^Token new label: #Integer; symbol: anObject printString].
    (anObject isKindOf: Character) ifTrue: [^Token new label: #Character; symbol: (String with: anObject)].
    (anObject isKindOf: Symbol) ifTrue: [^Token new label: #Identifier; symbol: anObject]. "or Symbol"
    (anObject isKindOf: String) ifTrue: [^Token new label: #SingleQuotedString; symbol: anObject].
    
    "We can't distinguish a symbol from an identifier because all identifiers become symbols in array literals."
    "We can't distinguish a SingleQuotedString from a DoubleQuotedString because all strings are single quoted in Smalltalk"
    
    ^self halt: 'Tree fromArray: did not expects the objects ', anObject printString!    !

!Tree class methods !
new

    ^super new initialize!   !

!Tree class methods !
fromArray: anObject
    "This assumes the array encode the tree in LISP notation; e.g. (root child1 child2 child3 ...)."
    (anObject isKindOf: Array) ifTrue: [^Tree new label: anObject first; children: (anObject rest collect: [:object | self fromArray: object])].
    (anObject isKindOf: Integer) ifTrue: [^Token new label: #walkInteger; symbol: anObject printString].
    (anObject isKindOf: Character) ifTrue: [^Token new label: #walkCharacter; symbol: (String with: anObject)].
    (anObject isKindOf: Symbol) ifTrue: [^Token new label: #walkIdentifier; symbol: anObject]. "or Symbol"
    (anObject isKindOf: String) ifTrue: [^Token new label: #walkString; symbol: anObject].
    
    "We can't distinguish a symbol from an identifier because all identifiers become symbols in array literals."
    ^self halt: 'Tree fromArray: did not expects the object ', anObject printString!    !

"evaluate"   
(CodeFiler organizerFor: Tree class) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Tree class) reorganizeFrom: #(
('instance creation' fromOldStyleArray: new fromArray: )) !

(CodeFiler organizerFor: Tree class) reorganizeFrom: #(
('instance creation' fromOldStyleArray: new fromArray: )) !



!Tree methods !  
initialize
    children := OrderedCollection new.! !

"evaluate"   
(CodeFiler organizerFor: Tree) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('initializing' initialize )) !



!Tree methods !
children
    ^children!    !

!Tree methods !  
label: aSymbol
    label := aSymbol!   !

!Tree methods !  
label
    ^label!  !

!Tree methods !  
child: index
    ^children at: index!  !

!Tree methods !  
children: aCollection
    children := aCollection! !
(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('get/set' children label: label child: children: )) !

(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('get/set' children label: label child: children: )) !



!Tree methods !  
addChild: aTree
    children add: aTree!   !
(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('modifying' addChild: )) !

(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('modifying' addChild: )) !



!Tree methods !
printOn: aStream
    self printOn: aStream tabs: 0.!   !

!Tree methods !  
printOn: aStream tabs: tabs
    aStream cr.
    tabs timesRepeat: [aStream << '   '].
    aStream << self label.
    children do: [:child | child printOn: aStream tabs: tabs + 1]! !
(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('printing' printOn: printOn:tabs: )) !

(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('printing' printOn: printOn:tabs: )) !
CodeFiler setCommentFor: Tree to: ''!



!ScannerReadaheadTable methods !
table: anArray
    "Record the triples: an integer or character collection, attributes, and goto. The integers
    are unprintable characters or the end of file integer 256, the attributes are $R for read 
    ($L for stack) and $K for keep. It's particularly important here to store the data so that
    given a character or 256, you can perform a fast lookup to find the triple."
    
    transitions := Dictionary new.
    anArray do: [:triple |
        triple first do: [:characterOrInteger | transitions at: characterOrInteger asInteger put: triple rest]]
        
    "OLD WAY:
    anArray groupsDo: [:item :attributes :goto |
        item isString 
                ifTrue: [item do: [:character | transitions at: character asInteger put: (Array with: attributes with: goto)]]
                ifFalse: [item do: [:integer | transitions at: integer put: (Array with: attributes with: goto)]]]
    "! !

"evaluate"   
(CodeFiler organizerFor: ScannerReadaheadTable) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: ScannerReadaheadTable) reorganizeFrom: #(
('get/set' table: )) !

(CodeFiler organizerFor: ScannerReadaheadTable) reorganizeFrom: #(
('get/set' table: )) !



!ScannerReadaheadTable methods !  
printables
    "The last three printable characters are single quote (represented as two single quotest in a row; i.e. ''),
    double quote (represented as one double quote; the end of comment is a double quote), and a space.
    Note: that it's hard to see the difference between two single quotes and one double quote."
    
    ^'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!!,+-/\*~=@%&?|<>[]{}()^;#:.$_''" '.!  !

!ScannerReadaheadTable methods ! 
run
    | character isKeep isRead pair |

    "Consider the next input character or integer (it could be 256 for endOfFile).
    Search the transitions for the triple that matches it. Remember: the original
    data was triples: an integer or character collection, attributes, and goto. But
    for fast lookup, you want to just be able to look up the triple using the next
    input as a key... When you find it, the read attribute ($R as opposed to $L)
    indicates that you need to remove it from the input. Otherwise, it stays for future 
    use. If it has the keep attribute ($K), you need to append the character to
    'keptCharacters'. If you can't find it, it a lexical error (see reportLexicalError).
    When you are done, return the goto table."
    
    character := transducer peekInput.
    pair := transitions at: character asInteger ifAbsent: [nil].
    pair notNil ifTrue: [
        pair groupDo: [:attributes :goto |
            isRead := attributes includes: $R.
            isKeep := attributes includes: $K.
            isRead ifFalse: [^goto].
            isKeep ifTrue: [transducer keptCharacters: (transducer keptCharacters, character asString)].
            transducer discardInput.
            ^goto]].
            
    self reportLexicalError!   !

!ScannerReadaheadTable methods ! 
reportLexicalError
    | characterAsInteger character printables |

    characterAsInteger := transducer peekInput.
    characterAsInteger = 256 ifTrue: [self error: 'Lexical error: End of the file encountered unexpectedly'].
    character := characterAsInteger asCharacter.
    
    (self printables includes: character) 
        ifTrue: [self error: 'Lexical error, encountered unexpected character ', character asString]
        ifFalse: [
            self error: 'Lexical error, encountered unexpected unprintable character',
                ' hex ', (character asNumber printStringRadix: 16),
                ' decimal ', character asNumber printString]! !
(CodeFiler organizerFor: ScannerReadaheadTable) reorganizeFrom: #(
('running' printables run reportLexicalError )) !

(CodeFiler organizerFor: ScannerReadaheadTable) reorganizeFrom: #(
('running' printables run reportLexicalError )) !
CodeFiler setCommentFor: ScannerReadaheadTable to: ''!



"evaluate"   
(CodeFiler organizerFor: ReadaheadTable) removeCategory: 'no category methods' ifAbsent: [nil]!


!ReadaheadTable methods !
reportSyntaxError
    | token inputTokens inputText position |
            
    token := transducer peekScannerToken.
    inputTokens := transducer tokenStack rest. "Skip start stack information."
    
    Transcript cr; << 'Syntax error...'. 
    inputTokens isEmpty 
        ifTrue: [Transcript cr; << 'Did not expect input to start with '. Transcript << token]
        ifFalse: [
            Transcript cr; << 'DID NOT EXPECT'; << (inputTokens size > 6 ifTrue: [' ...'] ifFalse: ['']).
            inputTokens := inputTokens suffix: 6.
            inputTokens do: [:token | Transcript << ' '; << token].
            Transcript cr; << 'TO BE FOLLOWED BY '; << token.
            inputText := transducer scanner input collection. position := transducer scanner input position.
            Transcript << (inputText copyFrom: (position + 1 max: 1) to: (position + 100 min: inputText size))].
    self error: ('Syntax error: Illegal symbol: ', token label)! !

!ReadaheadTable methods !
run
    | token tokenLabel transition isRead isNode isStack |

    "Peek at the next token label..."
    tokenLabel := (token := transducer peekScannerToken) label asSymbol.

    "and then use the transition that matches it if there is one. Use the attributes to determine
    what to do. If there isn't one, it's a syntax error. Remember $R means read ($L look), $N
    means make the token part of a tree, and $S means stack. If we stack, we also need 'right'
    to refer to the last entry and 'left' to be one more to the right. Finally, returns the corresponding
    goto state."

    transition := transitions at: tokenLabel ifAbsent: [^self reportSyntaxError].
    transition groupDo: [:attributes :goto |
        isRead := attributes includes: $R.
        isNode := attributes includes: $N.
        isStack := attributes includes: $S.
        isRead ifFalse: [^goto].
        transducer discardScannerToken.
        isStack ifTrue: [
            transducer tokenStack add: token.
            transducer tableNumberStack add: goto.
            transducer treeStack add: (isNode ifTrue: [token] ifFalse: [nil]).
            transducer right: transducer tokenStack size.
            transducer left: transducer right + 1].
        ^goto].!   !
(CodeFiler organizerFor: ReadaheadTable) reorganizeFrom: #(
('running' reportSyntaxError run )) !

(CodeFiler organizerFor: ReadaheadTable) reorganizeFrom: #(
('running' reportSyntaxError run )) !



!ReadaheadTable methods !  
runUNUSEDVersionThatSearches
    | token tokenLabel isRead isNode isStack |

    "Peek at the next token label..."
    tokenLabel := (token := transducer peekScannerToken) label asSymbol.

    "and then search for a transition that matches it. When found, use the attributes to determine
    what to do. If you don't find it, it's a syntax error. Remember $R means read ($L look), $N
    means make the token part of a tree, and $S means stack. If we stack, we also need 'right'
    to refer to the last entry and 'left' to be one more to the right. Finally, returns the corresponding
    goto state."

    transitions groupsDo: [:symbol :attributes :goto |
        tokenLabel == symbol ifTrue: [
            isRead := attributes includes: $R.
            isNode := attributes includes: $N.
            isStack := attributes includes: $S.
            isRead ifFalse: [^goto].
            transducer discardScannerToken.
            isStack ifTrue: [
                transducer tokenStack add: token.
                transducer tableNumberStack add: goto.
                transducer treeStack add: (isNode ifTrue: [token] ifFalse: [nil]).
                transducer right: transducer tokenStack size.
                transducer left: transducer right + 1].
            ^goto]].

    self reportSyntaxError!    !

!ReadaheadTable methods !
tableUNUSEDVersionThatSearches: anArray
    "Record the data unmodified so you can later perform a fast search."
    transitions := anArray!  !
(CodeFiler organizerFor: ReadaheadTable) reorganizeFrom: #(
('unused' runUNUSEDVersionThatSearches tableUNUSEDVersionThatSearches: )) !

(CodeFiler organizerFor: ReadaheadTable) reorganizeFrom: #(
('unused' runUNUSEDVersionThatSearches tableUNUSEDVersionThatSearches: )) !
CodeFiler setCommentFor: ReadaheadTable to: ''!



!TableWithTransitions methods !   
table: anArray
    "Record the data so you can later perform a fast lookup."
    transitions := Dictionary new.
    anArray do: [:triple | transitions at: triple first put: triple rest]!   !

"evaluate"   
(CodeFiler organizerFor: TableWithTransitions) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: TableWithTransitions) reorganizeFrom: #(
('get/set' table: )) !

(CodeFiler organizerFor: TableWithTransitions) reorganizeFrom: #(
('get/set' table: )) !
CodeFiler setCommentFor: TableWithTransitions to: ''!



"evaluate"
(CodeFiler organizerFor: ReadbackTable) removeCategory: 'no category methods' ifAbsent: [nil]!


!ReadbackTable methods !  
run
    | pair transition isRead |
    "Readback considers the token label in the token stack and the state number in the table number at position 'left - 1'
    and then uses the transition that matches it. If there isn't one it's a design error. Otherwise, it then uses the attribute $R for read, $L for look to
    decide what to do. If it's read, it decrements 'left'. Finally it returns the goto state."

    pair := Array with: (transducer tokenStack at: transducer left - 1) label with: (transducer tableNumberStack at: transducer left - 1).
    transition := transitions at: pair ifAbsent: [^self reportDesignError].
    transition groupDo: [:attributes :goto |
        isRead := attributes  includes: $R.
        isRead ifTrue: [transducer left: transducer left - 1].
        ^goto].!    !

!ReadbackTable methods ! 
reportDesignError
    self error: 'Design error: reached end of ReadbackTable without having found a suitable transition'! !
(CodeFiler organizerFor: ReadbackTable) reorganizeFrom: #(
('running' run reportDesignError )) !

(CodeFiler organizerFor: ReadbackTable) reorganizeFrom: #(
('running' run reportDesignError )) !



!ReadbackTable methods ! 
tableUNUSEDVersionThatSearches: anArray
    "Store the data, old state number/symbol/new state number triples for search in run."
    | pair |
    transitions := anArray collect: [:triple |
        pair := triple first.
        Array with: (Array with: pair first asSymbol with: pair second) with: triple second with: triple third]!   !

!ReadbackTable methods ! 
runUNUSEDVersionThatSearches
    | pair isRead |
    "Readback considers the token label in the token stack and the state number in the table number at position 'left - 1'
    and then finds the transition that matches it. When it finds it, it then uses the attribute $R for read, $L for look to
    decide what to do. If it's read, it decrements 'left'. Finally it returns the goto state."
    
    pair := Array with: (transducer tokenStack at: transducer left - 1) label with: (transducer tableNumberStack at: transducer left - 1).
    transitions groupsDo: [:nextPair :attributes :goto |
        pair = nextPair ifTrue:[
            isRead := attributes  includes: $R.
            isRead ifTrue: [transducer left: transducer left - 1].
            ^goto]].
    self reportDesignError!    !
(CodeFiler organizerFor: ReadbackTable) reorganizeFrom: #(
('unused' tableUNUSEDVersionThatSearches: runUNUSEDVersionThatSearches )) !

(CodeFiler organizerFor: ReadbackTable) reorganizeFrom: #(
('unused' tableUNUSEDVersionThatSearches: runUNUSEDVersionThatSearches )) !
CodeFiler setCommentFor: ReadbackTable to: ''!



"evaluate"   
(CodeFiler organizerFor: Screener class) removeCategory: 'no category methods' ifAbsent: [nil]!


!Screener methods !  
keywords
    ^keywords!    !

!Screener methods !  
keywords: aCollection
    keywords := aCollection! !

"evaluate"   
(CodeFiler organizerFor: Screener) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Screener) reorganizeFrom: #(
('get/set' keywords keywords: )) !

(CodeFiler organizerFor: Screener) reorganizeFrom: #(
('get/set' keywords keywords: )) !



!Screener methods !  
screen: aToken
    "Older name is #Identifier, newer name is #walkIdentifier:"
    (aToken label = #Identifier) | (aToken label = #walkIdentifier:) ifFalse: [^aToken]. 
    (self keywords includes: aToken symbol) ifFalse: [^aToken].
    ^Token new label: aToken symbol; symbol: aToken symbol.!   !
(CodeFiler organizerFor: Screener) reorganizeFrom: #(
('screening' screen: )) !

(CodeFiler organizerFor: Screener) reorganizeFrom: #(
('screening' screen: )) !
CodeFiler setCommentFor: Screener to: ''!



!SemanticTable methods !
table: aTable
    action := aTable first.
    parameters := aTable copyFrom: 2 to: aTable size - 1.
    goto := aTable last! !

!SemanticTable methods ! 
action: aSymbol
    action := aSymbol! !

!SemanticTable methods ! 
parameters
    ^parameters!    !

!SemanticTable methods ! 
goto
    ^goto!    !

!SemanticTable methods ! 
parameters: aCollection
    parameters := aCollection! !

!SemanticTable methods ! 
goto: aNumber
    goto := aNumber! !

!SemanticTable methods ! 
action
    ^action!    !

"evaluate"   
(CodeFiler organizerFor: SemanticTable) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: SemanticTable) reorganizeFrom: #(
('get/set' table: action: parameters goto parameters: goto: action )) !

(CodeFiler organizerFor: SemanticTable) reorganizeFrom: #(
('get/set' table: action: parameters goto parameters: goto: action )) !



!SemanticTable methods !
run
    | recipient |
    recipient := (transducer class canUnderstand: action) ifTrue: [transducer] ifFalse: [transducer sponsor].
    recipient perform: action withArguments: parameters.
    ^goto! !
(CodeFiler organizerFor: SemanticTable) reorganizeFrom: #(
('running' run )) !

(CodeFiler organizerFor: SemanticTable) reorganizeFrom: #(
('running' run )) !
CodeFiler setCommentFor: SemanticTable to: ''!



!Parser class methods !  
for: aSponsor parserTables: parserTables scannerTables: scannerTables
    | parser |
    parser := self new.
    
    "Set up the user (or sponsor) of the scanner and parser."
    parser sponsor: aSponsor. parser scanner sponsor: aSponsor.
    
    "Give the keywords to the screener and the remaining tables to the parser..."
    parser tables: parserTables rest; screener: (Screener new keywords: parserTables first rest).
    
    "Give the entire set of scanner tables to the scanner..."
    parser scanner tables: scannerTables.
    
    ^parser!    !

"evaluate"   
(CodeFiler organizerFor: Parser class) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Parser class) reorganizeFrom: #(
('instance creation' for:parserTables:scannerTables: )) !

(CodeFiler organizerFor: Parser class) reorganizeFrom: #(
('instance creation' for:parserTables:scannerTables: )) !



!Parser methods !  
initialize
    scanner := Scanner new. screener := Screener new.
    tokenStack := OrderedCollection new add: (Token new label: #'|-'; symbol: #'|-'); yourself.
    treeStack := OrderedCollection new add: nil; yourself.
    tableNumberStack := OrderedCollection new add: 1; yourself.
    left := 1. right := 1.!    !

"evaluate"   
(CodeFiler organizerFor: Parser) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('initializing' initialize )) !



!Parser methods !
screener: aScreener
    screener := aScreener! !

!Parser methods !
screener
    ^screener!    !

!Parser methods !
right
    ^right!  !

!Parser methods !
tokenStack: aCollection
    tokenStack := aCollection! !

!Parser methods !
treeStack
    ^treeStack!  !

!Parser methods !
left: aNumber
    left := aNumber! !

!Parser methods !
tableNumberStack: aCollection
    tableNumberStack := aCollection! !

!Parser methods !
tokenStack
    ^tokenStack!    !

!Parser methods !
tableNumberStack
    ^tableNumberStack!    !

!Parser methods !
tables: aCollection
    "Store the collection of all table objects in tables. Moreover, each type of table will store it's data
    in its own way. So, you had better let the object store it. Note: The collection contains the NAMES for the types
    of table objects, they are not table objects. Also, whoever sent this message had better not have 
    included an entry for a keyword list since that was supposed to have been given to the screener.
    IN OTHER WORDS: Create the appropriate kind of table object, give the table data to that object, and 
    then store that object in the parser's tables."
    
    "HINT: 'Smalltalk at: x' where x is a variable containing the symbol #Apple returns the class object called
    Apple. Once you have a class object, you can say new to it."
    
    tables := aCollection collect:[ :element |     
        "Each table is of the form (tableType tableNumber ...)."
        "Get the class name for the type, then make a new instance, then give it the table and tell it that I'm it's transducer."
        (Smalltalk at: element first) new table: (element copyFrom: 3); transducer: self ].!    !

!Parser methods !
newTree
    ^newTree!  !

!Parser methods !
scanner
    ^scanner!  !

!Parser methods !
right: aNumber
    right := aNumber!   !

!Parser methods !
treeStack: aCollection
    treeStack := aCollection!   !

!Parser methods !
tables
    ^tables!    !

!Parser methods !
left
    ^left!    !

!Parser methods !
newTree: aTree
    newTree := aTree!   !

!Parser methods !
scanner: aScanner
    scanner := aScanner! !
(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('get/set' screener: tokenStack: screener tables: treeStack left: tokenStack tableNumberStack: tableNumberStack right newTree scanner right: treeStack: tables left newTree: scanner: )) !

(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('get/set' screener: tokenStack: screener tables: treeStack left: tokenStack tableNumberStack: tableNumberStack right newTree scanner right: treeStack: tables left newTree: scanner: )) !



!Parser methods !
parse: text
    "To parse the text, you have to give it to the scanner (say via scan: text).
    It in turn should have the first token set up for you. Next you need
    to execute tables starting from table 1 until you reach an Accept table.
    Once that happen, the tree that was built should be on top of the tree
    stack. Just return it. If you look at the Accept table, you will see
    that it of all the tables, it is the only one that returns nil. You can
    use that information to stop your loop."
    | table |
    
    scanner scan: text.
    tableNumber := 1. table := tables at: tableNumber.
    [table class = AcceptTable ] whileFalse: [
        self log. "<---for debugging. You might want to comment this out for now"
        tableNumber := table run.
        table := tables at: tableNumber.].
    ^treeStack last!    !
(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('parsing' parse: )) !

(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('parsing' parse: )) !



!Parser methods !
discardScannerToken
    scanner discardToken.! !

!Parser methods !
peekScannerToken
    ^screener screen: scanner peekToken.! !
(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('streaming' discardScannerToken peekScannerToken )) !

(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('streaming' discardScannerToken peekScannerToken )) !



!Parser methods !
buildTreeFromIndex: index
    "Index is positive (1, 2, 3, ...) => label is in the token relative to the left end; i.e., to the right of left end."
    "index is negative (-1, -2, -3...) => label is in the token relative to the right end; i.e., to the left of right end."
    | children |    
    children := (left to: right) collect: [:index | treeStack at: index] when: [:index | (treeStack at: index) notNil].
    newTree := Tree new 
        label:  (index isPositive ifTrue: [tokenStack at: left + index - 1] ifFalse: [tokenStack at: right + index + 1]) symbol
        children: children.!   !

!Parser methods !
buildTree: rootNode
    "Pick up the children from the tree stack between left and     right inclusive (provided they're not nil) and 
    build a tree with the given label. Store it in instance variable newTree so a reduce table can use it."
    
    | children |
    children := (left to: right) collect: [:index | treeStack at: index] when: [:index | (treeStack at: index) notNil].
    newTree := Tree new label: rootNode; children: children.!    !
(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('semanticActions' buildTreeFromIndex: buildTree: )) !

(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('semanticActions' buildTreeFromIndex: buildTree: )) !



!Parser methods !
log
    | table useTerseTree whichCharacterToStartLogging |
    true ifTrue: [^self]. "currently disabled"
    whichCharacterToStartLogging := 4040.
    scanner input position < whichCharacterToStartLogging ifTrue: [^self].
    useTerseTree := true. "Set to false if more details are wanted..."
    table := tables at: tableNumber.

    "Log a preliminary heading..."
    Transcript cr; << 'At '; << scanner input position; << self peekScannerToken; << ' | left '; << left; << ' right '; << right; << ' |'; << ' Table '; << tableNumber; space; << table.

    "Log state specific information..."
    table class = ReadaheadTable ifTrue: [Transcript << ' SEARCHING FOR '; << self peekScannerToken label].
    table class = ReadbackTable ifTrue: [Transcript << ' SEARCHING FOR ';
        << '['; << (tokenStack at: left - 1) label; << ' '; << (tableNumberStack at: left - 1); << ']'].
    table class = ReduceTable ifTrue: [Transcript space; << table nonterminal; << ' SEARCHING FOR ';
        << (tableNumberStack at: left - 1)].
    table class = ShiftbackTable ifTrue: [Transcript << ' SHIFT '; << table shift; << ' GOTO '; << table goto].
    (table class = SemanticTable) ifTrue: [
        Transcript space; << table action. table parameters do: [:parameter | Transcript space; << parameter].
        Transcript << ' GOTO '; << table goto].

    "Log information in the stacks..."
    self treeStack indexedDo: [:index :tree |
        (index = left and: [left <= right]) ifTrue: [Transcript cr; << '       ---------------------------'].
        Transcript cr; << '       '; << index; << ' ['; << (self tokenStack at: index); << ' '; << (self tableNumberStack at: index); << '] '.
        tree isNil ifFalse:[useTerseTree ifTrue: [Transcript << ' Tree ('; << tree label; << ' ...)'] ifFalse: [tree printOn: Transcript tabs: 3]].
        (index = right and: [left > right]) ifTrue: [Transcript cr; << '       ---------------------------'].
        index = right ifTrue: [Transcript cr; << '       ---------------------------'].].!  !
(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('debugging' log )) !

(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('debugging' log )) !
CodeFiler setCommentFor: Parser to: ''!



!ReduceTable methods !
nonterminal: aSymbol
    nonterminal := aSymbol!   !

!ReduceTable methods !   
nonterminal
    ^nonterminal!  !

!ReduceTable methods !   
table: anArray
    "Store the data; namely a nonterminal and a bunch of transition information; triples
    with a 'from table numer', attributes, and a 'to table number'."
    nonterminal := anArray first.
    super table: anArray rest!   !

"evaluate"   
(CodeFiler organizerFor: ReduceTable) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: ReduceTable) reorganizeFrom: #(
('get/set' nonterminal: nonterminal table: )) !

(CodeFiler organizerFor: ReduceTable) reorganizeFrom: #(
('get/set' nonterminal: nonterminal table: )) !



!ReduceTable methods !
run
    "This is a 'Reduce to A' table where A is the nonterminal to reduce to. Pick up the new tree
    and simulate a readahead of A where the new tree is associated with A"

    | transition children tree tableNumber isStack isNode  |
    "Pick up the new tree if there is one OR bubble up the one tree in the stack between
    'left' and 'right' or nil if there isn't one. There better not be 2 or more."
    transducer newTree notNil
        ifTrue: [
            tree := transducer newTree. transducer newTree: nil]
        ifFalse: [
            "Just capture the one subtree (if any) and have it ready for stacking."
            children := (transducer treeStack copyFrom: transducer left to: transducer right) withoutNils.
            children size = 0 ifTrue: [tree := nil] ifFalse: [
            children size = 1 ifTrue: [tree := children first] ifFalse: [
            self halt: 'Design error: more than 1 child in ReduceTable'. tree := children last]]].

    "Clear the stacks between left and right (inclusive)."
    (transducer left to: transducer right) do: [:index |
        transducer tokenStack removeLast.
        transducer tableNumberStack removeLast.
        transducer treeStack removeLast].

    "Use the top table number on the stack (the 'from table number') to locate the pair (attributes, 'to table number);
    it's a design error if you can't find it. The other table number is to be returned when you're done. Also use the
    attributes in the same manner as you did for a readahead table but this time, instead of using the next token,
    use a new token you create using the nonterminal as it's symbol. Don't forget to adjust 'right' and 'left' like you
    did for the readahead table."

    tableNumber := transducer tableNumberStack last.
    transition := transitions at: tableNumber ifAbsent: [^self reportDesignError].
    transition groupDo: [:attributes :goto |
        isStack := attributes includes: $S. isNode := attributes includes: $N.
        isStack ifTrue: [
            transducer tokenStack add: (Token new label: nonterminal; symbol: nonterminal).
            transducer tableNumberStack add: goto.
            transducer treeStack add: (isNode ifTrue: [tree] ifFalse: [nil])].
        transducer right: transducer treeStack size.
        transducer left: transducer right + 1.
        ^goto].!   !

!ReduceTable methods !   
reportDesignError
    self error: 'Design error: reached end of ReduceTable without having found a suitable transition'!   !
(CodeFiler organizerFor: ReduceTable) reorganizeFrom: #(
('running' run reportDesignError )) !

(CodeFiler organizerFor: ReduceTable) reorganizeFrom: #(
('running' run reportDesignError )) !



!ReduceTable methods !   
runUNUSEDVersionThatSearches
    "This is a 'Reduce to A' table where A is the nonterminal to reduce to. Pick up the new tree
    and simulate a readahead of A where the new tree is associated with A"

    | stack children tree tableNumber isStack isNode token |
    "Pick up the new tree if there is one OR bubble up the one tree in the stack between
    'left' and 'right' or nil if there isn't one. There better not be 2 or more."
    transducer newTree notNil
        ifTrue: [
            tree := transducer newTree. transducer newTree: nil]
        ifFalse: [
            "Just capture the one subtree (if any) and have it ready for stacking."
            children := (transducer treeStack copyFrom: transducer left to: transducer right) withoutNils.
            children size = 0 ifTrue: [tree := nil] ifFalse: [
            children size = 1 ifTrue: [tree := children first] ifFalse: [
            self halt: 'Design error: more than 1 child in ReduceTable'. tree := children last]]].

    "Clear the stacks between left and right (inclusive)."
    (transducer left to: transducer right) do: [:index |
        transducer tokenStack removeLast.
        transducer tableNumberStack removeLast.
        transducer treeStack removeLast].

    "Using the top table number on the stack, search the triples ('from table number, attributes,
    'to table number) and find the one that matches 'from table number'; it's a design error if you can't
    find it. The other table number is to be returned when you're done. Also use the attributes in the
    same manner as you did for a readahead table but this time, instead of using the next token,
    use a new token you create using the nonterminal as it's symbol. Don't forget to adjust
    'right' and 'left' like you did for the readahead table."

    tableNumber := transducer tableNumberStack last.
    transitions groupsDo: [:candidateTableNumber :attributes :goto |
        tableNumber = candidateTableNumber ifTrue: [
            isStack := attributes includes: $S. isNode := attributes includes: $N.
            isStack ifTrue: [
                transducer tokenStack add: (Token new label: nonterminal; symbol: nonterminal).
                transducer tableNumberStack add: goto.
                transducer treeStack add: (isNode ifTrue: [tree] ifFalse: [nil])].
            transducer right: transducer treeStack size.
            transducer left: transducer right + 1.
            ^goto]].

    self reportDesignError! !

!ReduceTable methods !   
tableUNUSEDVersionThatSearches: anArray
    "Store the data; namely a nonterminal and a bunch of transition information; triples
    with a 'from table numer', attributes, and a 'to table number'."
    nonterminal := anArray first.
    super table: anArray rest!  !
(CodeFiler organizerFor: ReduceTable) reorganizeFrom: #(
('unused' runUNUSEDVersionThatSearches tableUNUSEDVersionThatSearches: )) !

(CodeFiler organizerFor: ReduceTable) reorganizeFrom: #(
('unused' runUNUSEDVersionThatSearches tableUNUSEDVersionThatSearches: )) !
CodeFiler setCommentFor: ReduceTable to: ''!



!Scanner methods ! 
initialize
    token := nil.
    keptCharacters := ''.!   !

"evaluate"   
(CodeFiler organizerFor: Scanner) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('initializing' initialize )) !



!Scanner methods !
tables
    ^tables!    !

!Scanner methods !   
tables: aCollection
    "Store the collection of all table objects in tables. Moreover, each type of table will store it's data
    in its own way. So, you had better let the object store it. Note: The Collection contains the NAMES of the 
    types of table objects, they are not table objects. IN OTHER WORDS: Create the appropriate kind of table
    object, give the table data to that object, and then store that object in the scanner's tables."
    
    "HINT: 'Smalltalk at: x' where x is a variable containing the symbol #Apple returns the class object called
    Apple. Once you have a class object, you can say new to it."
    
    tables := aCollection collect: [:element | 
        "Each table is of the form (tableType tableNumber ...)."
        "Get the class name for the type, then make a new instance, then give it the table and tell it that I'm it's transducer."
        (Smalltalk at: element first) new table: (element copyFrom: 3); transducer: self]!  !

!Scanner methods !   
keptCharacters
    ^keptCharacters!    !

!Scanner methods !   
keptCharacters: aString
    keptCharacters := aString! !

!Scanner methods !   
input: aStream
    input := aStream!   !

!Scanner methods !   
input
    ^input!  !
(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('get/set' tables tables: keptCharacters keptCharacters: input: input )) !

(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('get/set' tables tables: keptCharacters keptCharacters: input: input )) !



!Scanner methods ! 
scan: text
    self input: (ReadStream on: text).
    self discardToken!  !
(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('scanning' scan: )) !

(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('scanning' scan: )) !



!Scanner methods ! 
peekInput
    ^input atEnd ifTrue:[256] ifFalse:[input peek]!  !

!Scanner methods !   
peekToken
    ^token!  !

!Scanner methods !   
discardToken
    "To discard the current token, set token to nil and execute the tables
    in a loop starting with table 1 until token is no longer nil. Then return 
    nothing. Somewhere during this execution, the semantic action buildToken:
    will execute putting something into variable 'token'."
    
    | tableNumber table |
    tableNumber := 1. token := nil.
    [token isNil] whileTrue: [
        table := tables at: tableNumber.
        tableNumber := table run].
    ^nil "We now have a token"!    !

!Scanner methods !   
discardInput
    ^input next!  !
(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('streaming' peekInput discardToken discardInput peekToken )) !

(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('streaming' peekInput discardToken discardInput peekToken )) !



!Scanner methods !   
buildToken: label
    "Create a token with the supplied label and the characters in keptCharacters
    and put the result in token so peek can return it when requested.
    Reset keptCharacters to an empty string so the process can repeat."
    
    token := Token new label: label asSymbol; symbol: keptCharacters asSymbol.
    keptCharacters := ''.!   !
(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('semantic actions' buildToken: )) !

(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('semantic actions' buildToken: )) !
CodeFiler setCommentFor: Scanner to: ''!



!Token methods ! 
label: aLabel
    label := aLabel! !

!Token methods ! 
label
    ^label!  !

!Token methods ! 
symbol
    ^symbol!    !

!Token methods ! 
symbol: aSymbol
    symbol := aSymbol! !

"evaluate"   
(CodeFiler organizerFor: Token) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Token) reorganizeFrom: #(
('get/set' label: label symbol symbol: )) !

(CodeFiler organizerFor: Token) reorganizeFrom: #(
('get/set' label: label symbol symbol: )) !



!Token methods !
printOn: aStream
    "Make label #Identifier with symbol #hello look like Identifier: hello 
    whereas label #keyword with symbol #keyword looks like keyword."
    self label == self symbol 
        ifTrue: [aStream << self label]
        ifFalse: [aStream << self label; << ': '; << self symbol].!   !

!Token methods ! 
printOn: aStream tabs: tabs
    aStream cr.
    tabs timesRepeat: [ aStream << '   '].
    aStream << self label; << ' ('; << self symbol; << ')'.!  !
(CodeFiler organizerFor: Token) reorganizeFrom: #(
('printing' printOn: printOn:tabs: )) !

(CodeFiler organizerFor: Token) reorganizeFrom: #(
('printing' printOn: printOn:tabs: )) !



!Token methods ! 
= anObject
    self class = anObject class ifFalse: [^false].
    ^self label = anObject label and: [self symbol = anObject symbol]!  !

!Token methods ! 
hash
    ^label hash + symbol hash!    !
(CodeFiler organizerFor: Token) reorganizeFrom: #(
('comparing' = hash )) !

(CodeFiler organizerFor: Token) reorganizeFrom: #(
('comparing' = hash )) !
CodeFiler setCommentFor: Token to: ''!



!ShiftbackTable methods !  
table: aTable
    "Record the data it needs."
    shift := aTable first. goto := aTable second!   !

!ShiftbackTable methods !
goto
    ^goto!    !

!ShiftbackTable methods !
goto: aNumber
    goto := aNumber! !

!ShiftbackTable methods !
shift: aNumber
    shift := aNumber!   !

!ShiftbackTable methods !
shift
    ^shift!  !

"evaluate"   
(CodeFiler organizerFor: ShiftbackTable) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: ShiftbackTable) reorganizeFrom: #(
('get/set' goto table: goto: shift: shift )) !

(CodeFiler organizerFor: ShiftbackTable) reorganizeFrom: #(
('get/set' goto table: goto: shift: shift )) !



!ShiftbackTable methods !  
run
    "Adjust left by the amount specified and return the goto table."
    transducer left: transducer left - shift.
    ^goto!    !
(CodeFiler organizerFor: ShiftbackTable) reorganizeFrom: #(
('running' run )) !

(CodeFiler organizerFor: ShiftbackTable) reorganizeFrom: #(
('running' run )) !
CodeFiler setCommentFor: ShiftbackTable to: ''!



!Table methods !  
transducer: aTransducer
    transducer := aTransducer! !

!Table methods ! 
transducer
    ^transducer!    !
(CodeFiler organizerFor: Table) reorganizeFrom: #(
('get/set' transducer: transducer )) !

(CodeFiler organizerFor: Table) reorganizeFrom: #(
('get/set' transducer: transducer )) !
CodeFiler setCommentFor: Table to: ''!



!Transducer class methods !
new

    ^super new initialize!   !

"evaluate"   
(CodeFiler organizerFor: Transducer class) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Transducer class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: Transducer class) reorganizeFrom: #(
('instance creation' new )) !



!Transducer methods !  
tables: aCollection
    tables := aCollection! !

!Transducer methods !
tables
    ^tables!    !

!Transducer methods !
sponsor
    ^sponsor!  !

!Transducer methods !
sponsor: anObject
    sponsor := anObject! !

"evaluate"   
(CodeFiler organizerFor: Transducer) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Transducer) reorganizeFrom: #(
('get/set' tables: tables sponsor sponsor: )) !

(CodeFiler organizerFor: Transducer) reorganizeFrom: #(
('get/set' tables: tables sponsor sponsor: )) !
CodeFiler setCommentFor: Transducer to: ''!



!SampleTranslator class methods !   
new

    ^super new initialize!   !
(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('instance creation' new )) !



!SampleTranslator class methods !  
rawParserTables
    "Tables generated from GrammarBuilder class>>parserGrammar"
    ^
#(
   (keywords where)
   (ReadaheadTable 1 (Integer 'RSN' 28) (Identifier 'RSN' 4) (#'(' 'RS' 5))
   (ReadaheadTable 2 (#'+' 'RS' 6) (#'-|' 'L' 25))
   (ReadaheadTable 3 (#'*' 'RS' 7) (#'+' 'L' 26) (#'-|' 'L' 26) (#';' 'L' 26) (#')' 'L' 26) (#',' 'L' 26))
   (ReadaheadTable 4 (#'(' 'RS' 8) (#'=' 'RS' 9) (#'+' 'L' 28) (#'*' 'L' 28) (#'-|' 'L' 28) (#';' 'L' 28) (#')' 'L' 28) (#',' 'L' 28))
   (ReadaheadTable 5 (Integer 'RSN' 28) (Identifier 'RSN' 11) (#'(' 'RS' 5))
   (ReadaheadTable 6 (Identifier 'RSN' 11) (#'(' 'RS' 5) (Integer 'RSN' 28))
   (ReadaheadTable 7 (Identifier 'RSN' 11) (#'(' 'RS' 5) (Integer 'RSN' 28))
   (ReadaheadTable 8 (#')' 'RS' 32) (Integer 'RSN' 28) (Identifier 'RSN' 11) (#'(' 'RS' 5))
   (ReadaheadTable 9 (Integer 'RSN' 28) (Identifier 'RSN' 11) (#'(' 'RS' 5))
   (ReadaheadTable 10 (#')' 'RS' 29) (#'+' 'RS' 6))
   (ReadaheadTable 11 (#'(' 'RS' 8) (#'+' 'L' 28) (#'*' 'L' 28) (#'-|' 'L' 28) (#';' 'L' 28) (#')' 'L' 28) (#',' 'L' 28))
   (ReadaheadTable 12 (#'*' 'RS' 7) (#'+' 'L' 30) (#'-|' 'L' 30) (#';' 'L' 30) (#')' 'L' 30) (#',' 'L' 30))
   (ReadaheadTable 13 (#'+' 'RS' 6) (#',' 'RS' 15) (#')' 'RS' 32))
   (ReadaheadTable 14 (#'+' 'RS' 6) (#';' 'RS' 16))
   (ReadaheadTable 15 (Integer 'RSN' 28) (Identifier 'RSN' 11) (#'(' 'RS' 5))
   (ReadaheadTable 16 (Identifier 'RSN' 18) (#'-|' 'L' 33))
   (ReadaheadTable 17 (#'+' 'RS' 6) (#',' 'RS' 15) (#')' 'RS' 32))
   (ReadaheadTable 18 (#'=' 'RS' 9))
   (ReadbackTable 19 ((#'(' 8) 'RS' 22) ((Expression 13) 'RSN' 34) ((Expression 17) 'RSN' 35))
   (ReadbackTable 20 ((Expression 10) 'RSN' 40) ((Expression 17) 'RSN' 40) ((Expression 2) 'RSN' 40) ((Expression 13) 'RSN' 40) ((Expression 14) 'RSN' 40))
   (ReadbackTable 21 ((Term 12) 'RSN' 41) ((Term 3) 'RSN' 41))
   (ReadbackTable 22 ((Identifier 4) 'RSN' 42) ((Identifier 11) 'RSN' 42))
   (ReadbackTable 23 ((Expression 13) 'RSN' 34) ((Expression 17) 'RSN' 35))
   (ReadbackTable 24 ((Identifier 4) 'RSN' 43) ((Identifier 18) 'RSN' 33))
   (ShiftbackTable 25 1 37)
   (ShiftbackTable 26 1 36)
   (ShiftbackTable 27 1 38)
   (ShiftbackTable 28 1 39)
   (ShiftbackTable 29 3 39)
   (ShiftbackTable 30 2 20)
   (ShiftbackTable 31 2 21)
   (ShiftbackTable 32 1 19)
   (ShiftbackTable 33 3 24)
   (ShiftbackTable 34 1 22)
   (ShiftbackTable 35 1 23)
   (ReduceTable 36 Expression (1 'RSN' 2)(5 'RSN' 10)(8 'RSN' 13)(9 'RSN' 14)(15 'RSN' 17))
   (ReduceTable 37 Grammar (1 'RSN' 44))
   (ReduceTable 38 Term (1 'RSN' 3)(5 'RSN' 3)(6 'RSN' 12)(8 'RSN' 3)(9 'RSN' 3)(15 'RSN' 3))
   (ReduceTable 39 Primary (1 'RSN' 27)(5 'RSN' 27)(6 'RSN' 27)(7 'RSN' 31)(8 'RSN' 27)(9 'RSN' 27)(15 'RSN' 27))
   (SemanticTable 40 buildTree: '+' 36)
   (SemanticTable 41 buildTree: '*' 38)
   (SemanticTable 42 buildTree: send 39)
   (SemanticTable 43 buildTree: '<-' 37)
   (AcceptTable 44))!   !

!SampleTranslator class methods !
rawScannerTables
    "Scanner rawScannerTables"

    "EndOfFileCharacter is 256"
    ^
#(
   (ScannerReadaheadTable 1 ((256) 'L' 5) (')' 'RK' 7) ('*' 'RK' 8) ('+' 'RK' 9) (',' 'RK' 10) ('0123456789' 'RK' 2) ('(' 'RK' 6) (';' 'RK' 12) ('=' 'RK' 13) ('ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz' 'RK' 3) ((9 10 12 13) 'R' 4) (' ' 'R' 4))
   (ScannerReadaheadTable 2 ((9 10 12 13 256) 'L' 11) ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_+*=[]{}()^;#:.$ ' 'L' 11) ('0123456789' 'RK' 2))
   (ScannerReadaheadTable 3 ((9 10 12 13 256) 'L' 14) ('+*=[]{}()^;#:.$ ' 'L' 14) ('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz' 'RK' 3))
   (ScannerReadaheadTable 4 ((256) 'L' 1) ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_0123456789+*=[]{}()^;#:.$' 'L' 1) ((9 10 12 13) 'R' 4) (' ' 'R' 4))
   (SemanticTable 5 buildToken: '-|' 1)
   (SemanticTable 6 buildToken: '(' 1)
   (SemanticTable 7 buildToken: ')' 1)
   (SemanticTable 8 buildToken: '*' 1)
   (SemanticTable 9 buildToken: '+' 1)
   (SemanticTable 10 buildToken: ',' 1)
   (SemanticTable 11 buildToken: Integer 1)
   (SemanticTable 12 buildToken: ';' 1)
   (SemanticTable 13 buildToken: '=' 1)
   (SemanticTable 14 buildToken: Identifier 1))! !
(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('raw tables' rawParserTables rawScannerTables )) !

(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('raw tables' rawParserTables rawScannerTables )) !



!SampleTranslator class methods !  
evaluateExample1
    "SampleTranslator evaluateExample1"
    ^SampleTranslator new evaluate: '1+ 2*3'!    !

!SampleTranslator class methods !
compileExample1
    "SampleTranslator compileExample1"
    ^SampleTranslator new compile: '1+ 2*3'!   !

!SampleTranslator class methods !
promptForCompilation
    "SampleTranslator promptForCompilation"
    ^SampleTranslator new 
        compile: (Prompter prompt: 'Expression to compile' default: '1+2*3')!    !

!SampleTranslator class methods !
promptForEvaluation
    "SampleTranslator promptForEvaluation"
    ^SampleTranslator new 
        evaluate: (Prompter prompt: 'Expression to evaluate' default: '1+2*3')!    !
(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('examples' evaluateExample1 promptForEvaluation compileExample1 promptForCompilation )) !

(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('examples' evaluateExample1 promptForEvaluation compileExample1 promptForCompilation )) !



!SampleTranslator methods !  
initialize
    parser := Parser 
        for: self 
        parserTables: self class rawParserTables 
        scannerTables: self class rawScannerTables.
    codeIfCompiler := WriteStream on: (String new: 1000).
    expressionsIfEvaluator := Dictionary new. "each key is a variable"
    compilationOperatorMap := Dictionary new
        at: #+ put: #compilePlus:;
        at: #- put: #compileMinus:;
        at: #* put: #compileMultiply:;
        at: #/ put: #compileDivide:;
        at: #'<-' put: #compileAssign:;
        at: #'Identifier' put: #compileIdentifier:;
        at: #'Integer' put: #compileInteger:;
        at: #'send' put: #compileFunctionCall:;
        at: #'where' put: #compileWhere:;
        yourself.
    evaluationOperatorMap := Dictionary new
        at: #+ put: #evaluatePlus:;
        at: #- put: #evaluateMinus:;
        at: #* put: #evaluateMultiply:;
        at: #/ put: #evaluateDivide:;
        at: #'<-' put: #evaluateAssign:;
        at: #'Identifier' put: #evaluateIdentifier:;
        at: #'Integer' put: #evaluateInteger:;
        at: #'send' put: #evaluateFunctionCall:;
        at: #'where' put: #evaluateWhere:;
        yourself!  !
(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('initializing' initialize )) !



!SampleTranslator methods !
parser: aParser
    parser := aParser! !

!SampleTranslator methods !  
tree
    ^tree!    !

!SampleTranslator methods !  
tree: aTree
    tree := aTree! !

!SampleTranslator methods !  
parser
    ^parser!    !
(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('get/set' parser: tree tree: parser )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('get/set' parser: tree tree: parser )) !



!SampleTranslator methods !
evaluate: text
    | result |
    "If no variables are set up, just return the expression; otherwise, a dictionary of variables."
    tree := parser parse: text.
    self halt: 'See tree returned by parser'.
    result := self evaluateExpressionFor: tree.
    self halt: 'See result and variable dictionary'.
    expressionsIfEvaluator size = 0 ifTrue: [^result] ifFalse: [^expressionsIfEvaluator]!   !

!SampleTranslator methods !  
evaluateExpressionFor: tree
    ^self perform: (evaluationOperatorMap at: tree label asSymbol) with: tree! !

!SampleTranslator methods !  
compileExpressionFor: tree
    self perform: (compilationOperatorMap at: tree label asSymbol) with: tree!  !

!SampleTranslator methods !  
compile: text
    tree := parser parse: text.
    self compileExpressionFor: tree.
    ^codeIfCompiler contents! !
(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compiling/evaluating' evaluate: compileExpressionFor: compile: evaluateExpressionFor: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compiling/evaluating' evaluate: compileExpressionFor: compile: evaluateExpressionFor: )) !



!SampleTranslator methods !  
generate: instruction
    codeIfCompiler cr; << instruction!   !

!SampleTranslator methods !  
generate: instruction with: operand
    codeIfCompiler cr; << instruction; << ' '; << operand! !
(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compilation support' generate: generate:with: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compilation support' generate: generate:with: )) !




!SampleTranslator methods !
compileAssign: tree
    1 to: tree children size by: 2 do: [:index |
            self compileExpressionFor: (tree child: index + 1).
            self generate: 'POP' with: (tree child: index) symbol]! !

!SampleTranslator methods !  
compileFunctionCall: tree
    tree children rest do: [:child | self compileExpressionFor: child]. 
    self generate: 'FUNCTION_CALL' with: (tree child: 1) symbol!   !

!SampleTranslator methods !  
compilePlus: tree
    self compileExpressionFor: (tree child: 1).
    self compileExpressionFor: (tree child: 2).
    self generate: 'ADD'.! !

!SampleTranslator methods !  
compileDivide: tree
    self compileExpressionFor: (tree child: 1).
    self compileExpressionFor: (tree child: 2).
    self generate: 'DIVIDE'.!    !

!SampleTranslator methods !  
compileWhere: tree
    "Not currently implementing where properly since ignoring other children."
    self halt: 'compile WHERE'.
    self compileExpressionFor: (tree child: 1).!   !

!SampleTranslator methods !  
compileMultiply: tree
    self compileExpressionFor: (tree child: 1).
    self compileExpressionFor: (tree child: 2).
    self generate: 'MULTIPLY'.!    !

!SampleTranslator methods !  
compileInteger: token
    self generate: 'PUSH' with: token symbol asInteger!  !

!SampleTranslator methods !  
compileIdentifier: token
    self generate: 'PUSH' with: token symbol! !

!SampleTranslator methods !  
compileMinus: tree
    self halt: 'compile MINUS'.!    !
(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compilation details' compileAssign: compileFunctionCall: compilePlus: compileDivide: compileWhere: compileMultiply: compileInteger: compileIdentifier: compileMinus: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compilation details' compileAssign: compileFunctionCall: compilePlus: compileDivide: compileWhere: compileMultiply: compileInteger: compileIdentifier: compileMinus: )) !



!SampleTranslator methods !
evaluatePlus: aTree
    ^(self evaluateExpressionFor: (aTree child: 1)) + (self evaluateExpressionFor: (aTree child: 2))!  !

!SampleTranslator methods !  
evaluateInteger: token
    ^token symbol asInteger!    !

!SampleTranslator methods !  
evaluateDivide: tree
    | expression1 expression2 |
    expression1 := self evaluateExpressionFor: (tree child: 1).
    expression2 := self evaluateExpressionFor: (tree child: 2).
    ^expression1 / expression2!    !

!SampleTranslator methods !  
evaluateWhere: tree
    "Evaluate all but the first expression to obtain the values for individual variables,
    then store them in expressionsIfEvaluator and finally evaluate the first expression."
    self halt: 'evaluate WHERE'! !

!SampleTranslator methods !  
evaluateMinus: tree
   self halt: 'evaluate MINUS'!    !

!SampleTranslator methods !  
evaluateAssign: token
    | expression |
    expression := self evaluateExpressionFor: (tree child: 2).
    expressionsIfEvaluator at: (tree child: 1) symbol put: expression!   !

!SampleTranslator methods !  
evaluateFunctionCall: tree
    | function parameters |
    function := (tree child: 1) label.
    parameters := tree children rest collect: [:child | self evaluateExpressionFor: child].  
    
    function = #tan ifTrue: [^parameters first tan] ifFalse: [
    function = #abs ifTrue: [^parameters first abs]].
    
    self halt: 'Function ', function printString, ' not yet handled'!    !

!SampleTranslator methods !  
evaluateIdentifier: token
    | identifier |
    identifier := token symbol.
    ^expressionsIfEvaluator at: identifier ifAbsent: [self halt: 'Identifier ', identifier printString, ' is not defined'].!    !

!SampleTranslator methods !  
evaluateMultiply: tree
    | expression1 expression2 |
    expression1 := self evaluateExpressionFor: (tree child: 1).
    expression2 := self evaluateExpressionFor: (tree child: 2).
    ^expression1 * expression2!  !
(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('evaluation details' evaluatePlus: evaluateInteger: evaluateDivide: evaluateWhere: evaluateMinus: evaluateAssign: evaluateFunctionCall: evaluateIdentifier: evaluateMultiply: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('evaluation details' evaluatePlus: evaluateInteger: evaluateDivide: evaluateWhere: evaluateMinus: evaluateAssign: evaluateFunctionCall: evaluateIdentifier: evaluateMultiply: )) !

CodeFiler setCommentFor: SampleTranslator to: ''!

"*** Image started on: January 26, 2021 02:39:45 AM ***"!

"define class"   

Object subclass: #Table
  instanceVariableNames: 
    ' transducer '
  classVariableNames: ''
  poolDictionaries: ''!

"define class" 

Object subclass: #Transducer
  instanceVariableNames: 
    ' sponsor tables '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"

Table subclass: #TableWithTransitions
  instanceVariableNames: 
    ' transitions '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"  

Table subclass: #AcceptTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

"define class"  

Object subclass: #Tree
  instanceVariableNames: 
    ' label children '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"  

TableWithTransitions subclass: #ScannerReadaheadTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

"define class" 

TableWithTransitions subclass: #ReadaheadTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

"define class"

TableWithTransitions subclass: #ReadbackTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

"define class" 

Transducer subclass: #Screener
  instanceVariableNames: 
    ' keywords '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"

Table subclass: #SemanticTable
  instanceVariableNames: 
    ' action parameters goto '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"  

Transducer subclass: #Parser
  instanceVariableNames: 
    ' scanner screener tokenStack tableNumberStack treeStack left right tableNumber newTree '
  classVariableNames: ''
  poolDictionaries: ''!

"define class" 

TableWithTransitions subclass: #ReduceTable
  instanceVariableNames: 
    ' nonterminal '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"

Transducer subclass: #Scanner
  instanceVariableNames: 
    ' input token keptCharacters '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"   

Object subclass: #Token
  instanceVariableNames: 
    ' label symbol '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"   

Table subclass: #ShiftbackTable
  instanceVariableNames: 
    ' shift goto '
  classVariableNames: ''
  poolDictionaries: ''!

"define class" 

Object subclass: #Table
  instanceVariableNames: 
    ' transducer '
  classVariableNames: ''
  poolDictionaries: ''!

"define class" 

Object subclass: #SampleTranslator
  instanceVariableNames: 
    ' parser tree codeIfCompiler expressionsIfEvaluator compilationOperatorMap evaluationOperatorMap '
  classVariableNames: ''
  poolDictionaries: ''!


!Table methods !  
transducer: aTransducer
    transducer := aTransducer! !

!Table methods ! 
transducer
    ^transducer!    !

"evaluate"   
(CodeFiler organizerFor: Table) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Table) reorganizeFrom: #(
('get/set' transducer: transducer )) !

(CodeFiler organizerFor: Table) reorganizeFrom: #(
('get/set' transducer: transducer )) !
CodeFiler setCommentFor: Table to: ''!



!AcceptTable methods !
table: aTable
    "Do nothing."!   !

"evaluate"   
(CodeFiler organizerFor: AcceptTable) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: AcceptTable) reorganizeFrom: #(
('get/set' table: )) !

(CodeFiler organizerFor: AcceptTable) reorganizeFrom: #(
('get/set' table: )) !



!AcceptTable methods !  
run
    ^nil "Ensure that parsing does not continue..."!   !
(CodeFiler organizerFor: AcceptTable) reorganizeFrom: #(
('running' run )) !

(CodeFiler organizerFor: AcceptTable) reorganizeFrom: #(
('running' run )) !
CodeFiler setCommentFor: AcceptTable to: ''!



!Tree class methods !  
fromOldStyleArray: anObject
    "This assumes the array encode the tree in LISP notation; e.g. (root child1 child2 child3 ...)."
    (anObject isKindOf: Array) ifTrue: [^Tree new label: anObject first; children: (anObject rest collect: [:object | self fromArray: object])].
    (anObject isKindOf: Number) ifTrue: [^Token new label: #Integer; symbol: anObject printString].
    (anObject isKindOf: Character) ifTrue: [^Token new label: #Character; symbol: (String with: anObject)].
    (anObject isKindOf: Symbol) ifTrue: [^Token new label: #Identifier; symbol: anObject]. "or Symbol"
    (anObject isKindOf: String) ifTrue: [^Token new label: #SingleQuotedString; symbol: anObject].
    
    "We can't distinguish a symbol from an identifier because all identifiers become symbols in array literals."
    "We can't distinguish a SingleQuotedString from a DoubleQuotedString because all strings are single quoted in Smalltalk"
    
    ^self halt: 'Tree fromArray: did not expects the objects ', anObject printString!    !

!Tree class methods !
new

    ^super new initialize!   !

!Tree class methods !
fromArray: anObject
    "This assumes the array encode the tree in LISP notation; e.g. (root child1 child2 child3 ...)."
    (anObject isKindOf: Array) ifTrue: [^Tree new label: anObject first; children: (anObject rest collect: [:object | self fromArray: object])].
    (anObject isKindOf: Integer) ifTrue: [^Token new label: #walkInteger; symbol: anObject printString].
    (anObject isKindOf: Character) ifTrue: [^Token new label: #walkCharacter; symbol: (String with: anObject)].
    (anObject isKindOf: Symbol) ifTrue: [^Token new label: #walkIdentifier; symbol: anObject]. "or Symbol"
    (anObject isKindOf: String) ifTrue: [^Token new label: #walkString; symbol: anObject].
    
    "We can't distinguish a symbol from an identifier because all identifiers become symbols in array literals."
    ^self halt: 'Tree fromArray: did not expects the object ', anObject printString!    !

"evaluate"   
(CodeFiler organizerFor: Tree class) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Tree class) reorganizeFrom: #(
('instance creation' fromOldStyleArray: new fromArray: )) !

(CodeFiler organizerFor: Tree class) reorganizeFrom: #(
('instance creation' fromOldStyleArray: new fromArray: )) !



!Tree methods !  
initialize
    children := OrderedCollection new.! !

"evaluate"   
(CodeFiler organizerFor: Tree) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('initializing' initialize )) !



!Tree methods !
children
    ^children!    !

!Tree methods !  
label: aSymbol
    label := aSymbol!   !

!Tree methods !  
label
    ^label!  !

!Tree methods !  
child: index
    ^children at: index!  !

!Tree methods !  
children: aCollection
    children := aCollection! !
(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('get/set' children label: label child: children: )) !

(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('get/set' children label: label child: children: )) !



!Tree methods !  
addChild: aTree
    children add: aTree!   !
(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('modifying' addChild: )) !

(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('modifying' addChild: )) !



!Tree methods !
printOn: aStream
    self printOn: aStream tabs: 0.!   !

!Tree methods !  
printOn: aStream tabs: tabs
    aStream cr.
    tabs timesRepeat: [aStream << '   '].
    aStream << self label.
    children do: [:child | child printOn: aStream tabs: tabs + 1]! !
(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('printing' printOn: printOn:tabs: )) !

(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('printing' printOn: printOn:tabs: )) !
CodeFiler setCommentFor: Tree to: ''!



!ScannerReadaheadTable methods !
table: anArray
    "Record the triples: an integer or character collection, attributes, and goto. The integers
    are unprintable characters or the end of file integer 256, the attributes are $R for read 
    ($L for stack) and $K for keep. It's particularly important here to store the data so that
    given a character or 256, you can perform a fast lookup to find the triple."
    
    transitions := Dictionary new.
    anArray do: [:triple |
        triple first do: [:characterOrInteger | transitions at: characterOrInteger asInteger put: triple rest]]
        
    "OLD WAY:
    anArray groupsDo: [:item :attributes :goto |
        item isString 
                ifTrue: [item do: [:character | transitions at: character asInteger put: (Array with: attributes with: goto)]]
                ifFalse: [item do: [:integer | transitions at: integer put: (Array with: attributes with: goto)]]]
    "! !

"evaluate"   
(CodeFiler organizerFor: ScannerReadaheadTable) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: ScannerReadaheadTable) reorganizeFrom: #(
('get/set' table: )) !

(CodeFiler organizerFor: ScannerReadaheadTable) reorganizeFrom: #(
('get/set' table: )) !



!ScannerReadaheadTable methods !  
printables
    "The last three printable characters are single quote (represented as two single quotest in a row; i.e. ''),
    double quote (represented as one double quote; the end of comment is a double quote), and a space.
    Note: that it's hard to see the difference between two single quotes and one double quote."
    
    ^'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!!,+-/\*~=@%&?|<>[]{}()^;#:.$_''" '.!  !

!ScannerReadaheadTable methods ! 
run
    | character isKeep isRead pair |

    "Consider the next input character or integer (it could be 256 for endOfFile).
    Search the transitions for the triple that matches it. Remember: the original
    data was triples: an integer or character collection, attributes, and goto. But
    for fast lookup, you want to just be able to look up the triple using the next
    input as a key... When you find it, the read attribute ($R as opposed to $L)
    indicates that you need to remove it from the input. Otherwise, it stays for future 
    use. If it has the keep attribute ($K), you need to append the character to
    'keptCharacters'. If you can't find it, it a lexical error (see reportLexicalError).
    When you are done, return the goto table."
    
    character := transducer peekInput.
    pair := transitions at: character asInteger ifAbsent: [nil].
    pair notNil ifTrue: [
        pair groupDo: [:attributes :goto |
            isRead := attributes includes: $R.
            isKeep := attributes includes: $K.
            isRead ifFalse: [^goto].
            isKeep ifTrue: [transducer keptCharacters: (transducer keptCharacters, character asString)].
            transducer discardInput.
            ^goto]].
            
    self reportLexicalError!   !

!ScannerReadaheadTable methods ! 
reportLexicalError
    | characterAsInteger character printables |

    characterAsInteger := transducer peekInput.
    characterAsInteger = 256 ifTrue: [self error: 'Lexical error: End of the file encountered unexpectedly'].
    character := characterAsInteger asCharacter.
    
    (self printables includes: character) 
        ifTrue: [self error: 'Lexical error, encountered unexpected character ', character asString]
        ifFalse: [
            self error: 'Lexical error, encountered unexpected unprintable character',
                ' hex ', (character asNumber printStringRadix: 16),
                ' decimal ', character asNumber printString]! !
(CodeFiler organizerFor: ScannerReadaheadTable) reorganizeFrom: #(
('running' printables run reportLexicalError )) !

(CodeFiler organizerFor: ScannerReadaheadTable) reorganizeFrom: #(
('running' printables run reportLexicalError )) !
CodeFiler setCommentFor: ScannerReadaheadTable to: ''!



"evaluate"   
(CodeFiler organizerFor: ReadaheadTable) removeCategory: 'no category methods' ifAbsent: [nil]!


!ReadaheadTable methods !
reportSyntaxError
    | token inputTokens inputText position |
            
    token := transducer peekScannerToken.
    inputTokens := transducer tokenStack rest. "Skip start stack information."
    
    Transcript cr; << 'Syntax error...'. 
    inputTokens isEmpty 
        ifTrue: [Transcript cr; << 'Did not expect input to start with '. Transcript << token]
        ifFalse: [
            Transcript cr; << 'DID NOT EXPECT'; << (inputTokens size > 6 ifTrue: [' ...'] ifFalse: ['']).
            inputTokens := inputTokens suffix: 6.
            inputTokens do: [:token | Transcript << ' '; << token].
            Transcript cr; << 'TO BE FOLLOWED BY '; << token.
            inputText := transducer scanner input collection. position := transducer scanner input position.
            Transcript << (inputText copyFrom: (position + 1 max: 1) to: (position + 100 min: inputText size))].
    self error: ('Syntax error: Illegal symbol: ', token label)! !

!ReadaheadTable methods !
run
    | token tokenLabel transition isRead isNode isStack |

    "Peek at the next token label..."
    tokenLabel := (token := transducer peekScannerToken) label asSymbol.

    "and then use the transition that matches it if there is one. Use the attributes to determine
    what to do. If there isn't one, it's a syntax error. Remember $R means read ($L look), $N
    means make the token part of a tree, and $S means stack. If we stack, we also need 'right'
    to refer to the last entry and 'left' to be one more to the right. Finally, returns the corresponding
    goto state."

    transition := transitions at: tokenLabel ifAbsent: [^self reportSyntaxError].
    transition groupDo: [:attributes :goto |
        isRead := attributes includes: $R.
        isNode := attributes includes: $N.
        isStack := attributes includes: $S.
        isRead ifFalse: [^goto].
        transducer discardScannerToken.
        isStack ifTrue: [
            transducer tokenStack add: token.
            transducer tableNumberStack add: goto.
            transducer treeStack add: (isNode ifTrue: [token] ifFalse: [nil]).
            transducer right: transducer tokenStack size.
            transducer left: transducer right + 1].
        ^goto].!   !
(CodeFiler organizerFor: ReadaheadTable) reorganizeFrom: #(
('running' reportSyntaxError run )) !

(CodeFiler organizerFor: ReadaheadTable) reorganizeFrom: #(
('running' reportSyntaxError run )) !



!ReadaheadTable methods !  
runUNUSEDVersionThatSearches
    | token tokenLabel isRead isNode isStack |

    "Peek at the next token label..."
    tokenLabel := (token := transducer peekScannerToken) label asSymbol.

    "and then search for a transition that matches it. When found, use the attributes to determine
    what to do. If you don't find it, it's a syntax error. Remember $R means read ($L look), $N
    means make the token part of a tree, and $S means stack. If we stack, we also need 'right'
    to refer to the last entry and 'left' to be one more to the right. Finally, returns the corresponding
    goto state."

    transitions groupsDo: [:symbol :attributes :goto |
        tokenLabel == symbol ifTrue: [
            isRead := attributes includes: $R.
            isNode := attributes includes: $N.
            isStack := attributes includes: $S.
            isRead ifFalse: [^goto].
            transducer discardScannerToken.
            isStack ifTrue: [
                transducer tokenStack add: token.
                transducer tableNumberStack add: goto.
                transducer treeStack add: (isNode ifTrue: [token] ifFalse: [nil]).
                transducer right: transducer tokenStack size.
                transducer left: transducer right + 1].
            ^goto]].

    self reportSyntaxError!    !

!ReadaheadTable methods !
tableUNUSEDVersionThatSearches: anArray
    "Record the data unmodified so you can later perform a fast search."
    transitions := anArray!  !
(CodeFiler organizerFor: ReadaheadTable) reorganizeFrom: #(
('unused' runUNUSEDVersionThatSearches tableUNUSEDVersionThatSearches: )) !

(CodeFiler organizerFor: ReadaheadTable) reorganizeFrom: #(
('unused' runUNUSEDVersionThatSearches tableUNUSEDVersionThatSearches: )) !
CodeFiler setCommentFor: ReadaheadTable to: ''!



!TableWithTransitions methods !   
table: anArray
    "Record the data so you can later perform a fast lookup."
    transitions := Dictionary new.
    anArray do: [:triple | transitions at: triple first put: triple rest]!   !

"evaluate"   
(CodeFiler organizerFor: TableWithTransitions) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: TableWithTransitions) reorganizeFrom: #(
('get/set' table: )) !

(CodeFiler organizerFor: TableWithTransitions) reorganizeFrom: #(
('get/set' table: )) !
CodeFiler setCommentFor: TableWithTransitions to: ''!



"evaluate"
(CodeFiler organizerFor: ReadbackTable) removeCategory: 'no category methods' ifAbsent: [nil]!


!ReadbackTable methods !  
run
    | pair transition isRead |
    "Readback considers the token label in the token stack and the state number in the table number at position 'left - 1'
    and then uses the transition that matches it. If there isn't one it's a design error. Otherwise, it then uses the attribute $R for read, $L for look to
    decide what to do. If it's read, it decrements 'left'. Finally it returns the goto state."

    pair := Array with: (transducer tokenStack at: transducer left - 1) label with: (transducer tableNumberStack at: transducer left - 1).
    transition := transitions at: pair ifAbsent: [^self reportDesignError].
    transition groupDo: [:attributes :goto |
        isRead := attributes  includes: $R.
        isRead ifTrue: [transducer left: transducer left - 1].
        ^goto].!    !

!ReadbackTable methods ! 
reportDesignError
    self error: 'Design error: reached end of ReadbackTable without having found a suitable transition'! !
(CodeFiler organizerFor: ReadbackTable) reorganizeFrom: #(
('running' run reportDesignError )) !

(CodeFiler organizerFor: ReadbackTable) reorganizeFrom: #(
('running' run reportDesignError )) !



!ReadbackTable methods ! 
tableUNUSEDVersionThatSearches: anArray
    "Store the data, old state number/symbol/new state number triples for search in run."
    | pair |
    transitions := anArray collect: [:triple |
        pair := triple first.
        Array with: (Array with: pair first asSymbol with: pair second) with: triple second with: triple third]!   !

!ReadbackTable methods ! 
runUNUSEDVersionThatSearches
    | pair isRead |
    "Readback considers the token label in the token stack and the state number in the table number at position 'left - 1'
    and then finds the transition that matches it. When it finds it, it then uses the attribute $R for read, $L for look to
    decide what to do. If it's read, it decrements 'left'. Finally it returns the goto state."
    
    pair := Array with: (transducer tokenStack at: transducer left - 1) label with: (transducer tableNumberStack at: transducer left - 1).
    transitions groupsDo: [:nextPair :attributes :goto |
        pair = nextPair ifTrue:[
            isRead := attributes  includes: $R.
            isRead ifTrue: [transducer left: transducer left - 1].
            ^goto]].
    self reportDesignError!    !
(CodeFiler organizerFor: ReadbackTable) reorganizeFrom: #(
('unused' tableUNUSEDVersionThatSearches: runUNUSEDVersionThatSearches )) !

(CodeFiler organizerFor: ReadbackTable) reorganizeFrom: #(
('unused' tableUNUSEDVersionThatSearches: runUNUSEDVersionThatSearches )) !
CodeFiler setCommentFor: ReadbackTable to: ''!



"evaluate"   
(CodeFiler organizerFor: Screener class) removeCategory: 'no category methods' ifAbsent: [nil]!


!Screener methods !  
keywords
    ^keywords!    !

!Screener methods !  
keywords: aCollection
    keywords := aCollection! !

"evaluate"   
(CodeFiler organizerFor: Screener) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Screener) reorganizeFrom: #(
('get/set' keywords keywords: )) !

(CodeFiler organizerFor: Screener) reorganizeFrom: #(
('get/set' keywords keywords: )) !



!Screener methods !  
screen: aToken
    "Older name is #Identifier, newer name is #walkIdentifier:"
    (aToken label = #Identifier) | (aToken label = #walkIdentifier:) ifFalse: [^aToken]. 
    (self keywords includes: aToken symbol) ifFalse: [^aToken].
    ^Token new label: aToken symbol; symbol: aToken symbol.!   !
(CodeFiler organizerFor: Screener) reorganizeFrom: #(
('screening' screen: )) !

(CodeFiler organizerFor: Screener) reorganizeFrom: #(
('screening' screen: )) !
CodeFiler setCommentFor: Screener to: ''!



!SemanticTable methods !
table: aTable
    action := aTable first.
    parameters := aTable copyFrom: 2 to: aTable size - 1.
    goto := aTable last! !

!SemanticTable methods ! 
action: aSymbol
    action := aSymbol! !

!SemanticTable methods ! 
parameters
    ^parameters!    !

!SemanticTable methods ! 
goto
    ^goto!    !

!SemanticTable methods ! 
parameters: aCollection
    parameters := aCollection! !

!SemanticTable methods ! 
goto: aNumber
    goto := aNumber! !

!SemanticTable methods ! 
action
    ^action!    !

"evaluate"   
(CodeFiler organizerFor: SemanticTable) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: SemanticTable) reorganizeFrom: #(
('get/set' table: action: parameters goto parameters: goto: action )) !

(CodeFiler organizerFor: SemanticTable) reorganizeFrom: #(
('get/set' table: action: parameters goto parameters: goto: action )) !



!SemanticTable methods !
run
    | recipient |
    recipient := (transducer class canUnderstand: action) ifTrue: [transducer] ifFalse: [transducer sponsor].
    recipient perform: action withArguments: parameters.
    ^goto! !
(CodeFiler organizerFor: SemanticTable) reorganizeFrom: #(
('running' run )) !

(CodeFiler organizerFor: SemanticTable) reorganizeFrom: #(
('running' run )) !
CodeFiler setCommentFor: SemanticTable to: ''!



!Parser class methods !  
for: aSponsor parserTables: parserTables scannerTables: scannerTables
    | parser |
    parser := self new.
    
    "Set up the user (or sponsor) of the scanner and parser."
    parser sponsor: aSponsor. parser scanner sponsor: aSponsor.
    
    "Give the keywords to the screener and the remaining tables to the parser..."
    parser tables: parserTables rest; screener: (Screener new keywords: parserTables first rest).
    
    "Give the entire set of scanner tables to the scanner..."
    parser scanner tables: scannerTables.
    
    ^parser!    !

"evaluate"   
(CodeFiler organizerFor: Parser class) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Parser class) reorganizeFrom: #(
('instance creation' for:parserTables:scannerTables: )) !

(CodeFiler organizerFor: Parser class) reorganizeFrom: #(
('instance creation' for:parserTables:scannerTables: )) !



!Parser methods !  
initialize
    scanner := Scanner new. screener := Screener new.
    tokenStack := OrderedCollection new add: (Token new label: #'|-'; symbol: #'|-'); yourself.
    treeStack := OrderedCollection new add: nil; yourself.
    tableNumberStack := OrderedCollection new add: 1; yourself.
    left := 1. right := 1.!    !

"evaluate"   
(CodeFiler organizerFor: Parser) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('initializing' initialize )) !



!Parser methods !
screener: aScreener
    screener := aScreener! !

!Parser methods !
screener
    ^screener!    !

!Parser methods !
right
    ^right!  !

!Parser methods !
tokenStack: aCollection
    tokenStack := aCollection! !

!Parser methods !
treeStack
    ^treeStack!  !

!Parser methods !
left: aNumber
    left := aNumber! !

!Parser methods !
tableNumberStack: aCollection
    tableNumberStack := aCollection! !

!Parser methods !
tokenStack
    ^tokenStack!    !

!Parser methods !
tableNumberStack
    ^tableNumberStack!    !

!Parser methods !
tables: aCollection
    "Store the collection of all table objects in tables. Moreover, each type of table will store it's data
    in its own way. So, you had better let the object store it. Note: The collection contains the NAMES for the types
    of table objects, they are not table objects. Also, whoever sent this message had better not have 
    included an entry for a keyword list since that was supposed to have been given to the screener.
    IN OTHER WORDS: Create the appropriate kind of table object, give the table data to that object, and 
    then store that object in the parser's tables."
    
    "HINT: 'Smalltalk at: x' where x is a variable containing the symbol #Apple returns the class object called
    Apple. Once you have a class object, you can say new to it."
    
    tables := aCollection collect:[ :element |     
        "Each table is of the form (tableType tableNumber ...)."
        "Get the class name for the type, then make a new instance, then give it the table and tell it that I'm it's transducer."
        (Smalltalk at: element first) new table: (element copyFrom: 3); transducer: self ].!    !

!Parser methods !
newTree
    ^newTree!  !

!Parser methods !
scanner
    ^scanner!  !

!Parser methods !
right: aNumber
    right := aNumber!   !

!Parser methods !
treeStack: aCollection
    treeStack := aCollection!   !

!Parser methods !
tables
    ^tables!    !

!Parser methods !
left
    ^left!    !

!Parser methods !
newTree: aTree
    newTree := aTree!   !

!Parser methods !
scanner: aScanner
    scanner := aScanner! !
(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('get/set' screener: tokenStack: screener tables: treeStack left: tokenStack tableNumberStack: tableNumberStack right newTree scanner right: treeStack: tables left newTree: scanner: )) !

(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('get/set' screener: tokenStack: screener tables: treeStack left: tokenStack tableNumberStack: tableNumberStack right newTree scanner right: treeStack: tables left newTree: scanner: )) !



!Parser methods !
parse: text
    "To parse the text, you have to give it to the scanner (say via scan: text).
    It in turn should have the first token set up for you. Next you need
    to execute tables starting from table 1 until you reach an Accept table.
    Once that happen, the tree that was built should be on top of the tree
    stack. Just return it. If you look at the Accept table, you will see
    that it of all the tables, it is the only one that returns nil. You can
    use that information to stop your loop."
    | table |
    
    scanner scan: text.
    tableNumber := 1. table := tables at: tableNumber.
    [table class = AcceptTable ] whileFalse: [
        self log. "<---for debugging. You might want to comment this out for now"
        tableNumber := table run.
        table := tables at: tableNumber.].
    ^treeStack last!    !
(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('parsing' parse: )) !

(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('parsing' parse: )) !



!Parser methods !
discardScannerToken
    scanner discardToken.! !

!Parser methods !
peekScannerToken
    ^screener screen: scanner peekToken.! !
(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('streaming' discardScannerToken peekScannerToken )) !

(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('streaming' discardScannerToken peekScannerToken )) !



!Parser methods !
buildTreeFromIndex: index
    "Index is positive (1, 2, 3, ...) => label is in the token relative to the left end; i.e., to the right of left end."
    "index is negative (-1, -2, -3...) => label is in the token relative to the right end; i.e., to the left of right end."
    | children |    
    children := (left to: right) collect: [:index | treeStack at: index] when: [:index | (treeStack at: index) notNil].
    newTree := Tree new 
        label:  (index isPositive ifTrue: [tokenStack at: left + index - 1] ifFalse: [tokenStack at: right + index + 1]) symbol
        children: children.!   !

!Parser methods !
buildTree: rootNode
    "Pick up the children from the tree stack between left and     right inclusive (provided they're not nil) and 
    build a tree with the given label. Store it in instance variable newTree so a reduce table can use it."
    
    | children |
    children := (left to: right) collect: [:index | treeStack at: index] when: [:index | (treeStack at: index) notNil].
    newTree := Tree new label: rootNode; children: children.!    !
(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('semanticActions' buildTreeFromIndex: buildTree: )) !

(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('semanticActions' buildTreeFromIndex: buildTree: )) !



!Parser methods !
log
    | table useTerseTree whichCharacterToStartLogging |
    true ifTrue: [^self]. "currently disabled"
    whichCharacterToStartLogging := 4040.
    scanner input position < whichCharacterToStartLogging ifTrue: [^self].
    useTerseTree := true. "Set to false if more details are wanted..."
    table := tables at: tableNumber.

    "Log a preliminary heading..."
    Transcript cr; << 'At '; << scanner input position; << self peekScannerToken; << ' | left '; << left; << ' right '; << right; << ' |'; << ' Table '; << tableNumber; space; << table.

    "Log state specific information..."
    table class = ReadaheadTable ifTrue: [Transcript << ' SEARCHING FOR '; << self peekScannerToken label].
    table class = ReadbackTable ifTrue: [Transcript << ' SEARCHING FOR ';
        << '['; << (tokenStack at: left - 1) label; << ' '; << (tableNumberStack at: left - 1); << ']'].
    table class = ReduceTable ifTrue: [Transcript space; << table nonterminal; << ' SEARCHING FOR ';
        << (tableNumberStack at: left - 1)].
    table class = ShiftbackTable ifTrue: [Transcript << ' SHIFT '; << table shift; << ' GOTO '; << table goto].
    (table class = SemanticTable) ifTrue: [
        Transcript space; << table action. table parameters do: [:parameter | Transcript space; << parameter].
        Transcript << ' GOTO '; << table goto].

    "Log information in the stacks..."
    self treeStack indexedDo: [:index :tree |
        (index = left and: [left <= right]) ifTrue: [Transcript cr; << '       ---------------------------'].
        Transcript cr; << '       '; << index; << ' ['; << (self tokenStack at: index); << ' '; << (self tableNumberStack at: index); << '] '.
        tree isNil ifFalse:[useTerseTree ifTrue: [Transcript << ' Tree ('; << tree label; << ' ...)'] ifFalse: [tree printOn: Transcript tabs: 3]].
        (index = right and: [left > right]) ifTrue: [Transcript cr; << '       ---------------------------'].
        index = right ifTrue: [Transcript cr; << '       ---------------------------'].].!  !
(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('debugging' log )) !

(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('debugging' log )) !
CodeFiler setCommentFor: Parser to: ''!



!ReduceTable methods !
nonterminal: aSymbol
    nonterminal := aSymbol!   !

!ReduceTable methods !   
nonterminal
    ^nonterminal!  !

!ReduceTable methods !   
table: anArray
    "Store the data; namely a nonterminal and a bunch of transition information; triples
    with a 'from table numer', attributes, and a 'to table number'."
    nonterminal := anArray first.
    super table: anArray rest!   !

"evaluate"   
(CodeFiler organizerFor: ReduceTable) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: ReduceTable) reorganizeFrom: #(
('get/set' nonterminal: nonterminal table: )) !

(CodeFiler organizerFor: ReduceTable) reorganizeFrom: #(
('get/set' nonterminal: nonterminal table: )) !



!ReduceTable methods !
run
    "This is a 'Reduce to A' table where A is the nonterminal to reduce to. Pick up the new tree
    and simulate a readahead of A where the new tree is associated with A"

    | transition children tree tableNumber isStack isNode  |
    "Pick up the new tree if there is one OR bubble up the one tree in the stack between
    'left' and 'right' or nil if there isn't one. There better not be 2 or more."
    transducer newTree notNil
        ifTrue: [
            tree := transducer newTree. transducer newTree: nil]
        ifFalse: [
            "Just capture the one subtree (if any) and have it ready for stacking."
            children := (transducer treeStack copyFrom: transducer left to: transducer right) withoutNils.
            children size = 0 ifTrue: [tree := nil] ifFalse: [
            children size = 1 ifTrue: [tree := children first] ifFalse: [
            self halt: 'Design error: more than 1 child in ReduceTable'. tree := children last]]].

    "Clear the stacks between left and right (inclusive)."
    (transducer left to: transducer right) do: [:index |
        transducer tokenStack removeLast.
        transducer tableNumberStack removeLast.
        transducer treeStack removeLast].

    "Use the top table number on the stack (the 'from table number') to locate the pair (attributes, 'to table number);
    it's a design error if you can't find it. The other table number is to be returned when you're done. Also use the
    attributes in the same manner as you did for a readahead table but this time, instead of using the next token,
    use a new token you create using the nonterminal as it's symbol. Don't forget to adjust 'right' and 'left' like you
    did for the readahead table."

    tableNumber := transducer tableNumberStack last.
    transition := transitions at: tableNumber ifAbsent: [^self reportDesignError].
    transition groupDo: [:attributes :goto |
        isStack := attributes includes: $S. isNode := attributes includes: $N.
        isStack ifTrue: [
            transducer tokenStack add: (Token new label: nonterminal; symbol: nonterminal).
            transducer tableNumberStack add: goto.
            transducer treeStack add: (isNode ifTrue: [tree] ifFalse: [nil])].
        transducer right: transducer treeStack size.
        transducer left: transducer right + 1.
        ^goto].!   !

!ReduceTable methods !   
reportDesignError
    self error: 'Design error: reached end of ReduceTable without having found a suitable transition'!   !
(CodeFiler organizerFor: ReduceTable) reorganizeFrom: #(
('running' run reportDesignError )) !

(CodeFiler organizerFor: ReduceTable) reorganizeFrom: #(
('running' run reportDesignError )) !



!ReduceTable methods !   
runUNUSEDVersionThatSearches
    "This is a 'Reduce to A' table where A is the nonterminal to reduce to. Pick up the new tree
    and simulate a readahead of A where the new tree is associated with A"

    | stack children tree tableNumber isStack isNode token |
    "Pick up the new tree if there is one OR bubble up the one tree in the stack between
    'left' and 'right' or nil if there isn't one. There better not be 2 or more."
    transducer newTree notNil
        ifTrue: [
            tree := transducer newTree. transducer newTree: nil]
        ifFalse: [
            "Just capture the one subtree (if any) and have it ready for stacking."
            children := (transducer treeStack copyFrom: transducer left to: transducer right) withoutNils.
            children size = 0 ifTrue: [tree := nil] ifFalse: [
            children size = 1 ifTrue: [tree := children first] ifFalse: [
            self halt: 'Design error: more than 1 child in ReduceTable'. tree := children last]]].

    "Clear the stacks between left and right (inclusive)."
    (transducer left to: transducer right) do: [:index |
        transducer tokenStack removeLast.
        transducer tableNumberStack removeLast.
        transducer treeStack removeLast].

    "Using the top table number on the stack, search the triples ('from table number, attributes,
    'to table number) and find the one that matches 'from table number'; it's a design error if you can't
    find it. The other table number is to be returned when you're done. Also use the attributes in the
    same manner as you did for a readahead table but this time, instead of using the next token,
    use a new token you create using the nonterminal as it's symbol. Don't forget to adjust
    'right' and 'left' like you did for the readahead table."

    tableNumber := transducer tableNumberStack last.
    transitions groupsDo: [:candidateTableNumber :attributes :goto |
        tableNumber = candidateTableNumber ifTrue: [
            isStack := attributes includes: $S. isNode := attributes includes: $N.
            isStack ifTrue: [
                transducer tokenStack add: (Token new label: nonterminal; symbol: nonterminal).
                transducer tableNumberStack add: goto.
                transducer treeStack add: (isNode ifTrue: [tree] ifFalse: [nil])].
            transducer right: transducer treeStack size.
            transducer left: transducer right + 1.
            ^goto]].

    self reportDesignError! !

!ReduceTable methods !   
tableUNUSEDVersionThatSearches: anArray
    "Store the data; namely a nonterminal and a bunch of transition information; triples
    with a 'from table numer', attributes, and a 'to table number'."
    nonterminal := anArray first.
    super table: anArray rest!  !
(CodeFiler organizerFor: ReduceTable) reorganizeFrom: #(
('unused' runUNUSEDVersionThatSearches tableUNUSEDVersionThatSearches: )) !

(CodeFiler organizerFor: ReduceTable) reorganizeFrom: #(
('unused' runUNUSEDVersionThatSearches tableUNUSEDVersionThatSearches: )) !
CodeFiler setCommentFor: ReduceTable to: ''!



!Scanner methods ! 
initialize
    token := nil.
    keptCharacters := ''.!   !

"evaluate"   
(CodeFiler organizerFor: Scanner) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('initializing' initialize )) !



!Scanner methods !
tables
    ^tables!    !

!Scanner methods !   
tables: aCollection
    "Store the collection of all table objects in tables. Moreover, each type of table will store it's data
    in its own way. So, you had better let the object store it. Note: The Collection contains the NAMES of the 
    types of table objects, they are not table objects. IN OTHER WORDS: Create the appropriate kind of table
    object, give the table data to that object, and then store that object in the scanner's tables."
    
    "HINT: 'Smalltalk at: x' where x is a variable containing the symbol #Apple returns the class object called
    Apple. Once you have a class object, you can say new to it."
    
    tables := aCollection collect: [:element | 
        "Each table is of the form (tableType tableNumber ...)."
        "Get the class name for the type, then make a new instance, then give it the table and tell it that I'm it's transducer."
        (Smalltalk at: element first) new table: (element copyFrom: 3); transducer: self]!  !

!Scanner methods !   
keptCharacters
    ^keptCharacters!    !

!Scanner methods !   
keptCharacters: aString
    keptCharacters := aString! !

!Scanner methods !   
input: aStream
    input := aStream!   !

!Scanner methods !   
input
    ^input!  !
(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('get/set' tables tables: keptCharacters keptCharacters: input: input )) !

(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('get/set' tables tables: keptCharacters keptCharacters: input: input )) !



!Scanner methods ! 
scan: text
    self input: (ReadStream on: text).
    self discardToken!  !
(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('scanning' scan: )) !

(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('scanning' scan: )) !



!Scanner methods ! 
peekInput
    ^input atEnd ifTrue:[256] ifFalse:[input peek]!  !

!Scanner methods !   
peekToken
    ^token!  !

!Scanner methods !   
discardToken
    "To discard the current token, set token to nil and execute the tables
    in a loop starting with table 1 until token is no longer nil. Then return 
    nothing. Somewhere during this execution, the semantic action buildToken:
    will execute putting something into variable 'token'."
    
    | tableNumber table |
    tableNumber := 1. token := nil.
    [token isNil] whileTrue: [
        table := tables at: tableNumber.
        tableNumber := table run].
    ^nil "We now have a token"!    !

!Scanner methods !   
discardInput
    ^input next!  !
(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('streaming' peekInput discardToken discardInput peekToken )) !

(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('streaming' peekInput discardToken discardInput peekToken )) !



!Scanner methods !   
buildToken: label
    "Create a token with the supplied label and the characters in keptCharacters
    and put the result in token so peek can return it when requested.
    Reset keptCharacters to an empty string so the process can repeat."
    
    token := Token new label: label asSymbol; symbol: keptCharacters asSymbol.
    keptCharacters := ''.!   !
(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('semantic actions' buildToken: )) !

(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('semantic actions' buildToken: )) !
CodeFiler setCommentFor: Scanner to: ''!



!Token methods ! 
label: aLabel
    label := aLabel! !

!Token methods ! 
label
    ^label!  !

!Token methods ! 
symbol
    ^symbol!    !

!Token methods ! 
symbol: aSymbol
    symbol := aSymbol! !

"evaluate"   
(CodeFiler organizerFor: Token) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Token) reorganizeFrom: #(
('get/set' label: label symbol symbol: )) !

(CodeFiler organizerFor: Token) reorganizeFrom: #(
('get/set' label: label symbol symbol: )) !



!Token methods !
printOn: aStream
    "Make label #Identifier with symbol #hello look like Identifier: hello 
    whereas label #keyword with symbol #keyword looks like keyword."
    self label == self symbol 
        ifTrue: [aStream << self label]
        ifFalse: [aStream << self label; << ': '; << self symbol].!   !

!Token methods ! 
printOn: aStream tabs: tabs
    aStream cr.
    tabs timesRepeat: [ aStream << '   '].
    aStream << self label; << ' ('; << self symbol; << ')'.!  !
(CodeFiler organizerFor: Token) reorganizeFrom: #(
('printing' printOn: printOn:tabs: )) !

(CodeFiler organizerFor: Token) reorganizeFrom: #(
('printing' printOn: printOn:tabs: )) !



!Token methods ! 
= anObject
    self class = anObject class ifFalse: [^false].
    ^self label = anObject label and: [self symbol = anObject symbol]!  !

!Token methods ! 
hash
    ^label hash + symbol hash!    !
(CodeFiler organizerFor: Token) reorganizeFrom: #(
('comparing' = hash )) !

(CodeFiler organizerFor: Token) reorganizeFrom: #(
('comparing' = hash )) !
CodeFiler setCommentFor: Token to: ''!



!ShiftbackTable methods !  
table: aTable
    "Record the data it needs."
    shift := aTable first. goto := aTable second!   !

!ShiftbackTable methods !
goto
    ^goto!    !

!ShiftbackTable methods !
goto: aNumber
    goto := aNumber! !

!ShiftbackTable methods !
shift: aNumber
    shift := aNumber!   !

!ShiftbackTable methods !
shift
    ^shift!  !

"evaluate"   
(CodeFiler organizerFor: ShiftbackTable) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: ShiftbackTable) reorganizeFrom: #(
('get/set' goto table: goto: shift: shift )) !

(CodeFiler organizerFor: ShiftbackTable) reorganizeFrom: #(
('get/set' goto table: goto: shift: shift )) !



!ShiftbackTable methods !  
run
    "Adjust left by the amount specified and return the goto table."
    transducer left: transducer left - shift.
    ^goto!    !
(CodeFiler organizerFor: ShiftbackTable) reorganizeFrom: #(
('running' run )) !

(CodeFiler organizerFor: ShiftbackTable) reorganizeFrom: #(
('running' run )) !
CodeFiler setCommentFor: ShiftbackTable to: ''!



!Table methods !  
transducer: aTransducer
    transducer := aTransducer! !

!Table methods ! 
transducer
    ^transducer!    !
(CodeFiler organizerFor: Table) reorganizeFrom: #(
('get/set' transducer: transducer )) !

(CodeFiler organizerFor: Table) reorganizeFrom: #(
('get/set' transducer: transducer )) !
CodeFiler setCommentFor: Table to: ''!



!Transducer class methods !
new

    ^super new initialize!   !

"evaluate"   
(CodeFiler organizerFor: Transducer class) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Transducer class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: Transducer class) reorganizeFrom: #(
('instance creation' new )) !



!Transducer methods !  
tables: aCollection
    tables := aCollection! !

!Transducer methods !
tables
    ^tables!    !

!Transducer methods !
sponsor
    ^sponsor!  !

!Transducer methods !
sponsor: anObject
    sponsor := anObject! !

"evaluate"   
(CodeFiler organizerFor: Transducer) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Transducer) reorganizeFrom: #(
('get/set' tables: tables sponsor sponsor: )) !

(CodeFiler organizerFor: Transducer) reorganizeFrom: #(
('get/set' tables: tables sponsor sponsor: )) !
CodeFiler setCommentFor: Transducer to: ''!



!SampleTranslator class methods !   
new

    ^super new initialize!   !

"evaluate"   
(CodeFiler organizerFor: SampleTranslator class) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('instance creation' new )) !



!SampleTranslator class methods !
rawParserTables
    "Tables generated from GrammarBuilder class>>parserGrammar"
    ^
#(
   (keywords where)
   (ReadaheadTable 1 (Integer 'RSN' 28) (Identifier 'RSN' 4) (#'(' 'RS' 5))
   (ReadaheadTable 2 (#'+' 'RS' 6) (#'-|' 'L' 25))
   (ReadaheadTable 3 (#'*' 'RS' 7) (#'+' 'L' 26) (#'-|' 'L' 26) (#';' 'L' 26) (#')' 'L' 26) (#',' 'L' 26))
   (ReadaheadTable 4 (#'(' 'RS' 8) (#'=' 'RS' 9) (#'+' 'L' 28) (#'*' 'L' 28) (#'-|' 'L' 28) (#';' 'L' 28) (#')' 'L' 28) (#',' 'L' 28))
   (ReadaheadTable 5 (Integer 'RSN' 28) (Identifier 'RSN' 11) (#'(' 'RS' 5))
   (ReadaheadTable 6 (Identifier 'RSN' 11) (#'(' 'RS' 5) (Integer 'RSN' 28))
   (ReadaheadTable 7 (Identifier 'RSN' 11) (#'(' 'RS' 5) (Integer 'RSN' 28))
   (ReadaheadTable 8 (#')' 'RS' 32) (Integer 'RSN' 28) (Identifier 'RSN' 11) (#'(' 'RS' 5))
   (ReadaheadTable 9 (Integer 'RSN' 28) (Identifier 'RSN' 11) (#'(' 'RS' 5))
   (ReadaheadTable 10 (#')' 'RS' 29) (#'+' 'RS' 6))
   (ReadaheadTable 11 (#'(' 'RS' 8) (#'+' 'L' 28) (#'*' 'L' 28) (#'-|' 'L' 28) (#';' 'L' 28) (#')' 'L' 28) (#',' 'L' 28))
   (ReadaheadTable 12 (#'*' 'RS' 7) (#'+' 'L' 30) (#'-|' 'L' 30) (#';' 'L' 30) (#')' 'L' 30) (#',' 'L' 30))
   (ReadaheadTable 13 (#'+' 'RS' 6) (#',' 'RS' 15) (#')' 'RS' 32))
   (ReadaheadTable 14 (#'+' 'RS' 6) (#';' 'RS' 16))
   (ReadaheadTable 15 (Integer 'RSN' 28) (Identifier 'RSN' 11) (#'(' 'RS' 5))
   (ReadaheadTable 16 (Identifier 'RSN' 18) (#'-|' 'L' 33))
   (ReadaheadTable 17 (#'+' 'RS' 6) (#',' 'RS' 15) (#')' 'RS' 32))
   (ReadaheadTable 18 (#'=' 'RS' 9))
   (ReadbackTable 19 ((#'(' 8) 'RS' 22) ((Expression 13) 'RSN' 34) ((Expression 17) 'RSN' 35))
   (ReadbackTable 20 ((Expression 10) 'RSN' 40) ((Expression 17) 'RSN' 40) ((Expression 2) 'RSN' 40) ((Expression 13) 'RSN' 40) ((Expression 14) 'RSN' 40))
   (ReadbackTable 21 ((Term 12) 'RSN' 41) ((Term 3) 'RSN' 41))
   (ReadbackTable 22 ((Identifier 4) 'RSN' 42) ((Identifier 11) 'RSN' 42))
   (ReadbackTable 23 ((Expression 13) 'RSN' 34) ((Expression 17) 'RSN' 35))
   (ReadbackTable 24 ((Identifier 4) 'RSN' 43) ((Identifier 18) 'RSN' 33))
   (ShiftbackTable 25 1 37)
   (ShiftbackTable 26 1 36)
   (ShiftbackTable 27 1 38)
   (ShiftbackTable 28 1 39)
   (ShiftbackTable 29 3 39)
   (ShiftbackTable 30 2 20)
   (ShiftbackTable 31 2 21)
   (ShiftbackTable 32 1 19)
   (ShiftbackTable 33 3 24)
   (ShiftbackTable 34 1 22)
   (ShiftbackTable 35 1 23)
   (ReduceTable 36 Expression (1 'RSN' 2)(5 'RSN' 10)(8 'RSN' 13)(9 'RSN' 14)(15 'RSN' 17))
   (ReduceTable 37 Grammar (1 'RSN' 44))
   (ReduceTable 38 Term (1 'RSN' 3)(5 'RSN' 3)(6 'RSN' 12)(8 'RSN' 3)(9 'RSN' 3)(15 'RSN' 3))
   (ReduceTable 39 Primary (1 'RSN' 27)(5 'RSN' 27)(6 'RSN' 27)(7 'RSN' 31)(8 'RSN' 27)(9 'RSN' 27)(15 'RSN' 27))
   (SemanticTable 40 buildTree: '+' 36)
   (SemanticTable 41 buildTree: '*' 38)
   (SemanticTable 42 buildTree: send 39)
   (SemanticTable 43 buildTree: '<-' 37)
   (AcceptTable 44))!   !

!SampleTranslator class methods !
rawScannerTables
    "Scanner rawScannerTables"

    "EndOfFileCharacter is 256"
    ^
#(
   (ScannerReadaheadTable 1 ((256) 'L' 5) (')' 'RK' 7) ('*' 'RK' 8) ('+' 'RK' 9) (',' 'RK' 10) ('0123456789' 'RK' 2) ('(' 'RK' 6) (';' 'RK' 12) ('=' 'RK' 13) ('ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz' 'RK' 3) ((9 10 12 13) 'R' 4) (' ' 'R' 4))
   (ScannerReadaheadTable 2 ((9 10 12 13 256) 'L' 11) ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_+*=[]{}()^;#:.$ ' 'L' 11) ('0123456789' 'RK' 2))
   (ScannerReadaheadTable 3 ((9 10 12 13 256) 'L' 14) ('+*=[]{}()^;#:.$ ' 'L' 14) ('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz' 'RK' 3))
   (ScannerReadaheadTable 4 ((256) 'L' 1) ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_0123456789+*=[]{}()^;#:.$' 'L' 1) ((9 10 12 13) 'R' 4) (' ' 'R' 4))
   (SemanticTable 5 buildToken: '-|' 1)
   (SemanticTable 6 buildToken: '(' 1)
   (SemanticTable 7 buildToken: ')' 1)
   (SemanticTable 8 buildToken: '*' 1)
   (SemanticTable 9 buildToken: '+' 1)
   (SemanticTable 10 buildToken: ',' 1)
   (SemanticTable 11 buildToken: Integer 1)
   (SemanticTable 12 buildToken: ';' 1)
   (SemanticTable 13 buildToken: '=' 1)
   (SemanticTable 14 buildToken: Identifier 1))! !
(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('raw tables' rawParserTables rawScannerTables )) !

(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('raw tables' rawParserTables rawScannerTables )) !



!SampleTranslator class methods !  
evaluateExample1
    "SampleTranslator evaluateExample1"
    ^SampleTranslator new evaluate: '1+ 2*3'!    !

!SampleTranslator class methods !
compileExample1
    "SampleTranslator compileExample1"
    ^SampleTranslator new compile: '1+ 2*3'!   !

!SampleTranslator class methods !
promptForCompilation
    "SampleTranslator promptForCompilation"
    ^SampleTranslator new 
        compile: (Prompter prompt: 'Expression to compile' default: '1+2*3')!    !

!SampleTranslator class methods !
promptForEvaluation
    "SampleTranslator promptForEvaluation"
    ^SampleTranslator new 
        evaluate: (Prompter prompt: 'Expression to evaluate' default: '1+2*3')!    !
(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('examples' evaluateExample1 promptForEvaluation compileExample1 promptForCompilation )) !

(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('examples' evaluateExample1 promptForEvaluation compileExample1 promptForCompilation )) !



!SampleTranslator methods !  
initialize
    parser := Parser 
        for: self 
        parserTables: self class rawParserTables 
        scannerTables: self class rawScannerTables.
    codeIfCompiler := WriteStream on: (String new: 1000).
    expressionsIfEvaluator := Dictionary new. "each key is a variable"
    compilationOperatorMap := Dictionary new
        at: #+ put: #compilePlus:;
        at: #- put: #compileMinus:;
        at: #* put: #compileMultiply:;
        at: #/ put: #compileDivide:;
        at: #'<-' put: #compileAssign:;
        at: #'Identifier' put: #compileIdentifier:;
        at: #'Integer' put: #compileInteger:;
        at: #'send' put: #compileFunctionCall:;
        at: #'where' put: #compileWhere:;
        yourself.
    evaluationOperatorMap := Dictionary new
        at: #+ put: #evaluatePlus:;
        at: #- put: #evaluateMinus:;
        at: #* put: #evaluateMultiply:;
        at: #/ put: #evaluateDivide:;
        at: #'<-' put: #evaluateAssign:;
        at: #'Identifier' put: #evaluateIdentifier:;
        at: #'Integer' put: #evaluateInteger:;
        at: #'send' put: #evaluateFunctionCall:;
        at: #'where' put: #evaluateWhere:;
        yourself!  !

"evaluate"   
(CodeFiler organizerFor: SampleTranslator) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('initializing' initialize )) !



!SampleTranslator methods !
parser: aParser
    parser := aParser! !

!SampleTranslator methods !  
tree
    ^tree!    !

!SampleTranslator methods !  
tree: aTree
    tree := aTree! !

!SampleTranslator methods !  
parser
    ^parser!    !
(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('get/set' parser: tree tree: parser )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('get/set' parser: tree tree: parser )) !



!SampleTranslator methods !
evaluate: text
    | result |
    "If no variables are set up, just return the expression; otherwise, a dictionary of variables."
    tree := parser parse: text.
    self halt: 'See tree returned by parser'.
    result := self evaluateExpressionFor: tree.
    self halt: 'See result and variable dictionary'.
    expressionsIfEvaluator size = 0 ifTrue: [^result] ifFalse: [^expressionsIfEvaluator]!   !

!SampleTranslator methods !  
evaluateExpressionFor: tree
    ^self perform: (evaluationOperatorMap at: tree label asSymbol) with: tree! !

!SampleTranslator methods !  
compileExpressionFor: tree
    self perform: (compilationOperatorMap at: tree label asSymbol) with: tree!  !

!SampleTranslator methods !  
compile: text
    tree := parser parse: text.
    self compileExpressionFor: tree.
    ^codeIfCompiler contents! !
(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compiling/evaluating' evaluate: compileExpressionFor: compile: evaluateExpressionFor: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compiling/evaluating' evaluate: compileExpressionFor: compile: evaluateExpressionFor: )) !



!SampleTranslator methods !  
generate: instruction
    codeIfCompiler cr; << instruction!   !

!SampleTranslator methods !  
generate: instruction with: operand
    codeIfCompiler cr; << instruction; << ' '; << operand! !
(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compilation support' generate: generate:with: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compilation support' generate: generate:with: )) !




!SampleTranslator methods !
compileAssign: tree
    1 to: tree children size by: 2 do: [:index |
            self compileExpressionFor: (tree child: index + 1).
            self generate: 'POP' with: (tree child: index) symbol]! !

!SampleTranslator methods !  
compileFunctionCall: tree
    tree children rest do: [:child | self compileExpressionFor: child]. 
    self generate: 'FUNCTION_CALL' with: (tree child: 1) symbol!   !

!SampleTranslator methods !  
compilePlus: tree
    self compileExpressionFor: (tree child: 1).
    self compileExpressionFor: (tree child: 2).
    self generate: 'ADD'.! !

!SampleTranslator methods !  
compileDivide: tree
    self compileExpressionFor: (tree child: 1).
    self compileExpressionFor: (tree child: 2).
    self generate: 'DIVIDE'.!    !

!SampleTranslator methods !  
compileWhere: tree
    "Not currently implementing where properly since ignoring other children."
    self halt: 'compile WHERE'.
    self compileExpressionFor: (tree child: 1).!   !

!SampleTranslator methods !  
compileMultiply: tree
    self compileExpressionFor: (tree child: 1).
    self compileExpressionFor: (tree child: 2).
    self generate: 'MULTIPLY'.!    !

!SampleTranslator methods !  
compileInteger: token
    self generate: 'PUSH' with: token symbol asInteger!  !

!SampleTranslator methods !  
compileIdentifier: token
    self generate: 'PUSH' with: token symbol! !

!SampleTranslator methods !  
compileMinus: tree
    self halt: 'compile MINUS'.!    !
(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compilation details' compileAssign: compileFunctionCall: compilePlus: compileDivide: compileWhere: compileMultiply: compileInteger: compileIdentifier: compileMinus: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compilation details' compileAssign: compileFunctionCall: compilePlus: compileDivide: compileWhere: compileMultiply: compileInteger: compileIdentifier: compileMinus: )) !



!SampleTranslator methods !
evaluatePlus: aTree
    ^(self evaluateExpressionFor: (aTree child: 1)) + (self evaluateExpressionFor: (aTree child: 2))!  !

!SampleTranslator methods !  
evaluateInteger: token
    ^token symbol asInteger!    !

!SampleTranslator methods !  
evaluateDivide: tree
    | expression1 expression2 |
    expression1 := self evaluateExpressionFor: (tree child: 1).
    expression2 := self evaluateExpressionFor: (tree child: 2).
    ^expression1 / expression2!    !

!SampleTranslator methods !  
evaluateWhere: tree
    "Evaluate all but the first expression to obtain the values for individual variables,
    then store them in expressionsIfEvaluator and finally evaluate the first expression."
    self halt: 'evaluate WHERE'! !

!SampleTranslator methods !  
evaluateMinus: tree
   self halt: 'evaluate MINUS'!    !

!SampleTranslator methods !  
evaluateAssign: token
    | expression |
    expression := self evaluateExpressionFor: (tree child: 2).
    expressionsIfEvaluator at: (tree child: 1) symbol put: expression!   !

!SampleTranslator methods !  
evaluateFunctionCall: tree
    | function parameters |
    function := (tree child: 1) label.
    parameters := tree children rest collect: [:child | self evaluateExpressionFor: child].  
    
    function = #tan ifTrue: [^parameters first tan] ifFalse: [
    function = #abs ifTrue: [^parameters first abs]].
    
    self halt: 'Function ', function printString, ' not yet handled'!    !

!SampleTranslator methods !  
evaluateIdentifier: token
    | identifier |
    identifier := token symbol.
    ^expressionsIfEvaluator at: identifier ifAbsent: [self halt: 'Identifier ', identifier printString, ' is not defined'].!    !

!SampleTranslator methods !  
evaluateMultiply: tree
    | expression1 expression2 |
    expression1 := self evaluateExpressionFor: (tree child: 1).
    expression2 := self evaluateExpressionFor: (tree child: 2).
    ^expression1 * expression2!  !
(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('evaluation details' evaluatePlus: evaluateInteger: evaluateDivide: evaluateWhere: evaluateMinus: evaluateAssign: evaluateFunctionCall: evaluateIdentifier: evaluateMultiply: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('evaluation details' evaluatePlus: evaluateInteger: evaluateDivide: evaluateWhere: evaluateMinus: evaluateAssign: evaluateFunctionCall: evaluateIdentifier: evaluateMultiply: )) !

CodeFiler setCommentFor: SampleTranslator to: ''!


"define class"  

Object subclass: #Table
  instanceVariableNames: 
    ' transducer '
  classVariableNames: ''
  poolDictionaries: ''!

"define class" 

Object subclass: #Transducer
  instanceVariableNames: 
    ' sponsor tables '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"

Table subclass: #TableWithTransitions
  instanceVariableNames: 
    ' transitions '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"  

Table subclass: #AcceptTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

"define class"  

Object subclass: #Tree
  instanceVariableNames: 
    ' label children '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"  

TableWithTransitions subclass: #ScannerReadaheadTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

"define class" 

TableWithTransitions subclass: #ReadaheadTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

"define class"

TableWithTransitions subclass: #ReadbackTable
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!

"define class" 

Transducer subclass: #Screener
  instanceVariableNames: 
    ' keywords '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"

Table subclass: #SemanticTable
  instanceVariableNames: 
    ' action parameters goto '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"  

Transducer subclass: #Parser
  instanceVariableNames: 
    ' scanner screener tokenStack tableNumberStack treeStack left right tableNumber newTree '
  classVariableNames: ''
  poolDictionaries: ''!

"define class" 

TableWithTransitions subclass: #ReduceTable
  instanceVariableNames: 
    ' nonterminal '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"

Transducer subclass: #Scanner
  instanceVariableNames: 
    ' input token keptCharacters '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"   

Object subclass: #Token
  instanceVariableNames: 
    ' label symbol '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"   

Table subclass: #ShiftbackTable
  instanceVariableNames: 
    ' shift goto '
  classVariableNames: ''
  poolDictionaries: ''!

"define class" 

Object subclass: #Table
  instanceVariableNames: 
    ' transducer '
  classVariableNames: ''
  poolDictionaries: ''!

"define class" 

Object subclass: #SampleTranslator
  instanceVariableNames: 
    ' parser tree codeIfCompiler expressionsIfEvaluator compilationOperatorMap evaluationOperatorMap '
  classVariableNames: ''
  poolDictionaries: ''!


!Table methods !  
transducer: aTransducer
    transducer := aTransducer! !

!Table methods ! 
transducer
    ^transducer!    !
(CodeFiler organizerFor: Table) reorganizeFrom: #(
('get/set' transducer: transducer )) !

(CodeFiler organizerFor: Table) reorganizeFrom: #(
('get/set' transducer: transducer )) !
CodeFiler setCommentFor: Table to: ''!



!AcceptTable methods ! 
table: aTable
    "Do nothing."!   !
(CodeFiler organizerFor: AcceptTable) reorganizeFrom: #(
('get/set' table: )) !

(CodeFiler organizerFor: AcceptTable) reorganizeFrom: #(
('get/set' table: )) !



!AcceptTable methods ! 
run
    ^nil "Ensure that parsing does not continue..."!   !
(CodeFiler organizerFor: AcceptTable) reorganizeFrom: #(
('running' run )) !

(CodeFiler organizerFor: AcceptTable) reorganizeFrom: #(
('running' run )) !
CodeFiler setCommentFor: AcceptTable to: ''!



!Tree class methods !  
fromOldStyleArray: anObject
    "This assumes the array encode the tree in LISP notation; e.g. (root child1 child2 child3 ...)."
    (anObject isKindOf: Array) ifTrue: [^Tree new label: anObject first; children: (anObject rest collect: [:object | self fromArray: object])].
    (anObject isKindOf: Number) ifTrue: [^Token new label: #Integer; symbol: anObject printString].
    (anObject isKindOf: Character) ifTrue: [^Token new label: #Character; symbol: (String with: anObject)].
    (anObject isKindOf: Symbol) ifTrue: [^Token new label: #Identifier; symbol: anObject]. "or Symbol"
    (anObject isKindOf: String) ifTrue: [^Token new label: #SingleQuotedString; symbol: anObject].
    
    "We can't distinguish a symbol from an identifier because all identifiers become symbols in array literals."
    "We can't distinguish a SingleQuotedString from a DoubleQuotedString because all strings are single quoted in Smalltalk"
    
    ^self halt: 'Tree fromArray: did not expects the objects ', anObject printString!    !

!Tree class methods !
new

    ^super new initialize!   !

!Tree class methods !
fromArray: anObject
    "This assumes the array encode the tree in LISP notation; e.g. (root child1 child2 child3 ...)."
    (anObject isKindOf: Array) ifTrue: [^Tree new label: anObject first; children: (anObject rest collect: [:object | self fromArray: object])].
    (anObject isKindOf: Integer) ifTrue: [^Token new label: #walkInteger; symbol: anObject printString].
    (anObject isKindOf: Character) ifTrue: [^Token new label: #walkCharacter; symbol: (String with: anObject)].
    (anObject isKindOf: Symbol) ifTrue: [^Token new label: #walkIdentifier; symbol: anObject]. "or Symbol"
    (anObject isKindOf: String) ifTrue: [^Token new label: #walkString; symbol: anObject].
    
    "We can't distinguish a symbol from an identifier because all identifiers become symbols in array literals."
    ^self halt: 'Tree fromArray: did not expects the object ', anObject printString!    !
(CodeFiler organizerFor: Tree class) reorganizeFrom: #(
('instance creation' fromOldStyleArray: new fromArray: )) !

(CodeFiler organizerFor: Tree class) reorganizeFrom: #(
('instance creation' fromOldStyleArray: new fromArray: )) !



!Tree methods !
initialize
    children := OrderedCollection new.! !
(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('initializing' initialize )) !



!Tree methods !
children
    ^children!    !

!Tree methods !  
label: aSymbol
    label := aSymbol!   !

!Tree methods !  
label
    ^label!  !

!Tree methods !  
child: index
    ^children at: index!  !

!Tree methods !  
children: aCollection
    children := aCollection! !
(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('get/set' children label: label child: children: )) !

(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('get/set' children label: label child: children: )) !



!Tree methods !  
addChild: aTree
    children add: aTree!   !
(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('modifying' addChild: )) !

(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('modifying' addChild: )) !



!Tree methods !
printOn: aStream
    self printOn: aStream tabs: 0.!   !

!Tree methods !  
printOn: aStream tabs: tabs
    aStream cr.
    tabs timesRepeat: [aStream << '   '].
    aStream << self label.
    children do: [:child | child printOn: aStream tabs: tabs + 1]! !
(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('printing' printOn: printOn:tabs: )) !

(CodeFiler organizerFor: Tree) reorganizeFrom: #(
('printing' printOn: printOn:tabs: )) !
CodeFiler setCommentFor: Tree to: ''!



!ScannerReadaheadTable methods !
table: anArray
    "Record the triples: an integer or character collection, attributes, and goto. The integers
    are unprintable characters or the end of file integer 256, the attributes are $R for read 
    ($L for stack) and $K for keep. It's particularly important here to store the data so that
    given a character or 256, you can perform a fast lookup to find the triple."
    
    transitions := Dictionary new.
    anArray do: [:triple |
        triple first do: [:characterOrInteger | transitions at: characterOrInteger asInteger put: triple rest]]
        
    "OLD WAY:
    anArray groupsDo: [:item :attributes :goto |
        item isString 
                ifTrue: [item do: [:character | transitions at: character asInteger put: (Array with: attributes with: goto)]]
                ifFalse: [item do: [:integer | transitions at: integer put: (Array with: attributes with: goto)]]]
    "! !
(CodeFiler organizerFor: ScannerReadaheadTable) reorganizeFrom: #(
('get/set' table: )) !

(CodeFiler organizerFor: ScannerReadaheadTable) reorganizeFrom: #(
('get/set' table: )) !



!ScannerReadaheadTable methods !   
printables
    "The last three printable characters are single quote (represented as two single quotest in a row; i.e. ''),
    double quote (represented as one double quote; the end of comment is a double quote), and a space.
    Note: that it's hard to see the difference between two single quotes and one double quote."
    
    ^'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!!,+-/\*~=@%&?|<>[]{}()^;#:.$_''" '.!  !

!ScannerReadaheadTable methods ! 
run
    | character isKeep isRead pair |

    "Consider the next input character or integer (it could be 256 for endOfFile).
    Search the transitions for the triple that matches it. Remember: the original
    data was triples: an integer or character collection, attributes, and goto. But
    for fast lookup, you want to just be able to look up the triple using the next
    input as a key... When you find it, the read attribute ($R as opposed to $L)
    indicates that you need to remove it from the input. Otherwise, it stays for future 
    use. If it has the keep attribute ($K), you need to append the character to
    'keptCharacters'. If you can't find it, it a lexical error (see reportLexicalError).
    When you are done, return the goto table."
    
    character := transducer peekInput.
    pair := transitions at: character asInteger ifAbsent: [nil].
    pair notNil ifTrue: [
        pair groupDo: [:attributes :goto |
            isRead := attributes includes: $R.
            isKeep := attributes includes: $K.
            isRead ifFalse: [^goto].
            isKeep ifTrue: [transducer keptCharacters: (transducer keptCharacters, character asString)].
            transducer discardInput.
            ^goto]].
            
    self reportLexicalError!   !

!ScannerReadaheadTable methods ! 
reportLexicalError
    | characterAsInteger character printables |

    characterAsInteger := transducer peekInput.
    characterAsInteger = 256 ifTrue: [self error: 'Lexical error: End of the file encountered unexpectedly'].
    character := characterAsInteger asCharacter.
    
    (self printables includes: character) 
        ifTrue: [self error: 'Lexical error, encountered unexpected character ', character asString]
        ifFalse: [
            self error: 'Lexical error, encountered unexpected unprintable character',
                ' hex ', (character asNumber printStringRadix: 16),
                ' decimal ', character asNumber printString]! !
(CodeFiler organizerFor: ScannerReadaheadTable) reorganizeFrom: #(
('running' printables run reportLexicalError )) !

(CodeFiler organizerFor: ScannerReadaheadTable) reorganizeFrom: #(
('running' printables run reportLexicalError )) !
CodeFiler setCommentFor: ScannerReadaheadTable to: ''!




!ReadaheadTable methods !  
reportSyntaxError
    | token inputTokens inputText position |
            
    token := transducer peekScannerToken.
    inputTokens := transducer tokenStack rest. "Skip start stack information."
    
    Transcript cr; << 'Syntax error...'. 
    inputTokens isEmpty 
        ifTrue: [Transcript cr; << 'Did not expect input to start with '. Transcript << token]
        ifFalse: [
            Transcript cr; << 'DID NOT EXPECT'; << (inputTokens size > 6 ifTrue: [' ...'] ifFalse: ['']).
            inputTokens := inputTokens suffix: 6.
            inputTokens do: [:token | Transcript << ' '; << token].
            Transcript cr; << 'TO BE FOLLOWED BY '; << token.
            inputText := transducer scanner input collection. position := transducer scanner input position.
            Transcript << (inputText copyFrom: (position + 1 max: 1) to: (position + 100 min: inputText size))].
    self error: ('Syntax error: Illegal symbol: ', token label)! !

!ReadaheadTable methods !
run
    | token tokenLabel transition isRead isNode isStack |

    "Peek at the next token label..."
    tokenLabel := (token := transducer peekScannerToken) label asSymbol.

    "and then use the transition that matches it if there is one. Use the attributes to determine
    what to do. If there isn't one, it's a syntax error. Remember $R means read ($L look), $N
    means make the token part of a tree, and $S means stack. If we stack, we also need 'right'
    to refer to the last entry and 'left' to be one more to the right. Finally, returns the corresponding
    goto state."

    transition := transitions at: tokenLabel ifAbsent: [^self reportSyntaxError].
    transition groupDo: [:attributes :goto |
        isRead := attributes includes: $R.
        isNode := attributes includes: $N.
        isStack := attributes includes: $S.
        isRead ifFalse: [^goto].
        transducer discardScannerToken.
        isStack ifTrue: [
            transducer tokenStack add: token.
            transducer tableNumberStack add: goto.
            transducer treeStack add: (isNode ifTrue: [token] ifFalse: [nil]).
            transducer right: transducer tokenStack size.
            transducer left: transducer right + 1].
        ^goto].!   !
(CodeFiler organizerFor: ReadaheadTable) reorganizeFrom: #(
('running' reportSyntaxError run )) !

(CodeFiler organizerFor: ReadaheadTable) reorganizeFrom: #(
('running' reportSyntaxError run )) !



!ReadaheadTable methods !  
runUNUSEDVersionThatSearches
    | token tokenLabel isRead isNode isStack |

    "Peek at the next token label..."
    tokenLabel := (token := transducer peekScannerToken) label asSymbol.

    "and then search for a transition that matches it. When found, use the attributes to determine
    what to do. If you don't find it, it's a syntax error. Remember $R means read ($L look), $N
    means make the token part of a tree, and $S means stack. If we stack, we also need 'right'
    to refer to the last entry and 'left' to be one more to the right. Finally, returns the corresponding
    goto state."

    transitions groupsDo: [:symbol :attributes :goto |
        tokenLabel == symbol ifTrue: [
            isRead := attributes includes: $R.
            isNode := attributes includes: $N.
            isStack := attributes includes: $S.
            isRead ifFalse: [^goto].
            transducer discardScannerToken.
            isStack ifTrue: [
                transducer tokenStack add: token.
                transducer tableNumberStack add: goto.
                transducer treeStack add: (isNode ifTrue: [token] ifFalse: [nil]).
                transducer right: transducer tokenStack size.
                transducer left: transducer right + 1].
            ^goto]].

    self reportSyntaxError!    !

!ReadaheadTable methods !
tableUNUSEDVersionThatSearches: anArray
    "Record the data unmodified so you can later perform a fast search."
    transitions := anArray!  !
(CodeFiler organizerFor: ReadaheadTable) reorganizeFrom: #(
('unused' runUNUSEDVersionThatSearches tableUNUSEDVersionThatSearches: )) !

(CodeFiler organizerFor: ReadaheadTable) reorganizeFrom: #(
('unused' runUNUSEDVersionThatSearches tableUNUSEDVersionThatSearches: )) !
CodeFiler setCommentFor: ReadaheadTable to: ''!



!TableWithTransitions methods !   
table: anArray
    "Record the data so you can later perform a fast lookup."
    transitions := Dictionary new.
    anArray do: [:triple | transitions at: triple first put: triple rest]!   !
(CodeFiler organizerFor: TableWithTransitions) reorganizeFrom: #(
('get/set' table: )) !

(CodeFiler organizerFor: TableWithTransitions) reorganizeFrom: #(
('get/set' table: )) !
CodeFiler setCommentFor: TableWithTransitions to: ''!




!ReadbackTable methods !
run
    | pair transition isRead |
    "Readback considers the token label in the token stack and the state number in the table number at position 'left - 1'
    and then uses the transition that matches it. If there isn't one it's a design error. Otherwise, it then uses the attribute $R for read, $L for look to
    decide what to do. If it's read, it decrements 'left'. Finally it returns the goto state."

    pair := Array with: (transducer tokenStack at: transducer left - 1) label with: (transducer tableNumberStack at: transducer left - 1).
    transition := transitions at: pair ifAbsent: [^self reportDesignError].
    transition groupDo: [:attributes :goto |
        isRead := attributes  includes: $R.
        isRead ifTrue: [transducer left: transducer left - 1].
        ^goto].!    !

!ReadbackTable methods ! 
reportDesignError
    self error: 'Design error: reached end of ReadbackTable without having found a suitable transition'! !
(CodeFiler organizerFor: ReadbackTable) reorganizeFrom: #(
('running' run reportDesignError )) !

(CodeFiler organizerFor: ReadbackTable) reorganizeFrom: #(
('running' run reportDesignError )) !



!ReadbackTable methods ! 
tableUNUSEDVersionThatSearches: anArray
    "Store the data, old state number/symbol/new state number triples for search in run."
    | pair |
    transitions := anArray collect: [:triple |
        pair := triple first.
        Array with: (Array with: pair first asSymbol with: pair second) with: triple second with: triple third]!   !

!ReadbackTable methods ! 
runUNUSEDVersionThatSearches
    | pair isRead |
    "Readback considers the token label in the token stack and the state number in the table number at position 'left - 1'
    and then finds the transition that matches it. When it finds it, it then uses the attribute $R for read, $L for look to
    decide what to do. If it's read, it decrements 'left'. Finally it returns the goto state."
    
    pair := Array with: (transducer tokenStack at: transducer left - 1) label with: (transducer tableNumberStack at: transducer left - 1).
    transitions groupsDo: [:nextPair :attributes :goto |
        pair = nextPair ifTrue:[
            isRead := attributes  includes: $R.
            isRead ifTrue: [transducer left: transducer left - 1].
            ^goto]].
    self reportDesignError!    !
(CodeFiler organizerFor: ReadbackTable) reorganizeFrom: #(
('unused' tableUNUSEDVersionThatSearches: runUNUSEDVersionThatSearches )) !

(CodeFiler organizerFor: ReadbackTable) reorganizeFrom: #(
('unused' tableUNUSEDVersionThatSearches: runUNUSEDVersionThatSearches )) !
CodeFiler setCommentFor: ReadbackTable to: ''!




!Screener methods !
keywords
    ^keywords!    !

!Screener methods !  
keywords: aCollection
    keywords := aCollection! !
(CodeFiler organizerFor: Screener) reorganizeFrom: #(
('get/set' keywords keywords: )) !

(CodeFiler organizerFor: Screener) reorganizeFrom: #(
('get/set' keywords keywords: )) !



!Screener methods !  
screen: aToken
    "Older name is #Identifier, newer name is #walkIdentifier:"
    (aToken label = #Identifier) | (aToken label = #walkIdentifier:) ifFalse: [^aToken]. 
    (self keywords includes: aToken symbol) ifFalse: [^aToken].
    ^Token new label: aToken symbol; symbol: aToken symbol.!   !
(CodeFiler organizerFor: Screener) reorganizeFrom: #(
('screening' screen: )) !

(CodeFiler organizerFor: Screener) reorganizeFrom: #(
('screening' screen: )) !
CodeFiler setCommentFor: Screener to: ''!



!SemanticTable methods !
table: aTable
    action := aTable first.
    parameters := aTable copyFrom: 2 to: aTable size - 1.
    goto := aTable last! !

!SemanticTable methods ! 
action: aSymbol
    action := aSymbol! !

!SemanticTable methods ! 
parameters
    ^parameters!    !

!SemanticTable methods ! 
goto
    ^goto!    !

!SemanticTable methods ! 
parameters: aCollection
    parameters := aCollection! !

!SemanticTable methods ! 
goto: aNumber
    goto := aNumber! !

!SemanticTable methods ! 
action
    ^action!    !
(CodeFiler organizerFor: SemanticTable) reorganizeFrom: #(
('get/set' table: action: parameters goto parameters: goto: action )) !

(CodeFiler organizerFor: SemanticTable) reorganizeFrom: #(
('get/set' table: action: parameters goto parameters: goto: action )) !



!SemanticTable methods ! 
run
    | recipient |
    recipient := (transducer class canUnderstand: action) ifTrue: [transducer] ifFalse: [transducer sponsor].
    recipient perform: action withArguments: parameters.
    ^goto! !
(CodeFiler organizerFor: SemanticTable) reorganizeFrom: #(
('running' run )) !

(CodeFiler organizerFor: SemanticTable) reorganizeFrom: #(
('running' run )) !
CodeFiler setCommentFor: SemanticTable to: ''!



!Parser class methods !  
for: aSponsor parserTables: parserTables scannerTables: scannerTables
    | parser |
    parser := self new.
    
    "Set up the user (or sponsor) of the scanner and parser."
    parser sponsor: aSponsor. parser scanner sponsor: aSponsor.
    
    "Give the keywords to the screener and the remaining tables to the parser..."
    parser tables: parserTables rest; screener: (Screener new keywords: parserTables first rest).
    
    "Give the entire set of scanner tables to the scanner..."
    parser scanner tables: scannerTables.
    
    ^parser!    !
(CodeFiler organizerFor: Parser class) reorganizeFrom: #(
('instance creation' for:parserTables:scannerTables: )) !

(CodeFiler organizerFor: Parser class) reorganizeFrom: #(
('instance creation' for:parserTables:scannerTables: )) !



!Parser methods !  
initialize
    scanner := Scanner new. screener := Screener new.
    tokenStack := OrderedCollection new add: (Token new label: #'|-'; symbol: #'|-'); yourself.
    treeStack := OrderedCollection new add: nil; yourself.
    tableNumberStack := OrderedCollection new add: 1; yourself.
    left := 1. right := 1.!    !
(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('initializing' initialize )) !



!Parser methods !  
screener: aScreener
    screener := aScreener! !

!Parser methods !
screener
    ^screener!    !

!Parser methods !
right
    ^right!  !

!Parser methods !
tokenStack: aCollection
    tokenStack := aCollection! !

!Parser methods !
treeStack
    ^treeStack!  !

!Parser methods !
left: aNumber
    left := aNumber! !

!Parser methods !
tableNumberStack: aCollection
    tableNumberStack := aCollection! !

!Parser methods !
tokenStack
    ^tokenStack!    !

!Parser methods !
tableNumberStack
    ^tableNumberStack!    !

!Parser methods !
tables: aCollection
    "Store the collection of all table objects in tables. Moreover, each type of table will store it's data
    in its own way. So, you had better let the object store it. Note: The collection contains the NAMES for the types
    of table objects, they are not table objects. Also, whoever sent this message had better not have 
    included an entry for a keyword list since that was supposed to have been given to the screener.
    IN OTHER WORDS: Create the appropriate kind of table object, give the table data to that object, and 
    then store that object in the parser's tables."
    
    "HINT: 'Smalltalk at: x' where x is a variable containing the symbol #Apple returns the class object called
    Apple. Once you have a class object, you can say new to it."
    
    tables := aCollection collect:[ :element |     
        "Each table is of the form (tableType tableNumber ...)."
        "Get the class name for the type, then make a new instance, then give it the table and tell it that I'm it's transducer."
        (Smalltalk at: element first) new table: (element copyFrom: 3); transducer: self ].!    !

!Parser methods !
newTree
    ^newTree!  !

!Parser methods !
scanner
    ^scanner!  !

!Parser methods !
right: aNumber
    right := aNumber!   !

!Parser methods !
treeStack: aCollection
    treeStack := aCollection!   !

!Parser methods !
tables
    ^tables!    !

!Parser methods !
left
    ^left!    !

!Parser methods !
newTree: aTree
    newTree := aTree!   !

!Parser methods !
scanner: aScanner
    scanner := aScanner! !
(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('get/set' screener: tokenStack: screener tables: treeStack left: tokenStack tableNumberStack: tableNumberStack right newTree scanner right: treeStack: tables left newTree: scanner: )) !

(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('get/set' screener: tokenStack: screener tables: treeStack left: tokenStack tableNumberStack: tableNumberStack right newTree scanner right: treeStack: tables left newTree: scanner: )) !



!Parser methods !
parse: text
    "To parse the text, you have to give it to the scanner (say via scan: text).
    It in turn should have the first token set up for you. Next you need
    to execute tables starting from table 1 until you reach an Accept table.
    Once that happen, the tree that was built should be on top of the tree
    stack. Just return it. If you look at the Accept table, you will see
    that it of all the tables, it is the only one that returns nil. You can
    use that information to stop your loop."
    | table |
    
    scanner scan: text.
    tableNumber := 1. table := tables at: tableNumber.
    [table class = AcceptTable ] whileFalse: [
        self log. "<---for debugging. You might want to comment this out for now"
        tableNumber := table run.
        table := tables at: tableNumber.].
    ^treeStack last!    !
(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('parsing' parse: )) !

(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('parsing' parse: )) !



!Parser methods !
discardScannerToken
    scanner discardToken.! !

!Parser methods !
peekScannerToken
    ^screener screen: scanner peekToken.! !
(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('streaming' discardScannerToken peekScannerToken )) !

(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('streaming' discardScannerToken peekScannerToken )) !



!Parser methods !
buildTreeFromIndex: index
    "Index is positive (1, 2, 3, ...) => label is in the token relative to the left end; i.e., to the right of left end."
    "index is negative (-1, -2, -3...) => label is in the token relative to the right end; i.e., to the left of right end."
    | children |    
    children := (left to: right) collect: [:index | treeStack at: index] when: [:index | (treeStack at: index) notNil].
    newTree := Tree new 
        label:  (index isPositive ifTrue: [tokenStack at: left + index - 1] ifFalse: [tokenStack at: right + index + 1]) symbol
        children: children.!   !

!Parser methods !
buildTree: rootNode
    "Pick up the children from the tree stack between left and     right inclusive (provided they're not nil) and 
    build a tree with the given label. Store it in instance variable newTree so a reduce table can use it."
    
    | children |
    children := (left to: right) collect: [:index | treeStack at: index] when: [:index | (treeStack at: index) notNil].
    newTree := Tree new label: rootNode; children: children.!    !
(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('semanticActions' buildTreeFromIndex: buildTree: )) !

(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('semanticActions' buildTreeFromIndex: buildTree: )) !



!Parser methods !
log
    | table useTerseTree whichCharacterToStartLogging |
    true ifTrue: [^self]. "currently disabled"
    whichCharacterToStartLogging := 4040.
    scanner input position < whichCharacterToStartLogging ifTrue: [^self].
    useTerseTree := true. "Set to false if more details are wanted..."
    table := tables at: tableNumber.

    "Log a preliminary heading..."
    Transcript cr; << 'At '; << scanner input position; << self peekScannerToken; << ' | left '; << left; << ' right '; << right; << ' |'; << ' Table '; << tableNumber; space; << table.

    "Log state specific information..."
    table class = ReadaheadTable ifTrue: [Transcript << ' SEARCHING FOR '; << self peekScannerToken label].
    table class = ReadbackTable ifTrue: [Transcript << ' SEARCHING FOR ';
        << '['; << (tokenStack at: left - 1) label; << ' '; << (tableNumberStack at: left - 1); << ']'].
    table class = ReduceTable ifTrue: [Transcript space; << table nonterminal; << ' SEARCHING FOR ';
        << (tableNumberStack at: left - 1)].
    table class = ShiftbackTable ifTrue: [Transcript << ' SHIFT '; << table shift; << ' GOTO '; << table goto].
    (table class = SemanticTable) ifTrue: [
        Transcript space; << table action. table parameters do: [:parameter | Transcript space; << parameter].
        Transcript << ' GOTO '; << table goto].

    "Log information in the stacks..."
    self treeStack indexedDo: [:index :tree |
        (index = left and: [left <= right]) ifTrue: [Transcript cr; << '       ---------------------------'].
        Transcript cr; << '       '; << index; << ' ['; << (self tokenStack at: index); << ' '; << (self tableNumberStack at: index); << '] '.
        tree isNil ifFalse:[useTerseTree ifTrue: [Transcript << ' Tree ('; << tree label; << ' ...)'] ifFalse: [tree printOn: Transcript tabs: 3]].
        (index = right and: [left > right]) ifTrue: [Transcript cr; << '       ---------------------------'].
        index = right ifTrue: [Transcript cr; << '       ---------------------------'].].!  !
(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('debugging' log )) !

(CodeFiler organizerFor: Parser) reorganizeFrom: #(
('debugging' log )) !
CodeFiler setCommentFor: Parser to: ''!



!ReduceTable methods !
nonterminal: aSymbol
    nonterminal := aSymbol!   !

!ReduceTable methods !   
nonterminal
    ^nonterminal!  !

!ReduceTable methods !   
table: anArray
    "Store the data; namely a nonterminal and a bunch of transition information; triples
    with a 'from table numer', attributes, and a 'to table number'."
    nonterminal := anArray first.
    super table: anArray rest!   !
(CodeFiler organizerFor: ReduceTable) reorganizeFrom: #(
('get/set' nonterminal: nonterminal table: )) !

(CodeFiler organizerFor: ReduceTable) reorganizeFrom: #(
('get/set' nonterminal: nonterminal table: )) !



!ReduceTable methods !   
run
    "This is a 'Reduce to A' table where A is the nonterminal to reduce to. Pick up the new tree
    and simulate a readahead of A where the new tree is associated with A"

    | transition children tree tableNumber isStack isNode  |
    "Pick up the new tree if there is one OR bubble up the one tree in the stack between
    'left' and 'right' or nil if there isn't one. There better not be 2 or more."
    transducer newTree notNil
        ifTrue: [
            tree := transducer newTree. transducer newTree: nil]
        ifFalse: [
            "Just capture the one subtree (if any) and have it ready for stacking."
            children := (transducer treeStack copyFrom: transducer left to: transducer right) withoutNils.
            children size = 0 ifTrue: [tree := nil] ifFalse: [
            children size = 1 ifTrue: [tree := children first] ifFalse: [
            self halt: 'Design error: more than 1 child in ReduceTable'. tree := children last]]].

    "Clear the stacks between left and right (inclusive)."
    (transducer left to: transducer right) do: [:index |
        transducer tokenStack removeLast.
        transducer tableNumberStack removeLast.
        transducer treeStack removeLast].

    "Use the top table number on the stack (the 'from table number') to locate the pair (attributes, 'to table number);
    it's a design error if you can't find it. The other table number is to be returned when you're done. Also use the
    attributes in the same manner as you did for a readahead table but this time, instead of using the next token,
    use a new token you create using the nonterminal as it's symbol. Don't forget to adjust 'right' and 'left' like you
    did for the readahead table."

    tableNumber := transducer tableNumberStack last.
    transition := transitions at: tableNumber ifAbsent: [^self reportDesignError].
    transition groupDo: [:attributes :goto |
        isStack := attributes includes: $S. isNode := attributes includes: $N.
        isStack ifTrue: [
            transducer tokenStack add: (Token new label: nonterminal; symbol: nonterminal).
            transducer tableNumberStack add: goto.
            transducer treeStack add: (isNode ifTrue: [tree] ifFalse: [nil])].
        transducer right: transducer treeStack size.
        transducer left: transducer right + 1.
        ^goto].!   !

!ReduceTable methods !   
reportDesignError
    self error: 'Design error: reached end of ReduceTable without having found a suitable transition'!   !
(CodeFiler organizerFor: ReduceTable) reorganizeFrom: #(
('running' run reportDesignError )) !

(CodeFiler organizerFor: ReduceTable) reorganizeFrom: #(
('running' run reportDesignError )) !



!ReduceTable methods !   
runUNUSEDVersionThatSearches
    "This is a 'Reduce to A' table where A is the nonterminal to reduce to. Pick up the new tree
    and simulate a readahead of A where the new tree is associated with A"

    | stack children tree tableNumber isStack isNode token |
    "Pick up the new tree if there is one OR bubble up the one tree in the stack between
    'left' and 'right' or nil if there isn't one. There better not be 2 or more."
    transducer newTree notNil
        ifTrue: [
            tree := transducer newTree. transducer newTree: nil]
        ifFalse: [
            "Just capture the one subtree (if any) and have it ready for stacking."
            children := (transducer treeStack copyFrom: transducer left to: transducer right) withoutNils.
            children size = 0 ifTrue: [tree := nil] ifFalse: [
            children size = 1 ifTrue: [tree := children first] ifFalse: [
            self halt: 'Design error: more than 1 child in ReduceTable'. tree := children last]]].

    "Clear the stacks between left and right (inclusive)."
    (transducer left to: transducer right) do: [:index |
        transducer tokenStack removeLast.
        transducer tableNumberStack removeLast.
        transducer treeStack removeLast].

    "Using the top table number on the stack, search the triples ('from table number, attributes,
    'to table number) and find the one that matches 'from table number'; it's a design error if you can't
    find it. The other table number is to be returned when you're done. Also use the attributes in the
    same manner as you did for a readahead table but this time, instead of using the next token,
    use a new token you create using the nonterminal as it's symbol. Don't forget to adjust
    'right' and 'left' like you did for the readahead table."

    tableNumber := transducer tableNumberStack last.
    transitions groupsDo: [:candidateTableNumber :attributes :goto |
        tableNumber = candidateTableNumber ifTrue: [
            isStack := attributes includes: $S. isNode := attributes includes: $N.
            isStack ifTrue: [
                transducer tokenStack add: (Token new label: nonterminal; symbol: nonterminal).
                transducer tableNumberStack add: goto.
                transducer treeStack add: (isNode ifTrue: [tree] ifFalse: [nil])].
            transducer right: transducer treeStack size.
            transducer left: transducer right + 1.
            ^goto]].

    self reportDesignError! !

!ReduceTable methods !   
tableUNUSEDVersionThatSearches: anArray
    "Store the data; namely a nonterminal and a bunch of transition information; triples
    with a 'from table numer', attributes, and a 'to table number'."
    nonterminal := anArray first.
    super table: anArray rest!  !
(CodeFiler organizerFor: ReduceTable) reorganizeFrom: #(
('unused' runUNUSEDVersionThatSearches tableUNUSEDVersionThatSearches: )) !

(CodeFiler organizerFor: ReduceTable) reorganizeFrom: #(
('unused' runUNUSEDVersionThatSearches tableUNUSEDVersionThatSearches: )) !
CodeFiler setCommentFor: ReduceTable to: ''!



!Scanner methods ! 
initialize
    token := nil.
    keptCharacters := ''.!   !
(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('initializing' initialize )) !



!Scanner methods !   
tables
    ^tables!    !

!Scanner methods !   
tables: aCollection
    "Store the collection of all table objects in tables. Moreover, each type of table will store it's data
    in its own way. So, you had better let the object store it. Note: The Collection contains the NAMES of the 
    types of table objects, they are not table objects. IN OTHER WORDS: Create the appropriate kind of table
    object, give the table data to that object, and then store that object in the scanner's tables."
    
    "HINT: 'Smalltalk at: x' where x is a variable containing the symbol #Apple returns the class object called
    Apple. Once you have a class object, you can say new to it."
    
    tables := aCollection collect: [:element | 
        "Each table is of the form (tableType tableNumber ...)."
        "Get the class name for the type, then make a new instance, then give it the table and tell it that I'm it's transducer."
        (Smalltalk at: element first) new table: (element copyFrom: 3); transducer: self]!  !

!Scanner methods !   
keptCharacters
    ^keptCharacters!    !

!Scanner methods !   
keptCharacters: aString
    keptCharacters := aString! !

!Scanner methods !   
input: aStream
    input := aStream!   !

!Scanner methods !   
input
    ^input!  !
(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('get/set' tables tables: keptCharacters keptCharacters: input: input )) !

(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('get/set' tables tables: keptCharacters keptCharacters: input: input )) !



!Scanner methods ! 
scan: text
    self input: (ReadStream on: text).
    self discardToken!  !
(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('scanning' scan: )) !

(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('scanning' scan: )) !



!Scanner methods ! 
peekInput
    ^input atEnd ifTrue:[256] ifFalse:[input peek]!  !

!Scanner methods !   
peekToken
    ^token!  !

!Scanner methods !   
discardToken
    "To discard the current token, set token to nil and execute the tables
    in a loop starting with table 1 until token is no longer nil. Then return 
    nothing. Somewhere during this execution, the semantic action buildToken:
    will execute putting something into variable 'token'."
    
    | tableNumber table |
    tableNumber := 1. token := nil.
    [token isNil] whileTrue: [
        table := tables at: tableNumber.
        tableNumber := table run].
    ^nil "We now have a token"!    !

!Scanner methods !   
discardInput
    ^input next!  !
(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('streaming' peekInput discardToken discardInput peekToken )) !

(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('streaming' peekInput discardToken discardInput peekToken )) !



!Scanner methods !   
buildToken: label
    "Create a token with the supplied label and the characters in keptCharacters
    and put the result in token so peek can return it when requested.
    Reset keptCharacters to an empty string so the process can repeat."
    
    token := Token new label: label asSymbol; symbol: keptCharacters asSymbol.
    keptCharacters := ''.!   !
(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('semantic actions' buildToken: )) !

(CodeFiler organizerFor: Scanner) reorganizeFrom: #(
('semantic actions' buildToken: )) !
CodeFiler setCommentFor: Scanner to: ''!



!Token methods ! 
label: aLabel
    label := aLabel! !

!Token methods ! 
label
    ^label!  !

!Token methods ! 
symbol
    ^symbol!    !

!Token methods ! 
symbol: aSymbol
    symbol := aSymbol! !
(CodeFiler organizerFor: Token) reorganizeFrom: #(
('get/set' label: label symbol symbol: )) !

(CodeFiler organizerFor: Token) reorganizeFrom: #(
('get/set' label: label symbol symbol: )) !



!Token methods ! 
printOn: aStream
    "Make label #Identifier with symbol #hello look like Identifier: hello 
    whereas label #keyword with symbol #keyword looks like keyword."
    self label == self symbol 
        ifTrue: [aStream << self label]
        ifFalse: [aStream << self label; << ': '; << self symbol].!   !

!Token methods ! 
printOn: aStream tabs: tabs
    aStream cr.
    tabs timesRepeat: [ aStream << '   '].
    aStream << self label; << ' ('; << self symbol; << ')'.!  !
(CodeFiler organizerFor: Token) reorganizeFrom: #(
('printing' printOn: printOn:tabs: )) !

(CodeFiler organizerFor: Token) reorganizeFrom: #(
('printing' printOn: printOn:tabs: )) !



!Token methods ! 
= anObject
    self class = anObject class ifFalse: [^false].
    ^self label = anObject label and: [self symbol = anObject symbol]!  !

!Token methods ! 
hash
    ^label hash + symbol hash!    !
(CodeFiler organizerFor: Token) reorganizeFrom: #(
('comparing' = hash )) !

(CodeFiler organizerFor: Token) reorganizeFrom: #(
('comparing' = hash )) !
CodeFiler setCommentFor: Token to: ''!



!ShiftbackTable methods !  
table: aTable
    "Record the data it needs."
    shift := aTable first. goto := aTable second!   !

!ShiftbackTable methods !
goto
    ^goto!    !

!ShiftbackTable methods !
goto: aNumber
    goto := aNumber! !

!ShiftbackTable methods !
shift: aNumber
    shift := aNumber!   !

!ShiftbackTable methods !
shift
    ^shift!  !
(CodeFiler organizerFor: ShiftbackTable) reorganizeFrom: #(
('get/set' goto table: goto: shift: shift )) !

(CodeFiler organizerFor: ShiftbackTable) reorganizeFrom: #(
('get/set' goto table: goto: shift: shift )) !



!ShiftbackTable methods !
run
    "Adjust left by the amount specified and return the goto table."
    transducer left: transducer left - shift.
    ^goto!    !
(CodeFiler organizerFor: ShiftbackTable) reorganizeFrom: #(
('running' run )) !

(CodeFiler organizerFor: ShiftbackTable) reorganizeFrom: #(
('running' run )) !
CodeFiler setCommentFor: ShiftbackTable to: ''!



!Table methods !  
transducer: aTransducer
    transducer := aTransducer! !

!Table methods ! 
transducer
    ^transducer!    !
(CodeFiler organizerFor: Table) reorganizeFrom: #(
('get/set' transducer: transducer )) !

(CodeFiler organizerFor: Table) reorganizeFrom: #(
('get/set' transducer: transducer )) !
CodeFiler setCommentFor: Table to: ''!



!Transducer class methods !
new

    ^super new initialize!   !
(CodeFiler organizerFor: Transducer class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: Transducer class) reorganizeFrom: #(
('instance creation' new )) !



!Transducer methods !  
tables: aCollection
    tables := aCollection! !

!Transducer methods !
tables
    ^tables!    !

!Transducer methods !
sponsor
    ^sponsor!  !

!Transducer methods !
sponsor: anObject
    sponsor := anObject! !
(CodeFiler organizerFor: Transducer) reorganizeFrom: #(
('get/set' tables: tables sponsor sponsor: )) !

(CodeFiler organizerFor: Transducer) reorganizeFrom: #(
('get/set' tables: tables sponsor sponsor: )) !
CodeFiler setCommentFor: Transducer to: ''!



!SampleTranslator class methods ! 
new

    ^super new initialize!   !
(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('instance creation' new )) !



!SampleTranslator class methods !  
rawParserTables
    "Tables generated from GrammarBuilder class>>parserGrammar"
    ^
#(
   (keywords where)
   (ReadaheadTable 1 (Integer 'RSN' 28) (Identifier 'RSN' 4) (#'(' 'RS' 5))
   (ReadaheadTable 2 (#'+' 'RS' 6) (#'-|' 'L' 25))
   (ReadaheadTable 3 (#'*' 'RS' 7) (#'+' 'L' 26) (#'-|' 'L' 26) (#';' 'L' 26) (#')' 'L' 26) (#',' 'L' 26))
   (ReadaheadTable 4 (#'(' 'RS' 8) (#'=' 'RS' 9) (#'+' 'L' 28) (#'*' 'L' 28) (#'-|' 'L' 28) (#';' 'L' 28) (#')' 'L' 28) (#',' 'L' 28))
   (ReadaheadTable 5 (Integer 'RSN' 28) (Identifier 'RSN' 11) (#'(' 'RS' 5))
   (ReadaheadTable 6 (Identifier 'RSN' 11) (#'(' 'RS' 5) (Integer 'RSN' 28))
   (ReadaheadTable 7 (Identifier 'RSN' 11) (#'(' 'RS' 5) (Integer 'RSN' 28))
   (ReadaheadTable 8 (#')' 'RS' 32) (Integer 'RSN' 28) (Identifier 'RSN' 11) (#'(' 'RS' 5))
   (ReadaheadTable 9 (Integer 'RSN' 28) (Identifier 'RSN' 11) (#'(' 'RS' 5))
   (ReadaheadTable 10 (#')' 'RS' 29) (#'+' 'RS' 6))
   (ReadaheadTable 11 (#'(' 'RS' 8) (#'+' 'L' 28) (#'*' 'L' 28) (#'-|' 'L' 28) (#';' 'L' 28) (#')' 'L' 28) (#',' 'L' 28))
   (ReadaheadTable 12 (#'*' 'RS' 7) (#'+' 'L' 30) (#'-|' 'L' 30) (#';' 'L' 30) (#')' 'L' 30) (#',' 'L' 30))
   (ReadaheadTable 13 (#'+' 'RS' 6) (#',' 'RS' 15) (#')' 'RS' 32))
   (ReadaheadTable 14 (#'+' 'RS' 6) (#';' 'RS' 16))
   (ReadaheadTable 15 (Integer 'RSN' 28) (Identifier 'RSN' 11) (#'(' 'RS' 5))
   (ReadaheadTable 16 (Identifier 'RSN' 18) (#'-|' 'L' 33))
   (ReadaheadTable 17 (#'+' 'RS' 6) (#',' 'RS' 15) (#')' 'RS' 32))
   (ReadaheadTable 18 (#'=' 'RS' 9))
   (ReadbackTable 19 ((#'(' 8) 'RS' 22) ((Expression 13) 'RSN' 34) ((Expression 17) 'RSN' 35))
   (ReadbackTable 20 ((Expression 10) 'RSN' 40) ((Expression 17) 'RSN' 40) ((Expression 2) 'RSN' 40) ((Expression 13) 'RSN' 40) ((Expression 14) 'RSN' 40))
   (ReadbackTable 21 ((Term 12) 'RSN' 41) ((Term 3) 'RSN' 41))
   (ReadbackTable 22 ((Identifier 4) 'RSN' 42) ((Identifier 11) 'RSN' 42))
   (ReadbackTable 23 ((Expression 13) 'RSN' 34) ((Expression 17) 'RSN' 35))
   (ReadbackTable 24 ((Identifier 4) 'RSN' 43) ((Identifier 18) 'RSN' 33))
   (ShiftbackTable 25 1 37)
   (ShiftbackTable 26 1 36)
   (ShiftbackTable 27 1 38)
   (ShiftbackTable 28 1 39)
   (ShiftbackTable 29 3 39)
   (ShiftbackTable 30 2 20)
   (ShiftbackTable 31 2 21)
   (ShiftbackTable 32 1 19)
   (ShiftbackTable 33 3 24)
   (ShiftbackTable 34 1 22)
   (ShiftbackTable 35 1 23)
   (ReduceTable 36 Expression (1 'RSN' 2)(5 'RSN' 10)(8 'RSN' 13)(9 'RSN' 14)(15 'RSN' 17))
   (ReduceTable 37 Grammar (1 'RSN' 44))
   (ReduceTable 38 Term (1 'RSN' 3)(5 'RSN' 3)(6 'RSN' 12)(8 'RSN' 3)(9 'RSN' 3)(15 'RSN' 3))
   (ReduceTable 39 Primary (1 'RSN' 27)(5 'RSN' 27)(6 'RSN' 27)(7 'RSN' 31)(8 'RSN' 27)(9 'RSN' 27)(15 'RSN' 27))
   (SemanticTable 40 buildTree: '+' 36)
   (SemanticTable 41 buildTree: '*' 38)
   (SemanticTable 42 buildTree: send 39)
   (SemanticTable 43 buildTree: '<-' 37)
   (AcceptTable 44))!   !

!SampleTranslator class methods !
rawScannerTables
    "Scanner rawScannerTables"

    "EndOfFileCharacter is 256"
    ^
#(
   (ScannerReadaheadTable 1 ((256) 'L' 5) (')' 'RK' 7) ('*' 'RK' 8) ('+' 'RK' 9) (',' 'RK' 10) ('0123456789' 'RK' 2) ('(' 'RK' 6) (';' 'RK' 12) ('=' 'RK' 13) ('ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz' 'RK' 3) ((9 10 12 13) 'R' 4) (' ' 'R' 4))
   (ScannerReadaheadTable 2 ((9 10 12 13 256) 'L' 11) ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_+*=[]{}()^;#:.$ ' 'L' 11) ('0123456789' 'RK' 2))
   (ScannerReadaheadTable 3 ((9 10 12 13 256) 'L' 14) ('+*=[]{}()^;#:.$ ' 'L' 14) ('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz' 'RK' 3))
   (ScannerReadaheadTable 4 ((256) 'L' 1) ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_0123456789+*=[]{}()^;#:.$' 'L' 1) ((9 10 12 13) 'R' 4) (' ' 'R' 4))
   (SemanticTable 5 buildToken: '-|' 1)
   (SemanticTable 6 buildToken: '(' 1)
   (SemanticTable 7 buildToken: ')' 1)
   (SemanticTable 8 buildToken: '*' 1)
   (SemanticTable 9 buildToken: '+' 1)
   (SemanticTable 10 buildToken: ',' 1)
   (SemanticTable 11 buildToken: Integer 1)
   (SemanticTable 12 buildToken: ';' 1)
   (SemanticTable 13 buildToken: '=' 1)
   (SemanticTable 14 buildToken: Identifier 1))! !
(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('raw tables' rawParserTables rawScannerTables )) !

(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('raw tables' rawParserTables rawScannerTables )) !



!SampleTranslator class methods !  
evaluateExample1
    "SampleTranslator evaluateExample1"
    ^SampleTranslator new evaluate: '1+ 2*3'!    !

!SampleTranslator class methods !
compileExample1
    "SampleTranslator compileExample1"
    ^SampleTranslator new compile: '1+ 2*3'!   !

!SampleTranslator class methods !
promptForCompilation
    "SampleTranslator promptForCompilation"
    ^SampleTranslator new 
        compile: (Prompter prompt: 'Expression to compile' default: '1+2*3')!    !

!SampleTranslator class methods !
promptForEvaluation
    "SampleTranslator promptForEvaluation"
    ^SampleTranslator new 
        evaluate: (Prompter prompt: 'Expression to evaluate' default: '1+2*3')!    !
(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('examples' evaluateExample1 promptForEvaluation compileExample1 promptForCompilation )) !

(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('examples' evaluateExample1 promptForEvaluation compileExample1 promptForCompilation )) !



!SampleTranslator methods !  
initialize
    parser := Parser 
        for: self 
        parserTables: self class rawParserTables 
        scannerTables: self class rawScannerTables.
    codeIfCompiler := WriteStream on: (String new: 1000).
    expressionsIfEvaluator := Dictionary new. "each key is a variable"
    compilationOperatorMap := Dictionary new
        at: #+ put: #compilePlus:;
        at: #- put: #compileMinus:;
        at: #* put: #compileMultiply:;
        at: #/ put: #compileDivide:;
        at: #'<-' put: #compileAssign:;
        at: #'Identifier' put: #compileIdentifier:;
        at: #'Integer' put: #compileInteger:;
        at: #'send' put: #compileFunctionCall:;
        at: #'where' put: #compileWhere:;
        yourself.
    evaluationOperatorMap := Dictionary new
        at: #+ put: #evaluatePlus:;
        at: #- put: #evaluateMinus:;
        at: #* put: #evaluateMultiply:;
        at: #/ put: #evaluateDivide:;
        at: #'<-' put: #evaluateAssign:;
        at: #'Identifier' put: #evaluateIdentifier:;
        at: #'Integer' put: #evaluateInteger:;
        at: #'send' put: #evaluateFunctionCall:;
        at: #'where' put: #evaluateWhere:;
        yourself!  !
(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('initializing' initialize )) !



!SampleTranslator methods !
parser: aParser
    parser := aParser! !

!SampleTranslator methods !  
tree
    ^tree!    !

!SampleTranslator methods !  
tree: aTree
    tree := aTree! !

!SampleTranslator methods !  
parser
    ^parser!    !
(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('get/set' parser: tree tree: parser )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('get/set' parser: tree tree: parser )) !



!SampleTranslator methods !
evaluate: text
    | result |
    "If no variables are set up, just return the expression; otherwise, a dictionary of variables."
    tree := parser parse: text.
    self halt: 'See tree returned by parser'.
    result := self evaluateExpressionFor: tree.
    self halt: 'See result and variable dictionary'.
    expressionsIfEvaluator size = 0 ifTrue: [^result] ifFalse: [^expressionsIfEvaluator]!   !

!SampleTranslator methods !  
evaluateExpressionFor: tree
    ^self perform: (evaluationOperatorMap at: tree label asSymbol) with: tree! !

!SampleTranslator methods !  
compileExpressionFor: tree
    self perform: (compilationOperatorMap at: tree label asSymbol) with: tree!  !

!SampleTranslator methods !  
compile: text
    tree := parser parse: text.
    self compileExpressionFor: tree.
    ^codeIfCompiler contents! !
(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compiling/evaluating' evaluate: compileExpressionFor: compile: evaluateExpressionFor: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compiling/evaluating' evaluate: compileExpressionFor: compile: evaluateExpressionFor: )) !



!SampleTranslator methods !  
generate: instruction
    codeIfCompiler cr; << instruction!   !

!SampleTranslator methods !  
generate: instruction with: operand
    codeIfCompiler cr; << instruction; << ' '; << operand! !
(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compilation support' generate: generate:with: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compilation support' generate: generate:with: )) !




!SampleTranslator methods !
compileAssign: tree
    1 to: tree children size by: 2 do: [:index |
            self compileExpressionFor: (tree child: index + 1).
            self generate: 'POP' with: (tree child: index) symbol]! !

!SampleTranslator methods !  
compileFunctionCall: tree
    tree children rest do: [:child | self compileExpressionFor: child]. 
    self generate: 'FUNCTION_CALL' with: (tree child: 1) symbol!   !

!SampleTranslator methods !  
compilePlus: tree
    self compileExpressionFor: (tree child: 1).
    self compileExpressionFor: (tree child: 2).
    self generate: 'ADD'.! !

!SampleTranslator methods !  
compileDivide: tree
    self compileExpressionFor: (tree child: 1).
    self compileExpressionFor: (tree child: 2).
    self generate: 'DIVIDE'.!    !

!SampleTranslator methods !  
compileWhere: tree
    "Not currently implementing where properly since ignoring other children."
    self halt: 'compile WHERE'.
    self compileExpressionFor: (tree child: 1).!   !

!SampleTranslator methods !  
compileMultiply: tree
    self compileExpressionFor: (tree child: 1).
    self compileExpressionFor: (tree child: 2).
    self generate: 'MULTIPLY'.!    !

!SampleTranslator methods !  
compileInteger: token
    self generate: 'PUSH' with: token symbol asInteger!  !

!SampleTranslator methods !  
compileIdentifier: token
    self generate: 'PUSH' with: token symbol! !

!SampleTranslator methods !  
compileMinus: tree
    self halt: 'compile MINUS'.!    !
(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compilation details' compileAssign: compileFunctionCall: compilePlus: compileDivide: compileWhere: compileMultiply: compileInteger: compileIdentifier: compileMinus: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compilation details' compileAssign: compileFunctionCall: compilePlus: compileDivide: compileWhere: compileMultiply: compileInteger: compileIdentifier: compileMinus: )) !



!SampleTranslator methods !
evaluatePlus: aTree
    ^(self evaluateExpressionFor: (aTree child: 1)) + (self evaluateExpressionFor: (aTree child: 2))!  !

!SampleTranslator methods !  
evaluateInteger: token
    ^token symbol asInteger!    !

!SampleTranslator methods !  
evaluateDivide: tree
    | expression1 expression2 |
    expression1 := self evaluateExpressionFor: (tree child: 1).
    expression2 := self evaluateExpressionFor: (tree child: 2).
    ^expression1 / expression2!    !

!SampleTranslator methods !  
evaluateWhere: tree
    "Evaluate all but the first expression to obtain the values for individual variables,
    then store them in expressionsIfEvaluator and finally evaluate the first expression."
    self halt: 'evaluate WHERE'! !

!SampleTranslator methods !  
evaluateMinus: tree
   self halt: 'evaluate MINUS'!    !

!SampleTranslator methods !  
evaluateAssign: token
    | expression |
    expression := self evaluateExpressionFor: (tree child: 2).
    expressionsIfEvaluator at: (tree child: 1) symbol put: expression!   !

!SampleTranslator methods !  
evaluateFunctionCall: tree
    | function parameters |
    function := (tree child: 1) label.
    parameters := tree children rest collect: [:child | self evaluateExpressionFor: child].  
    
    function = #tan ifTrue: [^parameters first tan] ifFalse: [
    function = #abs ifTrue: [^parameters first abs]].
    
    self halt: 'Function ', function printString, ' not yet handled'!    !

!SampleTranslator methods !  
evaluateIdentifier: token
    | identifier |
    identifier := token symbol.
    ^expressionsIfEvaluator at: identifier ifAbsent: [self halt: 'Identifier ', identifier printString, ' is not defined'].!    !

!SampleTranslator methods !  
evaluateMultiply: tree
    | expression1 expression2 |
    expression1 := self evaluateExpressionFor: (tree child: 1).
    expression2 := self evaluateExpressionFor: (tree child: 2).
    ^expression1 * expression2!  !
(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('evaluation details' evaluatePlus: evaluateInteger: evaluateDivide: evaluateWhere: evaluateMinus: evaluateAssign: evaluateFunctionCall: evaluateIdentifier: evaluateMultiply: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('evaluation details' evaluatePlus: evaluateInteger: evaluateDivide: evaluateWhere: evaluateMinus: evaluateAssign: evaluateFunctionCall: evaluateIdentifier: evaluateMultiply: )) !

CodeFiler setCommentFor: SampleTranslator to: ''!


!SampleTranslator class methods !   
rawScannerTables
    "Scanner rawScannerTables"

    "EndOfFileCharacter is 256"
    ^
#(
   (ScannerReadaheadTable 1 ((256) 'L' 5) ('ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz' 'RK' 3) (')' 'RK' 7) ('*' 'RK' 8) ('+' 'RK' 9) (',' 'RK' 10) ('-' 'RK' 11) ('(' 'RK' 6) ('/' 'RK' 12) ('0123456789' 'RK' 2) ((9 10 12 13) 'R' 4) (' ' 'R' 4) (';' 'RK' 14) ('=' 'RK' 15))
   (ScannerReadaheadTable 2 ((9 10 12 13 256) 'L' 13) ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_+-*/=[]{}()^;#:.$''" ' 'L' 13) ('0123456789' 'RK' 2))
   (ScannerReadaheadTable 3 ((9 10 12 13 256) 'L' 16) ('+-*/=[]{}()^;#:.$''" ' 'L' 16) ('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz' 'RK' 3))
   (ScannerReadaheadTable 4 ((256) 'L' 1) ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_0123456789+-*/=[]{}()^;#:.$''"' 'L' 1) ((9 10 12 13) 'R' 4) (' ' 'R' 4))
   (SemanticTable 5 buildToken: '-|' 1)
   (SemanticTable 6 buildToken: '(' 1)
   (SemanticTable 7 buildToken: ')' 1)
   (SemanticTable 8 buildToken: '*' 1)
   (SemanticTable 9 buildToken: '+' 1)
   (SemanticTable 10 buildToken: ',' 1)
   (SemanticTable 11 buildToken: '-' 1)
   (SemanticTable 12 buildToken: '/' 1)
   (SemanticTable 13 buildToken: Integer 1)
   (SemanticTable 14 buildToken: ';' 1)
   (SemanticTable 15 buildToken: '=' 1)
   (SemanticTable 16 buildToken: Identifier 1))!    ! 
#('January 26, 2021' '02:50:38 AM' 1641008)!

(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('raw tables' rawScannerTables )) !

(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('raw tables' rawScannerTables )) !


!SampleTranslator class methods !   
rawParserTables
    "Tables generated from GrammarBuilder class>>parserGrammar"
    ^
#(
   (keywords where)
   (ReadaheadTable 1 (Expression 'RSN' 2) (Term 'RSN' 3) (Primary 'RSN' 38) (Integer 'RSN' 39) (Identifier 'RSN' 4) (Grammar 'RSN' 63) (#'(' 'RS' 5))
   (ReadaheadTable 2 (#'+' 'RS' 6) (#'-' 'RS' 7) (where 'RS' 8) (#'-|' 'L' 36))
   (ReadaheadTable 3 (#'*' 'RS' 9) (#'/' 'RS' 10) (#'+' 'L' 37) (#'-' 'L' 37) (where 'L' 37) (#'-|' 'L' 37) (#';' 'L' 37) (#')' 'L' 37) (#',' 'L' 37))
   (ReadaheadTable 4 (#'(' 'RS' 11) (#'=' 'RS' 12) (#'+' 'L' 39) (#'-' 'L' 39) (#'*' 'L' 39) (#'/' 'L' 39) (where 'L' 39) (#'-|' 'L' 39) (#';' 'L' 39) (#')' 'L' 39) (#',' 'L' 39))
   (ReadaheadTable 5 (Expression 'RSN' 13) (Primary 'RSN' 38) (Term 'RSN' 3) (Integer 'RSN' 39) (Identifier 'RSN' 14) (#'(' 'RS' 5))
   (ReadaheadTable 6 (Identifier 'RSN' 14) (#'(' 'RS' 5) (Integer 'RSN' 39) (Primary 'RSN' 38) (Term 'RSN' 15))
   (ReadaheadTable 7 (Identifier 'RSN' 14) (#'(' 'RS' 5) (Integer 'RSN' 39) (Primary 'RSN' 38) (Term 'RSN' 16))
   (ReadaheadTable 8 (Identifier 'RSN' 17))
   (ReadaheadTable 9 (Identifier 'RSN' 14) (#'(' 'RS' 5) (Integer 'RSN' 39) (Primary 'RSN' 43))
   (ReadaheadTable 10 (Identifier 'RSN' 14) (#'(' 'RS' 5) (Integer 'RSN' 39) (Primary 'RSN' 44))
   (ReadaheadTable 11 (Expression 'RSN' 18) (#')' 'RS' 45) (Term 'RSN' 3) (Primary 'RSN' 38) (Integer 'RSN' 39) (Identifier 'RSN' 14) (#'(' 'RS' 5))
   (ReadaheadTable 12 (Expression 'RSN' 19) (Primary 'RSN' 38) (Term 'RSN' 3) (Integer 'RSN' 39) (Identifier 'RSN' 14) (#'(' 'RS' 5))
   (ReadaheadTable 13 (#')' 'RS' 40) (#'+' 'RS' 6) (#'-' 'RS' 7))
   (ReadaheadTable 14 (#'(' 'RS' 11) (#'+' 'L' 39) (#'-' 'L' 39) (#'*' 'L' 39) (#'/' 'L' 39) (where 'L' 39) (#'-|' 'L' 39) (#';' 'L' 39) (#')' 'L' 39) (#',' 'L' 39))
   (ReadaheadTable 15 (#'*' 'RS' 9) (#'/' 'RS' 10) (#'+' 'L' 41) (#'-' 'L' 41) (where 'L' 41) (#'-|' 'L' 41) (#';' 'L' 41) (#')' 'L' 41) (#',' 'L' 41))
   (ReadaheadTable 16 (#'*' 'RS' 9) (#'/' 'RS' 10) (#'+' 'L' 42) (#'-' 'L' 42) (where 'L' 42) (#'-|' 'L' 42) (#';' 'L' 42) (#')' 'L' 42) (#',' 'L' 42))
   (ReadaheadTable 17 (#'=' 'RS' 20))
   (ReadaheadTable 18 (#'+' 'RS' 6) (#'-' 'RS' 7) (#',' 'RS' 21) (#')' 'RS' 45))
   (ReadaheadTable 19 (#';' 'RS' 22) (#'+' 'RS' 6) (#'-' 'RS' 7))
   (ReadaheadTable 20 (Expression 'RSN' 23) (Primary 'RSN' 38) (Term 'RSN' 3) (Integer 'RSN' 39) (Identifier 'RSN' 14) (#'(' 'RS' 5))
   (ReadaheadTable 21 (Expression 'RSN' 24) (Primary 'RSN' 38) (Term 'RSN' 3) (Integer 'RSN' 39) (Identifier 'RSN' 14) (#'(' 'RS' 5))
   (ReadaheadTable 22 (Identifier 'RSN' 25) (#'-|' 'L' 46))
   (ReadaheadTable 23 (#'+' 'RS' 6) (#'-' 'RS' 7) (#';' 'RS' 26))
   (ReadaheadTable 24 (#'+' 'RS' 6) (#'-' 'RS' 7) (#',' 'RS' 21) (#')' 'RS' 45))
   (ReadaheadTable 25 (#'=' 'RS' 12))
   (ReadaheadTable 26 (Identifier 'RSN' 17) (#'-|' 'L' 47))
   (ReadbackTable 27 ((Expression 24) 'RSN' 49) ((Expression 18) 'RSN' 50) ((#'(' 11) 'RS' 32))
   (ReadbackTable 28 ((Expression 13) 'RSN' 56) ((Expression 23) 'RSN' 56) ((Expression 24) 'RSN' 56) ((Expression 2) 'RSN' 56) ((Expression 18) 'RSN' 56) ((Expression 19) 'RSN' 56))
   (ReadbackTable 29 ((Expression 13) 'RSN' 57) ((Expression 23) 'RSN' 57) ((Expression 24) 'RSN' 57) ((Expression 2) 'RSN' 57) ((Expression 18) 'RSN' 57) ((Expression 19) 'RSN' 57))
   (ReadbackTable 30 ((Term 15) 'RSN' 58) ((Term 16) 'RSN' 58) ((Term 3) 'RSN' 58))
   (ReadbackTable 31 ((Term 15) 'RSN' 59) ((Term 16) 'RSN' 59) ((Term 3) 'RSN' 59))
   (ReadbackTable 32 ((Identifier 14) 'RSN' 60) ((Identifier 4) 'RSN' 60))
   (ReadbackTable 33 ((Expression 24) 'RSN' 49) ((Expression 18) 'RSN' 50))
   (ReadbackTable 34 ((Identifier 25) 'RSN' 46) ((Identifier 4) 'RSN' 61))
   (ReadbackTable 35 ((#';' 26) 'RS' 48) ((where 8) 'RS' 51))
   (ShiftbackTable 36 1 53)
   (ShiftbackTable 37 1 52)
   (ShiftbackTable 38 1 54)
   (ShiftbackTable 39 1 55)
   (ShiftbackTable 40 3 55)
   (ShiftbackTable 41 2 28)
   (ShiftbackTable 42 2 29)
   (ShiftbackTable 43 2 30)
   (ShiftbackTable 44 2 31)
   (ShiftbackTable 45 1 27)
   (ShiftbackTable 46 3 34)
   (ShiftbackTable 47 4 35)
   (ShiftbackTable 48 3 35)
   (ShiftbackTable 49 1 33)
   (ShiftbackTable 50 1 32)
   (ShiftbackTable 51 1 62)
   (ReduceTable 52 Expression (1 'RSN' 2)(5 'RSN' 13)(11 'RSN' 18)(12 'RSN' 19)(20 'RSN' 23)(21 'RSN' 24))
   (ReduceTable 53 Grammar (1 'RSN' 63))
   (ReduceTable 54 Term (1 'RSN' 3)(5 'RSN' 3)(6 'RSN' 15)(7 'RSN' 16)(11 'RSN' 3)(12 'RSN' 3)(20 'RSN' 3)(21 'RSN' 3))
   (ReduceTable 55 Primary (1 'RSN' 38)(5 'RSN' 38)(6 'RSN' 38)(7 'RSN' 38)(9 'RSN' 43)(10 'RSN' 44)(11 'RSN' 38)(12 'RSN' 38)(20 'RSN' 38)(21 'RSN' 38))
   (SemanticTable 56 buildTree: #'+' 52)
   (SemanticTable 57 buildTree: #'-' 52)
   (SemanticTable 58 buildTree: #'*' 54)
   (SemanticTable 59 buildTree: #'/' 54)
   (SemanticTable 60 buildTree: send 55)
   (SemanticTable 61 buildTree: #'<-' 53)
   (SemanticTable 62 buildTree: where 53)
   (AcceptTable 63))!  ! 
#('January 26, 2021' '02:53:08 AM' 1638024)!

(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('raw tables' rawParserTables )) !

(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('raw tables' rawParserTables )) !


!SampleTranslator class methods ! 
rawParserTables
    "Tables generated from GrammarBuilder class>>parserGrammar"
    ^
#(
   (keywords where)
   (ReadaheadTable 1 (Expression 'RSN' 2) (Term 'RSN' 3) (Primary 'RSN' 38) (Integer 'RSN' 39) (Identifier 'RSN' 4) (Grammar 'RSN' 63) (#'(' 'RS' 5))
   (ReadaheadTable 2 (#'+' 'RS' 6) (#'-' 'RS' 7) (where 'RS' 8) (#'-|' 'L' 36))
   (ReadaheadTable 3 (#'*' 'RS' 9) (#'/' 'RS' 10) (#'+' 'L' 37) (#'-' 'L' 37) (where 'L' 37) (#'-|' 'L' 37) (#';' 'L' 37) (#')' 'L' 37) (#',' 'L' 37))
   (ReadaheadTable 4 (#'(' 'RS' 11) (#'=' 'RS' 12) (#'+' 'L' 39) (#'-' 'L' 39) (#'*' 'L' 39) (#'/' 'L' 39) (where 'L' 39) (#'-|' 'L' 39) (#';' 'L' 39) (#')' 'L' 39) (#',' 'L' 39))
   (ReadaheadTable 5 (Expression 'RSN' 13) (Primary 'RSN' 38) (Term 'RSN' 3) (Integer 'RSN' 39) (Identifier 'RSN' 14) (#'(' 'RS' 5))
   (ReadaheadTable 6 (Identifier 'RSN' 14) (#'(' 'RS' 5) (Integer 'RSN' 39) (Primary 'RSN' 38) (Term 'RSN' 15))
   (ReadaheadTable 7 (Identifier 'RSN' 14) (#'(' 'RS' 5) (Integer 'RSN' 39) (Primary 'RSN' 38) (Term 'RSN' 16))
   (ReadaheadTable 8 (Identifier 'RSN' 17))
   (ReadaheadTable 9 (Identifier 'RSN' 14) (#'(' 'RS' 5) (Integer 'RSN' 39) (Primary 'RSN' 43))
   (ReadaheadTable 10 (Identifier 'RSN' 14) (#'(' 'RS' 5) (Integer 'RSN' 39) (Primary 'RSN' 44))
   (ReadaheadTable 11 (Expression 'RSN' 18) (#')' 'RS' 45) (Term 'RSN' 3) (Primary 'RSN' 38) (Integer 'RSN' 39) (Identifier 'RSN' 14) (#'(' 'RS' 5))
   (ReadaheadTable 12 (Expression 'RSN' 19) (Primary 'RSN' 38) (Term 'RSN' 3) (Integer 'RSN' 39) (Identifier 'RSN' 14) (#'(' 'RS' 5))
   (ReadaheadTable 13 (#')' 'RS' 40) (#'+' 'RS' 6) (#'-' 'RS' 7))
   (ReadaheadTable 14 (#'(' 'RS' 11) (#'+' 'L' 39) (#'-' 'L' 39) (#'*' 'L' 39) (#'/' 'L' 39) (where 'L' 39) (#'-|' 'L' 39) (#';' 'L' 39) (#')' 'L' 39) (#',' 'L' 39))
   (ReadaheadTable 15 (#'*' 'RS' 9) (#'/' 'RS' 10) (#'+' 'L' 41) (#'-' 'L' 41) (where 'L' 41) (#'-|' 'L' 41) (#';' 'L' 41) (#')' 'L' 41) (#',' 'L' 41))
   (ReadaheadTable 16 (#'*' 'RS' 9) (#'/' 'RS' 10) (#'+' 'L' 42) (#'-' 'L' 42) (where 'L' 42) (#'-|' 'L' 42) (#';' 'L' 42) (#')' 'L' 42) (#',' 'L' 42))
   (ReadaheadTable 17 (#'=' 'RS' 20))
   (ReadaheadTable 18 (#'+' 'RS' 6) (#'-' 'RS' 7) (#',' 'RS' 21) (#')' 'RS' 45))
   (ReadaheadTable 19 (#';' 'RS' 22) (#'+' 'RS' 6) (#'-' 'RS' 7))
   (ReadaheadTable 20 (Expression 'RSN' 23) (Primary 'RSN' 38) (Term 'RSN' 3) (Integer 'RSN' 39) (Identifier 'RSN' 14) (#'(' 'RS' 5))
   (ReadaheadTable 21 (Expression 'RSN' 24) (Primary 'RSN' 38) (Term 'RSN' 3) (Integer 'RSN' 39) (Identifier 'RSN' 14) (#'(' 'RS' 5))
   (ReadaheadTable 22 (Identifier 'RSN' 25) (#'-|' 'L' 46))
   (ReadaheadTable 23 (#'+' 'RS' 6) (#'-' 'RS' 7) (#';' 'RS' 26))
   (ReadaheadTable 24 (#'+' 'RS' 6) (#'-' 'RS' 7) (#',' 'RS' 21) (#')' 'RS' 45))
   (ReadaheadTable 25 (#'=' 'RS' 12))
   (ReadaheadTable 26 (Identifier 'RSN' 17) (#'-|' 'L' 47))
   (ReadbackTable 27 ((Expression 24) 'RSN' 49) ((Expression 18) 'RSN' 50) ((#'(' 11) 'RS' 32))
   (ReadbackTable 28 ((Expression 13) 'RSN' 56) ((Expression 23) 'RSN' 56) ((Expression 24) 'RSN' 56) ((Expression 2) 'RSN' 56) ((Expression 18) 'RSN' 56) ((Expression 19) 'RSN' 56))
   (ReadbackTable 29 ((Expression 13) 'RSN' 57) ((Expression 23) 'RSN' 57) ((Expression 24) 'RSN' 57) ((Expression 2) 'RSN' 57) ((Expression 18) 'RSN' 57) ((Expression 19) 'RSN' 57))
   (ReadbackTable 30 ((Term 15) 'RSN' 58) ((Term 16) 'RSN' 58) ((Term 3) 'RSN' 58))
   (ReadbackTable 31 ((Term 15) 'RSN' 59) ((Term 16) 'RSN' 59) ((Term 3) 'RSN' 59))
   (ReadbackTable 32 ((Identifier 14) 'RSN' 60) ((Identifier 4) 'RSN' 60))
   (ReadbackTable 33 ((Expression 24) 'RSN' 49) ((Expression 18) 'RSN' 50))
   (ReadbackTable 34 ((Identifier 25) 'RSN' 46) ((Identifier 4) 'RSN' 61))
   (ReadbackTable 35 ((#';' 26) 'RS' 48) ((where 8) 'RS' 51))
   (ShiftbackTable 36 1 53)
   (ShiftbackTable 37 1 52)
   (ShiftbackTable 38 1 54)
   (ShiftbackTable 39 1 55)
   (ShiftbackTable 40 3 55)
   (ShiftbackTable 41 2 28)
   (ShiftbackTable 42 2 29)
   (ShiftbackTable 43 2 30)
   (ShiftbackTable 44 2 31)
   (ShiftbackTable 45 1 27)
   (ShiftbackTable 46 3 34)
   (ShiftbackTable 47 4 35)
   (ShiftbackTable 48 3 35)
   (ShiftbackTable 49 1 33)
   (ShiftbackTable 50 1 32)
   (ShiftbackTable 51 1 62)
   (ReduceTable 52 Expression (1 'RSN' 2)(5 'RSN' 13)(11 'RSN' 18)(12 'RSN' 19)(20 'RSN' 23)(21 'RSN' 24))
   (ReduceTable 53 Grammar (1 'RSN' 63))
   (ReduceTable 54 Term (1 'RSN' 3)(5 'RSN' 3)(6 'RSN' 15)(7 'RSN' 16)(11 'RSN' 3)(12 'RSN' 3)(20 'RSN' 3)(21 'RSN' 3))
   (ReduceTable 55 Primary (1 'RSN' 38)(5 'RSN' 38)(6 'RSN' 38)(7 'RSN' 38)(9 'RSN' 43)(10 'RSN' 44)(11 'RSN' 38)(12 'RSN' 38)(20 'RSN' 38)(21 'RSN' 38))
   (SemanticTable 56 buildTree: #'+' 52)
   (SemanticTable 57 buildTree: #'-' 52)
   (SemanticTable 58 buildTree: #'*' 54)
   (SemanticTable 59 buildTree: #'/' 54)
   (SemanticTable 60 buildTree: send 55)
   (SemanticTable 61 buildTree: #'<-' 53)
   (SemanticTable 62 buildTree: where 53)
   (AcceptTable 63))!  ! 
#('January 26, 2021' '02:54:29 AM' 1653464)!

(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('raw tables' rawParserTables )) !

(CodeFiler organizerFor: SampleTranslator class) reorganizeFrom: #(
('raw tables' rawParserTables )) !


  
'SampleTranslator promptForCompilation'!

  
'SampleTranslator promptForCompilation'!

  
'SampleTranslator promptForCompilation'!

!SampleTranslator methods !   
compileMinus: tree
    self compileExpressionFor: (tree child: 1).
    self compileExpressionFor: (tree child: 2).
    self generate: 'MINUS'.!  ! 
#('January 26, 2021' '03:22:43 AM' 1648632)!

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compilation details' compileMinus: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compilation details' compileMinus: )) !


!SampleTranslator methods ! 
evaluateMinus: tree
    | expression1 expression2 |
    expression1 := self evaluateExpressionFor: (tree child: 1).
    expression2 := self evaluateExpressionFor: (tree child: 2).
    ^expression1 - expression2! ! 
#('January 26, 2021' '03:23:30 AM' 1649980)!

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('evaluation details' evaluateMinus: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('evaluation details' evaluateMinus: )) !



'SampleTranslator evaluateExample1'!

  
'SampleTranslator promptForEvaluation'!

   
'SampleTranslator promptForCompilation'!

!SampleTranslator methods !   
evaluateWhere: tree
    "Evaluate all but the first expression to obtain the values for individual variables,
    then store them in expressionsIfEvaluator and finally evaluate the first expression."
    self halt: 'evaluate WHERE'
        | value |

    "First the variables."
    3 to: tree children size by: 2 do: [:index |
        value := self evaluateExpressionFor: (tree child: index).
        expressionsIfEvaluator at: (tree child: index - 1) symbol put: value].

    "Second the expression using those variables."
    ^self evaluateExpressionFor: (tree child: 1).!  ! 
#('January 26, 2021' '03:51:39 AM' 1649708)!

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('evaluation details' evaluateWhere: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('evaluation details' evaluateWhere: )) !


!SampleTranslator methods ! 
evaluateWhere: tree
    "Evaluate all but the first expression to obtain the values for individual variables,
    then store them in expressionsIfEvaluator and finally evaluate the first expression."
        | value |
        
    3 to: tree children size by: 2 do: [:index |
        value := self evaluateExpressionFor: (tree child: index).
        expressionsIfEvaluator at: (tree child: index - 1) symbol put: value].

    ^self evaluateExpressionFor: (tree child: 1).!   ! 
#('January 26, 2021' '03:52:25 AM' 1665332)!

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('evaluation details' evaluateWhere: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('evaluation details' evaluateWhere: )) !


!SampleTranslator methods ! 
evaluateWhere: tree
    | value |
    
    3 to: tree children size by: 2 do: [:index |
        value := self evaluateExpressionFor: (tree child: index).
        expressionsIfEvaluator at: (tree child: index - 1) symbol put: value].

    ^self evaluateExpressionFor: (tree child: 1).! ! 
#('January 26, 2021' '03:54:53 AM' 1666220)!

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('evaluation details' evaluateWhere: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('evaluation details' evaluateWhere: )) !


!SampleTranslator methods ! 
evaluateWhere: tree
    | value |
    
    3 to: tree children size do: [:index |
        value := self evaluateExpressionFor: (tree child: index).
        expressionsIfEvaluator at: (tree child: index - 1) symbol put: value].

    ^self evaluateExpressionFor: (tree child: 1).!   ! 
#('January 26, 2021' '03:56:10 AM' 1667004)!

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('evaluation details' evaluateWhere: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('evaluation details' evaluateWhere: )) !


!SampleTranslator methods ! 
evaluateWhere: tree
    | value |
    3 to: tree children size do: [:index |
        value := self evaluateExpressionFor: (tree child: index).
        expressionsIfEvaluator at: (tree child: index - 1) symbol put: value].

    ^self evaluateExpressionFor: (tree child: 1).! ! 
#('January 26, 2021' '03:57:05 AM' 1667596)!

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('evaluation details' evaluateWhere: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('evaluation details' evaluateWhere: )) !


!SampleTranslator methods ! 
evaluateWhere: tree
    | value |
    3 to: tree children size do: [:index |
        value := self evaluateExpressionFor: (tree child: index).
        expressionsIfEvaluator at: (tree child: index - 1) symbol put: value
        ].

    ^self evaluateExpressionFor: (tree child: 1).!   ! 
#('January 26, 2021' '04:10:37 AM' 1668184)!

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('evaluation details' evaluateWhere: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('evaluation details' evaluateWhere: )) !


!SampleTranslator methods ! 
evaluateWhere: tree
    | value |
    3 to: tree children size by: 2 do: [:index |
        value := self evaluateExpressionFor: (tree child: index).
        expressionsIfEvaluator at: (tree child: index - 1) symbol put: value
        ].

    ^self evaluateExpressionFor: (tree child: 1).! ! 
#('January 26, 2021' '04:22:29 AM' 1668764)!

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('evaluation details' evaluateWhere: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('evaluation details' evaluateWhere: )) !


!SampleTranslator methods ! 
evaluate: text
    | result |
    "If no variables are set up, just return the expression; otherwise, a dictionary of variables."
    tree := parser parse: text.
    self halt: 'See tree returned by parser'.
    result := self evaluateExpressionFor: tree.
    self halt: 'See result and variable dictionary'.
    true ifTrue:[^result].
    expressionsIfEvaluator size = 0 ifTrue: [^result] ifFalse: [^expressionsIfEvaluator]!   ! 
#('January 26, 2021' '04:26:27 AM' 1645508)!

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compiling/evaluating' evaluate: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compiling/evaluating' evaluate: )) !


!SampleTranslator methods !   
evaluate: text
    | result |
    "If no variables are set up, just return the expression; otherwise, a dictionary of variables."
    tree := parser parse: text.
    self halt: 'See tree returned by parser'.
    result := self evaluateExpressionFor: tree.
    self halt: 'See result and variable dictionary'.
    expressionsIfEvaluator size = 0 ifTrue: [^result] ifFalse: [^expressionsIfEvaluator]!   ! 
#('January 26, 2021' '04:29:51 AM' 1669952)!

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compiling/evaluating' evaluate: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compiling/evaluating' evaluate: )) !


  
'SampleTranslator promptForEvaluation'!

   
'SampleTranslator promptForEvaluation'!

   
'SampleTranslator promptForEvaluation'!

!SampleTranslator methods !
evaluate: text
    | result |
    "If no variables are set up, just return the expression; otherwise, a dictionary of variables."
    tree := parser parse: text.
    self halt: 'See tree returned by parser'.
    result := self evaluateExpressionFor: tree.
    self halt: 'See result and variable dictionary'.
    true ifTrue: [^result].
    expressionsIfEvaluator size = 0 ifTrue: [^result] ifFalse: [^expressionsIfEvaluator]!  ! 
#('January 26, 2021' '04:34:23 AM' 1670684)!

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compiling/evaluating' evaluate: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compiling/evaluating' evaluate: )) !


  
'SampleTranslator promptForEvaluation'!

!SampleTranslator methods !
evaluate: text
    | result |
    "If no variables are set up, just return the expression; otherwise, a dictionary of variables."
    tree := parser parse: text.
    self halt: 'See tree returned by parser'.
    result := self evaluateExpressionFor: tree.
    true ifTrue: [^result].
    expressionsIfEvaluator size = 0 ifTrue: [^result] ifFalse: [^expressionsIfEvaluator]!    ! 
#('January 26, 2021' '04:36:01 AM' 1671528)!

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compiling/evaluating' evaluate: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compiling/evaluating' evaluate: )) !


!SampleTranslator methods !   
evaluate: text
    | result |
    "If no variables are set up, just return the expression; otherwise, a dictionary of variables."
    tree := parser parse: text.
    result := self evaluateExpressionFor: tree.
    true ifTrue: [^result].
    expressionsIfEvaluator size = 0 ifTrue: [^result] ifFalse: [^expressionsIfEvaluator]!   ! 
#('January 26, 2021' '04:36:09 AM' 1672304)!

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compiling/evaluating' evaluate: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compiling/evaluating' evaluate: )) !


  
'SampleTranslator promptForEvaluation'!

!SampleTranslator methods !
compileWhere: tree
    "Not currently implementing where properly since ignoring other children."
    self halt: 'compile WHERE'.
    
    3 to: tree children size by: 2 do: [:index |
        self compileExpressionFor: (tree child: index).
        self generate: 'POP' with: (tree child: index - 1) symbol].
    ^self compileExpressionFor: (tree child: 1).!    ! 
#('January 26, 2021' '04:51:02 AM' 1647996)!

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compilation details' compileWhere: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compilation details' compileWhere: )) !


!SampleTranslator methods ! 
compileWhere: tree
    3 to: tree children size by: 2 do: [:index |
        self compileExpressionFor: (tree child: index).
        self generate: 'POP' with: (tree child: index - 1) symbol].
    ^self compileExpressionFor: (tree child: 1).!   ! 
#('January 26, 2021' '04:56:06 AM' 1673660)!

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compilation details' compileWhere: )) !

(CodeFiler organizerFor: SampleTranslator) reorganizeFrom: #(
('compilation details' compileWhere: )) !



'SampleTranslator promptForCompilation'!

  
'SampleTranslator promptForCompilation'!

  
'SampleTranslator promptForEvaluation'!

"evaluate" 
"*** saved image on: January 26, 2021 04:59:06 AM ***"!   
"*** Image started on: January 26, 2021 04:59:19 AM ***"!

"evaluate"   
"*** saved image on: January 26, 2021 05:00:04 AM ***"!   
"*** Image started on: February 8, 2021 04:47:22 PM ***"!

"define class"   

Object subclass: #Relation
  instanceVariableNames: 
    ' triples '
  classVariableNames: ''
  poolDictionaries: ''!


!Relation class methods !
new

    ^super new initialize!   !

"evaluate"   
(CodeFiler organizerFor: Relation class) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('instance creation' new )) !



!Relation class methods !
example1
    "Relation example1"
        | collection relation bracket1 |
        "First, build a relation."
        collection := #((2 < 3) (1 = 1) (3 > 1) (2 < 4)(1 < 5) (5 < 6) (2 < 5)).
        relation := Relation new.
        collection do: [:triple | relation addTriple: triple].
        Transcript cr; << 'Let relation = '; << collection.
        Transcript cr; << 'The created relation is '.
        relation do: [:a :b :c |Transcript cr; << a; space; << b; space; << c; space]!    !

!Relation class methods !
example2
        "Relation example2"
        | collection relation |
        "First, build a relation."
        collection := #((2 < 3) (1 = 1) (3 > 1) (2 < 4)(1 < 5) (5 < 6) (2 < 5)).
        relation := Relation new.
        collection do: [:triple | relation addTriple: triple].

        Transcript cr; << 'Let relation = '; << collection.
        Transcript cr; << 'Starting from {1 2 3},'.
            relation from: #(1 2 3) do: [:relationship :subrelation |                 
                Transcript cr; << 'There is a relationship '; << relationship; 
                    << ' with subrelation'; cr; tab.
                subrelation do: [:triple |Transcript space; << triple]]!    !
(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('examples' example1 example2 )) !

(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('examples' example1 example2 )) !



!Relation class methods !
using: relation1 and: relation2 performCollectionOneStep: aCollection
    | newRelation |
     newRelation := self using: relation1 and: 2 performRelationOneStep: aCollection.
     ^newRelation allTo! !

!Relation class methods !
using: relation performRelationOneStep: items
    "Builds new triples by applying 'relation' ONCE to each item in items. Returns the triples in a totally new relation."
    | newRelation tos |
    newRelation := Relation new. tos = OrderedCollection new.
    
    relation from: items do: [:relationship :subrelation |
        subrelation do: [:triple | tos addifAbsent: triple third]].

    relation from: tos do: [:relationship :subrelation |
        subrelation do: [:triple | newRelation addTriple: triple]].

    ^newRelation!  !

!Relation class methods !
using: relation1 and: relation2 performItemStep: items
    | newRelation |
     newRelation := self using: relation1 and: 2 performRelationOneStep: items.
     ^newRelation allTo!  !

!Relation class methods !
using: relation1 and: relation2 performRelationOneStep: items
    "Builds new triples by applying 'relation1' ONCE to each item in items and 'relation2' ONCE to each item in items. Returns the triples in a totally new relation."!  !

!Relation class methods !
using: relation performRelationStar: items
    | newRelation workingCollection|
    newRelation := Relation new.
    workingCollection := OrderedCollection new addAllIfAbsent: items.
    workingCollection do: [:item |
        relation from: (OrderedCollection with: item) do: [:relationship :subrelation |
        subrelation do: [:triple | 
            workingCollection addIfAbsent: triples last.
            newRelation addTriple: triple]]].

    ^newRelation!   !

!Relation class methods !
using: relation performCollectionOneStep: aCollection
    | newRelation |
     newRelation := self using: relation performRelationOneStep: aCollection.
     ^newRelation allTo! !

!Relation class methods !
using: relation performItemOneStep: items
    | newRelation |
     newRelation := self using: relation performRelationOneStep: items.
     ^newRelation allTo!   !

!Relation class methods !
using: relation performItemStar: items
    | newRelation |
    newRelation := self using: relation performRelationStar: items.
    ^newRelation allTo addAllIfAbsent: items! !
(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('performMethods' using:and:performCollectionOneStep: using:performRelationOneStep: using:and:performItemStep: using:and:performRelationOneStep: using:performRelationStar: using:performCollectionOneStep: using:performItemStar: using:performItemOneStep: )) !

(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('performMethods' using:and:performCollectionOneStep: using:performRelationOneStep: using:and:performItemStep: using:and:performRelationOneStep: using:performRelationStar: using:performCollectionOneStep: using:performItemStar: using:performItemOneStep: )) !



!Relation methods !
initialize

    self
        triples: OrderedCollection new! !

"evaluate"   
(CodeFiler organizerFor: Relation) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('initializing' initialize )) !



!Relation methods !
triples: anOrderedCollection
    triples := anOrderedCollection!   !

!Relation methods !  
triples
    ^triples!  !
(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('get/set' triples: triples )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('get/set' triples: triples )) !



!Relation methods !  
allRelationships
    ^triples collect: [:triple | triple second]!  !

!Relation methods !  
allFrom
    ^triples collect: [:triple | triple first]!    !

!Relation methods !  
from: keys do: aBlock
    (triples select: [:triple | keys includes: triple first]) 
    do: [:triple | 
        aBlock 
            value: triple first 
            value: triple rest]! !

!Relation methods !  
addFrom: key via: relationship to: value
    triples add: 
        [Array 
            with: key
            with: relationship 
            with: value].!    !

!Relation methods !  
allTo
    ^triples collect: [:triple | triple third]!  !

!Relation methods !  
addTriple: triple
        triples addAllIfAbsent: triple!  !

!Relation methods !  
do: aBlock
    triples do: [:triple | 
        aBlock 
            value: triple first 
            value: triple second 
            value: triple third]!    !
(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' allRelationships allFrom from:do: addFrom:via:to: allTo addTriple: do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' allRelationships allFrom from:do: addFrom:via:to: allTo addTriple: do: )) !
CodeFiler setCommentFor: Relation to: ''!


"define class"  

Object subclass: #StudentCompiler
  instanceVariableNames: 
    ' parser tree contextStack code '
  classVariableNames: ''
  poolDictionaries: ''!


!StudentCompiler class methods !
new

    ^super new initialize!   !

"evaluate"   
(CodeFiler organizerFor: StudentCompiler class) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('instance creation' new )) !



!StudentCompiler class methods !
rawParserTables
    "Tables generated from GrammarBuilder class>>parserGrammar"
    ^
#(
   (keywords if for else)
   (ReadaheadTable 1 (for 'RS' 4) (#'(' 'RS' 6) (walkInteger: 'RSN' 68) (walkIdentifier: 'RSN' 7) (if 'RS' 8) (#'}' 'L' 52) (#'-|' 'L' 52))
   (ReadaheadTable 2 (if 'RS' 8) (walkIdentifier: 'RSN' 7) (for 'RS' 4) (walkInteger: 'RSN' 68) (#'(' 'RS' 6) (#'}' 'L' 52) (#'-|' 'L' 52))
   (ReadaheadTable 3 (#'*' 'RS' 11) (#'/' 'RS' 12) (#'+' 'L' 66) (#'-' 'L' 66) (#'<' 'L' 66) (#'>' 'L' 66) (#'==' 'L' 66) (#'?' 'L' 66) (#')' 'L' 66) (#',' 'L' 66) (#';' 'L' 66) (#':' 'L' 66))
   (ReadaheadTable 4 (#'(' 'RS' 13))
   (ReadaheadTable 5 (#'<' 'RS' 14) (#'>' 'RS' 15) (#'==' 'RS' 16) (#'?' 'RS' 17) (#')' 'L' 67) (#',' 'L' 67) (#';' 'L' 67))
   (ReadaheadTable 6 (walkIdentifier: 'RSN' 7) (walkInteger: 'RSN' 68) (#'(' 'RS' 6))
   (ReadaheadTable 7 (#'=' 'RS' 19) (#'(' 'RS' 20) (#'*' 'L' 68) (#'/' 'L' 68) (#'+' 'L' 68) (#'-' 'L' 68) (#'<' 'L' 68) (#'>' 'L' 68) (#'==' 'L' 68) (#'?' 'L' 68) (#')' 'L' 68) (#',' 'L' 68) (#';' 'L' 68) (#':' 'L' 68))
   (ReadaheadTable 8 (#'(' 'RS' 21))
   (ReadaheadTable 9 (#'+' 'RS' 22) (#'-' 'RS' 23) (#'<' 'L' 70) (#'>' 'L' 70) (#'==' 'L' 70) (#'?' 'L' 70) (#')' 'L' 70) (#',' 'L' 70) (#';' 'L' 70) (#':' 'L' 70))
   (ReadaheadTable 10 (#';' 'RS' 71))
   (ReadaheadTable 11 (#'(' 'RS' 6) (walkInteger: 'RSN' 68) (walkIdentifier: 'RSN' 24))
   (ReadaheadTable 12 (#'(' 'RS' 6) (walkInteger: 'RSN' 68) (walkIdentifier: 'RSN' 24))
   (ReadaheadTable 13 (#'(' 'RS' 6) (walkIdentifier: 'RSN' 7) (walkInteger: 'RSN' 68))
   (ReadaheadTable 14 (walkIdentifier: 'RSN' 24) (walkInteger: 'RSN' 68) (#'(' 'RS' 6))
   (ReadaheadTable 15 (walkIdentifier: 'RSN' 24) (walkInteger: 'RSN' 68) (#'(' 'RS' 6))
   (ReadaheadTable 16 (walkIdentifier: 'RSN' 24) (walkInteger: 'RSN' 68) (#'(' 'RS' 6))
   (ReadaheadTable 17 (walkIdentifier: 'RSN' 24) (walkInteger: 'RSN' 68) (#'(' 'RS' 6))
   (ReadaheadTable 18 (#')' 'RS' 72))
   (ReadaheadTable 19 (walkIdentifier: 'RSN' 7) (walkInteger: 'RSN' 68) (#'(' 'RS' 6))
   (ReadaheadTable 20 (#')' 'RS' 79) (#'(' 'RS' 6) (walkIdentifier: 'RSN' 7) (walkInteger: 'RSN' 68))
   (ReadaheadTable 21 (#'(' 'RS' 6) (walkIdentifier: 'RSN' 7) (walkInteger: 'RSN' 68))
   (ReadaheadTable 22 (walkIdentifier: 'RSN' 24) (#'(' 'RS' 6) (walkInteger: 'RSN' 68))
   (ReadaheadTable 23 (walkIdentifier: 'RSN' 24) (#'(' 'RS' 6) (walkInteger: 'RSN' 68))
   (ReadaheadTable 24 (#'(' 'RS' 20) (#'*' 'L' 68) (#'/' 'L' 68) (#'+' 'L' 68) (#'-' 'L' 68) (#'<' 'L' 68) (#'>' 'L' 68) (#'==' 'L' 68) (#'?' 'L' 68) (#')' 'L' 68) (#',' 'L' 68) (#';' 'L' 68) (#':' 'L' 68))
   (ReadaheadTable 25 (#';' 'RS' 34))
   (ReadaheadTable 26 (#'+' 'RS' 22) (#'-' 'RS' 23) (#'<' 'L' 75) (#'>' 'L' 75) (#'==' 'L' 75) (#'?' 'L' 75) (#')' 'L' 75) (#',' 'L' 75) (#';' 'L' 75) (#':' 'L' 75))
   (ReadaheadTable 27 (#'+' 'RS' 22) (#'-' 'RS' 23) (#'<' 'L' 76) (#'>' 'L' 76) (#'==' 'L' 76) (#'?' 'L' 76) (#')' 'L' 76) (#',' 'L' 76) (#';' 'L' 76) (#':' 'L' 76))
   (ReadaheadTable 28 (#'+' 'RS' 22) (#'-' 'RS' 23) (#'<' 'L' 77) (#'>' 'L' 77) (#'==' 'L' 77) (#'?' 'L' 77) (#')' 'L' 77) (#',' 'L' 77) (#';' 'L' 77) (#':' 'L' 77))
   (ReadaheadTable 29 (#'<' 'RS' 14) (#'>' 'RS' 15) (#'==' 'RS' 16) (#':' 'RS' 35))
   (ReadaheadTable 30 (#',' 'RS' 36) (#')' 'RS' 79))
   (ReadaheadTable 31 (#')' 'RS' 37))
   (ReadaheadTable 32 (#'*' 'RS' 11) (#'/' 'RS' 12) (#'+' 'L' 80) (#'-' 'L' 80) (#'<' 'L' 80) (#'>' 'L' 80) (#'==' 'L' 80) (#'?' 'L' 80) (#')' 'L' 80) (#',' 'L' 80) (#';' 'L' 80) (#':' 'L' 80))
   (ReadaheadTable 33 (#'*' 'RS' 11) (#'/' 'RS' 12) (#'+' 'L' 81) (#'-' 'L' 81) (#'<' 'L' 81) (#'>' 'L' 81) (#'==' 'L' 81) (#'?' 'L' 81) (#')' 'L' 81) (#',' 'L' 81) (#';' 'L' 81) (#':' 'L' 81))
   (ReadaheadTable 34 (#'(' 'RS' 6) (walkIdentifier: 'RSN' 7) (walkInteger: 'RSN' 68))
   (ReadaheadTable 35 (#'(' 'RS' 6) (walkIdentifier: 'RSN' 24) (walkInteger: 'RSN' 68))
   (ReadaheadTable 36 (walkIdentifier: 'RSN' 7) (walkInteger: 'RSN' 68) (#'(' 'RS' 6))
   (ReadaheadTable 37 (#'{' 'RS' 41))
   (ReadaheadTable 38 (#';' 'RS' 42))
   (ReadaheadTable 39 (#'<' 'RS' 14) (#'>' 'RS' 15) (#'==' 'RS' 16) (#')' 'L' 82) (#',' 'L' 82) (#';' 'L' 82))
   (ReadaheadTable 40 (#',' 'RS' 36) (#')' 'RS' 79))
   (ReadaheadTable 41 (for 'RS' 4) (walkInteger: 'RSN' 68) (#'(' 'RS' 6) (walkIdentifier: 'RSN' 7) (if 'RS' 8) (#'}' 'L' 52) (#'-|' 'L' 52))
   (ReadaheadTable 42 (walkIdentifier: 'RSN' 7) (walkInteger: 'RSN' 68) (#'(' 'RS' 6))
   (ReadaheadTable 43 (#'}' 'RS' 45))
   (ReadaheadTable 44 (#')' 'RS' 46))
   (ReadaheadTable 45 (else 'RS' 47) (if 'L' 53) (for 'L' 53) (walkInteger: 'L' 53) (walkIdentifier: 'L' 53) (#'(' 'L' 53) (#'}' 'L' 53) (#'-|' 'L' 53))
   (ReadaheadTable 46 (#'{' 'RS' 48))
   (ReadaheadTable 47 (#'{' 'RS' 49))
   (ReadaheadTable 48 (for 'RS' 4) (#'(' 'RS' 6) (walkInteger: 'RSN' 68) (walkIdentifier: 'RSN' 7) (if 'RS' 8) (#'}' 'L' 52) (#'-|' 'L' 52))
   (ReadaheadTable 49 (for 'RS' 4) (#'(' 'RS' 6) (walkInteger: 'RSN' 68) (walkIdentifier: 'RSN' 7) (if 'RS' 8) (#'}' 'L' 52) (#'-|' 'L' 52))
   (ReadaheadTable 50 (#'}' 'RS' 83))
   (ReadaheadTable 51 (#'}' 'RS' 53))
   (ReadbackTable 52 ((Statement 2) 'RSN' 54) ((#'|-' 1) 'L' 96) ((#'{' 41) 'L' 96) ((#'{' 48) 'L' 96) ((#'{' 49) 'L' 96))
   (ReadbackTable 53 ((#'}' 53) 'RS' 84) ((#'}' 45) 'RS' 85))
   (ReadbackTable 54 ((Statement 2) 'RSN' 54) ((#'|-' 1) 'L' 96) ((#'{' 41) 'L' 96) ((#'{' 48) 'L' 96) ((#'{' 49) 'L' 96))
   (ReadbackTable 55 ((#'(' 20) 'RS' 61) ((Expression 40) 'RSN' 86) ((Expression 30) 'RSN' 87))
   (ReadbackTable 56 ((Expression2 32) 'RSN' 97) ((Expression2 33) 'RSN' 97) ((Expression2 3) 'RSN' 97))
   (ReadbackTable 57 ((Expression2 32) 'RSN' 98) ((Expression2 33) 'RSN' 98) ((Expression2 3) 'RSN' 98))
   (ReadbackTable 58 ((Expression0 39) 'RSN' 99) ((Expression0 5) 'RSN' 99) ((Expression0 29) 'RSN' 99))
   (ReadbackTable 59 ((Expression0 39) 'RSN' 100) ((Expression0 5) 'RSN' 100) ((Expression0 29) 'RSN' 100))
   (ReadbackTable 60 ((Expression0 39) 'RSN' 101) ((Expression0 5) 'RSN' 101) ((Expression0 29) 'RSN' 101))
   (ReadbackTable 61 ((walkIdentifier: 24) 'RSN' 103) ((walkIdentifier: 7) 'RSN' 103))
   (ReadbackTable 62 ((Expression1 27) 'RSN' 104) ((Expression1 28) 'RSN' 104) ((Expression1 9) 'RSN' 104) ((Expression1 26) 'RSN' 104))
   (ReadbackTable 63 ((Expression1 27) 'RSN' 105) ((Expression1 28) 'RSN' 105) ((Expression1 9) 'RSN' 105) ((Expression1 26) 'RSN' 105))
   (ReadbackTable 64 ((Expression 40) 'RSN' 86) ((Expression 30) 'RSN' 87))
   (ShiftbackTable 65 1 91)
   (ShiftbackTable 66 1 94)
   (ShiftbackTable 67 1 95)
   (ShiftbackTable 68 1 93)
   (ShiftbackTable 69 1 92)
   (ShiftbackTable 70 1 88)
   (ShiftbackTable 71 2 90)
   (ShiftbackTable 72 3 93)
   (ShiftbackTable 73 2 56)
   (ShiftbackTable 74 2 57)
   (ShiftbackTable 75 2 58)
   (ShiftbackTable 76 2 59)
   (ShiftbackTable 77 2 60)
   (ShiftbackTable 78 3 102)
   (ShiftbackTable 79 1 55)
   (ShiftbackTable 80 2 62)
   (ShiftbackTable 81 2 63)
   (ShiftbackTable 82 5 106)
   (ShiftbackTable 83 11 108)
   (ShiftbackTable 84 10 107)
   (ShiftbackTable 85 6 107)
   (ShiftbackTable 86 1 64)
   (ShiftbackTable 87 1 61)
   (ReduceTable 88 Expression0 (1 'RSN' 5)(2 'RSN' 5)(6 'RSN' 5)(13 'RSN' 5)(17 'RSN' 29)(19 'RSN' 5)(20 'RSN' 5)(21 'RSN' 5)(34 'RSN' 5)(35 'RSN' 39)(36 'RSN' 5)(41 'RSN' 5)(42 'RSN' 5)(48 'RSN' 5)(49 'RSN' 5))
   (ReduceTable 89 Statements (1 'RSN' 65)(41 'RSN' 43)(48 'RSN' 50)(49 'RSN' 51))
   (ReduceTable 90 Statement (1 'RSN' 2)(2 'RSN' 2)(41 'RSN' 2)(48 'RSN' 2)(49 'RSN' 2))
   (ReduceTable 91 Grammar (1 'RSN' 109))
   (ReduceTable 92 Expression2 (1 'RSN' 3)(2 'RSN' 3)(6 'RSN' 3)(13 'RSN' 3)(14 'RSN' 3)(15 'RSN' 3)(16 'RSN' 3)(17 'RSN' 3)(19 'RSN' 3)(20 'RSN' 3)(21 'RSN' 3)(22 'RSN' 32)(23 'RSN' 33)(34 'RSN' 3)(35 'RSN' 3)(36 'RSN' 3)(41 'RSN' 3)(42 'RSN' 3)(48 'RSN' 3)(49 'RSN' 3))
   (ReduceTable 93 Expression3 (1 'RSN' 69)(2 'RSN' 69)(6 'RSN' 69)(11 'RSN' 73)(12 'RSN' 74)(13 'RSN' 69)(14 'RSN' 69)(15 'RSN' 69)(16 'RSN' 69)(17 'RSN' 69)(19 'RSN' 69)(20 'RSN' 69)(21 'RSN' 69)(22 'RSN' 69)(23 'RSN' 69)(34 'RSN' 69)(35 'RSN' 69)(36 'RSN' 69)(41 'RSN' 69)(42 'RSN' 69)(48 'RSN' 69)(49 'RSN' 69))
   (ReduceTable 94 Expression1 (1 'RSN' 9)(2 'RSN' 9)(6 'RSN' 9)(13 'RSN' 9)(14 'RSN' 26)(15 'RSN' 27)(16 'RSN' 28)(17 'RSN' 9)(19 'RSN' 9)(20 'RSN' 9)(21 'RSN' 9)(34 'RSN' 9)(35 'RSN' 9)(36 'RSN' 9)(41 'RSN' 9)(42 'RSN' 9)(48 'RSN' 9)(49 'RSN' 9))
   (ReduceTable 95 Expression (1 'RSN' 10)(2 'RSN' 10)(6 'RSN' 18)(13 'RSN' 25)(19 'RSN' 78)(20 'RSN' 30)(21 'RSN' 31)(34 'RSN' 38)(36 'RSN' 40)(41 'RSN' 10)(42 'RSN' 44)(48 'RSN' 10)(49 'RSN' 10))
   (SemanticTable 96 buildTree: walkList: 89)
   (SemanticTable 97 buildTree: walkMultiply: 92)
   (SemanticTable 98 buildTree: walkDivide: 92)
   (SemanticTable 99 buildTree: walkLess: 88)
   (SemanticTable 100 buildTree: walkGreater: 88)
   (SemanticTable 101 buildTree: walkEqual: 88)
   (SemanticTable 102 buildTree: walkAssign: 95)
   (SemanticTable 103 buildTree: walkSend: 93)
   (SemanticTable 104 buildTree: walkPlus: 94)
   (SemanticTable 105 buildTree: walkMinus: 94)
   (SemanticTable 106 buildTree: walkIf: 95)
   (SemanticTable 107 buildTree: walkIf: 90)
   (SemanticTable 108 buildTree: walkFor: 90)
   (AcceptTable 109))!   !

!StudentCompiler class methods ! 
rawScannerTables
    "Scanner rawScannerTables"

    "EndOfFileCharacter is 256"
    ^

#(
   (ScannerReadaheadTable 1 ('#' 'R' 6) ('{' 'RK' 23) ('}' 'RK' 24) ((256) 'L' 7) ('<' 'RK' 18) ('=' 'RK' 3) ('>' 'RK' 20) (')' 'RK' 9) ('*' 'RK' 10) ('+' 'RK' 11) (',' 'RK' 12) ('-' 'RK' 13) ('(' 'RK' 8) ('/' 'RK' 14) ('0123456789' 'RK' 2) (':' 'RK' 16) (';' 'RK' 17) ('?' 'RK' 21) ('ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz' 'RK' 4) ((9 10 12 13) 'R' 5) (' ' 'R' 5))
   (ScannerReadaheadTable 2 ((9 10 12 13 256) 'L' 15) ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_+-*/<>=?[]{}()^;#:.$ ' 'L' 15) ('0123456789' 'RK' 2))
   (ScannerReadaheadTable 3 ((9 10 12 13 256) 'L' 19) ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_0123456789+-*/<>?[]{}()^;#:.$ ' 'L' 19) ('=' 'RK' 25))
   (ScannerReadaheadTable 4 ((9 10 12 13 256) 'L' 22) ('+-*/<>=?[]{}()^;#:.$ ' 'L' 22) ('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz' 'RK' 4))
   (ScannerReadaheadTable 5 ((256) 'L' 1) ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_0123456789+-*/<>=?[]{}()^;#:.$' 'L' 1) ((9 10 12 13) 'R' 5) (' ' 'R' 5))
   (ScannerReadaheadTable 6 ((9 256) 'R' 6) ('=>?ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_abcdefghijklmnopqrstuvwxyz{} #$()*+-./0123456789:;<' 'R' 6) ((10 12 13) 'R' 1))
   (SemanticTable 7 buildToken: '-|' 1)
   (SemanticTable 8 buildToken: '(' 1)
   (SemanticTable 9 buildToken: ')' 1)
   (SemanticTable 10 buildToken: '*' 1)
   (SemanticTable 11 buildToken: '+' 1)
   (SemanticTable 12 buildToken: ',' 1)
   (SemanticTable 13 buildToken: '-' 1)
   (SemanticTable 14 buildToken: '/' 1)
   (SemanticTable 15 buildToken: walkInteger: 1)
   (SemanticTable 16 buildToken: ':' 1)
   (SemanticTable 17 buildToken: ';' 1)
   (SemanticTable 18 buildToken: '<' 1)
   (SemanticTable 19 buildToken: '=' 1)
   (SemanticTable 20 buildToken: '>' 1)
   (SemanticTable 21 buildToken: '?' 1)
   (SemanticTable 22 buildToken: walkIdentifier: 1)
   (SemanticTable 23 buildToken: '{' 1)
   (SemanticTable 24 buildToken: '}' 1)
   (SemanticTable 25 buildToken: '==' 1))!  !
(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('raw tables' rawParserTables rawScannerTables )) !

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('raw tables' rawParserTables rawScannerTables )) !



!StudentCompiler class methods ! 
walkExample2
    "StudentCompiler walkExample2"
    ^StudentCompiler new compile: 'for (a =1; a< 5; a+1) {b-2;}'! !

!StudentCompiler class methods ! 
walkExample1
    "StudentCompiler walkExample1"
    ^StudentCompiler new compile: 'if (a > b) {a = b; c = d;} else {e = f;}'! !
(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample1 walkExample2 )) !

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample1 walkExample2 )) !



!StudentCompiler methods ! 
initialize
    parser := Parser 
        for: self 
        parserTables: self class rawParserTables 
        scannerTables: self class rawScannerTables.
        contextStack := OrderedCollection new.
        contextStack add: #statement.
        code := OrderedCollection new.!   !

"evaluate"   
(CodeFiler organizerFor: StudentCompiler) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('initializing' initialize )) !



!StudentCompiler methods !
parser: aParser
    parser := aParser! !

!StudentCompiler methods !   
contextStack: anOrderedCollection
    contextStack := anOrderedCollection! !

!StudentCompiler methods !   
code
    ^code!    !

!StudentCompiler methods !   
parser
    ^parser!    !

!StudentCompiler methods !   
code: anOrderedCollection
    code := anOrderedCollection! !

!StudentCompiler methods !   
tree: aTree
    tree := aTree! !

!StudentCompiler methods !   
contextStack
    ^contextStack!    !

!StudentCompiler methods !   
tree
    ^tree!    !
(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('get/set' contextStack code parser: parser code: tree: contextStack: tree )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('get/set' contextStack code parser: parser code: tree: contextStack: tree )) !



!StudentCompiler methods !   
popContext
    contextStack removeLast!    !

!StudentCompiler methods !   
pushExpressionContext
    contextStack add: #expression!   !

!StudentCompiler methods !   
pushStatementContext
    contextStack add: #statement! !

!StudentCompiler methods !   
isStatementContext
    ^contextStack last == #statement!   !

!StudentCompiler methods !   
isExpressionContext
    ^contextStack last == #expression! !
(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('contextStackMethods' pushStatementContext isExpressionContext pushExpressionContext popContext isStatementContext )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('contextStackMethods' pushStatementContext isExpressionContext pushExpressionContext popContext isStatementContext )) !



!StudentCompiler methods ! 
walkTree: tree
    ^self perform: tree label with: tree!   !

!StudentCompiler methods !   
compile: text
    tree := parser parse: text.
    self walkTree: tree.
    ^code!    !
(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('compiling/evaluating/walk' compile: walkTree: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('compiling/evaluating/walk' compile: walkTree: )) !



!StudentCompiler methods ! 
walkInstruction: opCode
    code add: opCode. 
    ^code size -1! !

!StudentCompiler methods !   
walkBranch: opcode backTo: location
    ^self walkInstruction: opcode 
        with: (location - self nextInstruction)!   !

!StudentCompiler methods !   
nextInstruction
    ^code size+1!  !

!StudentCompiler methods !   
walkInstruction: opCode with: operand
    code add: opCode; add: operand.
    ^code size-2!   !
(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' walkInstruction: nextInstruction walkInstruction:with: walkBranch:backTo: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' walkInstruction: nextInstruction walkInstruction:with: walkBranch:backTo: )) !



!StudentCompiler methods ! 
walkMultiply: tree
    self walkTree: (tree child: 1).
    tree children size == 1 ifTrue: [^self].
    self walkTree: (tree child: 2).
    self isExpressionContext ifTrue: [
        self walkInstruction: #Multiply]!   !

!StudentCompiler methods !   
walkEqual: tree
    self walkTree: (tree child: 1).
    self isStatementContext ifTrue: [^self].
    self walkTree: (tree child: 2).
    self isExpressionContext ifTrue: [
        self walkInstruction: #Equal]! !

!StudentCompiler methods !   
walkIdentifier: tree
    | name|
    self isStatementContext ifTrue: [^self].
    name := tree symbol.
    self walkInstruction: #Push with: name.! !

!StudentCompiler methods !   
walkDivide: tree
    self walkTree: (tree child: 1).
    tree children size == 1 ifTrue: [^self]. 
    self walkTree: (tree child: 2).
    self isExpressionContext ifTrue: [
        self walkInstruction: #Divide]!  !

!StudentCompiler methods !   
walkGreater: tree
    self walkTree: (tree child: 1).
    self isStatementContext ifTrue: [^self].
    self walkTree: (tree child: 2).
    self isExpressionContext ifTrue: [
        self walkInstruction: #Greater]! !

!StudentCompiler methods !   
walkFloat: tree
    | constant | 
    self isStatementContext ifTrue: [^#void].
    constant := tree symbol asFloat.
    self walkInstruction: #PushFloat with: constant.
    ^#Float! !

!StudentCompiler methods !   
walkAssign: tree
    | name expression | 
    name := (tree child: 1) symbol. 
    expression := tree child: 2. 
    self pushExpressionContext.
    self walkTree: expression.
    self popContext.
    self isExpressionContext ifTrue: [
        self walkInstruction: #Duplicate].
    self walkInstruction: #Pop with: name.! !

!StudentCompiler methods !   
walkList: tree
    tree children isEmpty ifTrue: [
        self isExpressionContext ifTrue: [
            self walkInstruction: #push with: nil. 
        ^self]].
    self pushStatementContext. 
        tree children allButLast do: [:child |
            self walkTree: child]. 
    self popContext. 
    self walkTree: (tree child: tree children size).!  !

!StudentCompiler methods !   
walkFor: tree
    |initialExpression booleanExpression incrementExpression body whileStart fixAtEnd end |
    
    self isExpressionContext ifTrue: [
        self designError: 'Can''t use for loop as expression'.    
        ^self
        ].
    
    initialExpression := tree child: 1.
    booleanExpression := tree child: 2.
    incrementExpression := tree child: 3.
    body := tree child: 4.
    

    self walkTree: initialExpression.
    self pushExpressionContext "For branchIfFalse to work".
        whileStart  := self nextInstruction.
        self walkTree: booleanExpression.
    
    self popContext.

    fixAtEnd:= self nextInstruction.
    self walkInstruction:  #branchIfFalse with: nil. 
    self walkTree: body.
    self walkTree: incrementExpression.
    self walkBranch: #branch backTo: whileStart.
    end:=self nextInstruction.
    self fixupBranch: fixAtEnd with: end.! !

!StudentCompiler methods !   
walkSend: tree
    | resultType selector types |
    types := OrderedCollection new.
    self pushExpressionContext.
    tree children indexedDo: [:index :child |index = 2
        ifTrue: [selector := child]
        ifFalse: types add: (self walkTree: child)].
    self popContext.
    self walkInstruction: #Send.! !

!StudentCompiler methods !   
walkMinus: tree
    self walkTree: (tree child: 1).
    tree children size == 1 ifTrue: [^self].
    self walkTree: (tree child: 2).
    self isExpressionContext ifTrue: [
        self walkInstruction: #Minus]! !

!StudentCompiler methods !   
walkLess: tree
    self walkTree: (tree child: 1).
    self isStatementContext ifTrue: [^self].
    self walkTree: (tree child: 2).
    self isExpressionContext ifTrue: [
        self walkInstruction: #Less]!   !

!StudentCompiler methods !   
walkPlus: tree
    self walkTree: (tree child: 1).
    tree children size == 1 ifTrue: [^self].
    self walkTree: (tree child: 2).
    self isExpressionContext ifTrue: [
        self walkInstruction: #Add.]!   !

!StudentCompiler methods !   
walkInteger: tree
    | constant |
    self isStatementContext ifTrue: [^#void].
    constant := tree symbol asInteger.
    self walkInstruction: #PushInteger with: constant.
    ^#Integer!  !

!StudentCompiler methods !   
walkIf: tree
    |exp then else fixToElse elseStart fixToEnd endStart|
    exp := tree child: 1.
    then := tree  child: 2.
    else := tree children size < 3
        ifTrue: [nil]
        ifFalse: [tree child: 3].
        else isNil 
            ifTrue:[ 
                self isExpressionContext 
                    ifTrue:[
                        self error: 'Missing else for if expression'.
                        else := then ]].
    
    self pushExpressionContext.
    self walkTree: exp.
    self popContext.
    
    fixToElse := self walkInstruction: #branchIfFalse with: nil. 
    self walkTree: then.
    else isNil
        ifTrue:[
                elseStart:= self nextInstruction.
                self fixupBranch: fixToElse with: elseStart]
        ifFalse: [
            fixToEnd := self walkInstruction: #branch with: nil.
            elseStart := self nextInstruction.
            self walkTree: else.
            endStart := self nextInstruction.
            
            self  fixupBranch: fixToElse with: elseStart.
            self fixupBranch: fixToEnd with: endStart].!   !
(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkMultiply: walkEqual: walkIdentifier: walkDivide: walkGreater: walkFloat: walkAssign: walkList: walkFor: walkSend: walkMinus: walkLess: walkPlus: walkInteger: walkIf: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkMultiply: walkEqual: walkIdentifier: walkDivide: walkGreater: walkFloat: walkAssign: walkList: walkFor: walkSend: walkMinus: walkLess: walkPlus: walkInteger: walkIf: )) !
CodeFiler setCommentFor: StudentCompiler to: ''!


"define class" 

Object subclass: #StudentCompiler
  instanceVariableNames: 
    ' parser tree contextStack code '
  classVariableNames: ''
  poolDictionaries: ''!


!StudentCompiler class methods !
new

    ^super new initialize!   !
(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('instance creation' new )) !



!StudentCompiler class methods ! 
rawParserTables
    "Tables generated from GrammarBuilder class>>parserGrammar"
    ^
#(
   (keywords if for else)
   (ReadaheadTable 1 (for 'RS' 4) (#'(' 'RS' 6) (walkInteger: 'RSN' 68) (walkIdentifier: 'RSN' 7) (if 'RS' 8) (#'}' 'L' 52) (#'-|' 'L' 52))
   (ReadaheadTable 2 (if 'RS' 8) (walkIdentifier: 'RSN' 7) (for 'RS' 4) (walkInteger: 'RSN' 68) (#'(' 'RS' 6) (#'}' 'L' 52) (#'-|' 'L' 52))
   (ReadaheadTable 3 (#'*' 'RS' 11) (#'/' 'RS' 12) (#'+' 'L' 66) (#'-' 'L' 66) (#'<' 'L' 66) (#'>' 'L' 66) (#'==' 'L' 66) (#'?' 'L' 66) (#')' 'L' 66) (#',' 'L' 66) (#';' 'L' 66) (#':' 'L' 66))
   (ReadaheadTable 4 (#'(' 'RS' 13))
   (ReadaheadTable 5 (#'<' 'RS' 14) (#'>' 'RS' 15) (#'==' 'RS' 16) (#'?' 'RS' 17) (#')' 'L' 67) (#',' 'L' 67) (#';' 'L' 67))
   (ReadaheadTable 6 (walkIdentifier: 'RSN' 7) (walkInteger: 'RSN' 68) (#'(' 'RS' 6))
   (ReadaheadTable 7 (#'=' 'RS' 19) (#'(' 'RS' 20) (#'*' 'L' 68) (#'/' 'L' 68) (#'+' 'L' 68) (#'-' 'L' 68) (#'<' 'L' 68) (#'>' 'L' 68) (#'==' 'L' 68) (#'?' 'L' 68) (#')' 'L' 68) (#',' 'L' 68) (#';' 'L' 68) (#':' 'L' 68))
   (ReadaheadTable 8 (#'(' 'RS' 21))
   (ReadaheadTable 9 (#'+' 'RS' 22) (#'-' 'RS' 23) (#'<' 'L' 70) (#'>' 'L' 70) (#'==' 'L' 70) (#'?' 'L' 70) (#')' 'L' 70) (#',' 'L' 70) (#';' 'L' 70) (#':' 'L' 70))
   (ReadaheadTable 10 (#';' 'RS' 71))
   (ReadaheadTable 11 (#'(' 'RS' 6) (walkInteger: 'RSN' 68) (walkIdentifier: 'RSN' 24))
   (ReadaheadTable 12 (#'(' 'RS' 6) (walkInteger: 'RSN' 68) (walkIdentifier: 'RSN' 24))
   (ReadaheadTable 13 (#'(' 'RS' 6) (walkIdentifier: 'RSN' 7) (walkInteger: 'RSN' 68))
   (ReadaheadTable 14 (walkIdentifier: 'RSN' 24) (walkInteger: 'RSN' 68) (#'(' 'RS' 6))
   (ReadaheadTable 15 (walkIdentifier: 'RSN' 24) (walkInteger: 'RSN' 68) (#'(' 'RS' 6))
   (ReadaheadTable 16 (walkIdentifier: 'RSN' 24) (walkInteger: 'RSN' 68) (#'(' 'RS' 6))
   (ReadaheadTable 17 (walkIdentifier: 'RSN' 24) (walkInteger: 'RSN' 68) (#'(' 'RS' 6))
   (ReadaheadTable 18 (#')' 'RS' 72))
   (ReadaheadTable 19 (walkIdentifier: 'RSN' 7) (walkInteger: 'RSN' 68) (#'(' 'RS' 6))
   (ReadaheadTable 20 (#')' 'RS' 79) (#'(' 'RS' 6) (walkIdentifier: 'RSN' 7) (walkInteger: 'RSN' 68))
   (ReadaheadTable 21 (#'(' 'RS' 6) (walkIdentifier: 'RSN' 7) (walkInteger: 'RSN' 68))
   (ReadaheadTable 22 (walkIdentifier: 'RSN' 24) (#'(' 'RS' 6) (walkInteger: 'RSN' 68))
   (ReadaheadTable 23 (walkIdentifier: 'RSN' 24) (#'(' 'RS' 6) (walkInteger: 'RSN' 68))
   (ReadaheadTable 24 (#'(' 'RS' 20) (#'*' 'L' 68) (#'/' 'L' 68) (#'+' 'L' 68) (#'-' 'L' 68) (#'<' 'L' 68) (#'>' 'L' 68) (#'==' 'L' 68) (#'?' 'L' 68) (#')' 'L' 68) (#',' 'L' 68) (#';' 'L' 68) (#':' 'L' 68))
   (ReadaheadTable 25 (#';' 'RS' 34))
   (ReadaheadTable 26 (#'+' 'RS' 22) (#'-' 'RS' 23) (#'<' 'L' 75) (#'>' 'L' 75) (#'==' 'L' 75) (#'?' 'L' 75) (#')' 'L' 75) (#',' 'L' 75) (#';' 'L' 75) (#':' 'L' 75))
   (ReadaheadTable 27 (#'+' 'RS' 22) (#'-' 'RS' 23) (#'<' 'L' 76) (#'>' 'L' 76) (#'==' 'L' 76) (#'?' 'L' 76) (#')' 'L' 76) (#',' 'L' 76) (#';' 'L' 76) (#':' 'L' 76))
   (ReadaheadTable 28 (#'+' 'RS' 22) (#'-' 'RS' 23) (#'<' 'L' 77) (#'>' 'L' 77) (#'==' 'L' 77) (#'?' 'L' 77) (#')' 'L' 77) (#',' 'L' 77) (#';' 'L' 77) (#':' 'L' 77))
   (ReadaheadTable 29 (#'<' 'RS' 14) (#'>' 'RS' 15) (#'==' 'RS' 16) (#':' 'RS' 35))
   (ReadaheadTable 30 (#',' 'RS' 36) (#')' 'RS' 79))
   (ReadaheadTable 31 (#')' 'RS' 37))
   (ReadaheadTable 32 (#'*' 'RS' 11) (#'/' 'RS' 12) (#'+' 'L' 80) (#'-' 'L' 80) (#'<' 'L' 80) (#'>' 'L' 80) (#'==' 'L' 80) (#'?' 'L' 80) (#')' 'L' 80) (#',' 'L' 80) (#';' 'L' 80) (#':' 'L' 80))
   (ReadaheadTable 33 (#'*' 'RS' 11) (#'/' 'RS' 12) (#'+' 'L' 81) (#'-' 'L' 81) (#'<' 'L' 81) (#'>' 'L' 81) (#'==' 'L' 81) (#'?' 'L' 81) (#')' 'L' 81) (#',' 'L' 81) (#';' 'L' 81) (#':' 'L' 81))
   (ReadaheadTable 34 (#'(' 'RS' 6) (walkIdentifier: 'RSN' 7) (walkInteger: 'RSN' 68))
   (ReadaheadTable 35 (#'(' 'RS' 6) (walkIdentifier: 'RSN' 24) (walkInteger: 'RSN' 68))
   (ReadaheadTable 36 (walkIdentifier: 'RSN' 7) (walkInteger: 'RSN' 68) (#'(' 'RS' 6))
   (ReadaheadTable 37 (#'{' 'RS' 41))
   (ReadaheadTable 38 (#';' 'RS' 42))
   (ReadaheadTable 39 (#'<' 'RS' 14) (#'>' 'RS' 15) (#'==' 'RS' 16) (#')' 'L' 82) (#',' 'L' 82) (#';' 'L' 82))
   (ReadaheadTable 40 (#',' 'RS' 36) (#')' 'RS' 79))
   (ReadaheadTable 41 (for 'RS' 4) (walkInteger: 'RSN' 68) (#'(' 'RS' 6) (walkIdentifier: 'RSN' 7) (if 'RS' 8) (#'}' 'L' 52) (#'-|' 'L' 52))
   (ReadaheadTable 42 (walkIdentifier: 'RSN' 7) (walkInteger: 'RSN' 68) (#'(' 'RS' 6))
   (ReadaheadTable 43 (#'}' 'RS' 45))
   (ReadaheadTable 44 (#')' 'RS' 46))
   (ReadaheadTable 45 (else 'RS' 47) (if 'L' 53) (for 'L' 53) (walkInteger: 'L' 53) (walkIdentifier: 'L' 53) (#'(' 'L' 53) (#'}' 'L' 53) (#'-|' 'L' 53))
   (ReadaheadTable 46 (#'{' 'RS' 48))
   (ReadaheadTable 47 (#'{' 'RS' 49))
   (ReadaheadTable 48 (for 'RS' 4) (#'(' 'RS' 6) (walkInteger: 'RSN' 68) (walkIdentifier: 'RSN' 7) (if 'RS' 8) (#'}' 'L' 52) (#'-|' 'L' 52))
   (ReadaheadTable 49 (for 'RS' 4) (#'(' 'RS' 6) (walkInteger: 'RSN' 68) (walkIdentifier: 'RSN' 7) (if 'RS' 8) (#'}' 'L' 52) (#'-|' 'L' 52))
   (ReadaheadTable 50 (#'}' 'RS' 83))
   (ReadaheadTable 51 (#'}' 'RS' 53))
   (ReadbackTable 52 ((Statement 2) 'RSN' 54) ((#'|-' 1) 'L' 96) ((#'{' 41) 'L' 96) ((#'{' 48) 'L' 96) ((#'{' 49) 'L' 96))
   (ReadbackTable 53 ((#'}' 53) 'RS' 84) ((#'}' 45) 'RS' 85))
   (ReadbackTable 54 ((Statement 2) 'RSN' 54) ((#'|-' 1) 'L' 96) ((#'{' 41) 'L' 96) ((#'{' 48) 'L' 96) ((#'{' 49) 'L' 96))
   (ReadbackTable 55 ((#'(' 20) 'RS' 61) ((Expression 40) 'RSN' 86) ((Expression 30) 'RSN' 87))
   (ReadbackTable 56 ((Expression2 32) 'RSN' 97) ((Expression2 33) 'RSN' 97) ((Expression2 3) 'RSN' 97))
   (ReadbackTable 57 ((Expression2 32) 'RSN' 98) ((Expression2 33) 'RSN' 98) ((Expression2 3) 'RSN' 98))
   (ReadbackTable 58 ((Expression0 39) 'RSN' 99) ((Expression0 5) 'RSN' 99) ((Expression0 29) 'RSN' 99))
   (ReadbackTable 59 ((Expression0 39) 'RSN' 100) ((Expression0 5) 'RSN' 100) ((Expression0 29) 'RSN' 100))
   (ReadbackTable 60 ((Expression0 39) 'RSN' 101) ((Expression0 5) 'RSN' 101) ((Expression0 29) 'RSN' 101))
   (ReadbackTable 61 ((walkIdentifier: 24) 'RSN' 103) ((walkIdentifier: 7) 'RSN' 103))
   (ReadbackTable 62 ((Expression1 27) 'RSN' 104) ((Expression1 28) 'RSN' 104) ((Expression1 9) 'RSN' 104) ((Expression1 26) 'RSN' 104))
   (ReadbackTable 63 ((Expression1 27) 'RSN' 105) ((Expression1 28) 'RSN' 105) ((Expression1 9) 'RSN' 105) ((Expression1 26) 'RSN' 105))
   (ReadbackTable 64 ((Expression 40) 'RSN' 86) ((Expression 30) 'RSN' 87))
   (ShiftbackTable 65 1 91)
   (ShiftbackTable 66 1 94)
   (ShiftbackTable 67 1 95)
   (ShiftbackTable 68 1 93)
   (ShiftbackTable 69 1 92)
   (ShiftbackTable 70 1 88)
   (ShiftbackTable 71 2 90)
   (ShiftbackTable 72 3 93)
   (ShiftbackTable 73 2 56)
   (ShiftbackTable 74 2 57)
   (ShiftbackTable 75 2 58)
   (ShiftbackTable 76 2 59)
   (ShiftbackTable 77 2 60)
   (ShiftbackTable 78 3 102)
   (ShiftbackTable 79 1 55)
   (ShiftbackTable 80 2 62)
   (ShiftbackTable 81 2 63)
   (ShiftbackTable 82 5 106)
   (ShiftbackTable 83 11 108)
   (ShiftbackTable 84 10 107)
   (ShiftbackTable 85 6 107)
   (ShiftbackTable 86 1 64)
   (ShiftbackTable 87 1 61)
   (ReduceTable 88 Expression0 (1 'RSN' 5)(2 'RSN' 5)(6 'RSN' 5)(13 'RSN' 5)(17 'RSN' 29)(19 'RSN' 5)(20 'RSN' 5)(21 'RSN' 5)(34 'RSN' 5)(35 'RSN' 39)(36 'RSN' 5)(41 'RSN' 5)(42 'RSN' 5)(48 'RSN' 5)(49 'RSN' 5))
   (ReduceTable 89 Statements (1 'RSN' 65)(41 'RSN' 43)(48 'RSN' 50)(49 'RSN' 51))
   (ReduceTable 90 Statement (1 'RSN' 2)(2 'RSN' 2)(41 'RSN' 2)(48 'RSN' 2)(49 'RSN' 2))
   (ReduceTable 91 Grammar (1 'RSN' 109))
   (ReduceTable 92 Expression2 (1 'RSN' 3)(2 'RSN' 3)(6 'RSN' 3)(13 'RSN' 3)(14 'RSN' 3)(15 'RSN' 3)(16 'RSN' 3)(17 'RSN' 3)(19 'RSN' 3)(20 'RSN' 3)(21 'RSN' 3)(22 'RSN' 32)(23 'RSN' 33)(34 'RSN' 3)(35 'RSN' 3)(36 'RSN' 3)(41 'RSN' 3)(42 'RSN' 3)(48 'RSN' 3)(49 'RSN' 3))
   (ReduceTable 93 Expression3 (1 'RSN' 69)(2 'RSN' 69)(6 'RSN' 69)(11 'RSN' 73)(12 'RSN' 74)(13 'RSN' 69)(14 'RSN' 69)(15 'RSN' 69)(16 'RSN' 69)(17 'RSN' 69)(19 'RSN' 69)(20 'RSN' 69)(21 'RSN' 69)(22 'RSN' 69)(23 'RSN' 69)(34 'RSN' 69)(35 'RSN' 69)(36 'RSN' 69)(41 'RSN' 69)(42 'RSN' 69)(48 'RSN' 69)(49 'RSN' 69))
   (ReduceTable 94 Expression1 (1 'RSN' 9)(2 'RSN' 9)(6 'RSN' 9)(13 'RSN' 9)(14 'RSN' 26)(15 'RSN' 27)(16 'RSN' 28)(17 'RSN' 9)(19 'RSN' 9)(20 'RSN' 9)(21 'RSN' 9)(34 'RSN' 9)(35 'RSN' 9)(36 'RSN' 9)(41 'RSN' 9)(42 'RSN' 9)(48 'RSN' 9)(49 'RSN' 9))
   (ReduceTable 95 Expression (1 'RSN' 10)(2 'RSN' 10)(6 'RSN' 18)(13 'RSN' 25)(19 'RSN' 78)(20 'RSN' 30)(21 'RSN' 31)(34 'RSN' 38)(36 'RSN' 40)(41 'RSN' 10)(42 'RSN' 44)(48 'RSN' 10)(49 'RSN' 10))
   (SemanticTable 96 buildTree: walkList: 89)
   (SemanticTable 97 buildTree: walkMultiply: 92)
   (SemanticTable 98 buildTree: walkDivide: 92)
   (SemanticTable 99 buildTree: walkLess: 88)
   (SemanticTable 100 buildTree: walkGreater: 88)
   (SemanticTable 101 buildTree: walkEqual: 88)
   (SemanticTable 102 buildTree: walkAssign: 95)
   (SemanticTable 103 buildTree: walkSend: 93)
   (SemanticTable 104 buildTree: walkPlus: 94)
   (SemanticTable 105 buildTree: walkMinus: 94)
   (SemanticTable 106 buildTree: walkIf: 95)
   (SemanticTable 107 buildTree: walkIf: 90)
   (SemanticTable 108 buildTree: walkFor: 90)
   (AcceptTable 109))!   !

!StudentCompiler class methods ! 
rawScannerTables
    "Scanner rawScannerTables"

    "EndOfFileCharacter is 256"
    ^

#(
   (ScannerReadaheadTable 1 ('#' 'R' 6) ('{' 'RK' 23) ('}' 'RK' 24) ((256) 'L' 7) ('<' 'RK' 18) ('=' 'RK' 3) ('>' 'RK' 20) (')' 'RK' 9) ('*' 'RK' 10) ('+' 'RK' 11) (',' 'RK' 12) ('-' 'RK' 13) ('(' 'RK' 8) ('/' 'RK' 14) ('0123456789' 'RK' 2) (':' 'RK' 16) (';' 'RK' 17) ('?' 'RK' 21) ('ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz' 'RK' 4) ((9 10 12 13) 'R' 5) (' ' 'R' 5))
   (ScannerReadaheadTable 2 ((9 10 12 13 256) 'L' 15) ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_+-*/<>=?[]{}()^;#:.$ ' 'L' 15) ('0123456789' 'RK' 2))
   (ScannerReadaheadTable 3 ((9 10 12 13 256) 'L' 19) ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_0123456789+-*/<>?[]{}()^;#:.$ ' 'L' 19) ('=' 'RK' 25))
   (ScannerReadaheadTable 4 ((9 10 12 13 256) 'L' 22) ('+-*/<>=?[]{}()^;#:.$ ' 'L' 22) ('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz' 'RK' 4))
   (ScannerReadaheadTable 5 ((256) 'L' 1) ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_0123456789+-*/<>=?[]{}()^;#:.$' 'L' 1) ((9 10 12 13) 'R' 5) (' ' 'R' 5))
   (ScannerReadaheadTable 6 ((9 256) 'R' 6) ('=>?ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_abcdefghijklmnopqrstuvwxyz{} #$()*+-./0123456789:;<' 'R' 6) ((10 12 13) 'R' 1))
   (SemanticTable 7 buildToken: '-|' 1)
   (SemanticTable 8 buildToken: '(' 1)
   (SemanticTable 9 buildToken: ')' 1)
   (SemanticTable 10 buildToken: '*' 1)
   (SemanticTable 11 buildToken: '+' 1)
   (SemanticTable 12 buildToken: ',' 1)
   (SemanticTable 13 buildToken: '-' 1)
   (SemanticTable 14 buildToken: '/' 1)
   (SemanticTable 15 buildToken: walkInteger: 1)
   (SemanticTable 16 buildToken: ':' 1)
   (SemanticTable 17 buildToken: ';' 1)
   (SemanticTable 18 buildToken: '<' 1)
   (SemanticTable 19 buildToken: '=' 1)
   (SemanticTable 20 buildToken: '>' 1)
   (SemanticTable 21 buildToken: '?' 1)
   (SemanticTable 22 buildToken: walkIdentifier: 1)
   (SemanticTable 23 buildToken: '{' 1)
   (SemanticTable 24 buildToken: '}' 1)
   (SemanticTable 25 buildToken: '==' 1))!  !
(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('raw tables' rawParserTables rawScannerTables )) !

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('raw tables' rawParserTables rawScannerTables )) !



!StudentCompiler class methods ! 
walkExample2
    "StudentCompiler walkExample2"
    ^StudentCompiler new compile: 'for (a =1; a< 5; a+1) {b-2;}'! !

!StudentCompiler class methods ! 
walkExample1
    "StudentCompiler walkExample1"
    ^StudentCompiler new compile: 'if (a > b) {a = b; c = d;} else {e = f;}'! !
(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample1 walkExample2 )) !

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample1 walkExample2 )) !



!StudentCompiler methods ! 
initialize
    parser := Parser 
        for: self 
        parserTables: self class rawParserTables 
        scannerTables: self class rawScannerTables.
        contextStack := OrderedCollection new.
        contextStack add: #statement.
        code := OrderedCollection new.!   !
(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('initializing' initialize )) !



!StudentCompiler methods !   
parser: aParser
    parser := aParser! !

!StudentCompiler methods !   
contextStack: anOrderedCollection
    contextStack := anOrderedCollection! !

!StudentCompiler methods !   
code
    ^code!    !

!StudentCompiler methods !   
parser
    ^parser!    !

!StudentCompiler methods !   
code: anOrderedCollection
    code := anOrderedCollection! !

!StudentCompiler methods !   
tree: aTree
    tree := aTree! !

!StudentCompiler methods !   
contextStack
    ^contextStack!    !

!StudentCompiler methods !   
tree
    ^tree!    !
(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('get/set' contextStack contextStack: parser: parser code: tree: code tree )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('get/set' contextStack contextStack: parser: parser code: tree: code tree )) !



!StudentCompiler methods !   
popContext
    contextStack removeLast!    !

!StudentCompiler methods !   
pushExpressionContext
    contextStack add: #expression!   !

!StudentCompiler methods !   
pushStatementContext
    contextStack add: #statement! !

!StudentCompiler methods !   
isStatementContext
    ^contextStack last == #statement!   !

!StudentCompiler methods !   
isExpressionContext
    ^contextStack last == #expression! !
(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('contextStackMethods' pushStatementContext isExpressionContext pushExpressionContext popContext isStatementContext )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('contextStackMethods' pushStatementContext isExpressionContext pushExpressionContext popContext isStatementContext )) !



!StudentCompiler methods ! 
walkTree: tree
    ^self perform: tree label with: tree!   !

!StudentCompiler methods !   
compile: text
    tree := parser parse: text.
    self walkTree: tree.
    ^code!    !
(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('compiling/evaluating/walk' compile: walkTree: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('compiling/evaluating/walk' compile: walkTree: )) !



!StudentCompiler methods ! 
walkInstruction: opCode
    code add: opCode. 
    ^code size -1! !

!StudentCompiler methods !   
walkBranch: opcode backTo: location
    ^self walkInstruction: opcode 
        with: (location - self nextInstruction)!   !

!StudentCompiler methods !   
fixupBranch: where with: nextInstruction
    newOffset := nextInstruction - where.
    code at: where + 1 put: newOffset! !

!StudentCompiler methods !   
nextInstruction
    ^code size+1!  !

!StudentCompiler methods !   
walkInstruction: opCode with: operand
    code add: opCode; add: operand.
    ^code size-2!   !
(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' walkInstruction: nextInstruction walkBranch:backTo: walkInstruction:with: fixupBranch:with: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' walkInstruction: nextInstruction walkBranch:backTo: walkInstruction:with: fixupBranch:with: )) !



!StudentCompiler methods ! 
walkMultiply: tree
    self walkTree: (tree child: 1).
    tree children size == 1 ifTrue: [^self].
    self walkTree: (tree child: 2).
    self isExpressionContext ifTrue: [
        self walkInstruction: #Multiply]!   !

!StudentCompiler methods !   
walkEqual: tree
    self walkTree: (tree child: 1).
    self isStatementContext ifTrue: [^self].
    self walkTree: (tree child: 2).
    self isExpressionContext ifTrue: [
        self walkInstruction: #Equal]! !

!StudentCompiler methods !   
walkIdentifier: tree
    | name|
    self isStatementContext ifTrue: [^self].
    name := tree symbol.
    self walkInstruction: #Push with: name.! !

!StudentCompiler methods !   
walkDivide: tree
    self walkTree: (tree child: 1).
    tree children size == 1 ifTrue: [^self]. 
    self walkTree: (tree child: 2).
    self isExpressionContext ifTrue: [
        self walkInstruction: #Divide]!  !

!StudentCompiler methods !   
walkGreater: tree
    self walkTree: (tree child: 1).
    self isStatementContext ifTrue: [^self].
    self walkTree: (tree child: 2).
    self isExpressionContext ifTrue: [
        self walkInstruction: #Greater]! !

!StudentCompiler methods !   
walkFloat: tree
    | constant | 
    self isStatementContext ifTrue: [^#void].
    constant := tree symbol asFloat.
    self walkInstruction: #PushFloat with: constant.
    ^#Float! !

!StudentCompiler methods !   
walkAssign: tree
    | name expression | 
    name := (tree child: 1) symbol. 
    expression := tree child: 2. 
    self pushExpressionContext.
    self walkTree: expression.
    self popContext.
    self isExpressionContext ifTrue: [
        self walkInstruction: #Duplicate].
    self walkInstruction: #Pop with: name.! !

!StudentCompiler methods !   
walkList: tree
    tree children isEmpty ifTrue: [
        self isExpressionContext ifTrue: [
            self walkInstruction: #push with: nil. 
        ^self]].
    self pushStatementContext. 
        tree children allButLast do: [:child |
            self walkTree: child]. 
    self popContext. 
    self walkTree: (tree child: tree children size).!  !

!StudentCompiler methods !   
walkFor: tree
    |initialExpression booleanExpression incrementExpression body whileStart fixAtEnd end |
    
    self isExpressionContext ifTrue: [
        self designError: 'Can''t use for loop as expression'.    
        ^self
        ].
    
    initialExpression := tree child: 1.
    booleanExpression := tree child: 2.
    incrementExpression := tree child: 3.
    body := tree child: 4.
    

    self walkTree: initialExpression.
    self pushExpressionContext "For branchIfFalse to work".
        whileStart  := self nextInstruction.
        self walkTree: booleanExpression.
    
    self popContext.

    fixAtEnd:= self nextInstruction.
    self walkInstruction:  #branchIfFalse with: nil. 
    self walkTree: body.
    self walkTree: incrementExpression.
    self walkBranch: #branch backTo: whileStart.
    end:=self nextInstruction.
    self fixupBranch: fixAtEnd with: end.! !

!StudentCompiler methods !   
walkSend: tree
    | resultType selector types |
    types := OrderedCollection new.
    self pushExpressionContext.
    tree children indexedDo: [:index :child |index = 2
        ifTrue: [selector := child]
        ifFalse: types add: (self walkTree: child)].
    self popContext.
    self walkInstruction: #Send.! !

!StudentCompiler methods !   
walkMinus: tree
    self walkTree: (tree child: 1).
    tree children size == 1 ifTrue: [^self].
    self walkTree: (tree child: 2).
    self isExpressionContext ifTrue: [
        self walkInstruction: #Minus]! !

!StudentCompiler methods !   
walkLess: tree
    self walkTree: (tree child: 1).
    self isStatementContext ifTrue: [^self].
    self walkTree: (tree child: 2).
    self isExpressionContext ifTrue: [
        self walkInstruction: #Less]!   !

!StudentCompiler methods !   
walkPlus: tree
    self walkTree: (tree child: 1).
    tree children size == 1 ifTrue: [^self].
    self walkTree: (tree child: 2).
    self isExpressionContext ifTrue: [
        self walkInstruction: #Add.]!   !

!StudentCompiler methods !   
walkInteger: tree
    | constant |
    self isStatementContext ifTrue: [^#void].
    constant := tree symbol asInteger.
    self walkInstruction: #PushInteger with: constant.
    ^#Integer!  !

!StudentCompiler methods !   
walkIf: tree
    |exp then else fixToElse elseStart fixToEnd endStart|
    exp := tree child: 1.
    then := tree  child: 2.
    else := tree children size < 3
        ifTrue: [nil]
        ifFalse: [tree child: 3].
        else isNil 
            ifTrue:[ 
                self isExpressionContext 
                    ifTrue:[
                        self error: 'Missing else for if expression'.
                        else := then ]].
    
    self pushExpressionContext.
    self walkTree: exp.
    self popContext.
    
    fixToElse := self walkInstruction: #branchIfFalse with: nil. 
    self walkTree: then.
    else isNil
        ifTrue:[
                elseStart:= self nextInstruction.
                self fixupBranch: fixToElse with: elseStart]
        ifFalse: [
            fixToEnd := self walkInstruction: #branch with: nil.
            elseStart := self nextInstruction.
            self walkTree: else.
            endStart := self nextInstruction.
            
            self  fixupBranch: fixToElse with: elseStart.
            self fixupBranch: fixToEnd with: endStart].!   !
(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkMultiply: walkEqual: walkIdentifier: walkDivide: walkGreater: walkFloat: walkAssign: walkList: walkFor: walkSend: walkMinus: walkLess: walkPlus: walkInteger: walkIf: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkMultiply: walkEqual: walkIdentifier: walkDivide: walkGreater: walkFloat: walkAssign: walkList: walkFor: walkSend: walkMinus: walkLess: walkPlus: walkInteger: walkIf: )) !
CodeFiler setCommentFor: StudentCompiler to: ''!


"define class" 

Object subclass: #Truck
  instanceVariableNames: 
    ' driver passengers loads '
  classVariableNames: ''
  poolDictionaries: ''!


!Truck class methods !  
new

    ^super new initialize!   !

"evaluate"   
(CodeFiler organizerFor: Truck class) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Truck class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: Truck class) reorganizeFrom: #(
('instance creation' new )) !



!Truck class methods !
example1
    "Truck example1"
    | aTruck |
    aTruck := Truck new driver: #Jim.
    aTruck addPassenger: #Tom; addPassenger: #Dayton.
    aTruck addLoad: #Wheelbarrow; addLoad: #Ladder; addLoad: #Cement.
    aTruck driverDo: [:driver | Transcript cr; << 'The driver is '; << driver].
    aTruck passengersDo: [:passenger | Transcript cr; << 'One passenger is '; << passenger].
    aTruck loadDo: [:load | Transcript cr; << 'The back of the truck contains a '; << load].
    "Method do: sequences over everything in the truck."
    aTruck do: [:anObject | Transcript cr; << 'In the truck, there is a '; << anObject].!   !
(CodeFiler organizerFor: Truck class) reorganizeFrom: #(
('examples' example1 )) !

(CodeFiler organizerFor: Truck class) reorganizeFrom: #(
('examples' example1 )) !



!Truck methods ! 
initialize

    self
        passengers: OrderedCollection new;
        loads: OrderedCollection new;
        driver: String new!  !

"evaluate"   
(CodeFiler organizerFor: Truck) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Truck) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: Truck) reorganizeFrom: #(
('initializing' initialize )) !



!Truck methods !
driver
    ^driver!    !

!Truck methods ! 
passengers
    ^passengers!    !

!Truck methods ! 
loads: anOrderedCollection
    loads := anOrderedCollection!   !

!Truck methods ! 
passengers: anOrderedCollection
    passengers := anOrderedCollection! !

!Truck methods ! 
loads
    ^loads!  !

!Truck methods ! 
driver: aString
    driver := aString! !
(CodeFiler organizerFor: Truck) reorganizeFrom: #(
('get/set' driver passengers loads: passengers: loads driver: )) !

(CodeFiler organizerFor: Truck) reorganizeFrom: #(
('get/set' driver passengers loads: passengers: loads driver: )) !



!Truck methods !   
passengersDo: anOutputStream
    self passengers isEmpty
    ifFalse: [ anOutputStream value: self passengers first. ]
    ifTrue: [ anOutputStream value: 'Empty'. ].!  !

!Truck methods ! 
do: anOutputStream
    |aBufferString|
    aBufferString:=''.

    self driver isEmpty 
        ifFalse: [
            aBufferString := aBufferString, Character cr asString.
            aBufferString := aBufferString, 'Driver: ', self driver asString.
         ].
         
    self passengers isEmpty 
         ifFalse: [
             aBufferString := aBufferString, Character cr asString.
             aBufferString := aBufferString, 'Passengers:'.
             1 to: self passengers size do: [:index| aBufferString := aBufferString, ' ', (self passengers at: index)].
          ].
          
    self loads isEmpty
        ifFalse:[
            aBufferString := aBufferString, Character cr asString.
            aBufferString := aBufferString, 'Loads:'.
            1 to: self loads size do: [:index| aBufferString := aBufferString, ' ', (self loads at: index)].
         ].
    anOutputStream value: aBufferString!   !

!Truck methods ! 
driverDo: anOutputStream
    anOutputStream value: self driver!    !

!Truck methods ! 
loadDo: anOutputStream
    self loads isEmpty
    ifFalse: [ anOutputStream value: self loads first. ]
    ifTrue: [ anOutputStream value: 'Empty'. ].!  !
(CodeFiler organizerFor: Truck) reorganizeFrom: #(
('doMethods' passengersDo: do: driverDo: loadDo: )) !

(CodeFiler organizerFor: Truck) reorganizeFrom: #(
('doMethods' passengersDo: do: driverDo: loadDo: )) !



!Truck methods ! 
addPassenger: aString
    passengers add: aString! !

!Truck methods ! 
addLoad: aString
    loads add: aString!   !
(CodeFiler organizerFor: Truck) reorganizeFrom: #(
('addMethods' addPassenger: addLoad: )) !

(CodeFiler organizerFor: Truck) reorganizeFrom: #(
('addMethods' addPassenger: addLoad: )) !
CodeFiler setCommentFor: Truck to: 'Truck example1'!


"define class"   

Object subclass: #Relation
  instanceVariableNames: 
    ' triples '
  classVariableNames: ''
  poolDictionaries: ''!


!Relation class methods !
new

    ^super new initialize!   !
(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('instance creation' new )) !



!Relation class methods !  
example1
    "Relation example1"
        | collection relation bracket1 |
        "First, build a relation."
        collection := #((2 < 3) (1 = 1) (3 > 1) (2 < 4)(1 < 5) (5 < 6) (2 < 5)).
        relation := Relation new.
        collection do: [:triple | relation addTriple: triple].
        Transcript cr; << 'Let relation = '; << collection.
        Transcript cr; << 'The created relation is '.
        relation do: [:a :b :c |Transcript cr; << a; space; << b; space; << c; space]!    !

!Relation class methods !
example2
        "Relation example2"
        | collection relation |
        "First, build a relation."
        collection := #((2 < 3) (1 = 1) (3 > 1) (2 < 4)(1 < 5) (5 < 6) (2 < 5)).
        relation := Relation new.
        collection do: [:triple | relation addTriple: triple].

        Transcript cr; << 'Let relation = '; << collection.
        Transcript cr; << 'Starting from {1 2 3},'.
            relation from: #(1 2 3) do: [:relationship :subrelation |                 
                Transcript cr; << 'There is a relationship '; << relationship; 
                    << ' with subrelation'; cr; tab.
                subrelation do: [:triple |Transcript space; << triple]]!    !
(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('examples' example1 example2 )) !

(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('examples' example1 example2 )) !



!Relation class methods !
using: relation1 and: relation2 performCollectionOneStep: aCollection
    | newRelation |
     newRelation := self using: relation1 and: 2 performRelationOneStep: aCollection.
     ^newRelation allTo! !

!Relation class methods !
using: relation performRelationOneStep: items
    "Builds new triples by applying 'relation' ONCE to each item in items. Returns the triples in a totally new relation."
    | newRelation tos |
    newRelation := Relation new. tos = OrderedCollection new.
    
    relation from: items do: [:relationship :subrelation |
        subrelation do: [:triple | tos addifAbsent: triple third]].

    relation from: tos do: [:relationship :subrelation |
        subrelation do: [:triple | newRelation addTriple: triple]].

    ^newRelation!  !

!Relation class methods !
using: relation1 and: relation2 performItemStep: items
    | newRelation |
     newRelation := self using: relation1 and: 2 performRelationOneStep: items.
     ^newRelation allTo!  !

!Relation class methods !
using: relation1 and: relation2 performRelationOneStep: items
    "Builds new triples by applying 'relation1' ONCE to each item in items and 'relation2' ONCE to each item in items. Returns the triples in a totally new relation."!  !

!Relation class methods !
using: relation performRelationStar: items
    | newRelation workingCollection|
    newRelation := Relation new.
    workingCollection := OrderedCollection new addAllIfAbsent: items.
    workingCollection do: [:item |
        relation from: (OrderedCollection with: item) do: [:relationship :subrelation |
        subrelation do: [:triple | 
            workingCollection addIfAbsent: triples last.
            newRelation addTriple: triple]]].

    ^newRelation!   !

!Relation class methods !
using: relation performCollectionOneStep: aCollection
    | newRelation |
     newRelation := self using: relation performRelationOneStep: aCollection.
     ^newRelation allTo! !

!Relation class methods !
using: relation performItemOneStep: items
    | newRelation |
     newRelation := self using: relation performRelationOneStep: items.
     ^newRelation allTo!   !

!Relation class methods !
using: relation performItemStar: items
    | newRelation |
    newRelation := self using: relation performRelationStar: items.
    ^newRelation allTo addAllIfAbsent: items! !
(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('performMethods' using:and:performCollectionOneStep: using:performRelationOneStep: using:and:performItemStep: using:and:performRelationOneStep: using:performRelationStar: using:performCollectionOneStep: using:performItemStar: using:performItemOneStep: )) !

(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('performMethods' using:and:performCollectionOneStep: using:performRelationOneStep: using:and:performItemStep: using:and:performRelationOneStep: using:performRelationStar: using:performCollectionOneStep: using:performItemStar: using:performItemOneStep: )) !



!Relation methods !
initialize

    self
        triples: OrderedCollection new! !
(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('initializing' initialize )) !



!Relation methods !
triples: anOrderedCollection
    triples := anOrderedCollection!   !

!Relation methods !  
triples
    ^triples!  !
(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('get/set' triples: triples )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('get/set' triples: triples )) !



!Relation methods !  
allRelationships
    ^triples collect: [:triple | triple second]!  !

!Relation methods !  
allFrom
    ^triples collect: [:triple | triple first]!    !

!Relation methods !  
from: keys do: aBlock
    (triples select: [:triple | keys includes: triple first]) 
    do: [:triple | 
        aBlock 
            value: triple first 
            value: triple rest]! !

!Relation methods !  
addFrom: key via: relationship to: value
    triples add: 
        [Array 
            with: key
            with: relationship 
            with: value].!    !

!Relation methods !  
allTo
    ^triples collect: [:triple | triple third]!  !

!Relation methods !  
addTriple: triple
        triples addAllIfAbsent: triple!  !

!Relation methods !  
do: aBlock
    triples do: [:triple | 
        aBlock 
            value: triple first 
            value: triple second 
            value: triple third]!    !
(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' allRelationships allFrom from:do: addFrom:via:to: allTo addTriple: do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' allRelationships allFrom from:do: addFrom:via:to: allTo addTriple: do: )) !
CodeFiler setCommentFor: Relation to: ''!


"evaluate"  
(CodeFiler organizerFor: Relation class) removeCategory: 'performMethods' ifAbsent: [nil]!
"*** Image started on: February 8, 2021 04:50:22 PM ***"!

"define class"   

Object subclass: #Relation
  instanceVariableNames: 
    ' triples '
  classVariableNames: ''
  poolDictionaries: ''!


!Relation class methods !
new

    ^super new initialize!   !

"evaluate"   
(CodeFiler organizerFor: Relation class) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('instance creation' new )) !



!Relation class methods !
example1
    "Relation example1"
        | collection relation bracket1 |
        "First, build a relation."
        collection := #((2 < 3) (1 = 1) (3 > 1) (2 < 4)(1 < 5) (5 < 6) (2 < 5)).
        relation := Relation new.
        collection do: [:triple | relation addTriple: triple].
        Transcript cr; << 'Let relation = '; << collection.
        Transcript cr; << 'The created relation is '.
        relation do: [:a :b :c |Transcript cr; << a; space; << b; space; << c; space]!    !

!Relation class methods !
example2
        "Relation example2"
        | collection relation |
        "First, build a relation."
        collection := #((2 < 3) (1 = 1) (3 > 1) (2 < 4)(1 < 5) (5 < 6) (2 < 5)).
        relation := Relation new.
        collection do: [:triple | relation addTriple: triple].

        Transcript cr; << 'Let relation = '; << collection.
        Transcript cr; << 'Starting from {1 2 3},'.
            relation from: #(1 2 3) do: [:relationship :subrelation |                 
                Transcript cr; << 'There is a relationship '; << relationship; 
                    << ' with subrelation'; cr; tab.
                subrelation do: [:triple |Transcript space; << triple]]!    !
(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('examples' example1 example2 )) !

(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('examples' example1 example2 )) !



!Relation class methods !
using: relation1 and: relation2 performCollectionOneStep: aCollection
    | newRelation |
     newRelation := self using: relation1 and: 2 performRelationOneStep: aCollection.
     ^newRelation allTo! !

!Relation class methods !
using: relation performRelationOneStep: items
    "Builds new triples by applying 'relation' ONCE to each item in items. Returns the triples in a totally new relation."
    | newRelation tos |
    newRelation := Relation new. tos = OrderedCollection new.
    
    relation from: items do: [:relationship :subrelation |
        subrelation do: [:triple | tos addifAbsent: triple third]].

    relation from: tos do: [:relationship :subrelation |
        subrelation do: [:triple | newRelation addTriple: triple]].

    ^newRelation!  !

!Relation class methods !
using: relation1 and: relation2 performItemStep: items
    | newRelation |
     newRelation := self using: relation1 and: 2 performRelationOneStep: items.
     ^newRelation allTo!  !

!Relation class methods !
using: relation1 and: relation2 performRelationOneStep: items
    "Builds new triples by applying 'relation1' ONCE to each item in items and 'relation2' ONCE to each item in items. Returns the triples in a totally new relation."!  !

!Relation class methods !
using: relation performCollectionOneStep: aCollection
    | newRelation |
     newRelation := self using: relation performRelationOneStep: aCollection.
     ^newRelation allTo! !

!Relation class methods !
using: relation performItemOneStep: items
    | newRelation |
     newRelation := self using: relation performRelationOneStep: items.
     ^newRelation allTo!   !

!Relation class methods !
using: relation performItemStar: items
    | newRelation |
    newRelation := self using: relation performRelationStar: items.
    ^newRelation allTo addAllIfAbsent: items! !
(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('performMethods' using:and:performCollectionOneStep: using:performRelationOneStep: using:and:performItemStep: using:and:performRelationOneStep: using:performCollectionOneStep: using:performItemOneStep: using:performItemStar: )) !

(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('performMethods' using:and:performCollectionOneStep: using:performRelationOneStep: using:and:performItemStep: using:and:performRelationOneStep: using:performCollectionOneStep: using:performItemOneStep: using:performItemStar: )) !



!Relation methods !  
initialize

    self
        triples: OrderedCollection new! !

"evaluate"   
(CodeFiler organizerFor: Relation) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('initializing' initialize )) !



!Relation methods !
triples: anOrderedCollection
    triples := anOrderedCollection!   !

!Relation methods !  
triples
    ^triples!  !
(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('get/set' triples: triples )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('get/set' triples: triples )) !



!Relation methods !  
allRelationships
    ^triples collect: [:triple | triple second]!  !

!Relation methods !  
allFrom
    ^triples collect: [:triple | triple first]!    !

!Relation methods !  
from: keys do: aBlock
    (triples select: [:triple | keys includes: triple first]) 
    do: [:triple | 
        aBlock 
            value: triple first 
            value: triple rest]! !

!Relation methods !  
allTo
    ^triples collect: [:triple | triple third]!  !

!Relation methods !  
addTriple: triple
        triples addAllIfAbsent: triple!  !

!Relation methods !  
do: aBlock
    triples do: [:triple | 
        aBlock 
            value: triple first 
            value: triple second 
            value: triple third]!    !
(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' allRelationships allFrom from:do: allTo addTriple: do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' allRelationships allFrom from:do: allTo addTriple: do: )) !
CodeFiler setCommentFor: Relation to: ''!



'Smalltalk'!

!Relation methods !   
do: aBlock
    triples do: [:triple | 
        aBlock 
            value: triple first 
            value: triple second 
            value: triple third]!    ! 
#('February 8, 2021' '04:54:09 PM' 1744780)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' do: )) !


"define class"  

Object subclass: #Relation
  instanceVariableNames: 
    ' triples '
  classVariableNames: ''
  poolDictionaries: ''!


!Relation class methods !
new

    ^super new initialize!   !
(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('instance creation' new )) !



!Relation class methods !  
example1
    "Relation example1"
        | collection relation bracket1 |
        "First, build a relation."
        collection := #((2 < 3) (1 = 1) (3 > 1) (2 < 4)(1 < 5) (5 < 6) (2 < 5)).
        relation := Relation new.
        collection do: [:triple | relation addTriple: triple].
        Transcript cr; << 'Let relation = '; << collection.
        Transcript cr; << 'The created relation is '.
        relation do: [:a :b :c |Transcript cr; << a; space; << b; space; << c; space]!    !

!Relation class methods !
example2
        "Relation example2"
        | collection relation |
        "First, build a relation."
        collection := #((2 < 3) (1 = 1) (3 > 1) (2 < 4)(1 < 5) (5 < 6) (2 < 5)).
        relation := Relation new.
        collection do: [:triple | relation addTriple: triple].

        Transcript cr; << 'Let relation = '; << collection.
        Transcript cr; << 'Starting from {1 2 3},'.
            relation from: #(1 2 3) do: [:relationship :subrelation |                 
                Transcript cr; << 'There is a relationship '; << relationship; 
                    << ' with subrelation'; cr; tab.
                subrelation do: [:triple |Transcript space; << triple]]!    !
(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('examples' example1 example2 )) !

(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('examples' example1 example2 )) !



!Relation class methods !
using: relation1 and: relation2 performCollectionOneStep: aCollection
    | newRelation |
     newRelation := self using: relation1 and: 2 performRelationOneStep: aCollection.
     ^newRelation allTo! !

!Relation class methods !
using: relation performRelationOneStep: items
    "Builds new triples by applying 'relation' ONCE to each item in items. Returns the triples in a totally new relation."
    | newRelation tos |
    newRelation := Relation new. tos = OrderedCollection new.
    
    relation from: items do: [:relationship :subrelation |
        subrelation do: [:triple | tos addifAbsent: triple third]].

    relation from: tos do: [:relationship :subrelation |
        subrelation do: [:triple | newRelation addTriple: triple]].

    ^newRelation!  !

!Relation class methods !
using: relation1 and: relation2 performItemStep: items
    | newRelation |
     newRelation := self using: relation1 and: 2 performRelationOneStep: items.
     ^newRelation allTo!  !

!Relation class methods !
using: relation1 and: relation2 performRelationOneStep: items
    "Builds new triples by applying 'relation1' ONCE to each item in items and 'relation2' ONCE to each item in items. Returns the triples in a totally new relation."!  !

!Relation class methods !
using: relation performRelationStar: items
    | newRelation workingCollection|
    newRelation := Relation new.
    workingCollection := OrderedCollection new addAllIfAbsent: items.
    workingCollection do: [:item |
        relation from: (OrderedCollection with: item) do: [:relationship :subrelation |
        subrelation do: [:triple | 
            workingCollection addIfAbsent: triples last.
            newRelation addTriple: triple]]].

    ^newRelation!   !

!Relation class methods !
using: relation performCollectionOneStep: aCollection
    | newRelation |
     newRelation := self using: relation performRelationOneStep: aCollection.
     ^newRelation allTo! !

!Relation class methods !
using: relation performItemOneStep: items
    | newRelation |
     newRelation := self using: relation performRelationOneStep: items.
     ^newRelation allTo!   !

!Relation class methods !
using: relation performItemStar: items
    | newRelation |
    newRelation := self using: relation performRelationStar: items.
    ^newRelation allTo addAllIfAbsent: items! !
(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('performMethods' using:and:performCollectionOneStep: using:performRelationOneStep: using:and:performItemStep: using:and:performRelationOneStep: using:performRelationStar: using:performCollectionOneStep: using:performItemStar: using:performItemOneStep: )) !

(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('performMethods' using:and:performCollectionOneStep: using:performRelationOneStep: using:and:performItemStep: using:and:performRelationOneStep: using:performRelationStar: using:performCollectionOneStep: using:performItemStar: using:performItemOneStep: )) !



!Relation methods !
initialize

    self
        triples: OrderedCollection new! !
(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('initializing' initialize )) !



!Relation methods !
triples: anOrderedCollection
    triples := anOrderedCollection!   !

!Relation methods !  
triples
    ^triples!  !
(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('get/set' triples: triples )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('get/set' triples: triples )) !



!Relation methods !  
allRelationships
    ^triples collect: [:triple | triple second]!  !

!Relation methods !  
allFrom
    ^triples collect: [:triple | triple first]!    !

!Relation methods !  
from: keys do: aBlock
    (triples select: [:triple | keys includes: triple first]) 
    do: [:triple | 
        aBlock 
            value: triple first 
            value: triple rest]! !

!Relation methods !  
addFrom: key via: relationship to: value
    triples add: 
        [Array 
            with: key
            with: relationship 
            with: value].!    !

!Relation methods !  
allTo
    ^triples collect: [:triple | triple third]!  !

!Relation methods !  
addTriple: triple
        triples addAllIfAbsent: triple!  !

!Relation methods !  
do: aBlock
    triples do: [:triple | 
        aBlock 
            value: triple first 
            value: triple second 
            value: triple third]!    !
(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' allRelationships allFrom from:do: addFrom:via:to: allTo addTriple: do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' allRelationships allFrom from:do: addFrom:via:to: allTo addTriple: do: )) !
CodeFiler setCommentFor: Relation to: ''!


!Relation methods ! 
do: aBlock
    triples do: [:triple | 
        aBlock 
            value: (triple first) 
            value: (triple second) 
            value: (triple third)]!  ! 
#('February 8, 2021' '04:56:05 PM' 1752020)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' do: )) !


!Relation methods ! 
addTriple: triple
        triples addIfAbsent: triple! ! 
#('February 8, 2021' '04:57:52 PM' 1751932)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' addTriple: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' addTriple: )) !


  
'Relation example1'!

  
'Relation example2'!

!Relation class methods ! 
using: relation1 and: relation2 performRelationOneStep: items
    "Builds new triples by applying 'relation1' ONCE to each item in items and 'relation2' ONCE to each item in items. 
    Returns the triples in a totally new relation."!    ! 
#('February 8, 2021' '05:05:27 PM' 1748620)!

(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('performMethods' using:and:performRelationOneStep: )) !

(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('performMethods' using:and:performRelationOneStep: )) !


!Relation class methods ! 
using: relation performRelationOneStep: items
    "Builds new triples by applying 'relation' ONCE to each item in items. 
    Returns the triples in a totally new relation."
    | newRelation tos |
    newRelation := Relation new. tos = OrderedCollection new.
    
    relation from: items do: [:relationship :subrelation |
        subrelation do: [:triple | tos addifAbsent: triple third]].

    relation from: tos do: [:relationship :subrelation |
        subrelation do: [:triple | newRelation addTriple: triple]].

    ^newRelation!    ! 
#('February 8, 2021' '05:06:17 PM' 1747828)!

(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('performMethods' using:performRelationOneStep: )) !

(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('performMethods' using:performRelationOneStep: )) !


!Relation methods !   
from: keys do: aBlock
    (triples select: [:triple | keys includes: triple first]) 
    do: [:triple | 
        aBlock 
            value: triple second 
            value: triple rest]!    ! 
#('February 8, 2021' '05:21:44 PM' 1751436)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


  
'Relation example2'!

!Relation methods !   
from: keys do: aBlock
    (triples select: [:triple | keys includes: triple first]) 
    do: [:triple | 
        aBlock 
            value: triple first 
            value: triple rest]! ! 
#('February 8, 2021' '05:22:45 PM' 1754772)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
do: aBlock
    triples do: [:triple | 
        aBlock 
            value: triple first 
            value: triple second
            value: triple third]! ! 
#('February 8, 2021' '05:23:44 PM' 1752556)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' do: )) !


!Relation class methods !   
using: relation performRelationOneStep: items
    "Builds new triples by applying 'relation' ONCE to each item in items. 
    Returns the triples in a totally new relation."
    | newRelation tos |
    newRelation := Relation new. tos = OrderedCollection new.
    
    relation from: items do: [:relationship :subrelation |
        subrelation do: [:triple | tos addifAbsent: triple third]].

    relation from: tos do: [:relationship :subrelation |
        subrelation do: [:triple | newRelation addTriple: triple]].

    ^newRelation!    ! 
#('February 8, 2021' '05:25:09 PM' 1753908)!

(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('performMethods' using:performRelationOneStep: )) !

(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('performMethods' using:performRelationOneStep: )) !


!Relation class methods ! 
using: relation1 and: relation2 performRelationOneStep: items
    "Builds new triples by applying 'relation1' ONCE to each item in items and 'relation2' ONCE to each item in items. 
    Returns the triples in a totally new relation."
    
    "Builds new triples by applying 'relation' ONCE to each item in items. 
    Returns the triples in a totally new relation."
    | newRelation tos |
    newRelation := Relation new. tos = OrderedCollection new.
    
    relation1 from: items do: [:relationship :subrelation |
        subrelation do: [:triple | tos addifAbsent: triple third]].

    relation1 from: tos do: [:relationship :subrelation |
        subrelation do: [:triple | newRelation addTriple: triple]].

    ^newRelation!  ! 
#('February 8, 2021' '05:25:48 PM' 1753344)!

(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('performMethods' using:and:performRelationOneStep: )) !

(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('performMethods' using:and:performRelationOneStep: )) !


!Relation class methods ! 
using: relation1 and: relation2 performRelationOneStep: items
    "Builds new triples by applying 'relation1' ONCE to each item in items and 'relation2' ONCE to each item in items. 
    Returns the triples in a totally new relation."
    
    "Builds new triples by applying 'relation' ONCE to each item in items. 
    Returns the triples in a totally new relation."
    | newRelation tos |
    newRelation := Relation new. tos = OrderedCollection new.
    
    relation1 from: items do: [:relationship :subrelation |
        subrelation do: [:triple | tos addifAbsent: triple third]].
    
    relation2 from: items do: [:relationship :subrelation |
        subrelation do: [:triple | tos addifAbsent: triple third]].

    relation2 from: tos do: [:relationship :subrelation |
        subrelation do: [:triple | newRelation addTriple: triple]].
    
    ^newRelation!  ! 
#('February 8, 2021' '05:28:20 PM' 1756980)!

(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('performMethods' using:and:performRelationOneStep: )) !

(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('performMethods' using:and:performRelationOneStep: )) !


!Relation class methods ! 
using: relation1 and: relation2 performRelationOneStep: items
    "Builds new triples by applying 'relation1' ONCE to each item in items and 'relation2' ONCE to each item in items. 
    Returns the triples in a totally new relation."
    | newRelation tos |
    newRelation := Relation new. tos = OrderedCollection new.
    
    relation1 from: items do: [:relationship :subrelation |
        subrelation do: [:triple | tos addifAbsent: triple third]].
    
    relation2 from: items do: [:relationship :subrelation |
        subrelation do: [:triple | tos addifAbsent: triple third]].

    relation2 from: tos do: [:relationship :subrelation |
        subrelation do: [:triple | newRelation addTriple: triple]].
    
    ^newRelation!  ! 
#('February 8, 2021' '05:28:29 PM' 1758052)!

(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('performMethods' using:and:performRelationOneStep: )) !

(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('performMethods' using:and:performRelationOneStep: )) !


!Relation class methods ! 
using: relation performRelationStar: items
    | newRelation |
    newRelation := Relation new.
    workingCollection := OrderedCollection new addAllIfAbsent: items.
    workingCollection do: [:item |
        relation from: (OrderedCollection with: item) do: [:relationship :subrelation |
        subrelation do: [:triple | 
            workingCollection addIfAbsent: triples last.
            newRelation addTriple: triple]]].

    ^newRelation!    ! 
#('February 8, 2021' '05:29:50 PM' 1748884)!

(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('performMethods' using:performRelationStar: )) !

(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('performMethods' using:performRelationStar: )) !



'Relation example1'!

  
'Relation example2'!

!Relation methods !   
from: keys do: aBlock
    (triples select: [:triple | keys includes: triple first]) 
    do: [:triple | 
        aBlock 
            value: triple second 
            value: triple first
            value: triple third]!  ! 
#('February 8, 2021' '05:31:21 PM' 1755252)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple|
    keyTriple := triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple |
        triple second].
    partition keysAndValuesDo: [:relationship :triples |
        aBlock value: relationship
            value: triples first
            value: triples third]!    ! 
#('February 8, 2021' '05:41:20 PM' 1761160)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
addAllTriple: allTriple
    allTriple do: [:triple |
        triples addIfAbsent: triple]!    ! 
#('February 8, 2021' '05:46:55 PM' nil)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' addAllTriple: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple|
    keyTriple := triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple |
        triple second].
    triples do: [:triple |
        aBlock 
            value: triple second
            value: (Relation new addAllTriple: triples)]!  ! 
#('February 8, 2021' '05:51:44 PM' 1761644)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
addTriple: tripleCollection
        tripleCollection do: [:triple |
            triples addIfAbsent: triple]! ! 
#('February 8, 2021' '05:54:04 PM' 1752968)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' addTriple: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' addTriple: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple|
    keyTriple := triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple |
        triple second].
    triples do: [:triple |
        aBlock 
            value: triple second
            value: triple rest]!   ! 
#('February 8, 2021' '05:54:22 PM' 1762536)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
addTriple: triple
            triples addIfAbsent: triple! ! 
#('February 8, 2021' '05:55:05 PM' 1763136)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' addTriple: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' addTriple: )) !


!Relation methods !   
addTriple: triple
        triples addIfAbsent: triple! ! 
#('February 8, 2021' '05:55:11 PM' 1764084)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' addTriple: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' addTriple: )) !


  
'Relation example2'!

!Relation methods !   
from: keys do: aBlock
    |partition keyTriple|
    keyTriple := triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple |
        triple second].
    partition keysAndValuesDo: [ :triples |
        aBlock 
            value: triples second
            value: triples rest]!    ! 
#('February 8, 2021' '05:58:00 PM' 1763508)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple|
    keyTriple := triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple |
        triple second].
    partition keysAndValuesDo: [ :triples |
        aBlock 
            value: triples second
            value: triples rest]!    ! 
#('February 8, 2021' '05:59:45 PM' 1764748)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple tripleCollection|
    keyTriple := triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple |
        triple second].
    tripleCollection:= triples do: [:triple | triples addIfAbsent: triple]
    partition keysAndValuesDo: [ :triples :tripleCollection |
        aBlock 
            value: triples second
            value: triples tripleCollection]! ! 
#('February 8, 2021' '06:05:09 PM' 1765344)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


"evaluate"
Relation removeSelector: #addAllTriple:!

!Relation methods !   
from: keys do: aBlock
    |partition keyTriple tripleCollection rest|
    keyTriple := triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple |
        triple second].
    tripleCollection:= rest do: [:triple | triples addIfAbsent: triple].
    partition keysAndValuesDo: [ :triples :tripleCollection |
        aBlock 
            value: triples second
            value: triples tripleCollection]!  ! 
#('February 8, 2021' '06:06:35 PM' 1765940)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple|
    keyTriple := triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple |
        triple second].
    partition keysAndValuesDo: [ :triples |
        aBlock 
            value: triples second
            value: triples rest]!    ! 
#('February 8, 2021' '06:08:05 PM' 1766712)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple|
    keyTriple := triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple |
        triple second].!   ! 
#('February 8, 2021' '06:09:46 PM' 1767432)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple|
    keyTriple := triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple |
        triple second].!   ! 
#('February 8, 2021' '06:10:12 PM' 1768028)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple|
    keyTriple := triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].!    ! 
#('February 8, 2021' '06:12:57 PM' 1768492)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple|
    keyTriple:= triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].
    
    partition do: [:relationship :triples |
        (aBlock value: relationship) ifTrue: [
            aBlock 
                value: relationship
                value: triples rest]]! ! 
#('February 8, 2021' '06:25:36 PM' 1768956)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple collection|
    keyTriple:= triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].
    collection do: [:triple | triples addIfAbsent: triple]
    partition do: [:relationship :triples |
        (aBlock value: relationship) ifTrue: [
            aBlock 
                value: relationship
                value: triples rest]]!    ! 
#('February 8, 2021' '06:27:18 PM' 1769412)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple collection|
    keyTriple:= triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].
    partition keysAndValuesDo: [:relationship :triples |
    aBlock value: relationship value: triples rest]!   ! 
#('February 8, 2021' '06:29:41 PM' 1770060)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple restCollection|
    keyTriple:= triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].
    partition keysAndValuesDo: [:relationship :triples |
    aBlock value: relationship value: triples rest]!   ! 
#('February 8, 2021' '06:30:00 PM' 1770776)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple restCollection|
    keyTriple:= triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].
    partition keysAndValuesDo: [:relationship :triples |
    restCollection := restCollection do: [:triple | triples addIfAbsent: triple]
    aBlock value: relationship value: Relation new restCollection: triples]! ! 
#('February 8, 2021' '06:31:49 PM' 1771352)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple restCollection|
    keyTriple:= triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].
    partition keysAndValuesDo: [:relationship :triples |
    aBlock value: relationship value: Relation new restCollection: triples]!   ! 
#('February 8, 2021' '06:32:00 PM' 1771932)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple restCollection|
    keyTriple:= triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].
    restCollection := restCollection do: [:triple | triples addIfAbsent: triple]
    partition keysAndValuesDo: [:relationship :triples |
    aBlock value: relationship value: Relation new restCollection: triples]! ! 
#('February 8, 2021' '06:32:10 PM' 1772616)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple restCollection|
    keyTriple:= triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].
    restCollection := restCollection do: [:triple | triples addIfAbsent: triple]
    partition keysAndValuesDo: [:relationship :triples |
    aBlock value: relationship value: (Relation new restCollection: triples)]!   ! 
#('February 8, 2021' '06:32:26 PM' 1773220)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple restCollection|
    keyTriple:= triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].
    restCollection := restCollection do: [:triple | 
        triples addIfAbsent: triple].
        
    partition keysAndValuesDo: [:relationship :triples |
        aBlock 
            value: relationship 
            value: (Relation new restCollection: triples)]!  ! 
#('February 8, 2021' '06:33:04 PM' 1773904)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple restCollection|
    keyTriple:= triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].
        
    partition keysAndValuesDo: [:relationship :triples |
        aBlock 
            value: relationship 
            value: triples rest]! ! 
#('February 8, 2021' '06:35:27 PM' 1774592)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


  
'Relation example2'!

!Relation methods !   
restCollection: triplesCollection
    triplesCollection do: [:triple |
        triples addIfAbsent: triple]!  ! 
#('February 8, 2021' '06:37:39 PM' nil)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' restCollection: )) !


!Relation methods ! 
from: keys do: aBlock
    |partition keyTriple restCollection|
    keyTriple:= triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].
        
    partition keysAndValuesDo: [:relationship :triples |
        aBlock 
            value: relationship 
            value:(Relation new restCollection: triples)]!    ! 
#('February 8, 2021' '06:38:23 PM' 1775332)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple restCollection|
    keyTriple:= triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].
        
    partition keysAndValuesDo: [:relationship :triples |
        (aBlock value: relationship) ifTrue: [
            aBlock value: relationship
            value: (Relation new restCollection: triples)]].!    ! 
#('February 8, 2021' '06:41:05 PM' 1776260)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple restCollection|
    keyTriple:= triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].
        
    partition keysAndValuesDo: [:relationship :triples |
        (triples second: relationship) ifTrue: [
            aBlock value: relationship
            value: (Relation new restCollection: triples)]].!  ! 
#('February 8, 2021' '06:44:17 PM' 1776908)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple restCollection|
    keyTriple:= triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].
        
    partition keysAndValuesDo: [:relationship :triples |
            aBlock 
                value: relationship
                value: triples rest].! ! 
#('February 8, 2021' '06:45:35 PM' 1777596)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


  
'Relation example2'!

!Relation methods !   
from: keys do: aBlock
    |partition keyTriple restCollection|
    keyTriple:= triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].
    partition keysAndValuesDo: [:relationship :triples |
            aBlock 
                value: relationship
                value: triples rest].!   ! 
#('February 8, 2021' '06:48:03 PM' 1778284)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple restCollection|
    keyTriple:= triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].
    partition keysAndValuesDo: [:relationship :triples |
            aBlock 
                value: relationship
                value: (keyTriple at: triples ifAbsentPut: [OrderedCollection new]) 
                    addAllifAbsent: triples].! ! 
#('February 8, 2021' '07:05:24 PM' 1778944)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple restCollection|
    keyTriple:= triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].
    partition keysAndValuesDo: [:relationship :triples |
            aBlock 
                value: relationship
                value: (triples rest ifAbsentPut: [OrderedCollection new]) 
                    addAllifAbsent: triples].!  ! 
#('February 8, 2021' '07:09:04 PM' 1779568)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple restCollection|
    keyTriple:= triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].
    partition keysAndValuesDo: [:relationship :triples |
            aBlock 
                value: relationship
                value: triples rest]!    ! 
#('February 8, 2021' '07:09:47 PM' 1780284)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple restCollection|
    keyTriple:= triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].
    partition keysAndValuesDo: [:relationship :triples |
            aBlock 
                value: relationship
                value: triples rest].!   ! 
#('February 8, 2021' '07:12:58 PM' 1780992)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple restCollection|
    keyTriple:= triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].
    partition keysAndValuesDo: [:relationship :triples |
            aBlock 
                value: relationship
                value: triples rest].!   ! 
#('February 8, 2021' '07:14:36 PM' 1781616)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple restCollection|
    keyTriple:= triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].
    partition keysAndValuesDo: [:relationship :triples |
            aBlock 
                value: relationship
                value: triples keyTriple].!  ! 
#('February 8, 2021' '07:18:08 PM' 1782240)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple restCollection|
    keyTriple:= triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].
    partition keysAndValuesDo: [:relationship :triples |
            aBlock 
                value: relationship
                value: (Relation new restCollection: triples)].! ! 
#('February 8, 2021' '07:22:39 PM' 1782864)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple restCollection|
    keyTriple:= triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].
    partition keysAndValuesDo: [:relationship :triple |
            aBlock 
                value: relationship
                value: triple rest].! ! 
#('February 8, 2021' '07:28:00 PM' 1783492)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


  
'Relation example2'!

!Relation methods !   
from: keys do: aBlock
    |partition keyTriple restCollection|
    keyTriple:= triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].
    partition keysAndValuesDo: [:relationship :triples |
            aBlock 
                value: relationship
                value: (Relation new restCollection: triples)]!  ! 
#('February 8, 2021' '07:30:16 PM' 1784140)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple restCollection|
    keyTriple:= triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].
    partition keysAndValuesDo: [:relationship :triples |
            aBlock 
                value: relationship
                value: restCollection]!  ! 
#('February 8, 2021' '07:31:58 PM' 1784788)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


"evaluate"
Relation removeSelector: #restCollection:!

!Relation methods ! 
restCollection: tripleCollection
    tripleCollection do: [:triple |
        triples addIfAbsent: triple]!    ! 
#('February 8, 2021' '07:33:49 PM' nil)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' restCollection: )) !


!Relation methods ! 
from: keys do: aBlock
    |partition keyTriple|
    keyTriple:= triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].
    partition keysAndValuesDo: [:relationship :triples |
            aBlock 
                value: relationship
                value: Relation new restCollection: triples]!   ! 
#('February 8, 2021' '07:34:23 PM' 1785436)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple|
    keyTriple:= triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].
    partition keysAndValuesDo: [:relationship :triples |
            aBlock 
                value: relationship
                value: triples]!    ! 
#('February 8, 2021' '07:35:01 PM' 1786396)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


  
'Relation example2'!

"evaluate"
Relation removeSelector: #restCollection:!

!Relation methods ! 
from: keys do: aBlock
    |partition keyTriple|
    keyTriple:= triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].
    partition keysAndValuesDo: [:relationship :triples |
            aBlock 
                value: relationship
                value: triples].!   ! 
#('February 8, 2021' '07:35:54 PM' 1787028)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation class methods ! 
example3
        "Relation example2"
        | collection relation |
        "First, build a relation."
        collection := #((2 < 3) (1 = 1) (3 > 1) (2 < 4)(1 < 5) (5 < 6) (2 < 5)).
        relation := Relation new.
        collection do: [:triple | relation addTriple: triple].

        Transcript cr; << 'Let relation = '; << collection.
        Transcript cr; << 'Starting from {1 2 3},'.
            relation from: #(1 2 3) do: [:relationship :subrelation |                 
                Transcript cr; << 'There is a relationship '; << relationship; 
                    << ' with subrelation'; cr; tab.
                subrelation do: [:triple |Transcript space; << triple]]!    ! 
#('February 8, 2021' '07:51:05 PM' nil)!

(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('examples' example3 )) !


!Relation class methods ! 
example3
        "Relation example3"!  ! 
#('February 8, 2021' '07:54:57 PM' 1788324)!

(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('examples' example3 )) !

(CodeFiler organizerFor: Relation class) reorganizeFrom: #(
('examples' example3 )) !


"evaluate"  
(CodeFiler organizerFor: 'Relation')  addCategory: 'performStar' before: nil!

!Relation methods !  
performItemStar: keys
    ^self using: [:x | true] performItemStar: keys!  ! 
#('February 8, 2021' '07:58:13 PM' nil)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStar' performItemStar: )) !


!Relation methods !  
performStar: keys!  ! 
#('February 8, 2021' '08:01:23 PM' nil)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStar' performStar: )) !


!Relation methods !  
rf! ! 
#('February 8, 2021' '08:03:12 PM' nil)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStar' rf )) !


"evaluate" 
Relation removeSelector: #performStar:!

"evaluate" 
Relation removeSelector: #rf!

"evaluate"   
Relation removeSelector: #performItemStar:!

"evaluate" 
(CodeFiler organizerFor: Relation) rename: 'performStar' to: 'performStarMethods'!

!Relation methods ! 
performStar: keys
    ^self using: [:x | true] performStar: keys!  ! 
#('February 8, 2021' '08:04:15 PM' nil)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStarMethods' performStar: )) !


!Relation methods !   
performItemOneStep: keys
    ^self using: [:x | true] performItemOneStep: keys!    ! 
#('February 8, 2021' '08:04:40 PM' nil)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStarMethods' performItemOneStep: )) !


!Relation methods !
performItemStar: keys
    ^self using: [:x | true] performItemStar: keys!  ! 
#('February 8, 2021' '08:05:07 PM' nil)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStarMethods' performItemStar: )) !


!Relation methods !   
performItemOneStep: items
    ^self using: [:x | true] performItemOneStep: items!  ! 
#('February 8, 2021' '08:06:37 PM' 1790676)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStarMethods' performItemOneStep: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStarMethods' performItemOneStep: )) !


!Relation methods !   
performItemStar: items
    ^self using: [:x | true] performItemStar: items!    ! 
#('February 8, 2021' '08:06:50 PM' 1790936)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStarMethods' performItemStar: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStarMethods' performItemStar: )) !


!Relation methods ! 
from: items do: aBlock
    ^self using: [:x | true] from: items do: aBlock!    ! 
#('February 8, 2021' '08:07:44 PM' 1787716)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
from: keys do: aBlock
    |partition keyTriple|
    keyTriple:= triples select: [:triple | keys includes: triple first].
    partition := keyTriple partitionsUsing: [:triple | triple second].
    partition keysAndValuesDo: [:relationship :triples |
            aBlock 
                value: relationship
                value: triples].!   ! 
#('February 8, 2021' '08:08:19 PM' 1791920)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('simpleMethods' from:do: )) !


!Relation methods !   
performItemStar: keys
    ^self using: [:x | true] performItemStar: keys!  ! 
#('February 8, 2021' '08:08:51 PM' 1791560)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStarMethods' performItemStar: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStarMethods' performItemStar: )) !


!Relation methods ! 
performItemOneStep: keys
    ^self using: [:x | true] performItemOneStep: keys!    ! 
#('February 8, 2021' '08:09:06 PM' 1791188)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStarMethods' performItemOneStep: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStarMethods' performItemOneStep: )) !


!Relation methods !   
performStar: items
    ^self using: [:x | true] performStar: items!    ! 
#('February 8, 2021' '08:12:10 PM' 1790436)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStarMethods' performStar: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStarMethods' performStar: )) !


!Relation methods ! 
performItemStar: items
    ^self using: [:x | true] performItemStar: items!    ! 
#('February 8, 2021' '08:12:20 PM' 1792860)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStarMethods' performItemStar: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStarMethods' performItemStar: )) !


!Relation methods ! 
performItemOneStep: items
    ^self using: [:x | true] performItemOneStep: items!  ! 
#('February 8, 2021' '08:12:32 PM' 1793216)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStarMethods' performItemOneStep: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStarMethods' performItemOneStep: )) !


!Relation methods !   
performItemOneStep: items
    ^self using: Relation performItemOneStep: items! ! 
#('February 8, 2021' '08:13:11 PM' 1794292)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStarMethods' performItemOneStep: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStarMethods' performItemOneStep: )) !


!Relation methods !   
performItemStar: items
    ^self using: Relation performItemStar: items!   ! 
#('February 8, 2021' '08:13:20 PM' 1793932)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStarMethods' performItemStar: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStarMethods' performItemStar: )) !


!Relation methods ! 
performStar: items
    ^self using: Relation performStar: items!   ! 
#('February 8, 2021' '08:13:30 PM' 1793588)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStarMethods' performStar: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStarMethods' performStar: )) !


!Relation methods ! 
performStar: triple
    |result|
    result := OrderedCollection new.
    result addIfIdenticalAbsent: triples.
    result do: [:triples |
    "For each triple of the form (a R b)"
        result addIfIdenticalAbsent: triple].

    ^self using: Relation performStar: triple!  ! 
#('February 8, 2021' '09:19:59 PM' 1795388)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStarMethods' performStar: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStarMethods' performStar: )) !


!Relation methods ! 
performStar: triple
    |result|
    result := OrderedCollection new.
    result addIfIdenticalAbsent: triples.
    result do: [:triples |
    "For each triple of the form (a R b)"
        result addIfIdenticalAbsent: triple].

    ^result!    ! 
#('February 8, 2021' '09:20:15 PM' 1795728)!

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStarMethods' performStar: )) !

(CodeFiler organizerFor: Relation) reorganizeFrom: #(
('performStarMethods' performStar: )) !


"evaluate"  
(CodeFiler organizerFor: Relation) removeCategory: 'performStarMethods' ifAbsent: [nil]!

"evaluate"
"*** saved image on: February 8, 2021 09:33:20 PM ***"!   
"*** Image started on: February 9, 2021 09:49:17 PM ***"!

"define class"   

Object subclass: #NewRelation
  instanceVariableNames: 
    ' triple '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: NewRelation to: ''!


"evaluate" 

Object subclass: #NewRelation
  instanceVariableNames: 
    ' triple '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Example Parser Users' )
  comment: ''!

"define class" 

Object subclass: #gfiureg
  instanceVariableNames: 
    ' parser tree codeIfCompiler expressionsIfEvaluator compilationOperatorMap evaluationOperatorMap '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: gfiureg to: ''!


"evaluate" 

Object subclass: #gfiureg
  instanceVariableNames: 
    ' parser tree codeIfCompiler expressionsIfEvaluator compilationOperatorMap evaluationOperatorMap '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Example Parser Users' )
  comment: ''!

"evaluate" 
gfiureg removeFromSystem!

"evaluate"   
CodeFiler removeOrganizerFor: #gfiureg!

"evaluate" 
CodeFiler removeOrganizerFor: #'gfiureg class'!

"define class" 

Object subclass: #Truck
  instanceVariableNames: 
    ' driver passengers loads '
  classVariableNames: ''
  poolDictionaries: ''!


!Truck class methods !  
new

    ^super new initialize!   !

"evaluate"   
(CodeFiler organizerFor: Truck class) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Truck class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: Truck class) reorganizeFrom: #(
('instance creation' new )) !



!Truck class methods !
example1
    "Truck example1"
    | aTruck |
    aTruck := Truck new driver: #Jim.
    aTruck addPassenger: #Tom; addPassenger: #Dayton.
    aTruck addLoad: #Wheelbarrow; addLoad: #Ladder; addLoad: #Cement.
    aTruck driverDo: [:driver | Transcript cr; << 'The driver is '; << driver].
    aTruck passengersDo: [:passenger | Transcript cr; << 'One passenger is '; << passenger].
    aTruck loadDo: [:load | Transcript cr; << 'The back of the truck contains a '; << load].
    "Method do: sequences over everything in the truck."
    aTruck do: [:anObject | Transcript cr; << 'In the truck, there is a '; << anObject].!   !
(CodeFiler organizerFor: Truck class) reorganizeFrom: #(
('examples' example1 )) !

(CodeFiler organizerFor: Truck class) reorganizeFrom: #(
('examples' example1 )) !



!Truck methods ! 
initialize

    self
        passengers: OrderedCollection new;
        loads: OrderedCollection new;
        driver: String new!  !

"evaluate"   
(CodeFiler organizerFor: Truck) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Truck) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: Truck) reorganizeFrom: #(
('initializing' initialize )) !



!Truck methods !
driver
    ^driver!    !

!Truck methods ! 
passengers
    ^passengers!    !

!Truck methods ! 
loads: anOrderedCollection
    loads := anOrderedCollection!   !

!Truck methods ! 
passengers: anOrderedCollection
    passengers := anOrderedCollection! !

!Truck methods ! 
loads
    ^loads!  !

!Truck methods ! 
driver: aString
    driver := aString! !
(CodeFiler organizerFor: Truck) reorganizeFrom: #(
('get/set' driver passengers loads: passengers: loads driver: )) !

(CodeFiler organizerFor: Truck) reorganizeFrom: #(
('get/set' driver passengers loads: passengers: loads driver: )) !



!Truck methods !   
passengersDo: anOutputStream
    self passengers isEmpty
    ifFalse: [ anOutputStream value: self passengers first. ]
    ifTrue: [ anOutputStream value: 'Empty'. ].!  !

!Truck methods ! 
do: anOutputStream
    |aBufferString|
    aBufferString:=''.

    self driver isEmpty 
        ifFalse: [
            aBufferString := aBufferString, Character cr asString.
            aBufferString := aBufferString, 'Driver: ', self driver asString.
         ].
         
    self passengers isEmpty 
         ifFalse: [
             aBufferString := aBufferString, Character cr asString.
             aBufferString := aBufferString, 'Passengers:'.
             1 to: self passengers size do: [:index| aBufferString := aBufferString, ' ', (self passengers at: index)].
          ].
          
    self loads isEmpty
        ifFalse:[
            aBufferString := aBufferString, Character cr asString.
            aBufferString := aBufferString, 'Loads:'.
            1 to: self loads size do: [:index| aBufferString := aBufferString, ' ', (self loads at: index)].
         ].
    anOutputStream value: aBufferString!   !

!Truck methods ! 
driverDo: anOutputStream
    anOutputStream value: self driver!    !

!Truck methods ! 
loadDo: anOutputStream
    self loads isEmpty
    ifFalse: [ anOutputStream value: self loads first. ]
    ifTrue: [ anOutputStream value: 'Empty'. ].!  !
(CodeFiler organizerFor: Truck) reorganizeFrom: #(
('doMethods' passengersDo: do: driverDo: loadDo: )) !

(CodeFiler organizerFor: Truck) reorganizeFrom: #(
('doMethods' passengersDo: do: driverDo: loadDo: )) !



!Truck methods ! 
addPassenger: aString
    passengers add: aString! !

!Truck methods ! 
addLoad: aString
    loads add: aString!   !
(CodeFiler organizerFor: Truck) reorganizeFrom: #(
('addMethods' addPassenger: addLoad: )) !

(CodeFiler organizerFor: Truck) reorganizeFrom: #(
('addMethods' addPassenger: addLoad: )) !
CodeFiler setCommentFor: Truck to: 'Truck example1'!



!NewRelation methods ! 
initialize

    self
        triple: OrderedCollection new!  !

"evaluate"   
(CodeFiler organizerFor: NewRelation) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: NewRelation) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: NewRelation) reorganizeFrom: #(
('initializing' initialize )) !



!NewRelation class methods !  
new

    ^super new initialize!   !

"evaluate"   
(CodeFiler organizerFor: NewRelation class) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: NewRelation class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: NewRelation class) reorganizeFrom: #(
('instance creation' new )) !



!NewRelation methods !  
triple
    ^triple!    !

!NewRelation methods !   
triple: anOrderedCollection
    triple := anOrderedCollection! !
(CodeFiler organizerFor: NewRelation) reorganizeFrom: #(
('get/set' triple: triple )) !

(CodeFiler organizerFor: NewRelation) reorganizeFrom: #(
('get/set' triple: triple )) !


"evaluate"   
(CodeFiler organizerFor: 'NewRelation class')  addCategory: 'relationClass' before: 'instance creation'!

!NewRelation class methods !  
relation: Collection
    ^self!    ! 
#('February 9, 2021' '10:01:13 PM' nil)!

(CodeFiler organizerFor: NewRelation class) reorganizeFrom: #(
('relationClass' relation: )) !


"evaluate"   
(CodeFiler organizerFor: NewRelation class) removeCategory: 'instance creation' ifAbsent: [nil]!

"evaluate"
(CodeFiler organizerFor: NewRelation class) removeCategory: 'relationClass' ifAbsent: [nil]!

"evaluate"
NewRelation removeFromSystem!

"evaluate"   
CodeFiler removeOrganizerFor: #NewRelation!

"evaluate" 
CodeFiler removeOrganizerFor: #'NewRelation class'!   
"*** Image started on: February 21, 2021 05:37:06 PM ***"!

"define class"  

Object subclass: #StudentCompiler
  instanceVariableNames: 
    ' parser tree contextStack code '
  classVariableNames: ''
  poolDictionaries: ''!


!StudentCompiler class methods !
new

    ^super new initialize!   !

"evaluate"   
(CodeFiler organizerFor: StudentCompiler class) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('instance creation' new )) !



!StudentCompiler class methods !
rawParserTables
    "Tables generated from GrammarBuilder class>>parserGrammar"
    ^
#(
   (keywords if for else)
   (ReadaheadTable 1 (for 'RS' 4) (#'(' 'RS' 6) (walkInteger: 'RSN' 68) (walkIdentifier: 'RSN' 7) (if 'RS' 8) (#'}' 'L' 52) (#'-|' 'L' 52))
   (ReadaheadTable 2 (if 'RS' 8) (walkIdentifier: 'RSN' 7) (for 'RS' 4) (walkInteger: 'RSN' 68) (#'(' 'RS' 6) (#'}' 'L' 52) (#'-|' 'L' 52))
   (ReadaheadTable 3 (#'*' 'RS' 11) (#'/' 'RS' 12) (#'+' 'L' 66) (#'-' 'L' 66) (#'<' 'L' 66) (#'>' 'L' 66) (#'==' 'L' 66) (#'?' 'L' 66) (#')' 'L' 66) (#',' 'L' 66) (#';' 'L' 66) (#':' 'L' 66))
   (ReadaheadTable 4 (#'(' 'RS' 13))
   (ReadaheadTable 5 (#'<' 'RS' 14) (#'>' 'RS' 15) (#'==' 'RS' 16) (#'?' 'RS' 17) (#')' 'L' 67) (#',' 'L' 67) (#';' 'L' 67))
   (ReadaheadTable 6 (walkIdentifier: 'RSN' 7) (walkInteger: 'RSN' 68) (#'(' 'RS' 6))
   (ReadaheadTable 7 (#'=' 'RS' 19) (#'(' 'RS' 20) (#'*' 'L' 68) (#'/' 'L' 68) (#'+' 'L' 68) (#'-' 'L' 68) (#'<' 'L' 68) (#'>' 'L' 68) (#'==' 'L' 68) (#'?' 'L' 68) (#')' 'L' 68) (#',' 'L' 68) (#';' 'L' 68) (#':' 'L' 68))
   (ReadaheadTable 8 (#'(' 'RS' 21))
   (ReadaheadTable 9 (#'+' 'RS' 22) (#'-' 'RS' 23) (#'<' 'L' 70) (#'>' 'L' 70) (#'==' 'L' 70) (#'?' 'L' 70) (#')' 'L' 70) (#',' 'L' 70) (#';' 'L' 70) (#':' 'L' 70))
   (ReadaheadTable 10 (#';' 'RS' 71))
   (ReadaheadTable 11 (#'(' 'RS' 6) (walkInteger: 'RSN' 68) (walkIdentifier: 'RSN' 24))
   (ReadaheadTable 12 (#'(' 'RS' 6) (walkInteger: 'RSN' 68) (walkIdentifier: 'RSN' 24))
   (ReadaheadTable 13 (#'(' 'RS' 6) (walkIdentifier: 'RSN' 7) (walkInteger: 'RSN' 68))
   (ReadaheadTable 14 (walkIdentifier: 'RSN' 24) (walkInteger: 'RSN' 68) (#'(' 'RS' 6))
   (ReadaheadTable 15 (walkIdentifier: 'RSN' 24) (walkInteger: 'RSN' 68) (#'(' 'RS' 6))
   (ReadaheadTable 16 (walkIdentifier: 'RSN' 24) (walkInteger: 'RSN' 68) (#'(' 'RS' 6))
   (ReadaheadTable 17 (walkIdentifier: 'RSN' 24) (walkInteger: 'RSN' 68) (#'(' 'RS' 6))
   (ReadaheadTable 18 (#')' 'RS' 72))
   (ReadaheadTable 19 (walkIdentifier: 'RSN' 7) (walkInteger: 'RSN' 68) (#'(' 'RS' 6))
   (ReadaheadTable 20 (#')' 'RS' 79) (#'(' 'RS' 6) (walkIdentifier: 'RSN' 7) (walkInteger: 'RSN' 68))
   (ReadaheadTable 21 (#'(' 'RS' 6) (walkIdentifier: 'RSN' 7) (walkInteger: 'RSN' 68))
   (ReadaheadTable 22 (walkIdentifier: 'RSN' 24) (#'(' 'RS' 6) (walkInteger: 'RSN' 68))
   (ReadaheadTable 23 (walkIdentifier: 'RSN' 24) (#'(' 'RS' 6) (walkInteger: 'RSN' 68))
   (ReadaheadTable 24 (#'(' 'RS' 20) (#'*' 'L' 68) (#'/' 'L' 68) (#'+' 'L' 68) (#'-' 'L' 68) (#'<' 'L' 68) (#'>' 'L' 68) (#'==' 'L' 68) (#'?' 'L' 68) (#')' 'L' 68) (#',' 'L' 68) (#';' 'L' 68) (#':' 'L' 68))
   (ReadaheadTable 25 (#';' 'RS' 34))
   (ReadaheadTable 26 (#'+' 'RS' 22) (#'-' 'RS' 23) (#'<' 'L' 75) (#'>' 'L' 75) (#'==' 'L' 75) (#'?' 'L' 75) (#')' 'L' 75) (#',' 'L' 75) (#';' 'L' 75) (#':' 'L' 75))
   (ReadaheadTable 27 (#'+' 'RS' 22) (#'-' 'RS' 23) (#'<' 'L' 76) (#'>' 'L' 76) (#'==' 'L' 76) (#'?' 'L' 76) (#')' 'L' 76) (#',' 'L' 76) (#';' 'L' 76) (#':' 'L' 76))
   (ReadaheadTable 28 (#'+' 'RS' 22) (#'-' 'RS' 23) (#'<' 'L' 77) (#'>' 'L' 77) (#'==' 'L' 77) (#'?' 'L' 77) (#')' 'L' 77) (#',' 'L' 77) (#';' 'L' 77) (#':' 'L' 77))
   (ReadaheadTable 29 (#'<' 'RS' 14) (#'>' 'RS' 15) (#'==' 'RS' 16) (#':' 'RS' 35))
   (ReadaheadTable 30 (#',' 'RS' 36) (#')' 'RS' 79))
   (ReadaheadTable 31 (#')' 'RS' 37))
   (ReadaheadTable 32 (#'*' 'RS' 11) (#'/' 'RS' 12) (#'+' 'L' 80) (#'-' 'L' 80) (#'<' 'L' 80) (#'>' 'L' 80) (#'==' 'L' 80) (#'?' 'L' 80) (#')' 'L' 80) (#',' 'L' 80) (#';' 'L' 80) (#':' 'L' 80))
   (ReadaheadTable 33 (#'*' 'RS' 11) (#'/' 'RS' 12) (#'+' 'L' 81) (#'-' 'L' 81) (#'<' 'L' 81) (#'>' 'L' 81) (#'==' 'L' 81) (#'?' 'L' 81) (#')' 'L' 81) (#',' 'L' 81) (#';' 'L' 81) (#':' 'L' 81))
   (ReadaheadTable 34 (#'(' 'RS' 6) (walkIdentifier: 'RSN' 7) (walkInteger: 'RSN' 68))
   (ReadaheadTable 35 (#'(' 'RS' 6) (walkIdentifier: 'RSN' 24) (walkInteger: 'RSN' 68))
   (ReadaheadTable 36 (walkIdentifier: 'RSN' 7) (walkInteger: 'RSN' 68) (#'(' 'RS' 6))
   (ReadaheadTable 37 (#'{' 'RS' 41))
   (ReadaheadTable 38 (#';' 'RS' 42))
   (ReadaheadTable 39 (#'<' 'RS' 14) (#'>' 'RS' 15) (#'==' 'RS' 16) (#')' 'L' 82) (#',' 'L' 82) (#';' 'L' 82))
   (ReadaheadTable 40 (#',' 'RS' 36) (#')' 'RS' 79))
   (ReadaheadTable 41 (for 'RS' 4) (walkInteger: 'RSN' 68) (#'(' 'RS' 6) (walkIdentifier: 'RSN' 7) (if 'RS' 8) (#'}' 'L' 52) (#'-|' 'L' 52))
   (ReadaheadTable 42 (walkIdentifier: 'RSN' 7) (walkInteger: 'RSN' 68) (#'(' 'RS' 6))
   (ReadaheadTable 43 (#'}' 'RS' 45))
   (ReadaheadTable 44 (#')' 'RS' 46))
   (ReadaheadTable 45 (else 'RS' 47) (if 'L' 53) (for 'L' 53) (walkInteger: 'L' 53) (walkIdentifier: 'L' 53) (#'(' 'L' 53) (#'}' 'L' 53) (#'-|' 'L' 53))
   (ReadaheadTable 46 (#'{' 'RS' 48))
   (ReadaheadTable 47 (#'{' 'RS' 49))
   (ReadaheadTable 48 (for 'RS' 4) (#'(' 'RS' 6) (walkInteger: 'RSN' 68) (walkIdentifier: 'RSN' 7) (if 'RS' 8) (#'}' 'L' 52) (#'-|' 'L' 52))
   (ReadaheadTable 49 (for 'RS' 4) (#'(' 'RS' 6) (walkInteger: 'RSN' 68) (walkIdentifier: 'RSN' 7) (if 'RS' 8) (#'}' 'L' 52) (#'-|' 'L' 52))
   (ReadaheadTable 50 (#'}' 'RS' 83))
   (ReadaheadTable 51 (#'}' 'RS' 53))
   (ReadbackTable 52 ((Statement 2) 'RSN' 54) ((#'|-' 1) 'L' 96) ((#'{' 41) 'L' 96) ((#'{' 48) 'L' 96) ((#'{' 49) 'L' 96))
   (ReadbackTable 53 ((#'}' 53) 'RS' 84) ((#'}' 45) 'RS' 85))
   (ReadbackTable 54 ((Statement 2) 'RSN' 54) ((#'|-' 1) 'L' 96) ((#'{' 41) 'L' 96) ((#'{' 48) 'L' 96) ((#'{' 49) 'L' 96))
   (ReadbackTable 55 ((#'(' 20) 'RS' 61) ((Expression 40) 'RSN' 86) ((Expression 30) 'RSN' 87))
   (ReadbackTable 56 ((Expression2 32) 'RSN' 97) ((Expression2 33) 'RSN' 97) ((Expression2 3) 'RSN' 97))
   (ReadbackTable 57 ((Expression2 32) 'RSN' 98) ((Expression2 33) 'RSN' 98) ((Expression2 3) 'RSN' 98))
   (ReadbackTable 58 ((Expression0 39) 'RSN' 99) ((Expression0 5) 'RSN' 99) ((Expression0 29) 'RSN' 99))
   (ReadbackTable 59 ((Expression0 39) 'RSN' 100) ((Expression0 5) 'RSN' 100) ((Expression0 29) 'RSN' 100))
   (ReadbackTable 60 ((Expression0 39) 'RSN' 101) ((Expression0 5) 'RSN' 101) ((Expression0 29) 'RSN' 101))
   (ReadbackTable 61 ((walkIdentifier: 24) 'RSN' 103) ((walkIdentifier: 7) 'RSN' 103))
   (ReadbackTable 62 ((Expression1 27) 'RSN' 104) ((Expression1 28) 'RSN' 104) ((Expression1 9) 'RSN' 104) ((Expression1 26) 'RSN' 104))
   (ReadbackTable 63 ((Expression1 27) 'RSN' 105) ((Expression1 28) 'RSN' 105) ((Expression1 9) 'RSN' 105) ((Expression1 26) 'RSN' 105))
   (ReadbackTable 64 ((Expression 40) 'RSN' 86) ((Expression 30) 'RSN' 87))
   (ShiftbackTable 65 1 91)
   (ShiftbackTable 66 1 94)
   (ShiftbackTable 67 1 95)
   (ShiftbackTable 68 1 93)
   (ShiftbackTable 69 1 92)
   (ShiftbackTable 70 1 88)
   (ShiftbackTable 71 2 90)
   (ShiftbackTable 72 3 93)
   (ShiftbackTable 73 2 56)
   (ShiftbackTable 74 2 57)
   (ShiftbackTable 75 2 58)
   (ShiftbackTable 76 2 59)
   (ShiftbackTable 77 2 60)
   (ShiftbackTable 78 3 102)
   (ShiftbackTable 79 1 55)
   (ShiftbackTable 80 2 62)
   (ShiftbackTable 81 2 63)
   (ShiftbackTable 82 5 106)
   (ShiftbackTable 83 11 108)
   (ShiftbackTable 84 10 107)
   (ShiftbackTable 85 6 107)
   (ShiftbackTable 86 1 64)
   (ShiftbackTable 87 1 61)
   (ReduceTable 88 Expression0 (1 'RSN' 5)(2 'RSN' 5)(6 'RSN' 5)(13 'RSN' 5)(17 'RSN' 29)(19 'RSN' 5)(20 'RSN' 5)(21 'RSN' 5)(34 'RSN' 5)(35 'RSN' 39)(36 'RSN' 5)(41 'RSN' 5)(42 'RSN' 5)(48 'RSN' 5)(49 'RSN' 5))
   (ReduceTable 89 Statements (1 'RSN' 65)(41 'RSN' 43)(48 'RSN' 50)(49 'RSN' 51))
   (ReduceTable 90 Statement (1 'RSN' 2)(2 'RSN' 2)(41 'RSN' 2)(48 'RSN' 2)(49 'RSN' 2))
   (ReduceTable 91 Grammar (1 'RSN' 109))
   (ReduceTable 92 Expression2 (1 'RSN' 3)(2 'RSN' 3)(6 'RSN' 3)(13 'RSN' 3)(14 'RSN' 3)(15 'RSN' 3)(16 'RSN' 3)(17 'RSN' 3)(19 'RSN' 3)(20 'RSN' 3)(21 'RSN' 3)(22 'RSN' 32)(23 'RSN' 33)(34 'RSN' 3)(35 'RSN' 3)(36 'RSN' 3)(41 'RSN' 3)(42 'RSN' 3)(48 'RSN' 3)(49 'RSN' 3))
   (ReduceTable 93 Expression3 (1 'RSN' 69)(2 'RSN' 69)(6 'RSN' 69)(11 'RSN' 73)(12 'RSN' 74)(13 'RSN' 69)(14 'RSN' 69)(15 'RSN' 69)(16 'RSN' 69)(17 'RSN' 69)(19 'RSN' 69)(20 'RSN' 69)(21 'RSN' 69)(22 'RSN' 69)(23 'RSN' 69)(34 'RSN' 69)(35 'RSN' 69)(36 'RSN' 69)(41 'RSN' 69)(42 'RSN' 69)(48 'RSN' 69)(49 'RSN' 69))
   (ReduceTable 94 Expression1 (1 'RSN' 9)(2 'RSN' 9)(6 'RSN' 9)(13 'RSN' 9)(14 'RSN' 26)(15 'RSN' 27)(16 'RSN' 28)(17 'RSN' 9)(19 'RSN' 9)(20 'RSN' 9)(21 'RSN' 9)(34 'RSN' 9)(35 'RSN' 9)(36 'RSN' 9)(41 'RSN' 9)(42 'RSN' 9)(48 'RSN' 9)(49 'RSN' 9))
   (ReduceTable 95 Expression (1 'RSN' 10)(2 'RSN' 10)(6 'RSN' 18)(13 'RSN' 25)(19 'RSN' 78)(20 'RSN' 30)(21 'RSN' 31)(34 'RSN' 38)(36 'RSN' 40)(41 'RSN' 10)(42 'RSN' 44)(48 'RSN' 10)(49 'RSN' 10))
   (SemanticTable 96 buildTree: walkList: 89)
   (SemanticTable 97 buildTree: walkMultiply: 92)
   (SemanticTable 98 buildTree: walkDivide: 92)
   (SemanticTable 99 buildTree: walkLess: 88)
   (SemanticTable 100 buildTree: walkGreater: 88)
   (SemanticTable 101 buildTree: walkEqual: 88)
   (SemanticTable 102 buildTree: walkAssign: 95)
   (SemanticTable 103 buildTree: walkSend: 93)
   (SemanticTable 104 buildTree: walkPlus: 94)
   (SemanticTable 105 buildTree: walkMinus: 94)
   (SemanticTable 106 buildTree: walkIf: 95)
   (SemanticTable 107 buildTree: walkIf: 90)
   (SemanticTable 108 buildTree: walkFor: 90)
   (AcceptTable 109))!   !

!StudentCompiler class methods ! 
rawScannerTables
    "Scanner rawScannerTables"

    "EndOfFileCharacter is 256"
    ^

#(
   (ScannerReadaheadTable 1 ('#' 'R' 6) ('{' 'RK' 23) ('}' 'RK' 24) ((256) 'L' 7) ('<' 'RK' 18) ('=' 'RK' 3) ('>' 'RK' 20) (')' 'RK' 9) ('*' 'RK' 10) ('+' 'RK' 11) (',' 'RK' 12) ('-' 'RK' 13) ('(' 'RK' 8) ('/' 'RK' 14) ('0123456789' 'RK' 2) (':' 'RK' 16) (';' 'RK' 17) ('?' 'RK' 21) ('ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz' 'RK' 4) ((9 10 12 13) 'R' 5) (' ' 'R' 5))
   (ScannerReadaheadTable 2 ((9 10 12 13 256) 'L' 15) ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_+-*/<>=?[]{}()^;#:.$ ' 'L' 15) ('0123456789' 'RK' 2))
   (ScannerReadaheadTable 3 ((9 10 12 13 256) 'L' 19) ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_0123456789+-*/<>?[]{}()^;#:.$ ' 'L' 19) ('=' 'RK' 25))
   (ScannerReadaheadTable 4 ((9 10 12 13 256) 'L' 22) ('+-*/<>=?[]{}()^;#:.$ ' 'L' 22) ('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz' 'RK' 4))
   (ScannerReadaheadTable 5 ((256) 'L' 1) ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_0123456789+-*/<>=?[]{}()^;#:.$' 'L' 1) ((9 10 12 13) 'R' 5) (' ' 'R' 5))
   (ScannerReadaheadTable 6 ((9 256) 'R' 6) ('=>?ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_abcdefghijklmnopqrstuvwxyz{} #$()*+-./0123456789:;<' 'R' 6) ((10 12 13) 'R' 1))
   (SemanticTable 7 buildToken: '-|' 1)
   (SemanticTable 8 buildToken: '(' 1)
   (SemanticTable 9 buildToken: ')' 1)
   (SemanticTable 10 buildToken: '*' 1)
   (SemanticTable 11 buildToken: '+' 1)
   (SemanticTable 12 buildToken: ',' 1)
   (SemanticTable 13 buildToken: '-' 1)
   (SemanticTable 14 buildToken: '/' 1)
   (SemanticTable 15 buildToken: walkInteger: 1)
   (SemanticTable 16 buildToken: ':' 1)
   (SemanticTable 17 buildToken: ';' 1)
   (SemanticTable 18 buildToken: '<' 1)
   (SemanticTable 19 buildToken: '=' 1)
   (SemanticTable 20 buildToken: '>' 1)
   (SemanticTable 21 buildToken: '?' 1)
   (SemanticTable 22 buildToken: walkIdentifier: 1)
   (SemanticTable 23 buildToken: '{' 1)
   (SemanticTable 24 buildToken: '}' 1)
   (SemanticTable 25 buildToken: '==' 1))!  !
(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('raw tables' rawParserTables rawScannerTables )) !

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('raw tables' rawParserTables rawScannerTables )) !



!StudentCompiler class methods ! 
walkExample2
    "StudentCompiler walkExample2"
    ^StudentCompiler new compile: 'for (a =1; a< 5; a+1) {b-2;}'! !

!StudentCompiler class methods ! 
walkExample1
    "StudentCompiler walkExample1"
    ^StudentCompiler new compile: 'if (a > b) {a = b; c = d;} else {e = f;}'! !
(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample1 walkExample2 )) !

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample1 walkExample2 )) !



!StudentCompiler methods ! 
initialize
    parser := Parser 
        for: self 
        parserTables: self class rawParserTables 
        scannerTables: self class rawScannerTables.
        contextStack := OrderedCollection new.
        contextStack add: #statement.
        code := OrderedCollection new.!   !

"evaluate"   
(CodeFiler organizerFor: StudentCompiler) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('initializing' initialize )) !



!StudentCompiler methods !
parser: aParser
    parser := aParser! !

!StudentCompiler methods !   
contextStack: anOrderedCollection
    contextStack := anOrderedCollection! !

!StudentCompiler methods !   
code
    ^code!    !

!StudentCompiler methods !   
parser
    ^parser!    !

!StudentCompiler methods !   
code: anOrderedCollection
    code := anOrderedCollection! !

!StudentCompiler methods !   
tree: aTree
    tree := aTree! !

!StudentCompiler methods !   
contextStack
    ^contextStack!    !

!StudentCompiler methods !   
tree
    ^tree!    !
(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('get/set' contextStack code parser: parser code: tree: contextStack: tree )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('get/set' contextStack code parser: parser code: tree: contextStack: tree )) !



!StudentCompiler methods !   
popContext
    contextStack removeLast!    !

!StudentCompiler methods !   
pushExpressionContext
    contextStack add: #expression!   !

!StudentCompiler methods !   
pushStatementContext
    contextStack add: #statement! !

!StudentCompiler methods !   
isStatementContext
    ^contextStack last == #statement!   !

!StudentCompiler methods !   
isExpressionContext
    ^contextStack last == #expression! !
(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('contextStackMethods' pushStatementContext isExpressionContext pushExpressionContext popContext isStatementContext )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('contextStackMethods' pushStatementContext isExpressionContext pushExpressionContext popContext isStatementContext )) !



!StudentCompiler methods ! 
walkTree: tree
    ^self perform: tree label with: tree!   !

!StudentCompiler methods !   
compile: text
    tree := parser parse: text.
    self walkTree: tree.
    ^code!    !
(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('compiling/evaluating/walk' compile: walkTree: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('compiling/evaluating/walk' compile: walkTree: )) !



!StudentCompiler methods ! 
walkInstruction: opCode
    code add: opCode. 
    ^code size -1! !

!StudentCompiler methods !   
walkBranch: opcode backTo: location
    ^self walkInstruction: opcode 
        with: (location - self nextInstruction)!   !

!StudentCompiler methods !   
fixupBranch: where with: nextInstruction
    newOffset := nextInstruction - where.
    code at: where + 1 put: newOffset! !

!StudentCompiler methods !   
nextInstruction
    ^code size+1!  !

!StudentCompiler methods !   
walkInstruction: opCode with: operand
    code add: opCode; add: operand.
    ^code size-2!   !
(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' walkInstruction: nextInstruction walkBranch:backTo: walkInstruction:with: fixupBranch:with: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' walkInstruction: nextInstruction walkBranch:backTo: walkInstruction:with: fixupBranch:with: )) !



!StudentCompiler methods ! 
walkMultiply: tree
    self walkTree: (tree child: 1).
    tree children size == 1 ifTrue: [^self].
    self walkTree: (tree child: 2).
    self isExpressionContext ifTrue: [
        self walkInstruction: #Multiply]!   !

!StudentCompiler methods !   
walkEqual: tree
    self walkTree: (tree child: 1).
    self isStatementContext ifTrue: [^self].
    self walkTree: (tree child: 2).
    self isExpressionContext ifTrue: [
        self walkInstruction: #Equal]! !

!StudentCompiler methods !   
walkIdentifier: tree
    | name|
    self isStatementContext ifTrue: [^self].
    name := tree symbol.
    self walkInstruction: #Push with: name.! !

!StudentCompiler methods !   
walkDivide: tree
    self walkTree: (tree child: 1).
    tree children size == 1 ifTrue: [^self]. 
    self walkTree: (tree child: 2).
    self isExpressionContext ifTrue: [
        self walkInstruction: #Divide]!  !

!StudentCompiler methods !   
walkGreater: tree
    self walkTree: (tree child: 1).
    self isStatementContext ifTrue: [^self].
    self walkTree: (tree child: 2).
    self isExpressionContext ifTrue: [
        self walkInstruction: #Greater]! !

!StudentCompiler methods !   
walkFloat: tree
    | constant | 
    self isStatementContext ifTrue: [^#void].
    constant := tree symbol asFloat.
    self walkInstruction: #PushFloat with: constant.
    ^#Float! !

!StudentCompiler methods !   
walkAssign: tree
    | name expression | 
    name := (tree child: 1) symbol. 
    expression := tree child: 2. 
    self pushExpressionContext.
    self walkTree: expression.
    self popContext.
    self isExpressionContext ifTrue: [
        self walkInstruction: #Duplicate].
    self walkInstruction: #Pop with: name.! !

!StudentCompiler methods !   
walkList: tree
    tree children isEmpty ifTrue: [
        self isExpressionContext ifTrue: [
            self walkInstruction: #push with: nil. 
        ^self]].
    self pushStatementContext. 
        tree children allButLast do: [:child |
            self walkTree: child]. 
    self popContext. 
    self walkTree: (tree child: tree children size).!  !

!StudentCompiler methods !   
walkFor: tree
    |initialExpression booleanExpression incrementExpression body whileStart fixAtEnd end |
    
    self isExpressionContext ifTrue: [
        self designError: 'Can''t use for loop as expression'.    
        ^self
        ].
    
    initialExpression := tree child: 1.
    booleanExpression := tree child: 2.
    incrementExpression := tree child: 3.
    body := tree child: 4.
    

    self walkTree: initialExpression.
    self pushExpressionContext "For branchIfFalse to work".
        whileStart  := self nextInstruction.
        self walkTree: booleanExpression.
    
    self popContext.

    fixAtEnd:= self nextInstruction.
    self walkInstruction:  #branchIfFalse with: nil. 
    self walkTree: body.
    self walkTree: incrementExpression.
    self walkBranch: #branch backTo: whileStart.
    end:=self nextInstruction.
    self fixupBranch: fixAtEnd with: end.! !

!StudentCompiler methods !   
walkSend: tree
    | resultType selector types |
    types := OrderedCollection new.
    self pushExpressionContext.
    tree children indexedDo: [:index :child |index = 2
        ifTrue: [selector := child]
        ifFalse: types add: (self walkTree: child)].
    self popContext.
    self walkInstruction: #Send.! !

!StudentCompiler methods !   
walkMinus: tree
    self walkTree: (tree child: 1).
    tree children size == 1 ifTrue: [^self].
    self walkTree: (tree child: 2).
    self isExpressionContext ifTrue: [
        self walkInstruction: #Minus]! !

!StudentCompiler methods !   
walkLess: tree
    self walkTree: (tree child: 1).
    self isStatementContext ifTrue: [^self].
    self walkTree: (tree child: 2).
    self isExpressionContext ifTrue: [
        self walkInstruction: #Less]!   !

!StudentCompiler methods !   
walkPlus: tree
    self walkTree: (tree child: 1).
    tree children size == 1 ifTrue: [^self].
    self walkTree: (tree child: 2).
    self isExpressionContext ifTrue: [
        self walkInstruction: #Add.]!   !

!StudentCompiler methods !   
walkInteger: tree
    | constant |
    self isStatementContext ifTrue: [^#void].
    constant := tree symbol asInteger.
    self walkInstruction: #PushInteger with: constant.
    ^#Integer!  !

!StudentCompiler methods !   
walkIf: tree
    |exp then else fixToElse elseStart fixToEnd endStart|
    exp := tree child: 1.
    then := tree  child: 2.
    else := tree children size < 3
        ifTrue: [nil]
        ifFalse: [tree child: 3].
        else isNil 
            ifTrue:[ 
                self isExpressionContext 
                    ifTrue:[
                        self error: 'Missing else for if expression'.
                        else := then ]].
    
    self pushExpressionContext.
    self walkTree: exp.
    self popContext.
    
    fixToElse := self walkInstruction: #branchIfFalse with: nil. 
    self walkTree: then.
    else isNil
        ifTrue:[
                elseStart:= self nextInstruction.
                self fixupBranch: fixToElse with: elseStart]
        ifFalse: [
            fixToEnd := self walkInstruction: #branch with: nil.
            elseStart := self nextInstruction.
            self walkTree: else.
            endStart := self nextInstruction.
            
            self  fixupBranch: fixToElse with: elseStart.
            self fixupBranch: fixToEnd with: endStart].!   !
(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkMultiply: walkEqual: walkIdentifier: walkDivide: walkGreater: walkFloat: walkAssign: walkList: walkFor: walkSend: walkMinus: walkLess: walkPlus: walkInteger: walkIf: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkMultiply: walkEqual: walkIdentifier: walkDivide: walkGreater: walkFloat: walkAssign: walkList: walkFor: walkSend: walkMinus: walkLess: walkPlus: walkInteger: walkIf: )) !
CodeFiler setCommentFor: StudentCompiler to: ''!


!StudentCompiler methods ! 
walkIf: aTree
    | exp then else fixToElse elseStart fixToEnd endStart |
    exp := aTree child: 1.
    then := aTree child: 2.
    else := aTree children size < 3 
        ifTrue: [nil]
        ifFalse: [aTree child: 3].
    else isNil and: [self isExpressionContext] 
        ifTrue: [
            self error: 'Missing else for if expression'.
            else := then "Make the compiler work"]
    self pushExpressionContext.
    self walkTree: exp.
    self popContext.
    fixToElse := self emitInstruction: #BRANCH_IF_FALSE with nil. "to elseStart"
    self walkTree: then.
    else isNil
        ifTrue: [
            elseStart := self nextInstruction.
            self fixupBranch: fixToElse with: elseStart.
        ]
        ifFalse: [
            fixToEnd := self emitInstruction: #BRANCH with: nil. "to endStart"
            elseStart := self nextInstruction.
            self walkTree: else.
            endStart := self nextInstruction.
            self fixupBranch: fixToElse with: elseStart.
            self fixupBranch: fixToEnd with: endStart.
        ].! ! 
#('February 21, 2021' '05:44:24 PM' 1825640)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIf: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIf: )) !


!StudentCompiler methods ! 
walkIf: aTree
    | exp then else fixToElse elseStart fixToEnd endStart |
    exp := aTree child: 1.
    then := aTree child: 2.
    else := aTree children size < 3 
        ifTrue: [nil]
        ifFalse: [aTree child: 3].
    else isNil and: [self isExpressionContext] 
        ifTrue: [
            self error: 'Missing else for if expression'.
            else := then "Make the compiler work"]
    self pushExpressionContext.
    self walkTree: exp.
    self popContext.
    fixToElse := self walkInstruction: #BRANCH_IF_FALSE with nil. "to elseStart"
    self walkTree: then.
    else isNil
        ifTrue: [
            elseStart := self nextInstruction.
            self fixupBranch: fixToElse with: elseStart.
        ]
        ifFalse: [
            fixToEnd := self walkInstruction: #BRANCH with: nil. "to endStart"
            elseStart := self nextInstruction.
            self walkTree: else.
            endStart := self nextInstruction.
            self fixupBranch: fixToElse with: elseStart.
            self fixupBranch: fixToEnd with: endStart.
        ].! ! 
#('February 21, 2021' '05:44:54 PM' 1827368)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIf: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIf: )) !


!StudentCompiler methods ! 
walkInteger: aTree
    | constant |
    self isStatementContext ifTrue: [^self].
    constant := aTree symbol asInteger.
    self emitInstruction: #PUSH with: constant.!   ! 
#('February 21, 2021' '05:45:15 PM' 1825408)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkInteger: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkInteger: )) !


!StudentCompiler methods !   
walkInteger: aTree
    | constant |
    self isStatementContext ifTrue: [^self].
    constant := aTree symbol asInteger.
    self walkInstruction: #PUSH with: constant.!   ! 
#('February 21, 2021' '05:45:27 PM' 1830120)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkInteger: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkInteger: )) !


!StudentCompiler methods !   
walkIdentifier: aTree
    | name |
    self isStatementContext ifTrue: [^self].
    name  := aTree symbol.
    self walkInstruction: #PUSH with: name.! ! 
#('February 21, 2021' '05:45:45 PM' 1821644)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIdentifier: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIdentifier: )) !


!StudentCompiler methods ! 
walkFor: aTree
    | initialExpression booleanExpression incrementExpression body whileStart fixAtEnd end |
    self isExpressionContext ifTrue: [
        self designError: 'Can not use for loop as expression'.
        ^self
    ].
    initialExpression := aTree child: 1.
    booleanExpression := aTree child: 2.
    incrementExpression := aTree child: 3.
    body := aTree child: 4.
    self walkTree: initialExpression.
    self pushExpressionContext. "For BRANCH_IF_FALSE to work"
    whileStart := self nextInstruction.
    self walkTree: booleanExpression.
    self popContext.
    fixAtEnd := self nextInstruction.
    self emitInstruction: #BRANCH_IF_FALSE with: nil. "To end"
    self walkTree: body.
    self walkTree: incrementExpression.
    self emitBranch: #BRANCH backTo: whileStart.
    end := self nextInstruction.
    self fixupBranch: fixAtEnd with: end.! ! 
#('February 21, 2021' '05:45:55 PM' 1823336)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFor: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFor: )) !


!StudentCompiler methods !   
walkFor: aTree
    | initialExpression booleanExpression incrementExpression body whileStart fixAtEnd end |
    self isExpressionContext ifTrue: [
        self designError: 'Can not use for loop as expression'.
        ^self
    ].
    initialExpression := aTree child: 1.
    booleanExpression := aTree child: 2.
    incrementExpression := aTree child: 3.
    body := aTree child: 4.
    self walkTree: initialExpression.
    self pushExpressionContext. "For BRANCH_IF_FALSE to work"
    whileStart := self nextInstruction.
    self walkTree: booleanExpression.
    self popContext.
    fixAtEnd := self nextInstruction.
    self walkInstruction: #BRANCH_IF_FALSE with: nil. "To end"
    self walkTree: body.
    self walkTree: incrementExpression.
    self walkBranch: #BRANCH backTo: whileStart.
    end := self nextInstruction.
    self fixupBranch: fixAtEnd with: end.! ! 
#('February 21, 2021' '05:46:19 PM' 1831484)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFor: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFor: )) !


!StudentCompiler methods !   
walkAssign: aTree
    |name expression|
    name := (aTree child: 1) symbol.
    expression := aTree child: 2. 
    self pushExpressionContext.
    self walkTree: expression.
    self popContext.
    self isExpressionContext ifTrue: [
        self walkInstruction: #DUPLICATE
    ].
    self walkInstruction: #POP with: name! ! 
#('February 21, 2021' '05:47:43 PM' 1822568)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkAssign: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkAssign: )) !


!StudentCompiler methods ! 
walkInteger: tree
    | constant |
    self isStatementContext ifTrue: [^self].
    constant := tree symbol asInteger.
    self walkInstruction: #PUSH with: constant.! ! 
#('February 21, 2021' '06:30:25 PM' 1830580)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkInteger: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkInteger: )) !


!StudentCompiler methods !   
walkIdentifier: tree
    | name |
    self isStatementContext ifTrue: [^self].
    name  := tree symbol.
    self walkInstruction: #PUSH with: name.!   ! 
#('February 21, 2021' '06:30:40 PM' 1831040)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIdentifier: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIdentifier: )) !


!StudentCompiler methods ! 
walkFor: tree
    | initialExpression booleanExpression incrementExpression body whileStart fixAtEnd end |
    self isExpressionContext ifTrue: [
        self designError: 'Can not use for loop as expression'.
        ^self
    ].
    initialExpression := tree child: 1.
    booleanExpression := tree child: 2.
    incrementExpression := tree child: 3.
    body := tree child: 4.
    self walkTree: initialExpression.
    self pushExpressionContext. "For BRANCH_IF_FALSE to work"
    whileStart := self nextInstruction.
    self walkTree: booleanExpression.
    self popContext.
    fixAtEnd := self nextInstruction.
    self walkInstruction: #BRANCH_IF_FALSE with: nil. "To end"
    self walkTree: body.
    self walkTree: incrementExpression.
    self walkBranch: #BRANCH backTo: whileStart.
    end := self nextInstruction.
    self fixupBranch: fixAtEnd with: end.!  ! 
#('February 21, 2021' '06:31:23 PM' 1832656)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFor: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFor: )) !


!StudentCompiler methods !   
walkIf: tree
    | exp then else fixToElse elseStart fixToEnd endStart |
    exp := tree child: 1.
    then := tree child: 2.
    else := tree children size < 3 
        ifTrue: [nil]
        ifFalse: [tree child: 3].
    else isNil and: [self isExpressionContext] 
        ifTrue: [
            self error: 'Missing else for if expression'.
            else := then "Make the compiler work"]
    self pushExpressionContext.
    self walkTree: exp.
    self popContext.
    fixToElse := self walkInstruction: #BRANCH_IF_FALSE with nil. "to elseStart"
    self walkTree: then.
    else isNil
        ifTrue: [
            elseStart := self nextInstruction.
            self fixupBranch: fixToElse with: elseStart.
        ]
        ifFalse: [
            fixToEnd := self walkInstruction: #BRANCH with: nil. "to endStart"
            elseStart := self nextInstruction.
            self walkTree: else.
            endStart := self nextInstruction.
            self fixupBranch: fixToElse with: elseStart.
            self fixupBranch: fixToEnd with: endStart.
        ].!  ! 
#('February 21, 2021' '06:32:02 PM' 1828744)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIf: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIf: )) !


!StudentCompiler methods ! 
walkAssign: tree
    |name expression|
    name := (tree child: 1) symbol.
    expression := tree child: 2. 
    self pushExpressionContext.
    self walkTree: expression.
    self popContext.
    self isExpressionContext ifTrue: [
        self walkInstruction: #DUPLICATE
    ].
    self walkInstruction: #POP with: name!    ! 
#('February 21, 2021' '06:32:35 PM' 1833828)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkAssign: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkAssign: )) !


!StudentCompiler methods ! 
walkAssign: tree
    |name expression|
    name := (tree child: 1) symbol.
    expression := tree child: 2. 
    self pushExpressionContext.
    self walkTree: expression.
    self popContext.
    self isExpressionContext ifTrue: [
        self walkInstruction: #Duplicate
    ].
    self walkInstruction: #Pop with: name!    ! 
#('February 21, 2021' '06:34:08 PM' 1837884)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkAssign: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkAssign: )) !


!StudentCompiler methods ! 
walkFor: tree
    | initialExpression booleanExpression incrementExpression body whileStart fixAtEnd end |
    self isExpressionContext ifTrue: [
        self designError: 'Can not use for loop as expression'.
        ^self
    ].
    initialExpression := tree child: 1.
    booleanExpression := tree child: 2.
    incrementExpression := tree child: 3.
    body := tree child: 4.
    self walkTree: initialExpression.
    self pushExpressionContext. "For BRANCH_IF_FALSE to work"
    whileStart := self nextInstruction.
    self walkTree: booleanExpression.
    self popContext.
    fixAtEnd := self nextInstruction.
    self walkInstruction: #Branch_if_False with: nil. "To end"
    self walkTree: body.
    self walkTree: incrementExpression.
    self walkBranch: #Branch backTo: whileStart.
    end := self nextInstruction.
    self fixupBranch: fixAtEnd with: end.!  ! 
#('February 21, 2021' '06:44:01 PM' 1835344)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFor: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFor: )) !


!StudentCompiler methods !   
walkTree: tree
    self perform: (tree label asSymbol) with: tree! ! 
#('February 21, 2021' '06:46:12 PM' 1819692)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('compiling/evaluating/walk' walkTree: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('compiling/evaluating/walk' walkTree: )) !


!StudentCompiler methods !   
fixupBranch: where with: nextInstruction
    | newOffset |
    newOffset := nextInstruction - where.
    code at: where + 1 put: newOffset!  ! 
#('February 21, 2021' '06:46:56 PM' 1820412)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' fixupBranch:with: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' fixupBranch:with: )) !


   
'Smalltalk'!

!StudentCompiler methods !
fixupAllBranches: unknown with: nextInstruction 
    | nextUnknown tempUnknown |
    tempUnknown = unknown.
    [tempUnknown notNil] whileTrue: [
        nextUnknown := code at: tempUnknown + 1
        sekf fixupBranch tempUnknown with: nextInstruction.
        tempUnknown := nextUnknown
    ]!  ! 
#('February 21, 2021' '06:48:31 PM' nil)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' fixupAllBranches:with: )) !


!StudentCompiler methods !
initialize
    parser := Parser 
        for: self 
        parserTables: self class rawParserTables 
        scannerTables: self class rawScannerTables.
    code := OrderedCollection new.
    contextStack := OrderedCollection new.
    self pushStatementContext.!  ! 
#('February 21, 2021' '06:50:25 PM' 1817340)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('initializing' initialize )) !


"evaluate"   
StudentCompiler removeSelector: #code!

"evaluate"  
StudentCompiler removeSelector: #code:!

"evaluate" 
StudentCompiler removeSelector: #contextStack!

"evaluate"  
StudentCompiler removeSelector: #contextStack:!

"evaluate" 
(CodeFiler setAndInitializeOrganizerFor: StudentCompiler to: (MethodBasedOrganizer fromArray: #(('initializing' initialize)
('get/set' parser parser: tree tree:)
('compiling/evaluating/walk' compile: walkTree:)
('contextStackMethods' isExpressionContext isStatementContext popContext pushExpressionContext pushStatementContext)
('walk support' fixupAllBranches:with: fixupBranch:with: nextInstruction walkBranch:backTo: walkInstruction: walkInstruction:with:)
('walk details' walkAssign: walkDivide: walkEqual: walkFloat: walkFor: walkGreater: walkIdentifier: walkIf: walkInteger: walkLess: walkList: walkMinus: walkMultiply: walkPlus: walkSend:)))).!

"evaluate"
(CodeFiler setAndInitializeOrganizerFor: StudentCompiler to: (MethodBasedOrganizer fromArray: #(('initializing' initialize)
('get/set' parser parser: tree tree:)
('compiling/evaluating/walk' compile: walkTree:)
('walk support' fixupAllBranches:with: fixupBranch:with: nextInstruction walkBranch:backTo: walkInstruction: walkInstruction:with:)
('contextStackMethods' isExpressionContext isStatementContext popContext pushExpressionContext pushStatementContext)
('walk details' walkAssign: walkDivide: walkEqual: walkFloat: walkFor: walkGreater: walkIdentifier: walkIf: walkInteger: walkLess: walkList: walkMinus: walkMultiply: walkPlus: walkSend:)))).!

!StudentCompiler methods !
walkBranch: instruction backTo: location
     ^self walkInstruction: 
         instruction with: 
             (location - self nextInstruction)!    ! 
#('February 21, 2021' '06:53:00 PM' 1820252)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' walkBranch:backTo: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' walkBranch:backTo: )) !


!StudentCompiler methods !   
walkBranch: opCode backTo: location
     ^self walkInstruction: opCode 
         with: (location - self nextInstruction)! ! 
#('February 21, 2021' '06:53:55 PM' 1843740)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' walkBranch:backTo: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' walkBranch:backTo: )) !


!StudentCompiler methods !   
walkInstruction: opCode
    code add: opCode. ^code size!  ! 
#('February 21, 2021' '06:54:13 PM' 1820148)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' walkInstruction: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' walkInstruction: )) !


!StudentCompiler methods !   
walkInstruction: opCode with: operand
    code add: opCode; add: operand.
    ^code size-1!   ! 
#('February 21, 2021' '06:54:28 PM' 1820644)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' walkInstruction:with: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' walkInstruction:with: )) !


!StudentCompiler methods ! 
fixupAllBranches: unknown with: nextInstruction 
    | nextUnknown tempUnknown |
    tempUnknown = unknown.
    [tempUnknown notNil] whileTrue: [
        nextUnknown := code at: tempUnknown + 1
        self fixupBranch tempUnknown with: nextInstruction.
        tempUnknown := nextUnknown
    ]!  ! 
#('February 21, 2021' '06:54:44 PM' 1841112)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' fixupAllBranches:with: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' fixupAllBranches:with: )) !


!StudentCompiler methods !   
generate: instruction
    code cr; << instruction! ! 
#('February 21, 2021' '06:55:06 PM' nil)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' generate: )) !


!StudentCompiler methods ! 
generate: opCode with: operand
    code cr; << opCode; << ' '; << operand! ! 
#('February 21, 2021' '06:56:10 PM' nil)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' generate:with: )) !


!StudentCompiler methods !
generate: opCode
    code cr; << opCode!   ! 
#('February 21, 2021' '06:56:28 PM' 1845964)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' generate: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' generate: )) !


!StudentCompiler methods ! 
walkFloat: tree
    | constant | 
    self isStatementContext ifTrue: [^self].
    constant := tree symbol asFloat.
    self walkInstruction: #PushFloat with: constant.!   ! 
#('February 21, 2021' '06:58:55 PM' 1822344)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFloat: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFloat: )) !


!StudentCompiler methods !   
walkIf: tree
    |exp then else fixToElse elseStart fixToEnd endStart|
    exp := tree child: 1.
    then := tree  child: 2.
    else := tree children size < 3
        ifTrue: [nil]
        ifFalse: [tree child: 3].
        else isNil 
            ifTrue:[ 
                self isExpressionContext 
                    ifTrue:[
                        self error: 'Missing else for if expression'.
                        else := then ]].
    
    self pushExpressionContext.
    self walkTree: exp.
    self popContext.
    
    fixToElse := self walkInstruction: #branchIfFalse with: nil. 
    self walkTree: then.
    else isNil
        ifTrue:[
                elseStart:= self nextInstruction.
                self fixupBranch: fixToElse with: elseStart]
        ifFalse: [
            fixToEnd := self walkInstruction: #branch with: nil.
            elseStart := self nextInstruction.
            self walkTree: else.
            endStart := self nextInstruction.
            
            self  fixupBranch: fixToElse with: elseStart.
            self fixupBranch: fixToEnd with: endStart].!   ! 
#('February 21, 2021' '07:00:13 PM' 1836512)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIf: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIf: )) !


!StudentCompiler methods ! 
walkInteger: tree
    | constant |
    self isStatementContext ifTrue: [^self].
    constant := tree symbol asInteger.
    self walkInstruction: #PushInteger with: constant.
    ^#Integer!   ! 
#('February 21, 2021' '07:00:45 PM' 1834444)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkInteger: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkInteger: )) !


!StudentCompiler methods !   
walkFloat: tree
    | constant | 
    self isStatementContext ifTrue: [^self].
    constant := tree symbol asFloat.
    self walkInstruction: #PushFloat with: constant.
    ^#Float!  ! 
#('February 21, 2021' '07:01:10 PM' 1846768)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFloat: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFloat: )) !


!StudentCompiler methods !   
walkIf: tree
    |exp then else fixToElse elseStart fixToEnd endStart|
    exp := tree child: 1.
    then := tree  child: 2.
    else := tree children size < 3
        ifTrue: [nil]
        ifFalse: [tree child: 3].
    else isNil and: [self isExpressionContext] 
        ifTrue: [
            self error: 'Missing else for if expression'.
            else := then "Make the compiler work"]
    
    self pushExpressionContext.
    self walkTree: exp.
    self popContext.
    
    fixToElse := self walkInstruction: #branchIfFalse with: nil. 
    self walkTree: then.
    else isNil
        ifTrue:[
                elseStart:= self nextInstruction.
                self fixupBranch: fixToElse with: elseStart]
        ifFalse: [
            fixToEnd := self walkInstruction: #branch with: nil.
            elseStart := self nextInstruction.
            self walkTree: else.
            endStart := self nextInstruction.
            
            self  fixupBranch: fixToElse with: elseStart.
            self fixupBranch: fixToEnd with: endStart].!  ! 
#('February 21, 2021' '07:02:20 PM' 1847224)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIf: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIf: )) !


!StudentCompiler methods ! 
walkIf: tree
    |exp then else fixToElse elseStart fixToEnd endStart|
    exp := tree child: 1.
    then := tree  child: 2.
    else := tree children size < 3
        ifTrue: [nil]
        ifFalse: [tree child: 3].
    else isNil and: [self isExpressionContext] 
        ifTrue: [
            self error: 'Missing else for if expression'.
            else := then "Make the compiler work"]
    self pushExpressionContext.
    self walkTree: exp.
    self popContext.
    
    fixToElse := self walkInstruction: #branchIfFalse with: nil. 
    self walkTree: then.
    else isNil
        ifTrue:[
                elseStart:= self nextInstruction.
                self fixupBranch: fixToElse with: elseStart]
        ifFalse: [
            fixToEnd := self walkInstruction: #branch with: nil.
            elseStart := self nextInstruction.
            self walkTree: else.
            endStart := self nextInstruction.
            
            self  fixupBranch: fixToElse with: elseStart.
            self fixupBranch: fixToEnd with: endStart].!    ! 
#('February 21, 2021' '07:02:48 PM' 1849576)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIf: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIf: )) !


!StudentCompiler methods ! 
walkFor: tree
    |initialExpression booleanExpression incrementExpression body whileStart fixAtEnd end |
    
    self isExpressionContext ifTrue: [
        self designError: 'Can''t use for loop as expression'.    
        ^self
        ].
    
    initialExpression := tree child: 1.
    booleanExpression := tree child: 2.
    incrementExpression := tree child: 3.
    body := tree child: 4.
    

    self walkTree: initialExpression.
    self pushExpressionContext "For branchIfFalse to work".
        whileStart  := self nextInstruction.
        self walkTree: booleanExpression.
    
    self popContext.

    fixAtEnd:= self nextInstruction.
    self walkInstruction:  #branchIfFalse with: nil. 
    self walkTree: body.
    self walkTree: incrementExpression.
    self walkBranch: #branch backTo: whileStart.
    end:=self nextInstruction.
    self fixupBranch: fixAtEnd with: end.! ! 
#('February 21, 2021' '07:03:51 PM' 1839116)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFor: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFor: )) !


!StudentCompiler methods !   
walkFor: tree
    |initialExpression booleanExpression incrementExpression body whileStart fixAtEnd end |
    
    self isExpressionContext ifTrue: [
        self designError: 'Can''t use for loop as expression'.    
        ^self
        ].
    
    initialExpression := tree child: 1.
    booleanExpression := tree child: 2.
    incrementExpression := tree child: 3.
    body := tree child: 4.
    

    self walkTree: initialExpression.
    self pushExpressionContext "For branchIfFalse to work".
    whileStart  := self nextInstruction.
    self walkTree: booleanExpression.
    
    self popContext.

    fixAtEnd:= self nextInstruction.
    self walkInstruction:  #branchIfFalse with: nil. "To end"
    self walkTree: body.
    self walkTree: incrementExpression.
    self walkBranch: #branch backTo: whileStart.
    end:=self nextInstruction.
    self fixupBranch: fixAtEnd with: end.! ! 
#('February 21, 2021' '07:05:07 PM' 1852276)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFor: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFor: )) !


!StudentCompiler methods !   
walkIdentifier: tree
    | name|
    self isStatementContext ifTrue: [^self].
    name := tree symbol.
    self walkInstruction: #Push with: name.! ! 
#('February 21, 2021' '07:05:44 PM' 1834900)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIdentifier: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIdentifier: )) !


!StudentCompiler class methods !   
walkExample1
    |text code|
    "StudentCompiler walkExample1"
    Transcript cr; << 'Compiling '; << text.
    code indexedDo: [:index :object | Transcript cr; << index; << ': '; << object].
    ^StudentCompiler new compile: 'if (a > b) {a = b; c = d;} else {e = f;}'! ! 
#('February 21, 2021' '07:08:24 PM' 1816948)!

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample1 )) !

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample1 )) !


!StudentCompiler class methods ! 
walkExample1
    "StudentCompiler walkExample1"
    ^StudentCompiler new compile: 'if (a > b) {a = b; c = d;} else {e = f;}'! ! 
#('February 21, 2021' '07:09:39 PM' 1855116)!

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample1 )) !

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample1 )) !


!StudentCompiler methods !   
walkIf: tree
    |exp then else fixToElse elseStart fixToEnd endStart|
    exp := tree child: 1.
    then := tree  child: 2.
    else := tree children size < 3
        ifTrue: [nil]
        ifFalse: [tree child: 3].
        else isNil 
            ifTrue:[ 
                self isExpressionContext 
                    ifTrue:[
                        self error: 'Missing else for if expression'.
                        else := then ]].
    
    self pushExpressionContext.
    self walkTree: exp.
    self popContext.
    
    fixToElse := self walkInstruction: #branchIfFalse with: nil. 
    self walkTree: then.
    else isNil
        ifTrue:[
                elseStart:= self nextInstruction.
                self fixupBranch: fixToElse with: elseStart]
        ifFalse: [
            fixToEnd := self walkInstruction: #branch with: nil.
            elseStart := self nextInstruction.
            self walkTree: else.
            endStart := self nextInstruction.
            
            self  fixupBranch: fixToElse with: elseStart.
            self fixupBranch: fixToEnd with: endStart].!   ! 
#('February 21, 2021' '07:10:31 PM' 1850928)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIf: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIf: )) !


   
'StudentCompiler walkExample1'!

   
'StudentCompiler walkExample1'!


!StudentCompiler methods !   
initialize

    self
        contextStack: OrderedCollection new;
        code: OrderedCollection new!  !
(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('initializing' initialize )) !



!StudentCompiler class methods ! 
new

    ^super new initialize!   !
(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('instance creation' new )) !



!StudentCompiler methods !   
contextStack
    ^contextStack!    !

!StudentCompiler methods !   
contextStack: anOrderedCollection
    contextStack := anOrderedCollection! !

!StudentCompiler methods !   
code
    ^code!    !

!StudentCompiler methods !   
code: anOrderedCollection
    code := anOrderedCollection! !
(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('get/set' code contextStack contextStack: code: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('get/set' code contextStack contextStack: code: )) !


!StudentCompiler class methods !   
walkExample1
    |text code|
    "StudentCompiler walkExample1"
    Transcript cr; << 'Compiling '; << text.
    code indexedDo: [:index :object | Transcript cr; << index; << ': '; << object].
    ^StudentCompiler new compile: 'if (a > b) {a = b; c = d;} else {e = f;}'! ! 
#('February 21, 2021' '07:15:01 PM' 1855684)!

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample1 )) !

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample1 )) !


!StudentCompiler methods !   
compile: text
    tree := parser parse: text.
    self walkTree: tree.
    ^code!    ! 
#('February 21, 2021' '07:15:14 PM' 1819788)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('compiling/evaluating/walk' compile: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('compiling/evaluating/walk' compile: )) !


!StudentCompiler methods ! 
walkIf: tree
    |exp then else fixToElse elseStart fixToEnd endStart|
    exp := tree child: 1.
    then := tree  child: 2.
    else := tree  children size <3
        ifTrue: [nil]
        ifFalse: [tree child: 3].
    (else isNil and: [self isExpressionContext]) ifTrue:
    [self error: 'Missing else for if expression'. else := then "make the compiler work"].
    
    self pushExpressionContext.
    self walkTree: exp.
    self popContext.
    fixToElse := self walkInstruction: #branchIfFalse with: nil. 
    self walkTree: then.
    else isNil
        ifTrue:[
            elseStart:= self nextInstruction.
            self fixupBranch: fixToElse with: elseStart]
        ifFalse: [
            fixToEnd := self walkInstruction: #branch with: nil.
            elseStart := self nextInstruction.
            self walkTree: else.
            endStart := self nextInstruction.
            self  fixupBranch: fixToElse with: elseStart.
            self fixupBranch: fixToEnd with: endStart].!   ! 
#('February 21, 2021' '07:20:21 PM' 1856100)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIf: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIf: )) !


   
'
	"StudentCompiler walkExample1"'!

!StudentCompiler class methods !   
walkExample1
    |text code|
    "StudentCompiler walkExample1"
    ^StudentCompiler new compile: 'if (a > b) {a = b; c = d;} else {e = f;}'!    ! 
#('February 21, 2021' '07:20:47 PM' 1858788)!

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample1 )) !

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample1 )) !


!StudentCompiler methods !   
compile: text
    tree := parser parse: text.
    self walkTree: tree.
    ^self code.!  ! 
#('February 21, 2021' '07:22:11 PM' 1859352)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('compiling/evaluating/walk' compile: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('compiling/evaluating/walk' compile: )) !


!StudentCompiler methods ! 
fixupBranch: where with: nextInstruction
    | newOffset |
    newOffset := nextInstruction - where.
    code at: (where + 1) put: newOffset!    ! 
#('February 21, 2021' '07:24:14 PM' 1840656)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' fixupBranch:with: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' fixupBranch:with: )) !


!StudentCompiler methods ! 
walkInstruction: opCode
    code add: opCode. 
    ^code size.!   ! 
#('February 21, 2021' '07:24:50 PM' 1844608)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' walkInstruction: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' walkInstruction: )) !


!StudentCompiler methods !   
walkInstruction: opCode with: operand
    code add: opCode; add: operand.
    ^code size-1.!  ! 
#('February 21, 2021' '07:25:07 PM' 1844960)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' walkInstruction:with: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' walkInstruction:with: )) !


!StudentCompiler class methods !   
walkExample1
    "StudentCompiler walkExample1"
    ^StudentCompiler new compile: 'if (a > b) {a = b; c = d;} else {e = f;}'! ! 
#('February 21, 2021' '07:25:20 PM' 1861088)!

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample1 )) !

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample1 )) !


!StudentCompiler methods !   
walkTree: tree
    self perform: tree label with: tree!    ! 
#('February 21, 2021' '07:26:13 PM' 1840284)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('compiling/evaluating/walk' walkTree: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('compiling/evaluating/walk' walkTree: )) !


!StudentCompiler methods !   
walkTree: tree
    self perform: tree label asSymbol with: tree!   ! 
#('February 21, 2021' '07:26:31 PM' 1863536)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('compiling/evaluating/walk' walkTree: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('compiling/evaluating/walk' walkTree: )) !


!StudentCompiler methods !   
initialize
    code:= OrderedCollection new.
    contextStack:=  OrderedCollection new.
    self pushStatementContext.
    parser := Parser
        for: self
        parserTables: self class rawParserTables
        scannerTables: self class rawScannerTables.!  ! 
#('February 21, 2021' '07:27:17 PM' 1857588)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('initializing' initialize )) !


"evaluate"   
StudentCompiler class removeSelector: #Doit!

"evaluate"
(CodeFiler organizerFor: StudentCompiler class) removeCategory: 'no category methods' ifAbsent: [nil]!


'StudentCompiler walkExample1'!

"evaluate" 
"*** saved image on: February 21, 2021 07:29:50 PM ***"!  
"*** Image started on: February 21, 2021 07:30:03 PM ***"!

"define class"  

Object subclass: #FiniteStateMachine
  instanceVariableNames: 
    ' states '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: FiniteStateMachine to: ''!


"evaluate"   
Object subclass: #FiniteStateMachine
  instanceVariableNames: 
    ' states '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Grammar Constructor' )
  comment: ''!

"define class" 

Object subclass: #FiniteStateMachineState
  instanceVariableNames: 
    ' transitions isInitial isFinal stateNumber cameFromInitial canReachFinal '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: FiniteStateMachineState to: ''!


"evaluate"

Object subclass: #FiniteStateMachineState
  instanceVariableNames: 
    ' transitions isInitial isFinal stateNumber cameFromInitial canReachFinal'
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Grammar Constructor' )
  comment: ''!

"define class"  

Object subclass: #Grammar
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: Grammar to: ''!


"evaluate"   

Object subclass: #Grammar
  instanceVariableNames: 
    '  '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Grammar Constructor' )
  comment: ''!

"evaluate"
(CodeFiler setAndInitializeOrganizerFor: Grammar class to: (MethodBasedOrganizer fromArray: #(('experiment' )))).!

!Grammar class methods !
findUselessStatesOf: fsm
    | canReachFinal canBeReachedFromInitial looping a b |
    canReachFinal := IdentityDictionary new.
    canBeReachedFromInitial := IdentityDictionary new.
    fsm states do: [:state |
        canReachFinal at: state put: state isFinal.
        canBeReachedFromInitial at: state put: state isInitial].
        
    looping := true.
    [looping] whileTrue: [
        looping := false.
        fsm states do: [:state |
            a := state.
            state transitions do: [:aTransition |
                b := aTransition goto.
                aTransition hasAttributes ifTrue: [
                    ((canBeReachedFromInitial at: a) and: [(canBeReachedFromInitial at: b) not]) ifTrue: [
                        canBeReachedFromInitial at: b at: true. looping := true].
                    ((canReachFinal at: b) and: [(canReachFinal at: a) not]) ifTrue: [
                        canReachFinal at: a at: true. looping := true]]]]].!   ! 
#('February 21, 2021' '07:44:15 PM' nil)!

(CodeFiler organizerFor: Grammar class) reorganizeFrom: #(
('experiment' findUselessStatesOf: )) !



'StudentCompiler walkExample2'!

   
'StudentCompiler walkExample2'!

!StudentCompiler methods ! 
walkFor: tree
    |initialExpression booleanExpression incrementExpression body whileStart fixAtEnd end |
    
    self isExpressionContext ifTrue:
    [self designError: 'Can''t use for loop as expression'.    ^self].
    
    initialExpression := tree child: 1.
    booleanExpression := tree child: 2.
    incrementExpression := tree child: 3.
    body := tree child: 4.
    
    "self beginScope."
    self walkTree: initialExpression.
    self pushExpressionContext "For branchIfFalse to work".
        whileStart  := self nextInstruction.
        self walkTree: booleanExpression.
        
    self popContext.
    
    fixAtEnd:= self nextInstruction.
    self walkInstruction:  #branchIfFalse with: nil. 
    self walkTree: body.
    self walkTree: incrementExpression.
    self walkBranch: #branch backTo: whileStart.
    end:=self nextInstruction.
    self fixupBranch: fixAtEnd with: end.
"end endScope."!   ! 
#('February 21, 2021' '07:50:51 PM' 1853472)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFor: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFor: )) !


 
'StudentCompiler walkExample2'!

   
'StudentCompiler walkExample1'!

"evaluate" 
"*** saved image on: February 21, 2021 07:54:11 PM ***"!  
"*** Image started on: February 21, 2021 07:55:39 PM ***"!

"define class"  

Object subclass: #Transition
  instanceVariableNames: 
    ' transitionName goto '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: Transition to: ''!


"evaluate"  

Object subclass: #Transition
  instanceVariableNames: 
  'transitionName goto'
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Grammar Constructor' )
  comment: ''!

"define class"  

Object subclass: #TransitionName
  instanceVariableNames: 
    ' symbolOrPair attributes action parameters isRootBuilding '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: TransitionName to: ''!


"evaluate" 

Object subclass: #TransitionName
  instanceVariableNames: 
    ' symbolOrPair attributes action parameters isRootBuilding'
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Grammar Constructor' )
  comment: ''!


!FiniteStateMachine methods ! 
initialize

    self
        states: OrderedCollection new!  !

"evaluate"   
(CodeFiler organizerFor: FiniteStateMachine) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('initializing' initialize )) !



!FiniteStateMachine class methods !  
new

    ^super new initialize!   !

"evaluate"   
(CodeFiler organizerFor: FiniteStateMachine class) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('instance creation' new )) !



!FiniteStateMachine methods !  
states
    ^states!    !

!FiniteStateMachine methods !
states: anOrderedCollection
    states := anOrderedCollection! !
(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('get/set' states: states )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('get/set' states: states )) !


!FiniteStateMachine methods !  
override: attributes
| attrs |

attributes do: [:symbol | 
    self states do: [:state | 
        state transitions do: [:transition |
            transition override: symbol.
        ].
    ].
].
^ self.! ! 
#('February 21, 2021' '08:22:00 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('initializing' override: )) !


!FiniteStateMachine methods !   
questionMark
    ^ self class for or: self.!   ! 
#('February 21, 2021' '08:22:18 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('initializing' questionMark )) !


"evaluate"   
(CodeFiler organizerFor: 'FiniteStateMachine')  addCategory: 'Query' before: nil!

!FiniteStateMachine methods !
recognizesE
    states do: [:state | (state isInitial and: [state isFinal]) ifTrue: [^true]].
    ^false.!    ! 
#('February 21, 2021' '08:22:45 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('Query' recognizesE )) !


"evaluate"   
(CodeFiler organizerFor: 'FiniteStateMachine')  addCategory: 'fsmMethods' before: nil!

"evaluate"  
(CodeFiler setAndInitializeOrganizerFor: FiniteStateMachine to: (MethodBasedOrganizer fromArray: #(('initializing' initialize override: questionMark)
('get/set' states states:)
('queryMethods' recognizesE)
('fsmMethods' )))).!

!FiniteStateMachine methods !
allFinal
    ^states select: [:x | x isFinal].!    ! 
#('February 21, 2021' '08:23:50 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' allFinal )) !


!FiniteStateMachine methods !  
allInitial
    ^states select: [:x | x isInitial].!    ! 
#('February 21, 2021' '08:23:59 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' allInitial )) !


!FiniteStateMachine methods !
allInitialStateTransitionSymbol

    | symbols |
    
    symbols := OrderedCollection new.
    
    self states do: [:state |
        (state isInitial) ifTrue: [
            state transitions do: [:transition | 
                symbols add: transition name symbol.
            ].
        ].
    ].

    ^ symbols!    ! 
#('February 21, 2021' '08:24:06 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' allInitialStateTransitionSymbol )) !


!FiniteStateMachine methods !   
and: fsm2
    | dualFSM |
    dualFSM := FiniteStateMachine new states: (self parallelBuild: fsm2).
    
    dualFSM states do: [:state | 
        state isFinal: (state stateSet1HasFinal and: [state stateSet2HasFinal])
    ].
    
    ^dualFSM reduce.!    ! 
#('February 21, 2021' '08:24:13 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' and: )) !


!FiniteStateMachine methods !  
concat: fsm2
    | fsm1RecE fsm2RecE fsm1Final fsm2Initial |
    fsm1Final := self allFinal.
    fsm2Initial := fsm2 allInitial.
    fsm1RecE := self recognizesE.
    fsm2RecE := fsm2 recognizesE.
    
    fsm1Final do: [:state | 
        state transitions addAllIfAbsent: (fsm2 initialTransitions).
    ].
    
    fsm2RecE ifFalse: [ fsm1Final do: [:state | state isFinal: false] ].
    fsm1RecE ifFalse: [ fsm2Initial do: [:state | state isInitial: false] ].

    self states addAll: fsm2 states.

    ^ self reduce.!    ! 
#('February 21, 2021' '08:24:20 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' concat: )) !


!FiniteStateMachine methods !   
convert: x
    self halt: 'doesnt match character 0'.
    ^x isDigit ifTrue: [x digitValue] ifFalse: [x asCharacter]! ! 
#('February 21, 2021' '08:24:27 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' convert: )) !


!FiniteStateMachine methods !  
copy
    | fsm stateMap |
    fsm := FiniteStateMachine new.
    stateMap := Dictionary new.
    "TODO: make states first, then copy the transitions
    deepCopy
    "    
    states do: [:state | 
    
        fsm states add: (FiniteStateMachineState new 
            isInitial: state isInitial;
            isFinal: state isFinal
        ).
        
        stateMap at: state put: fsm states last.    
    ].
    
    states do: [:state |
        state transitions do: [:trans | 
            (stateMap at: state) transitions add: (Transition new name: trans name deepCopy; goto: (stateMap at: trans goto)).
        ].
    ].
    
    ^ fsm renumber.!    ! 
#('February 21, 2021' '08:24:48 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' copy )) !


!FiniteStateMachine methods !  
initialTransitions
    ^ (states collect: [:x | x transitions] when: [:x | x isInitial]) flattened.!   ! 
#('February 21, 2021' '08:24:54 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' initialTransitions )) !


!FiniteStateMachine methods !
minus: fsm2
    | fsm dualStates |
    dualStates := self parallelBuild: fsm2.

    dualStates do: [:state | 
        state isFinal: (state stateSet1HasFinal and: [state stateSet2HasFinal not])
    ].
    
    fsm := FiniteStateMachine new states: dualStates.

    fsm := fsm reduce.
    ^fsm.!   ! 
#('February 21, 2021' '08:25:03 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' minus: )) !


!FiniteStateMachine methods !
or: fsm2
    states addAll: fsm2 states.
    ^ self reduce.!  ! 
#('February 21, 2021' '08:25:09 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' or: )) !



'
	^ self.'!

!FiniteStateMachine methods ! 
plus
    self allFinal do: [:state | state transitions addAllIfAbsent: self initialTransitions].
    ^ self.! ! 
#('February 21, 2021' '08:25:19 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' plus )) !


"define class" 

Object subclass: #FiniteStateMachine
  instanceVariableNames: 
    ' states '
  classVariableNames: ''
  poolDictionaries: ''!


!FiniteStateMachine class methods ! 
or: fsms
    | fsm |
    fsm := fsms first.
    fsms rest do: [:cfsm | 
        fsm or: cfsm.
    ].
    ^ fsm renumber.! !

!FiniteStateMachine class methods !  
minus: fsms
    | fsm |
    fsm := fsms first.
    fsms rest do: [:x |
        fsm := fsm minus: x.
    ].
    
    ^fsm renumber.!  !

!FiniteStateMachine class methods !  
concat: fsms
    | fsm |
    fsm := fsms first.
    fsms rest do: [:cfsm | 
        fsm concat: cfsm.
    ].
    ^ fsm renumber.! !
(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('ops' or: minus: concat: )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('ops' or: minus: concat: )) !



!FiniteStateMachine class methods !  
allInitialStateTransitionSymbol

    

    ^ nil!   !
(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('get/set' allInitialStateTransitionSymbol )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('get/set' allInitialStateTransitionSymbol )) !



!FiniteStateMachine class methods !
fromScannerCollection: aCollection attributes: attributes
    | fsm s1 s2 transition |
    fsm := FiniteStateMachine new.
    
    s1 := FiniteStateMachineState new.
    s1 isInitial: true.
    
    s2 := FiniteStateMachineState new.
    s2 isFinal: true.
    
    aCollection do: [:x | 
        transition := Transition new.
        transition goto: s2.
        transition name: (TransitionName new symbol: x; attributes: attributes).
        s1 transitions add: transition.
    ].
    fsm states add: s1.
    fsm states add: s2.

    ^ fsm renumber.! !

!FiniteStateMachine class methods !  
forE
    | fsm state1 |
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true; number: 1.
    fsm states add: state1.
    ^fsm.! !

!FiniteStateMachine class methods !  
fromParserTransitionSymbol: symbol
    | fsm s1 s2 transition |
    fsm := FiniteStateMachine new.
    
    s1 := FiniteStateMachineState new.
    s1 isInitial: true.
    
    s2 := FiniteStateMachineState new.
    s2 isFinal: true.
    
    transition := Transition new.
    transition goto: s2.
    transition name: symbol.
    s1 transitions add: transition.
    
    fsm states add: s1.
    fsm states add: s2.
    
    ^ fsm renumber.!  !

!FiniteStateMachine class methods !  
new

    ^super new initialize!   !

!FiniteStateMachine class methods !  
forIdentifier: aSymbol attributes: attributes
    | fsm transitions state1 state2 transition1 |
    fsm := FiniteStateMachine new.
    
    state1 := FiniteStateMachineState new isInitial: true; number: 1.
    state2 := FiniteStateMachineState new isFinal: true; number: 2.
    
    state1 transitions add: (Transition new goto: state2; name: (TransitionName new symbol: aSymbol; attributes: attributes )).
    
    fsm states add: state1; add: state2.
    ^fsm.!   !
(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('instance creation' new forE fromParserTransitionSymbol: forIdentifier:attributes: fromScannerCollection:attributes: )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('instance creation' new forE fromParserTransitionSymbol: forIdentifier:attributes: fromScannerCollection:attributes: )) !



!FiniteStateMachine methods !
override: attributes
| attrs |

attributes do: [:symbol | 
    self states do: [:state | 
        state transitions do: [:transition |
            transition override: symbol.
        ].
    ].
].
^ self.! !

!FiniteStateMachine methods !
questionMark
    ^ self class forE or: self.!  !

!FiniteStateMachine methods !
initialize

    self
        states: OrderedCollection new!  !
(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('initializing' override: questionMark initialize )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('initializing' override: questionMark initialize )) !



!FiniteStateMachine methods !
recognizesE
    states do: [:state | (state isInitial and: [state isFinal]) ifTrue: [^true]].
    ^false.!    !
(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('query' recognizesE )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('query' recognizesE )) !



!FiniteStateMachine methods !  
allFinal
    ^states select: [:x | x isFinal].!    !

!FiniteStateMachine methods !
and: fsm2
    | dualFSM |
    dualFSM := FiniteStateMachine new states: (self parallelBuild: fsm2).
    
    dualFSM states do: [:state | 
        state isFinal: (state stateSet1HasFinal and: [state stateSet2HasFinal])
    ].
    
    ^dualFSM reduce.!    !

!FiniteStateMachine methods !
convert: x
    self halt: 'doesnt match character 0'.
    ^x isDigit ifTrue: [x digitValue] ifFalse: [x asCharacter]! !

!FiniteStateMachine methods !
renumber
    states indexedDo: [:index :state | state number: index].! !

!FiniteStateMachine methods !
allInitial
    ^states select: [:x | x isInitial].!    !

!FiniteStateMachine methods !
star
    ^ (FiniteStateMachine forE or: self plus) renumber.!  !

!FiniteStateMachine methods !
reduce
    | cameFromInitial canReachFinal changed |
    self renumber.
    
    cameFromInitial := IdentityDictionary new.
    canReachFinal := IdentityDictionary new.
    
    self states do: [:state |
        cameFromInitial at: state put: state isInitial.
        canReachFinal at: state put: state isFinal.
    ].
    
    changed := true.
    [ changed ] whileTrue: [
        changed := false.
        self states do: [:state |
            state transitions do: [:transition |
                (cameFromInitial at: state) ifTrue: [
                    (cameFromInitial at: transition goto) ifFalse: [
                        changed := true.
                    ].
                    cameFromInitial at: transition goto put: true.
                ].
                
                (canReachFinal at: transition goto) ifTrue: [
                    (canReachFinal at: state) ifFalse: [
                        changed := true.
                    ].
                    canReachFinal at: state put: true.
                ].
            ].
        ].
    ].
    
    self states: (self states select: [:state |
        (cameFromInitial at: state) and: [canReachFinal at: state].
    ]).
    self states do: [:state |
        state transitions: (state transitions select: [:transition |
            states includesIdentical: transition goto.
        ]).
    ].
    
    
    ^self renumber!  !

!FiniteStateMachine methods !
initialTransitions
    ^ (states collect: [:x | x transitions] when: [:x | x isInitial]) flattened.!   !

!FiniteStateMachine methods !
minus: fsm2
    | fsm dualStates |
    dualStates := self parallelBuild: fsm2.

    dualStates do: [:state | 
        state isFinal: (state stateSet1HasFinal and: [state stateSet2HasFinal not])
    ].
    
    fsm := FiniteStateMachine new states: dualStates.

    fsm := fsm reduce.
    ^fsm.!   !

!FiniteStateMachine methods !
concat: fsm2
    | fsm1RecE fsm2RecE fsm1Final fsm2Initial |
    fsm1Final := self allFinal.
    fsm2Initial := fsm2 allInitial.
    fsm1RecE := self recognizesE.
    fsm2RecE := fsm2 recognizesE.
    
    fsm1Final do: [:state | 
        state transitions addAllIfAbsent: (fsm2 initialTransitions).
    ].
    
    fsm2RecE ifFalse: [ fsm1Final do: [:state | state isFinal: false] ].
    fsm1RecE ifFalse: [ fsm2Initial do: [:state | state isInitial: false] ].

    self states addAll: fsm2 states.

    ^ self reduce.!    !

!FiniteStateMachine methods !
copy
    | fsm stateMap |
    fsm := FiniteStateMachine new.
    stateMap := Dictionary new.
    "TODO: make states first, then copy the transitions
    deepCopy
    "    
    states do: [:state | 
    
        fsm states add: (FiniteStateMachineState new 
            isInitial: state isInitial;
            isFinal: state isFinal
        ).
        
        stateMap at: state put: fsm states last.    
    ].
    
    states do: [:state |
        state transitions do: [:trans | 
            (stateMap at: state) transitions add: (Transition new name: trans name deepCopy; goto: (stateMap at: trans goto)).
        ].
    ].
    
    ^ fsm renumber.!    !

!FiniteStateMachine methods !
allInitialStateTransitionSymbol

    | symbols |
    
    symbols := OrderedCollection new.
    
    self states do: [:state |
        (state isInitial) ifTrue: [
            state transitions do: [:transition | 
                symbols add: transition name symbol.
            ].
        ].
    ].

    ^ symbols!    !

!FiniteStateMachine methods !
or: fsm2
    states addAll: fsm2 states.
    ^ self reduce.!  !

!FiniteStateMachine methods !
plus
    self allFinal do: [:state | state transitions addAllIfAbsent: self initialTransitions].
    ^ self.! !
(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('ops' allFinal and: convert: renumber allInitial star reduce initialTransitions minus: concat: allInitialStateTransitionSymbol copy or: plus )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('ops' allFinal and: convert: renumber allInitial star reduce initialTransitions minus: concat: allInitialStateTransitionSymbol copy or: plus )) !



!FiniteStateMachine methods !
states: aCollection
    states := aCollection! !

!FiniteStateMachine methods !
states
    ^states!    !
(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('get/set' states: states )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('get/set' states: states )) !



!FiniteStateMachine methods !
printOn: aStream
    self printOn: aStream tabs: 0.!   !

!FiniteStateMachine methods !
printOn: aStream tabs: tabs
    tabs timesRepeat: [aStream << '   ']. aStream << 'FSM'.
        states do: [:state | state printOn: aStream tabs: tabs + 1].
    aStream cr. tabs timesRepeat: [aStream << '   ']. aStream << 'END'.!    !
(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('printing' printOn: printOn:tabs: )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('printing' printOn: printOn:tabs: )) !
CodeFiler setCommentFor: FiniteStateMachine to: ''!


"define class"  

FiniteStateMachineState subclass: #DualSetContainingState
  instanceVariableNames: 
    ' stateSet1 stateSet2 '
  classVariableNames: ''
  poolDictionaries: ''!


"evaluate"
(CodeFiler organizerFor: DualSetContainingState class) removeCategory: 'no category methods' ifAbsent: [nil]!


!DualSetContainingState methods !  
getSuccessor: transitionName
    | successor s1 s2 |
    
    s1 := OrderedCollection new.
    s2 := OrderedCollection new.
    
    stateSet1 do: [:state | state transitions do: [:tran | tran name = transitionName ifTrue: [
        s1 addIfAbsent: tran goto.
    ]]].
    
    stateSet2 do: [:state | state transitions do: [:tran | tran name = transitionName ifTrue: [
        s2 addIfAbsent: tran goto.
    ]]].
    
    successor := DualSetContainingState new stateSet1: s1; stateSet2: s2.
    ^successor.!    !

!DualSetContainingState methods !
transitionNames
    | names |
    names := OrderedCollection new.
    self stateSet1 do: [:state | state transitions do: [:tran | names addIfAbsent: tran name]].
    self stateSet2 do: [:state | state transitions do: [:tran | names addIfAbsent: tran name]].
    ^names.! !

!DualSetContainingState methods !
transitionSymbols
    | symbols |
    symbols := OrderedCollection new.
    stateSet1 do: [:state | state transitions do: [:tran | symbols add: tran name symbol]].
    stateSet2 do: [:state | state transitions do: [:tran | symbols add: tran name symbol]].
    ^symbols.! !

!DualSetContainingState methods !
stateSet2: aCollection
    stateSet2 := aCollection!   !

!DualSetContainingState methods !
stateSet1: aCollection
    stateSet1 := aCollection!   !

!DualSetContainingState methods !
stateSet1
    ^stateSet1!  !

!DualSetContainingState methods !
stateSet2
    ^stateSet2!  !

"evaluate"   
(CodeFiler organizerFor: DualSetContainingState) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: DualSetContainingState) reorganizeFrom: #(
('get/set' getSuccessor: transitionNames transitionSymbols stateSet2: stateSet1: stateSet1 stateSet2 )) !

(CodeFiler organizerFor: DualSetContainingState) reorganizeFrom: #(
('get/set' getSuccessor: transitionNames transitionSymbols stateSet2: stateSet1: stateSet1 stateSet2 )) !



!DualSetContainingState methods !
initialize

    super initialize.
    self stateSet1: OrderedCollection new.
    self stateSet2: OrderedCollection new.!    !
(CodeFiler organizerFor: DualSetContainingState) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: DualSetContainingState) reorganizeFrom: #(
('initializing' initialize )) !



!DualSetContainingState methods !  
= anObject
    (self class == anObject class) ifFalse: [ ^false ].
    
    (self stateSet1 includesAllIdentical: anObject stateSet1) ifFalse: [ ^false ].
    (anObject stateSet1 includesAllIdentical: self stateSet1) ifFalse: [ ^false ].
    (self stateSet2 includesAllIdentical: anObject stateSet2) ifFalse: [ ^false ].
    (anObject stateSet2 includesAllIdentical: self stateSet2) ifFalse: [ ^false ].
    
    ^true.!    !

!DualSetContainingState methods !
stateSet2HasFinal
    stateSet2 do: [:state | state isFinal ifTrue: [^true]].
    ^false.!    !

!DualSetContainingState methods !
stateSet1HasFinal
    stateSet1 do: [:state | state isFinal ifTrue: [^true]].
    ^false.!    !
(CodeFiler organizerFor: DualSetContainingState) reorganizeFrom: #(
('ops' = stateSet2HasFinal stateSet1HasFinal )) !

(CodeFiler organizerFor: DualSetContainingState) reorganizeFrom: #(
('ops' = stateSet2HasFinal stateSet1HasFinal )) !

CodeFiler setCommentFor: DualSetContainingState to: ''!


"define class"

Object subclass: #FiniteStateMachineState
  instanceVariableNames: 
    ' transitions isInitial isFinal number '
  classVariableNames: ''
  poolDictionaries: ''!

"define class" 

FiniteStateMachineState subclass: #DualSetContainingState
  instanceVariableNames: 
    ' stateSet1 stateSet2 '
  classVariableNames: ''
  poolDictionaries: ''!


!FiniteStateMachineState class methods !  
new

    ^super new initialize!   !

"evaluate"   
(CodeFiler organizerFor: FiniteStateMachineState class) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: FiniteStateMachineState class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: FiniteStateMachineState class) reorganizeFrom: #(
('instance creation' new )) !



!FiniteStateMachineState methods !  
initialize

    self
        isFinal: false;
        isInitial: false;
        number: nil;
        transitions: OrderedCollection new!   !

"evaluate"   
(CodeFiler organizerFor: FiniteStateMachineState) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('initializing' initialize )) !



!FiniteStateMachineState methods !
number: aNumber
    number := aNumber! !

!FiniteStateMachineState methods !   
number
    ^number!    !

!FiniteStateMachineState methods !   
transitions
    ^transitions!  !

!FiniteStateMachineState methods !   
transitions: aCollection
    transitions := aCollection!   !

!FiniteStateMachineState methods !   
isFinal: aBoolean
    isFinal := aBoolean! !

!FiniteStateMachineState methods !   
isFinal
    ^isFinal!  !

!FiniteStateMachineState methods !   
isInitial: aBoolean
    isInitial := aBoolean! !

!FiniteStateMachineState methods !   
isInitial
    ^isInitial!  !
(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('get/set' number: number transitions transitions: isFinal: isFinal isInitial: isInitial )) !

(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('get/set' number: number transitions transitions: isFinal: isFinal isInitial: isInitial )) !



!FiniteStateMachineState methods !   
printOn: aStream
    self printOn: aStream tabs: 0.!   !

!FiniteStateMachineState methods !   
printOn: aStream tabs: tabs
    aStream cr. tabs timesRepeat: [aStream << '   '].
    aStream << 'State '; << number; << ';'.
    aStream << (isInitial ifTrue: [' initial;'] ifFalse: ['']).
    aStream << (isFinal ifTrue: [' final;'] ifFalse: ['']).

    transitions do: [:transition | transition printOn: aStream tabs: tabs + 1].!   !
(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('printing' printOn: printOn:tabs: )) !

(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('printing' printOn: printOn:tabs: )) !
CodeFiler setCommentFor: FiniteStateMachineState to: ''!




!DualSetContainingState methods !
getSuccessor: transitionName
    | successor s1 s2 |
    
    s1 := OrderedCollection new.
    s2 := OrderedCollection new.
    
    stateSet1 do: [:state | state transitions do: [:tran | tran name = transitionName ifTrue: [
        s1 addIfAbsent: tran goto.
    ]]].
    
    stateSet2 do: [:state | state transitions do: [:tran | tran name = transitionName ifTrue: [
        s2 addIfAbsent: tran goto.
    ]]].
    
    successor := DualSetContainingState new stateSet1: s1; stateSet2: s2.
    ^successor.!    !

!DualSetContainingState methods !
transitionNames
    | names |
    names := OrderedCollection new.
    self stateSet1 do: [:state | state transitions do: [:tran | names addIfAbsent: tran name]].
    self stateSet2 do: [:state | state transitions do: [:tran | names addIfAbsent: tran name]].
    ^names.! !

!DualSetContainingState methods !
transitionSymbols
    | symbols |
    symbols := OrderedCollection new.
    stateSet1 do: [:state | state transitions do: [:tran | symbols add: tran name symbol]].
    stateSet2 do: [:state | state transitions do: [:tran | symbols add: tran name symbol]].
    ^symbols.! !

!DualSetContainingState methods !
stateSet2: aCollection
    stateSet2 := aCollection!   !

!DualSetContainingState methods !
stateSet1: aCollection
    stateSet1 := aCollection!   !

!DualSetContainingState methods !
stateSet1
    ^stateSet1!  !

!DualSetContainingState methods !
stateSet2
    ^stateSet2!  !
(CodeFiler organizerFor: DualSetContainingState) reorganizeFrom: #(
('get/set' getSuccessor: transitionNames transitionSymbols stateSet2: stateSet1: stateSet1 stateSet2 )) !

(CodeFiler organizerFor: DualSetContainingState) reorganizeFrom: #(
('get/set' getSuccessor: transitionNames transitionSymbols stateSet2: stateSet1: stateSet1 stateSet2 )) !



!DualSetContainingState methods !  
initialize

    super initialize.
    self stateSet1: OrderedCollection new.
    self stateSet2: OrderedCollection new.!    !
(CodeFiler organizerFor: DualSetContainingState) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: DualSetContainingState) reorganizeFrom: #(
('initializing' initialize )) !



!DualSetContainingState methods !  
= anObject
    (self class == anObject class) ifFalse: [ ^false ].
    
    (self stateSet1 includesAllIdentical: anObject stateSet1) ifFalse: [ ^false ].
    (anObject stateSet1 includesAllIdentical: self stateSet1) ifFalse: [ ^false ].
    (self stateSet2 includesAllIdentical: anObject stateSet2) ifFalse: [ ^false ].
    (anObject stateSet2 includesAllIdentical: self stateSet2) ifFalse: [ ^false ].
    
    ^true.!    !

!DualSetContainingState methods !
stateSet2HasFinal
    stateSet2 do: [:state | state isFinal ifTrue: [^true]].
    ^false.!    !

!DualSetContainingState methods !
stateSet1HasFinal
    stateSet1 do: [:state | state isFinal ifTrue: [^true]].
    ^false.!    !
(CodeFiler organizerFor: DualSetContainingState) reorganizeFrom: #(
('ops' = stateSet2HasFinal stateSet1HasFinal )) !

(CodeFiler organizerFor: DualSetContainingState) reorganizeFrom: #(
('ops' = stateSet2HasFinal stateSet1HasFinal )) !



!DualSetContainingState methods !  
printOn: aStream tabs: tabs
    aStream cr. tabs timesRepeat: [aStream << '   ']. aStream << 'DualState '; << number; << '; '.
    isInitial ifTrue: [aStream << 'initial; '].
    isFinal ifTrue: [aStream << 'final; '].
    aStream cr. tabs timesRepeat: [aStream << '   ']. aStream << '('.
    stateSet1 do: [ :state |
        aStream << state number. 
        (state = stateSet1 last) ifFalse: [aStream << ', ']
    ].
    aStream << ') ('.
    stateSet2 do: [ :state |
        aStream << state number. 
        (state = stateSet2 last) ifFalse: [aStream << ', ']
    ].
    aStream << ') '.
    transitions do: [:transition | transition printOn: aStream tabs: tabs + 1]!  !
(CodeFiler organizerFor: DualSetContainingState) reorganizeFrom: #(
('printing' printOn:tabs: )) !

(CodeFiler organizerFor: DualSetContainingState) reorganizeFrom: #(
('printing' printOn:tabs: )) !
CodeFiler setCommentFor: DualSetContainingState to: ''!


"define class"

FiniteStateMachineState subclass: #DualSetContainingState
  instanceVariableNames: 
    ' stateSet1 stateSet2 '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: DualSetContainingState to: ''!


"evaluate" 

FiniteStateMachineState subclass: #DualSetContainingState
  instanceVariableNames: 
    ' stateSet1 stateSet2 '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Grammar Constructor' )
  comment: ''!

"define class" 

Object subclass: #FiniteStateMachineState
  instanceVariableNames: 
    ' transitions isInitial isFinal number '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: FiniteStateMachineState to: ''!


"evaluate"   

Object subclass: #FiniteStateMachineState
  instanceVariableNames: 
    ' transitions isInitial isFinal number '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Grammar Constructor' )
  comment: ''!

"define class"

Object subclass: #FiniteStateMachine
  instanceVariableNames: 
    ' states '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: FiniteStateMachine to: ''!


"evaluate"   

Object subclass: #FiniteStateMachine
  instanceVariableNames: 
    ' states '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Grammar Constructor' )
  comment: ''!

"define class"   

Object subclass: #TransitionName
  instanceVariableNames: 
    ' symbol attributes action parameters isRootBuilding name state '
  classVariableNames: ''
  poolDictionaries: ''!


!TransitionName methods !
symbol: aSymbol
    symbol := aSymbol! !

!TransitionName methods !
isRootBuilding
    ^isRootBuilding!    !

!TransitionName methods !
action: aSymbol
    action := aSymbol! !

!TransitionName methods !
name: aSymbol
    name := aSymbol! !

!TransitionName methods !
name
    ^name!    !

!TransitionName methods !
symbol
    ^symbol!    !

!TransitionName methods !
parameters: aCollection
    parameters := aCollection! !

!TransitionName methods !
attributes
    ^attributes!    !

!TransitionName methods !
parameters
    ^parameters!    !

!TransitionName methods !
action
    ^action!    !

!TransitionName methods !
state
    ^state!  !

!TransitionName methods !
hasAction

^ action notNil.!  !

!TransitionName methods !
hasParameters

^ parameters notNil.!  !

!TransitionName methods !
hasAttributes

    ^ attributes notNil.!  !

!TransitionName methods !
isRootBuilding: aBoolean
    isRootBuilding := aBoolean!   !

!TransitionName methods !
= anObject
    self class == anObject class ifFalse: [^false].
    self symbol = anObject symbol ifFalse: [^false].
    self attributes = anObject attributes ifFalse: [^false].
    self action = anObject action ifFalse: [^false].
    self parameters = anObject parameters ifFalse: [^false].
    self isRootBuilding = anObject isRootBuilding ifFalse: [^false].
    self name = anObject name ifFalse: [^false].
    self state = anObject state ifFalse: [^false].
    
    ^true.!  !

!TransitionName methods !
attributes: aString
    attributes := aString! !

!TransitionName methods !
state: aState
    state := aState! !

!TransitionName methods !
isSemanticAction

    ^ action notNil or: [parameters notNil or: [isRootBuilding notNil]]!    !

"evaluate"   
(CodeFiler organizerFor: TransitionName) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' symbol: isRootBuilding action: name: name symbol parameters: hasParameters parameters action attributes hasAction state hasAttributes isRootBuilding: = attributes: state: isSemanticAction )) !

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' symbol: isRootBuilding action: name: name symbol parameters: hasParameters parameters action attributes hasAction state hasAttributes isRootBuilding: = attributes: state: isSemanticAction )) !



!TransitionName methods !
printOn: aStream
    (self hasParameters) ifTrue: [
        aStream << action storeString.
        isRootBuilding ifTrue: [ aStream << ' isRootBuilding;' ].
        aStream << ' parameters: '; << (parameters asArray) printString.
        ^self.
    ].

    (self hasAttributes) ifTrue: [
        symbol isCharacter ifTrue: [ "#b is not a character but i still want to print as #b"
        (symbol between: 33 and: 126)
            ifTrue: [ aStream << symbol storeString ]
            ifFalse: [ aStream << symbol asInteger ].
        ]
        ifFalse: [ aStream << symbol ].
        aStream << ' attributes: '; << self attributes storeString.
        ^self.
    ].!    !
(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('printing' printOn: )) !

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('printing' printOn: )) !
CodeFiler setCommentFor: TransitionName to: ''!


"define class"  

Object subclass: #Transition
  instanceVariableNames: 
    ' name goto '
  classVariableNames: ''
  poolDictionaries: ''!


"evaluate"   
(CodeFiler organizerFor: Transition class) removeCategory: 'no category methods' ifAbsent: [nil]!


!Transition methods !  
hasAttributes
    ^ name hasAttributes.!   !

"evaluate"   
(CodeFiler organizerFor: Transition) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('query' hasAttributes )) !

(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('query' hasAttributes )) !



!Transition methods !
name
    ^name!    !

!Transition methods !
attributes: newAttributes
    self name attributes: newAttributes.!    !

!Transition methods !
goto
    ^goto!    !

!Transition methods !
attributes
    ^ self name attributes.!    !

!Transition methods !
goto: aFiniteStateMachineState
    goto := aFiniteStateMachineState!   !

!Transition methods !
name: aTransitionName
    name := aTransitionName! !
(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('get/set' name attributes: goto attributes goto: name: )) !

(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('get/set' name attributes: goto attributes goto: name: )) !



!Transition methods !
override: attribute
   | finalAttributes |
   
    attribute = #treeBuilding ifTrue: [
        ^self isRootBuilding: true
    ].
    
    attribute = #notTreeBuilding ifTrue: [
        ^self isRootBuilding: false
    ].
    
    finalAttributes := ''.
    (attribute = #look) ifTrue: [
        finalAttributes := 'L', self attributes without: $R
    ].
    (attribute = #read) ifTrue: [
        finalAttributes := 'R', self attributes without: $L
    ].
    (attribute = #stack) ifTrue: [
        finalAttributes := 'S', self attributes
    ].
    (attribute = #noStack) ifTrue: [
        finalAttributes := self attributes without: $S
    ].
    (attribute = #node) ifTrue: [
        finalAttributes := 'N', self attributes
    ].
    (attribute = #noNode) ifTrue: [
        finalAttributes := self attributes without: $N
    ].
    (attribute = #keep) ifTrue: [
        finalAttributes := 'K', self attributes
    ].
    (attribute = #noKeep) ifTrue: [
        finalAttributes := self attributes without: $K
    ].

    
    self attributes: ''.
    (finalAttributes includes: $L) ifTrue: [self attributes: self attributes, 'L'].
    (finalAttributes includes: $R) ifTrue: [self attributes: self attributes, 'R'].
    (finalAttributes includes: $N) ifTrue: [self attributes: self attributes, 'N'].
    (finalAttributes includes: $S) ifTrue: [self attributes: self attributes, 'S'].
    (finalAttributes includes: $K) ifTrue: [self attributes: self attributes, 'K'].! !

!Transition methods !
= anObject

    self class == anObject class ifFalse: [^false].
    self name = anObject name ifFalse: [^false].
    
    ^ self goto == anObject goto!    !
(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('ops' override: = )) !

(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('ops' override: = )) !



!Transition methods !  
printOn: aStream
    self printOn: aStream tabs: 0.!   !

!Transition methods !
printOn: aStream tabs: tabs
    aStream cr. tabs timesRepeat: [aStream << '   ']. aStream << 'for: '; << name.
    aStream << ' goto: '; << goto number; << ';'.! !
(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('printing' printOn: printOn:tabs: )) !

(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('printing' printOn: printOn:tabs: )) !
CodeFiler setCommentFor: Transition to: ''!


"define class"  

Object subclass: #TransitionName
  instanceVariableNames: 
    ' symbol attributes action parameters isRootBuilding name state '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: TransitionName to: ''!


"evaluate"

Object subclass: #TransitionName
  instanceVariableNames: 
    ' symbol attributes action parameters isRootBuilding name state '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Grammar Constructor' )
  comment: ''!

"define class"

Object subclass: #Transition
  instanceVariableNames: 
    ' name goto '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: Transition to: ''!


"evaluate"

Object subclass: #Transition
  instanceVariableNames: 
    ' name goto '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Grammar Constructor' )
  comment: ''!

"evaluate"
(CodeFiler setAndInitializeOrganizerFor: FiniteStateMachine to: (MethodBasedOrganizer fromArray: #(('initializing' initialize override: questionMark)
('get/set' states states:)
('query' recognizesE)
('ops' allFinal allInitial allInitialStateTransitionSymbol and: concat: convert: copy initialTransitions minus: or: plus reduce renumber star)
('printing' printOn: printOn:tabs:)))).!

"evaluate"  
"*** saved image on: February 21, 2021 08:32:02 PM ***"!  
"*** Image started on: February 21, 2021 11:15:50 PM ***"!

"evaluate"  
DualSetContainingState removeFromSystem!

"evaluate"
CodeFiler removeOrganizerFor: #DualSetContainingState!

"evaluate"  
CodeFiler removeOrganizerFor: #'DualSetContainingState class'!

"evaluate"  
"*** saved image on: February 21, 2021 11:17:51 PM ***"!  
"*** Image started on: February 21, 2021 11:17:58 PM ***"!
"*** Image started on: February 21, 2021 11:25:21 PM ***"!

"evaluate"  
"*** saved image on: February 21, 2021 11:25:28 PM ***"!

"evaluate"
"*** saved image on: February 21, 2021 11:25:35 PM ***"!  
"*** Image started on: February 21, 2021 11:25:38 PM ***"!

"define class"  

Object subclass: #FiniteStateMachineState
  instanceVariableNames: 
    ' stateNumber isInitial isFinal transitions '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: FiniteStateMachineState to: ''!


"evaluate"  

Object subclass: #FiniteStateMachineState
  instanceVariableNames: 
    ' stateNumber isInitial isFinal  transitions '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Grammar Constructor' )
  comment: ''!

!FiniteStateMachineState methods !  
initialize

    self
        isFinal: false;
        isInitial: false;
        stateNumber: nil;
        transitions: OrderedCollection new!  ! 
#('February 21, 2021' '11:29:02 PM' 1892736)!

(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('initializing' initialize )) !


!FiniteStateMachineState methods !   
stateNumber
    ^stateNumber!  ! 
#('February 21, 2021' '11:29:17 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('get/set' stateNumber )) !


!FiniteStateMachineState methods !
stateNumber: aNumber
    stateNumber := aNumber!   ! 
#('February 21, 2021' '11:29:30 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('get/set' stateNumber: )) !


"evaluate"   
FiniteStateMachineState removeSelector: #number:!

"evaluate"   
FiniteStateMachineState removeSelector: #number!

"define class"

Object subclass: #Transition
  instanceVariableNames: 
    ' transitionName goto '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: Transition to: ''!


"evaluate"  

Object subclass: #Transition
  instanceVariableNames: 
    ' transitionName goto '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Grammar Constructor' )
  comment: ''!

!Transition methods !   
transitionName
    ^transitionName!    ! 
#('February 21, 2021' '11:30:34 PM' nil)!

(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('get/set' transitionName )) !


!Transition methods !   
transitionName: aTransitionName
    transitionName := aTransitionName! ! 
#('February 21, 2021' '11:30:55 PM' nil)!

(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('get/set' transitionName: )) !


"evaluate" 
Transition removeSelector: #name:!

"evaluate"  
Transition removeSelector: #name!

"evaluate"   
Transition removeSelector: #attributes!

"evaluate" 
Transition removeSelector: #attributes:!

"define class"

Object subclass: #TransitionName
  instanceVariableNames: 
    ' symbolOrPair attributes action parameters isRootBuilding '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: TransitionName to: ''!


"evaluate" 

Object subclass: #TransitionName
  instanceVariableNames: 
    ' symbolOrPair attributes action parameters isRootBuilding '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Grammar Constructor' )
  comment: ''!

"evaluate" 
TransitionName removeSelector: #=!

!TransitionName methods !   
symbolOrPair
    ^symbolOrPair!    ! 
#('February 21, 2021' '11:32:27 PM' nil)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' symbolOrPair )) !


!TransitionName methods ! 
symbolOrPair: aSymbol
    symbolOrPair := aSymbol! ! 
#('February 21, 2021' '11:32:46 PM' nil)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' symbolOrPair: )) !


"evaluate"   
TransitionName removeSelector: #symbol!

"evaluate" 
TransitionName removeSelector: #symbol:!

"evaluate"
TransitionName removeSelector: #hasAttributes!

"evaluate"  
TransitionName removeSelector: #hasParameters!

"evaluate"  
TransitionName removeSelector: #isSemanticAction!

"evaluate"   
TransitionName removeSelector: #hasAction!

"evaluate"  
TransitionName removeSelector: #name:!

"evaluate"  
TransitionName removeSelector: #name!

"evaluate"   
TransitionName removeSelector: #parameters!

"evaluate" 
TransitionName removeSelector: #parameters:!

"evaluate"
TransitionName removeSelector: #state:!

"evaluate" 
TransitionName removeSelector: #state!

!TransitionName methods !   
parameters
    ^parameters!    ! 
#('February 21, 2021' '11:34:44 PM' nil)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' parameters )) !


!TransitionName methods !   
parameters: aCollection
    parameters := aCollection! ! 
#('February 21, 2021' '11:35:02 PM' nil)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' parameters: )) !


"define class" 

Object subclass: #TransitionName
  instanceVariableNames: 
    ' symbol attributes action parameters isRootBuilding '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: TransitionName to: ''!


"evaluate"   

Object subclass: #TransitionName
  instanceVariableNames: 
    ' symbol attributes action parameters isRootBuilding '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Grammar Constructor' )
  comment: ''!


!TransitionName methods !  
initialize

    self
        symbol: Symbol new;
        action: Symbol new;
        attributes: Collection new;
        parameters: Collection new;
        isRootBuilding: Boolean new!    !
(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('initializing' initialize )) !



!TransitionName class methods !
new

    ^super new initialize!   !

"evaluate"   
(CodeFiler organizerFor: TransitionName class) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: TransitionName class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: TransitionName class) reorganizeFrom: #(
('instance creation' new )) !



!TransitionName methods !  
symbol
    ^symbol!    !

!TransitionName methods !
symbol: aSymbol
    symbol := aSymbol! !

!TransitionName methods !
action
    ^action!    !

!TransitionName methods !
action: aSymbol
    action := aSymbol! !

!TransitionName methods !
attributes
    ^attributes!    !

!TransitionName methods !
attributes: aCollection
    attributes := aCollection! !

!TransitionName methods !
parameters
    ^parameters!    !

!TransitionName methods !
parameters: aCollection
    parameters := aCollection! !

!TransitionName methods !
isRootBuilding
    ^isRootBuilding!    !

!TransitionName methods !
isRootBuilding: aBoolean
    isRootBuilding := aBoolean!   !
(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' symbol action: isRootBuilding parameters attributes: parameters: isRootBuilding: attributes action symbol: )) !

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' symbol action: isRootBuilding parameters attributes: parameters: isRootBuilding: attributes action symbol: )) !


"evaluate" 
(CodeFiler setAndInitializeOrganizerFor: TransitionName to: (MethodBasedOrganizer fromArray: #(('initializing' initialize)
('get/set' action action: attributes attributes: isRootBuilding isRootBuilding: parameters parameters: symbol symbol: symbolOrPair symbolOrPair:)
('printing' printOn:)))).!


!Transition methods !  
initialize

    self
!   !
(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('initializing' initialize )) !



!Transition class methods !
new

    ^super new initialize!   !
(CodeFiler organizerFor: Transition class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: Transition class) reorganizeFrom: #(
('instance creation' new )) !



"evaluate" 
(CodeFiler setAndInitializeOrganizerFor: Transition to: (MethodBasedOrganizer fromArray: #(('initializing' initialize)
('get/set' goto goto: transitionName transitionName:)
('query' hasAttributes)
('ops' = override:)
('printing' printOn: printOn:tabs:)))).!

!Transition methods !
goto: aState
    goto := aState!   ! 
#('February 21, 2021' '11:38:49 PM' 1905160)!

(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('get/set' goto: )) !

(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('get/set' goto: )) !


!Transition methods !  
printOn: aStream
    aStream cr;<<'      ';<<'for: ';<<self name;<<' goto: ';<<goto stateNumber;<<';'.!    ! 
#('February 21, 2021' '11:39:42 PM' 1907484)!

(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('printing' printOn: )) !

(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('printing' printOn: )) !


"evaluate" 
Transition removeSelector: #printOn:tabs:!

"evaluate"  
TransitionName removeSelector: #symbolOrPair!

"evaluate"   
TransitionName removeSelector: #symbolOrPair:!

!TransitionName methods !   
printOn: aStream
        self isAction 
        ifTrue:[aStream<< ' semanticAction: ';<<self action;<<' parameters: ';<< self parameters asArray.^self].
    self hasAttributes
        ifTrue:[aStream<<'#';<< self symbol;<<' properties: ';<<self attributes.^self].
    aStream<<self name;<<' ';<<self state stateNumber.^self!   ! 
#('February 21, 2021' '11:41:25 PM' 1903316)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('printing' printOn: )) !

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('printing' printOn: )) !


"evaluate" 
(CodeFiler setAndInitializeOrganizerFor: FiniteStateMachine class to: (MethodBasedOrganizer fromArray: #(('instance creation' forE forIdentifier:attributes: fromParserTransitionSymbol: fromScannerCollection:attributes: new)
('get/set' allInitialStateTransitionSymbol)))).!

"evaluate"   
FiniteStateMachine removeSelector: #recognizesE!

"evaluate"
(CodeFiler organizerFor: FiniteStateMachine) rename: 'query' to: 'queryMethods'!

"evaluate"
(CodeFiler organizerFor: FiniteStateMachine) removeCategory: 'ops' ifAbsent: [nil]!

"evaluate" 
(CodeFiler organizerFor: FiniteStateMachine) removeCategory: 'printing' ifAbsent: [nil]!

"evaluate"
FiniteStateMachine class removeSelector: #forE!

"evaluate" 
FiniteStateMachine class removeSelector: #forIdentifier:attributes:!

"evaluate"
FiniteStateMachine class removeSelector: #fromParserTransitionSymbol:!

"evaluate"  
FiniteStateMachine class removeSelector: #fromScannerCollection:attributes:!

"evaluate"
FiniteStateMachine class removeSelector: #allInitialStateTransitionSymbol!

"evaluate"  
FiniteStateMachine class removeSelector: #minus:!

"evaluate"   
FiniteStateMachine class removeSelector: #or:!

"evaluate"  
FiniteStateMachine class removeSelector: #concat:!

"evaluate"  
(CodeFiler organizerFor: FiniteStateMachine class) removeCategory: 'no category methods' ifAbsent: [nil]!

"evaluate"   
(CodeFiler organizerFor: FiniteStateMachine class) removeCategory: 'get/set' ifAbsent: [nil]!

"evaluate"   
FiniteStateMachine removeSelector: #override:!

"evaluate"  
FiniteStateMachine removeSelector: #questionMark!

"evaluate"   
(CodeFiler organizerFor: FiniteStateMachine) removeCategory: 'queryMethods' ifAbsent: [nil]!

"evaluate"
(CodeFiler setAndInitializeOrganizerFor: FiniteStateMachine to: (MethodBasedOrganizer fromArray: #(('initializing' initialize)
('get/set' states states:)
('printing')))).!

!FiniteStateMachine methods !
printOn: aStream

    aStream << 'FSM'.
    self states do:[ :state | state printOn: aStream ].
    aStream cr;<< 'END'.!   ! 
#('February 21, 2021' '11:56:27 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('printing' printOn: )) !


!FiniteStateMachine methods !
printOn: aStream

    aStream << 'FSM'.
    self states do:[ :state | state printOn: aStream ].
    aStream cr;<< 'End'.!   ! 
#('February 21, 2021' '11:56:35 PM' 1921704)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('printing' printOn: )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('printing' printOn: )) !


!FiniteStateMachineState methods ! 
initialize

    self
        isFinal: false;
        isInitial: false;
        stateNumber: 0;
        transitions: OrderedCollection new!    ! 
#('February 21, 2021' '11:57:27 PM' 1910572)!

(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('initializing' initialize )) !


"evaluate"   
FiniteStateMachineState removeSelector: #stateNumber:!

"evaluate"  
FiniteStateMachineState removeSelector: #isInitial:!

"evaluate"
FiniteStateMachineState removeSelector: #transitions:!

"evaluate"  
FiniteStateMachineState removeSelector: #stateNumber!

"evaluate"   
FiniteStateMachineState removeSelector: #transitions!

"evaluate"   
FiniteStateMachineState removeSelector: #isFinal:!

"evaluate"  
FiniteStateMachineState removeSelector: #isFinal!

"evaluate"   
FiniteStateMachineState removeSelector: #isInitial!


!FiniteStateMachineState methods !   
initialize

    self
        isFinal: Boolean new;
        isInitial: Boolean new;
        stateNumber: Integer new;
        transitions: OrderedCollection new!  !
(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('initializing' initialize )) !



!FiniteStateMachineState class methods ! 
new

    ^super new initialize!   !
(CodeFiler organizerFor: FiniteStateMachineState class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: FiniteStateMachineState class) reorganizeFrom: #(
('instance creation' new )) !



!FiniteStateMachineState methods !   
isFinal
    ^isFinal!  !

!FiniteStateMachineState methods !   
isFinal: aBoolean
    isFinal := aBoolean! !

!FiniteStateMachineState methods !   
isInitial
    ^isInitial!  !

!FiniteStateMachineState methods !   
isInitial: aBoolean
    isInitial := aBoolean! !

!FiniteStateMachineState methods !   
stateNumber
    ^stateNumber!  !

!FiniteStateMachineState methods !   
stateNumber: anInteger
    stateNumber := anInteger!   !

!FiniteStateMachineState methods !   
transitions
    ^transitions!  !

!FiniteStateMachineState methods !   
transitions: anOrderedCollection
    transitions := anOrderedCollection!   !
(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('get/set' transitions: stateNumber: stateNumber isFinal: isFinal transitions isInitial: isInitial )) !

(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('get/set' transitions: stateNumber: stateNumber isFinal: isFinal transitions isInitial: isInitial )) !


"evaluate" 
FiniteStateMachineState removeSelector: #printOn:tabs:!

!FiniteStateMachineState methods ! 
printOn: aStream
    aStream cr;<<'   state: ';<<stateNumber;<<' '.
    self isInitial 
        ifTrue: [aStream << 'initial;'].
    self isFinal
        ifTrue: [aStream << 'final;'].
    self transitions do:[:transit | transit printOn: aStream.]!  ! 
#('February 21, 2021' '11:59:15 PM' 1894244)!

(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('printing' printOn: )) !

(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('printing' printOn: )) !


!StudentCompiler methods !   
initialize
    parser := Parser
        for: self
        parserTables: self class rawParserTables
        scannerTables: self class rawScannerTables.
        
    code:= OrderedCollection new.
    contextStack:=  OrderedCollection new.
    self pushStatementContext.!    ! 
#('February 22, 2021' '12:07:32 AM' 1864272)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('initializing' initialize )) !


"evaluate"   
StudentCompiler removeSelector: #contextStack!

"evaluate"  
StudentCompiler removeSelector: #contextStack:!

"evaluate" 
StudentCompiler removeSelector: #code:!

"evaluate" 
StudentCompiler removeSelector: #code!

!StudentCompiler methods !  
compile: text
    tree := parser parse: text.
    self walkTree: tree.
    ^code.!   ! 
#('February 22, 2021' '12:08:51 AM' 1861524)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('compiling/evaluating/walk' compile: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('compiling/evaluating/walk' compile: )) !


!StudentCompiler methods ! 
walkTree: aTree
    self perform: (aTree label asSymbol) with: aTree!  ! 
#('February 22, 2021' '12:09:05 AM' 1863900)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('compiling/evaluating/walk' walkTree: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('compiling/evaluating/walk' walkTree: )) !


!StudentCompiler methods !   
walkMultiply: aTree
    self isStatementContext ifTrue: [^self].
    self walkTree: (aTree child: 1).
    self walkTree: (aTree child: 2).
    self walkInstruction: #Multiply! ! 
#('February 22, 2021' '12:10:36 AM' 1821132)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkMultiply: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkMultiply: )) !


!StudentCompiler methods ! 
walkAssign: aTree
    |name expression|
    name := (aTree child: 1) symbol.
    expression := aTree child: 2.
    self pushExpressionContext.
        self walkTree: expression.
    self popContext.
    self isExpressionContext ifTrue: [
        self emitInstruction: #Duplicate].
    self emitInstruction: #Pop with: name!    ! 
#('February 22, 2021' '12:12:14 AM' 1838500)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkAssign: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkAssign: )) !


!StudentCompiler methods ! 
walkAssign: aTree
    |name expression|
    name := (aTree child: 1) symbol.
    expression := aTree child: 2.
    self pushExpressionContext.
        self walkTree: expression.
    self popContext.
    self isExpressionContext ifTrue: [
        self walkInstruction: #Duplicate].
    self walkInstruction: #Pop with: name!    ! 
#('February 22, 2021' '12:12:46 AM' 1927844)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkAssign: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkAssign: )) !


!StudentCompiler methods ! 
walkList: aTree
    aTree children isEmpty ifTrue:[
        self isExpressionContext ifTrue:[
            self walkInstruction: #push with: nil. 
        ^self]].
    self pushStatementContext.
        aTree children allButLast do: [:child |
            self walkTree: child].
    self popContext.
    self walkTree:(aTree child: aTree children size).!   ! 
#('February 22, 2021' '12:13:44 AM' 1822936)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkList: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkList: )) !


"evaluate" 
StudentCompiler removeSelector: #walkFloat:!

!StudentCompiler methods !
walkFor: aTree
    |initialExpression booleanExpression incrementExpression body end whileStart fixAtEnd|
    self isExpressionContext ifTrue:[
        self designError: 'Can''t use for loop as expression'.
        ^self].
    initialExpression := aTree child: 1.
    booleanExpression := aTree child: 2.
    incrementExpression :=aTree child: 3.
    body := aTree child: 4.
    self walkTree: initialExpression.
    self pushExpressionContext "For branchIfFalse to work".
        whileStart := self nextInstruction.
        self walkTree: booleanExpression.
    self popContext.
    fixAtEnd := self nextInstruction.
    self walkInstruction: #branchIfFalse with: nil. "to End"
    self walkTree: body.
    self walkTree: incrementExpression.
    self walkBranch: #branch backTo: whileStart.
    end := self nextInstruction.
    self fixupBranch: fixAtEnd with: end.!    ! 
#('February 22, 2021' '12:15:25 AM' 1867872)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFor: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFor: )) !


!StudentCompiler methods !   
walkMinus: aTree
    self isStatementContext ifTrue: [^self].
    self walkTree: (aTree child: 1).
    self walkTree: (aTree child: 2).
    self walkInstruction: #Minus!   ! 
#('February 22, 2021' '12:17:27 AM' 1824652)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkMinus: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkMinus: )) !


!StudentCompiler methods !   
walkLess: aTree
    self isStatementContext ifTrue: [^self].
    self walkTree: (aTree child: 1).
    self walkTree: (aTree child: 2).
    self walkInstruction: #Less! ! 
#('February 22, 2021' '12:18:03 AM' 1824904)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkLess: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkLess: )) !


!StudentCompiler methods ! 
walkPlus: aTree
    self isStatementContext ifTrue: [^self].
    self walkTree: (aTree child: 1).
    self walkTree: (aTree child: 2).
    self walkInstruction: #Add.! ! 
#('February 22, 2021' '12:18:30 AM' 1825156)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkPlus: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkPlus: )) !


!StudentCompiler methods ! 
walkInteger: tree
    | constant |
    self isStatementContext ifTrue: [^self].
    constant := tree symbol asInteger.
    self walkInstruction: #PushInteger with: constant.!  ! 
#('February 22, 2021' '12:19:35 AM' 1848628)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkInteger: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkInteger: )) !


!StudentCompiler methods !   
walkIf: aTree
    |exp then else fixToElse elseStart fixToEnd endStart|
    exp := aTree child: 1.
    then := aTree child: 2.
    else := aTree children size < 3
        ifTrue: [nil]
        ifFalse: [aTree child: 3].
    (else isNil and: [self isExpressionContext]) ifTrue:[
        self error: 'Missing else for if expression'.
        else := then "Make the compiler work"].
        
        
    self pushExpressionContext.
        self walkTree: exp.
    self popContext.
    fixToElse := self walkInstruction: #branchIfFalse with: nil. 
    self walkTree: then.
    else isNil
        ifTrue:[
            elseStart := self nextInstruction.
            self fixupBranch: fixToElse with: elseStart]
        ifFalse:[
            fixToEnd := self walkInstruction: #branch with: nil. 
            elseStart := self nextInstruction. 
            self walkTree: else.
            endStart := self nextInstruction.
            self fixupBranch: fixToElse with: elseStart.
            self fixupBranch: fixToEnd with: endStart].!   ! 
#('February 22, 2021' '12:20:48 AM' 1859740)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIf: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIf: )) !


"evaluate" 
StudentCompiler removeSelector: #walkSend:!

!StudentCompiler methods ! 
walkGreater: aTree
    self isStatementContext ifTrue: [^self].
    self walkTree: (aTree child: 1).
    self walkTree: (aTree child: 2).
    self walkInstruction: #Greater!   ! 
#('February 22, 2021' '12:23:03 AM' 1822088)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkGreater: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkGreater: )) !


!StudentCompiler methods !   
walkEqual: aTree
    self isStatementContext ifTrue: [^self].
    self walkTree: (aTree child: 1).
    self walkTree: (aTree child: 2).
    self walkInstruction: #Equal!   ! 
#('February 22, 2021' '12:23:46 AM' 1821392)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkEqual: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkEqual: )) !


!StudentCompiler methods !   
walkDivide: aTree
    self isStatementContext ifTrue: [^self].
    self walkTree: (aTree child: 1).
    self walkTree: (aTree child: 2).
    self walkInstruction: #Divide.!    ! 
#('February 22, 2021' '12:24:24 AM' 1821832)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkDivide: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkDivide: )) !


!StudentCompiler methods ! 
walkEqual: aTree
    self isStatementContext ifTrue: [^self].
    self walkTree: (aTree child: 1).
    self walkTree: (aTree child: 2).
    self walkInstruction: #Equal.!  ! 
#('February 22, 2021' '12:24:33 AM' 1934616)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkEqual: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkEqual: )) !


!StudentCompiler methods !   
walkGreater: aTree
    self isStatementContext ifTrue: [^self].
    self walkTree: (aTree child: 1).
    self walkTree: (aTree child: 2).
    self walkInstruction: #Greater.!  ! 
#('February 22, 2021' '12:24:41 AM' 1934152)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkGreater: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkGreater: )) !


!StudentCompiler methods !   
walkLess: aTree
    self isStatementContext ifTrue: [^self].
    self walkTree: (aTree child: 1).
    self walkTree: (aTree child: 2).
    self walkInstruction: #Less.!    ! 
#('February 22, 2021' '12:24:57 AM' 1931400)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkLess: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkLess: )) !


!StudentCompiler methods ! 
walkMinus: aTree
    self isStatementContext ifTrue: [^self].
    self walkTree: (aTree child: 1).
    self walkTree: (aTree child: 2).
    self walkInstruction: #Minus.!  ! 
#('February 22, 2021' '12:25:10 AM' 1930944)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkMinus: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkMinus: )) !


!StudentCompiler methods !   
walkMultiply: aTree
    self isStatementContext ifTrue: [^self].
    self walkTree: (aTree child: 1).
    self walkTree: (aTree child: 2).
    self walkInstruction: #Multiply.!    ! 
#('February 22, 2021' '12:25:30 AM' 1927380)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkMultiply: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkMultiply: )) !


!StudentCompiler methods ! 
walkBranch: opcode backTo: location
     ^self walkInstruction: opcode 
         with: (location - self nextInstruction)! ! 
#('February 22, 2021' '12:26:25 AM' 1844188)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' walkBranch:backTo: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' walkBranch:backTo: )) !


!StudentCompiler methods !   
generate: instruction
    code cr; << instruction! ! 
#('February 22, 2021' '12:26:39 AM' 1846448)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' generate: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' generate: )) !


!StudentCompiler methods ! 
generate: instruction with: operand
    code cr; << instruction; << ' '; << operand!   ! 
#('February 22, 2021' '12:27:07 AM' 1846192)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' generate:with: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' generate:with: )) !


!StudentCompiler methods !   
fixupBranch: where with: nextInstruction
    | newOffset |
    newOffset := nextInstruction - where.
    code at: where + 1 put: newOffset!  ! 
#('February 22, 2021' '12:28:59 AM' 1861916)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' fixupBranch:with: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' fixupBranch:with: )) !


   
'Smalltalk'!

  
'StudentCompiler walkExample1'!

!StudentCompiler class methods !   
walkExample1
    "StudentCompiler walkExample1"
    ^StudentCompiler new compile: 'if (a > b) {a = b; c = d;} else {e = f;}'! ! 
#('February 22, 2021' '12:31:04 AM' 1863120)!

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample1 )) !

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample1 )) !


 
'StudentCompiler walkExample2'!

!TransitionName methods !  
symbolOrPair!   ! 
#('February 22, 2021' '12:32:52 AM' nil)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' symbolOrPair )) !


"evaluate"
(CodeFiler setAndInitializeOrganizerFor: TransitionName to: (MethodBasedOrganizer fromArray: #(('initializing' initialize)
('get/set' action action: attributes attributes: isRootBuilding isRootBuilding: parameters parameters: symbol symbol: symbolOrPair)
('querying')
('printing' printOn:)))).!

!TransitionName methods !
isPair
    ^self name ~= nil!  ! 
#('February 22, 2021' '12:42:25 AM' nil)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('querying' isPair )) !


!TransitionName methods !  
hasAttributes
    ^self attributes ~= nil! ! 
#('February 22, 2021' '12:42:42 AM' nil)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('querying' hasAttributes )) !


!TransitionName methods !   
isAction
    ^self action ~= nil!  ! 
#('February 22, 2021' '12:42:53 AM' nil)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('querying' isAction )) !


"evaluate"   
(CodeFiler organizerFor: 'FiniteStateMachine')  addCategory: 'easyMethods' before: nil!

!FiniteStateMachine methods !  
or: fsm
    self states addAll: fsm states.
    self renumber.
    ^self!    ! 
#('February 22, 2021' '12:45:34 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('easyMethods' or: )) !


!FiniteStateMachine methods !  
questionMark
    ^self or: FiniteStateMachine epsilon! ! 
#('February 22, 2021' '12:45:47 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('easyMethods' questionMark )) !


!FiniteStateMachine methods ! 
plus!   ! 
#('February 22, 2021' '12:46:07 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('easyMethods' plus )) !


!FiniteStateMachine methods ! 
renumber
    self states indexedDo:[ :index :state| state stateNumber: index].!    ! 
#('February 22, 2021' '12:46:33 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('easyMethods' renumber )) !


"evaluate"
(CodeFiler organizerFor: 'FiniteStateMachine')  addCategory: 'mediumMethods' before: nil!

!FiniteStateMachine methods !
star
    |fsm state1 transition1|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    transition1 := Transition new name: 'a'; goto: state1.
    state1 transitions add: transition1.
    fsm states add: state1. 
    ^fsm renumber.!  ! 
#('February 22, 2021' '12:47:42 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('mediumMethods' star )) !


!FiniteStateMachine methods !   
concatenate!    ! 
#('February 22, 2021' '12:48:58 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('mediumMethods' concatenate )) !


"evaluate"   
(CodeFiler organizerFor: 'FiniteStateMachine')  addCategory: 'hardMethods' before: nil!

"evaluate" 
(CodeFiler organizerFor: 'FiniteStateMachine class')  addCategory: 'easy' before: nil!

!FiniteStateMachine class methods ! 
epsilon
    |fsm state1|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    fsm states add: state1.
    ^fsm renumber.!  ! 
#('February 22, 2021' '12:52:00 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('easy' epsilon )) !


!FiniteStateMachine class methods ! 
scannerDefaultAttributes!   ! 
#('February 22, 2021' '12:52:46 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('easy' scannerDefaultAttributes )) !


!FiniteStateMachine class methods !
parserNonterminalDefaultAttributes! ! 
#('February 22, 2021' '12:53:45 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('easy' parserNonterminalDefaultAttributes )) !


!FiniteStateMachine class methods !  
parserTerminalDefaultAttributes!    ! 
#('February 22, 2021' '12:53:52 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('easy' parserTerminalDefaultAttributes )) !


"define class"  

Object subclass: #Attribute
  instanceVariableNames: 
    ' isRead isStack isNode isKeep '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: Attribute to: ''!


"evaluate"   

Object subclass: #Attribute
  instanceVariableNames: 
    '  isRead isStack isNode isKeep'
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Grammar Constructor' )
  comment: ''!


!Attribute methods !  
initialize

    self
        isNode: Boolean new;
        isKeep: Boolean new;
        isStack: Boolean new;
        isRead: Boolean new! !

"evaluate"   
(CodeFiler organizerFor: Attribute) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Attribute) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: Attribute) reorganizeFrom: #(
('initializing' initialize )) !



!Attribute class methods !  
new

    ^super new initialize!   !

"evaluate"   
(CodeFiler organizerFor: Attribute class) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Attribute class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: Attribute class) reorganizeFrom: #(
('instance creation' new )) !



!Attribute methods !  
isNode
    ^isNode!    !

!Attribute methods ! 
isNode: aBoolean
    isNode := aBoolean!   !

!Attribute methods ! 
isKeep
    ^isKeep!    !

!Attribute methods ! 
isKeep: aBoolean
    isKeep := aBoolean!   !

!Attribute methods ! 
isStack
    ^isStack!  !

!Attribute methods ! 
isStack: aBoolean
    isStack := aBoolean! !

!Attribute methods ! 
isRead
    ^isRead!    !

!Attribute methods ! 
isRead: aBoolean
    isRead := aBoolean!   !
(CodeFiler organizerFor: Attribute) reorganizeFrom: #(
('get/set' isStack isRead isKeep: isRead: isNode: isKeep isNode isStack: )) !

(CodeFiler organizerFor: Attribute) reorganizeFrom: #(
('get/set' isStack isRead isKeep: isRead: isNode: isKeep isNode isStack: )) !


"evaluate" 
(CodeFiler organizerFor: 'Attribute')  addCategory: 'printing' before: nil!

!Attribute methods !   
printOn: aStream
    aStream<<'"'.
    self isRead ifTrue:[aStream<<'R'] ifFalse:[aStream<<'L'].
    self isStack ifTrue:[aStream<<'S']. 
    self isNode ifTrue:[aStream<<'N']. 
    self isKeep ifTrue:[aStream<<'K'].
    aStream<<'"'.!   ! 
#('February 22, 2021' '12:58:01 AM' nil)!

(CodeFiler organizerFor: Attribute) reorganizeFrom: #(
('printing' printOn: )) !


"evaluate"
(CodeFiler organizerFor: 'Attribute class')  addCategory: 'defaultAttributes' before: nil!

!Attribute class methods !  
parserNonterminalDefaultAttributes
^Attribute new isRead: true; isKeep: false; isNode: true; isStack: true.!   ! 
#('February 22, 2021' '12:59:15 AM' nil)!

(CodeFiler organizerFor: Attribute class) reorganizeFrom: #(
('defaultAttributes' parserNonterminalDefaultAttributes )) !


!Attribute class methods !   
parserTerminalDefaultAttributes
    ^Attribute new isRead: true; isKeep: false; isNode: false; isStack: true.! ! 
#('February 22, 2021' '12:59:56 AM' nil)!

(CodeFiler organizerFor: Attribute class) reorganizeFrom: #(
('defaultAttributes' parserTerminalDefaultAttributes )) !


!Attribute class methods !  
scannerDefaultAttributes
    ^Attribute new isRead: true; isKeep: true; isNode: false; isStack: false.!    ! 
#('February 22, 2021' '01:00:39 AM' nil)!

(CodeFiler organizerFor: Attribute class) reorganizeFrom: #(
('defaultAttributes' scannerDefaultAttributes )) !


"evaluate" 
FiniteStateMachine class removeSelector: #parserTerminalDefaultAttributes!

"evaluate"  
FiniteStateMachine class removeSelector: #scannerDefaultAttributes!

"evaluate" 
FiniteStateMachine class removeSelector: #parserNonterminalDefaultAttributes!

!FiniteStateMachine methods !
plus
    |fsm state1 state2 transition1 transition2|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: false.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    transition1 := Transition new name: 'a'; goto: state2.
    transition2 := Transition new name: 'a'; goto: state2.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2. 
    ^fsm renumber.!   ! 
#('February 22, 2021' '01:03:44 AM' 1941640)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('easyMethods' plus )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('easyMethods' plus )) !


!FiniteStateMachine methods !
concatenate
    |fsm state1|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    fsm states add: state1.
    ^fsm renumber.!  ! 
#('February 22, 2021' '01:05:07 AM' 1942672)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('mediumMethods' concatenate )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('mediumMethods' concatenate )) !


"evaluate" 
FiniteStateMachine removeSelector: #concatenate!

!FiniteStateMachine methods ! 
star
    |fsm state1 transition1|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    transition1 := Transition new name: 'a'; goto: state1.
    state1 transitions add: transition1.
    fsm states add: state1. 
    ^fsm renumber.!  ! 
#('February 22, 2021' '01:06:24 AM' 1942192)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('mediumMethods' star )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('mediumMethods' star )) !


"evaluate"   
(CodeFiler setAndInitializeOrganizerFor: FiniteStateMachine to: (MethodBasedOrganizer fromArray: #(('initializing' initialize)
('get/set' states states:)
('printing' printOn:)
('easyMethods' or: plus questionMark renumber star)
('mediumMethods' )
('hardMethods' )))).!

"evaluate"   
(CodeFiler setAndInitializeOrganizerFor: FiniteStateMachine to: (MethodBasedOrganizer fromArray: #(('initializing' initialize)
('get/set' states states:)
('printing' printOn:)
('easyMethods' or: plus questionMark renumber star)))).!

"evaluate" 
(CodeFiler setAndInitializeOrganizerFor: FiniteStateMachine to: (MethodBasedOrganizer fromArray: #(('initializing' initialize)
('get/set' states states:)
('printing' printOn:)
('fsmMethods' or: plus questionMark renumber star)))).!

"evaluate"  
(CodeFiler setAndInitializeOrganizerFor: FiniteStateMachine class to: (MethodBasedOrganizer fromArray: #(('instance creation' new)
('fsmClass')))).!

"evaluate"   
FiniteStateMachine class removeSelector: #epsilon!

"evaluate"  
(CodeFiler organizerFor: FiniteStateMachine class) removeCategory: 'no category methods' ifAbsent: [nil]!

"evaluate"   
(CodeFiler setAndInitializeOrganizerFor: FiniteStateMachine class to: (MethodBasedOrganizer fromArray: #(('instance creation' new)
('fsm' )))).!

!FiniteStateMachine methods !
epsilon
    |fsm state1|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    fsm states add: state1.
    ^fsm renumber.!  ! 
#('February 22, 2021' '01:09:55 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' epsilon )) !


"evaluate"  
FiniteStateMachine removeSelector: #epsilon!

"evaluate"
FiniteStateMachine removeSelector: #star!

!FiniteStateMachine class methods !  
epsilon
    |fsm state1|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    fsm states add: state1.
    ^fsm renumber.!  ! 
#('February 22, 2021' '01:10:45 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('fsm' epsilon )) !


!FiniteStateMachine class methods !  
star
    |fsm state1 transition1|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    transition1 := Transition new name: 'a'; goto: state1.
    state1 transitions add: transition1.
    fsm states add: state1. 
    ^fsm renumber.!  ! 
#('February 22, 2021' '01:10:56 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('fsm' star )) !


!FiniteStateMachine class methods ! 
forParser: aTransitionName
    |fsm state1 state2 transition|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: false.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    transition := Transition new name: aTransitionName; goto: state2.
    state1 transitions add: transition.
    fsm states add: state1; add: state2. 
    ^fsm renumber.!  ! 
#('February 22, 2021' '01:11:06 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('fsm' forParser: )) !


!FiniteStateMachine class methods !   
orAll:  aCollectionOfFSMs!  ! 
#('February 22, 2021' '01:11:45 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('fsm' orAll: )) !


!FiniteStateMachine class methods !   
orAll: aCollectionOfFSMs!   ! 
#('February 22, 2021' '01:11:50 AM' 1953224)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('fsm' orAll: )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('fsm' orAll: )) !


!FiniteStateMachine class methods !  
concatenateAll: aCollectionOfFSMs!  ! 
#('February 22, 2021' '01:12:03 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('fsm' concatenateAll: )) !


"evaluate"   
FiniteStateMachine class removeSelector: #star!

!TransitionName methods !  
printOn: aStream
        self isPair
        ifTrue:[aStream<< ' semanticAction: ';<<self action;<<' parameters: ';<< self parameters asArray.^self].
    self isSymbol
        ifTrue:[aStream<<'#';<< self symbol;<<' properties: ';<<self attributes.^self].
    aStream<<self name;<<' ';<<self state stateNumber.^self!   ! 
#('February 22, 2021' '01:15:05 AM' 1919164)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('printing' printOn: )) !

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('printing' printOn: )) !


"evaluate" 
TransitionName removeSelector: #symbolOrPair!

!FiniteStateMachine methods !
questionMark
    ^self or: self FiniteStateMachine epsilon!    ! 
#('February 22, 2021' '01:17:10 AM' 1941400)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' questionMark )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' questionMark )) !


!FiniteStateMachine methods !  
plus
    ^self concatenate: self star! ! 
#('February 22, 2021' '01:17:41 AM' 1948036)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' plus )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' plus )) !


"evaluate" 
Grammar removeFromSystem!

"evaluate"   
CodeFiler removeOrganizerFor: #Grammar!

"evaluate" 
CodeFiler removeOrganizerFor: #'Grammar class'!

"evaluate" 
Transition removeSelector: #override:!

"evaluate"  
Transition removeSelector: #=!

"evaluate"  
(CodeFiler organizerFor: Transition) removeCategory: 'ops' ifAbsent: [nil]!

"evaluate" 
Transition removeSelector: #hasAttributes!

"evaluate"  
(CodeFiler organizerFor: Transition) removeCategory: 'query' ifAbsent: [nil]!

"evaluate"   
(CodeFiler organizerFor: 'FiniteStateMachine class')  addCategory: 'examples' before: nil!

!FiniteStateMachine class methods ! 
example1
    "FiniteStateMachine example1"
    |fsm state1 state2 transition1 transition2 tName|
    
    fsm = FiniteStateMachine new.
    state1 := (FiniteStateMachine new) isInitial: true;
        isFinal: false; stateNumber: 1; yourself.
    state2 := (FiniteStateMachine new) isInitial: false; 
        isFinal: true; stateNumber: 2; yourself.
    fsm add: state1.
    fsm add: state2.
    (transition1 := Transition new) goTo: 2.
    tName := (Transition new) symbolOrPair: #a.
    transition1 transitionName: tName.
    (fsm getState: 1) addTransition: transition1.
    Transcript cr; << fsm.! ! 
#('February 23, 2021' '03:00:33 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !


!FiniteStateMachine methods !  
concatenate: fsm
    | fsms |
    fsms := fsms first.
    fsm rest do: [:cfsm | 
        fsms concatenate: cfsm. ].
    ^ fsms renumber.!  ! 
#('February 23, 2021' '03:04:29 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' concatenate: )) !


!FiniteStateMachine methods !  
concatenate: fsm
    | fsms |
    fsms := fsm first.
    fsm rest do: [:cfsm | 
        fsms concatenate: cfsm. ].
    ^ fsms renumber.!   ! 
#('February 23, 2021' '03:04:43 PM' 1956772)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' concatenate: )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' concatenate: )) !


!FiniteStateMachine methods !  
concatenate: fsm
    | fsms |
    fsms := fsm first.
    fsm rest do: [:concatenate_fsm | 
        fsms concatenate: concatenate_fsm. ].
    ^ fsms renumber.! ! 
#('February 23, 2021' '03:05:01 PM' 1957100)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' concatenate: )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' concatenate: )) !


!FiniteStateMachine methods !  
concatenate: fsm
    | fsms |
    fsms := fsm first.
    fsm rest do: [:concatenateFsm | 
        fsms concatenate: concatenateFsm. ].
    ^ fsms renumber.!   ! 
#('February 23, 2021' '03:05:13 PM' 1957532)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' concatenate: )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' concatenate: )) !


!FiniteStateMachine methods !  
concatenate: fsm
    self states addAll: fsm states
    self renumber.
    ^ self!   ! 
#('February 23, 2021' '03:06:54 PM' 1957984)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' concatenate: )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' concatenate: )) !


"define class" 

Object subclass: #Transition
  instanceVariableNames: 
    ' transitionName goTo '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: Transition to: ''!


"evaluate"  

Object subclass: #Transition
  instanceVariableNames: 
    ' transitionName goTo '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Grammar Constructor' )
  comment: ''!

"define class"  

Object subclass: #Transition
  instanceVariableNames: 
    ' transitionName goto '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: Transition to: ''!


"evaluate"  

Object subclass: #Transition
  instanceVariableNames: 
    ' transitionName goto '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Grammar Constructor' )
  comment: ''!

!FiniteStateMachine class methods ! 
example1
    "FiniteStateMachine example1"
    |fsm state1 state2 transition1 transition2 tName|
    
    fsm = FiniteStateMachine new.
    state1 := (FiniteStateMachine new) isInitial: true;
        isFinal: false; stateNumber: 1; yourself.
    state2 := (FiniteStateMachine new) isInitial: false; 
        isFinal: true; stateNumber: 2; yourself.
    fsm add: state1.
    fsm add: state2.
    (transition1 := Transition new) goto: 2.
    tName := (Transition new) symbolOrPair: #a.
    transition1 transitionName: tName.
    (fsm getState: 1) addTransition: transition1.
    Transcript cr; << fsm.! ! 
#('February 23, 2021' '03:08:45 PM' 1955972)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !


!FiniteStateMachine class methods !
example1
    "FiniteStateMachine example1"
    |fsm state1 state2 transition1 transition2 tName|
    
    fsm = FiniteStateMachine new.
    state1 := (FiniteStateMachineState new) isInitial: true;
        isFinal: false; stateNumber: 1; yourself.
    state2 := (FiniteStateMachineState new) isInitial: false; 
        isFinal: true; stateNumber: 2; yourself.
    fsm add: state1.
    fsm add: state2.
    (transition1 := Transition new) goto: 2.
    tName := (Transition new) symbolOrPair: #a.
    transition1 transitionName: tName.
    (fsm getState: 1) addTransition: transition1.
    Transcript cr; << fsm.!   ! 
#('February 23, 2021' '03:09:02 PM' 1959648)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !


"define class" 

Object subclass: #TransitionName
  instanceVariableNames: 
    ' symbol attributes action parameters isRootBuilding name state '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: TransitionName to: ''!


"evaluate"

Object subclass: #TransitionName
  instanceVariableNames: 
    ' symbol attributes action parameters isRootBuilding name state'
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Grammar Constructor' )
  comment: ''!

!FiniteStateMachine class methods !
questionMark!   ! 
#('February 23, 2021' '03:14:03 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('instance creation' questionMark )) !


"evaluate"
FiniteStateMachine class removeSelector: #new!

!FiniteStateMachine class methods ! 
questionMark
    |fsm state1 state2 state3 transition1 transition2|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    transition1 := Transition new name: 'a'; goto: state2.
    transition2 := Transition new name: 'a'; goto: state3.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2; add: state3. 
    ^fsm renumber.!   ! 
#('February 23, 2021' '03:14:27 PM' 1961984)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('instance creation' questionMark )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('instance creation' questionMark )) !


!FiniteStateMachine class methods !  
new
    ^super new initialize! ! 
#('February 23, 2021' '03:15:06 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('instance creation' new )) !


"evaluate" 
(CodeFiler setAndInitializeOrganizerFor: FiniteStateMachine class to: (MethodBasedOrganizer fromArray: #(('instance creation' new )
('fsm' concatenateAll: epsilon forParser: orAll:)
('examples' example1 questionMark)))).!

"evaluate" 
(CodeFiler setAndInitializeOrganizerFor: FiniteStateMachine class to: (MethodBasedOrganizer fromArray: #(('instance creation' new)
('fsm' concatenateAll: epsilon forParser: orAll: questionMark)
('examples' example1 )))).!

"evaluate" 
FiniteStateMachine class removeSelector: #example1!

!FiniteStateMachine class methods !
plusMark
    |fsm state1 state2 transition1 transition2|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: false.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    transition1 := Transition new name: 'a'; goto: state2.
    transition2 := Transition new name: 'a'; goto: state2.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2. 
    ^fsm renumber.!   ! 
#('February 23, 2021' '03:16:36 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('fsm' plusMark )) !


!FiniteStateMachine class methods ! 
starMark
    |fsm state1 transition1|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    transition1 := Transition new name: 'a'; goto: state1.
    state1 transitions add: transition1.
    fsm states add: state1. 
    ^fsm renumber.!  ! 
#('February 23, 2021' '03:16:51 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('fsm' starMark )) !


!FiniteStateMachine methods !   
plus
    ^self concatenate: self FiniteStateMachine star!  ! 
#('February 23, 2021' '03:17:45 PM' 1955032)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' plus )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' plus )) !


!FiniteStateMachine class methods !
star
    |fsm state1 transition1|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    transition1 := Transition new name: 'a'; goto: state1.
    state1 transitions add: transition1.
    fsm states add: state1. 
    ^fsm renumber.!  ! 
#('February 23, 2021' '03:18:43 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('fsm' star )) !


"evaluate"  
FiniteStateMachine class removeSelector: #starMark!

!FiniteStateMachine class methods !
plus
    |fsm state1 state2 transition1 transition2|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: false.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    transition1 := Transition new name: 'a'; goto: state2.
    transition2 := Transition new name: 'a'; goto: state2.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2. 
    ^fsm renumber.!   ! 
#('February 23, 2021' '03:18:55 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('fsm' plus )) !


"evaluate"  
FiniteStateMachine class removeSelector: #plusMark!

"evaluate" 
FiniteStateMachine removeSelector: #plus!

"evaluate"   
FiniteStateMachine removeSelector: #concatenate:!


!FiniteStateMachine methods !  
initialize

    self
        states: OrderedCollection new!  !
(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('initializing' initialize )) !



!FiniteStateMachine class methods !
new

    ^super new initialize!   !
(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('instance creation' new )) !



!FiniteStateMachine methods !  
states
    ^states!    !

!FiniteStateMachine methods !
states: anOrderedCollection
    states := anOrderedCollection! !
(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('get/set' states: states )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('get/set' states: states )) !


!FiniteStateMachineState methods ! 
initialize

    self
        isFinal: false;
        isInitial: false;
        stateNumber: 0;
        transitions: OrderedCollection new!    ! 
#('February 23, 2021' '03:21:58 PM' 1923432)!

(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('initializing' initialize )) !


"evaluate"   
(CodeFiler setAndInitializeOrganizerFor: StudentCompiler to: (MethodBasedOrganizer fromArray: #(('initializing' initialize)
('get/set' parser parser: tree tree:)
('walk' compile: walkTree:)
('compilation support' generate: generate:with:)
('walk support' fixupAllBranches:with: fixupBranch:with: nextInstruction walkBranch:backTo: walkInstruction: walkInstruction:with:)
('contextStackMethods' isExpressionContext isStatementContext popContext pushExpressionContext pushStatementContext)
('walk details' walkAssign: walkDivide: walkEqual: walkFor: walkGreater: walkIdentifier: walkIf: walkInteger: walkLess: walkList: walkMinus: walkMultiply: walkPlus:)))).!

!StudentCompiler methods !
emitInstruction: opCode
    code add:opCode.
    ^code size!  ! 
#('February 23, 2021' '03:26:33 PM' nil)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' emitInstruction: )) !


!StudentCompiler methods !  
emitInstruction: opCode with: operand
    code add:opCode; add: operand.
    ^code size-1!    ! 
#('February 23, 2021' '03:26:44 PM' nil)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' emitInstruction:with: )) !


!StudentCompiler methods ! 
emitBranch: opcode backTo: location
    ^self emitInstruction: opcode
        with: (location - self nextInstruction)!    ! 
#('February 23, 2021' '03:26:53 PM' nil)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' emitBranch:backTo: )) !


"evaluate"
StudentCompiler removeSelector: #walkBranch:backTo:!

"evaluate"
StudentCompiler removeSelector: #walkInstruction:!

"evaluate"  
StudentCompiler removeSelector: #walkInstruction:with:!

!StudentCompiler methods ! 
fixupAllBranches: initUnknown with: a
    |nextUnknown unknown|
    unknown := initUnknown.
    [unknown notNil] whileTrue:[
        nextUnknown := code at: unknown + 1
        self fixupBranch unknown with: a.
        unknown := nextUnknown]!   ! 
#('February 23, 2021' '03:27:32 PM' 1845356)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' fixupAllBranches:with: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' fixupAllBranches:with: )) !


!StudentCompiler methods !   
fixupBranch: where with: nextInstruction
    |newOffset|
    newOffset :=nextInstruction - where.
    code at: where + 1 put: newOffset! ! 
#('February 23, 2021' '03:27:46 PM' 1938952)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' fixupBranch:with: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' fixupBranch:with: )) !


!StudentCompiler methods ! 
walkIf: aTree
    |exp then else fixToElse elseStart fixToEnd endStart|
    exp := aTree child: 1.
    then := aTree child: 2.
    else := aTree children size < 3
        ifTrue: [nil]
        ifFalse: [aTree child: 3].
    (else isNil and: [self isExpressionContext]) ifTrue:[
        self error: 'Missing else for if expression'.
        else := then "Make the compiler work"].
        
        
    self pushExpressionContext.
        self walkTree: exp.
    self popContext.
    fixToElse := self emitInstruction: #branchIfFalse with: nil. 
    self walkTree: then.
    else isNil
        ifTrue:[
            elseStart := self nextInstruction.
            self fixupBranch: fixToElse with: elseStart]
        ifFalse:[
            fixToEnd := self emitInstruction: #branch with: nil. 
            elseStart := self nextInstruction. 
            self walkTree: else.
            endStart := self nextInstruction.
            self fixupBranch: fixToElse with: elseStart.
            self fixupBranch: fixToEnd with: endStart].!   ! 
#('February 23, 2021' '03:28:49 PM' 1932760)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIf: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIf: )) !


!StudentCompiler methods ! 
walkIdentifier: tree
    | name|
    self isStatementContext ifTrue: [^self].
    name := tree symbol.
    self emitInstruction: #Push with: name.! ! 
#('February 23, 2021' '03:29:23 PM' 1854668)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIdentifier: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIdentifier: )) !


!StudentCompiler methods ! 
walkIdentifier: aTree
    | name|
    self isStatementContext ifTrue: [^self].
    name := aTree symbol.
    self emitInstruction: #Push with: name.!   ! 
#('February 23, 2021' '03:29:39 PM' 1972372)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIdentifier: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIdentifier: )) !


!StudentCompiler methods ! 
walkLess: aTree
    self isStatementContext ifTrue: [^self].
    self walkTree: (aTree child: 1).
    self walkTree: (aTree child: 2).
    self emitInstruction: 'Less'.!   ! 
#('February 23, 2021' '03:29:56 PM' 1936452)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkLess: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkLess: )) !


!StudentCompiler methods ! 
walkPlus: aTree
    self isStatementContext ifTrue: [^self].
    self walkTree: (aTree child: 1).
    self walkTree: (aTree child: 2).
    self emitInstruction: 'Add'.!    ! 
#('February 23, 2021' '03:30:10 PM' 1931848)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkPlus: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkPlus: )) !


!StudentCompiler methods ! 
walkMinus: aTree
    self isStatementContext ifTrue: [^self].
    self walkTree: (aTree child: 1).
    self walkTree: (aTree child: 2).
    self emitInstruction: #Minus.!  ! 
#('February 23, 2021' '03:30:55 PM' 1936904)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkMinus: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkMinus: )) !


!StudentCompiler methods !   
walkPlus: aTree
    self isStatementContext ifTrue: [^self].
    self walkTree: (aTree child: 1).
    self walkTree: (aTree child: 2).
    self emitInstruction: #Add.! ! 
#('February 23, 2021' '03:31:03 PM' 1973708)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkPlus: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkPlus: )) !


!StudentCompiler methods ! 
walkMultiply: aTree
    self isStatementContext ifTrue: [^self].
    self walkTree: (aTree child: 1).
    self walkTree: (aTree child: 2).
    self emitInstruction: #Multiply.!    ! 
#('February 23, 2021' '03:31:12 PM' 1937360)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkMultiply: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkMultiply: )) !


!StudentCompiler methods ! 
walkList: aTree
    aTree children isEmpty ifTrue:[
        self isExpressionContext ifTrue:[
            self emitInstruction: #push with: nil.
        ^self]].
    self pushStatementContext.
        aTree children allButLast do: [:child |
            self walkTree: child].
    self popContext.
    self walkTree:(aTree child: aTree children size).!    ! 
#('February 23, 2021' '03:31:32 PM' 1929076)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkList: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkList: )) !


!StudentCompiler methods ! 
walkFor: aTree
    |initialExpression booleanExpression incrementExpression body end whileStart fixAtEnd|
    self isExpressionContext ifTrue:[
        self designError: 'Can''t use for loop as expression'.
        ^self].
    initialExpression := aTree child: 1.
    booleanExpression := aTree child: 2.
    incrementExpression :=aTree child: 3.
    body := aTree child: 4.
    self walkTree: initialExpression.
    self pushExpressionContext "For branchIfFalse to work".
        whileStart := self nextInstruction.
        self walkTree: booleanExpression.
    self popContext.
    fixAtEnd := self nextInstruction.
    self emitInstruction: #branchIfFalse with: nil. "to End"
    self walkTree: body.
    self walkTree: incrementExpression.
    self emitBranch: #branch backTo: whileStart.
    end := self nextInstruction.
    self fixupBranch: fixAtEnd with: end.!    ! 
#('February 23, 2021' '03:31:49 PM' 1929776)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFor: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFor: )) !


!StudentCompiler methods !   
walkFunctionCall: aTree
    aTree children rest do: [:child | self walkTree: child].
    self emitInstruction: 'FUNCTION_CALL' with: (aTree child: 1) symbol! ! 
#('February 23, 2021' '03:32:15 PM' nil)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFunctionCall: )) !


!StudentCompiler methods ! 
walkDivide: aTree
    self isStatementContext ifTrue: [^self].
    self walkTree: (aTree child: 1).
    self walkTree: (aTree child: 2).
    self emitInstruction: #Divide.!    ! 
#('February 23, 2021' '03:32:30 PM' 1935072)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkDivide: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkDivide: )) !


!StudentCompiler methods ! 
walkAssign: aTree
    |name expression|
    name := (aTree child: 1) symbol.
    expression := aTree child: 2.
    self pushExpressionContext.
        self walkTree: expression.
    self popContext.
    self isExpressionContext ifTrue: [
        self emitInstruction: #Duplicate].
    self emitInstruction: #Pop with: name!    ! 
#('February 23, 2021' '03:32:42 PM' 1928460)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkAssign: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkAssign: )) !


!StudentCompiler methods ! 
walkEqual: aTree
    self isStatementContext ifTrue: [^self].
    self walkTree: (aTree child: 1).
    self walkTree: (aTree child: 2).
    self emitInstruction: #Equal.!  ! 
#('February 23, 2021' '03:32:52 PM' 1935532)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkEqual: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkEqual: )) !


!StudentCompiler methods !   
walkGreater: aTree
    self isStatementContext ifTrue: [^self].
    self walkTree: (aTree child: 1).
    self walkTree: (aTree child: 2).
    self walInstruction: #Greater.!   ! 
#('February 23, 2021' '03:33:02 PM' 1935988)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkGreater: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkGreater: )) !


!StudentCompiler methods !   
walkGreater: aTree
    self isStatementContext ifTrue: [^self].
    self walkTree: (aTree child: 1).
    self walkTree: (aTree child: 2).
    self emitInstruction: #Greater.!  ! 
#('February 23, 2021' '03:33:09 PM' 1979216)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkGreater: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkGreater: )) !


!StudentCompiler methods !   
walkInteger: aTree
    | constant |
    self isStatementContext ifTrue: [^self].
    constant := aTree symbol asInteger.
    self emitInstruction: #push with: constant.!   ! 
#('February 23, 2021' '03:34:35 PM' 1932296)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkInteger: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkInteger: )) !


 
'StudentCompiler walkExample1'!

   
'StudentCompiler walkExample2'!

!StudentCompiler methods ! 
walkFor: aTree
    |initialExpression booleanExpression incrementExpression body end whileStart fixAtEnd|
    self isExpressionContext ifTrue:[
        self designError: 'Can''t use for loop as expression'.
        ^self].
    initialExpression := aTree child: 1.
    booleanExpression := aTree child: 2.
    incrementExpression :=aTree child: 3.
    body := aTree child: 4.
    self walkTree: initialExpression.
    self pushExpressionContext "For branchIfFalse to work".
        whileStart := self nextInstruction.
        self walkTree: booleanExpression.
    self popContext.
    fixAtEnd := self nextInstruction.
    self emitInstruction: #branchIfFalse with: nil. "to End"
    self walkTree: body.
    self walkTree: incrementExpression.
    self emitBranch: #branch backTo: whileStart.
    end := self nextInstruction.
    self fixupBranch: fixAtEnd with: end.!    ! 
#('February 23, 2021' '03:36:32 PM' 1976172)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFor: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFor: )) !


 
'StudentCompiler walkExample2'!

!StudentCompiler methods ! 
walkInteger: aTree
    | constant |
    self isStatementContext ifTrue: [^self].
    constant := aTree symbol asInteger.
    self emitInstruction: #Push with: constant.!   ! 
#('February 23, 2021' '03:37:11 PM' 1980144)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkInteger: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkInteger: )) !


!StudentCompiler methods !   
walkFor: aTree
    |initialExpression booleanExpression incrementExpression body end whileStart fixAtEnd|
    self isExpressionContext ifTrue:[
        self designError: 'Can''t use for loop as expression'.
        ^self].
    initialExpression := aTree child: 1.
    booleanExpression := aTree child: 2.
    incrementExpression :=aTree child: 3.
    body := aTree child: 4.
    self walkTree: initialExpression.
    self pushExpressionContext "For branchIfFalse to work".
        whileStart := self nextInstruction.
        self walkTree: booleanExpression.
    self popContext.
    fixAtEnd := self nextInstruction.
    self emitInstruction: #branchIfFalse with: nil. "to End"
    self walkTree: body.
    self walkTree: incrementExpression.
    self emitBranch: #Branch backTo: whileStart.
    end := self nextInstruction.
    self fixupBranch: fixAtEnd with: end.!    ! 
#('February 23, 2021' '03:37:36 PM' 1980680)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFor: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFor: )) !


!StudentCompiler methods !   
walkFor: aTree
    |initialExpression booleanExpression incrementExpression body end whileStart fixAtEnd|
    self isExpressionContext ifTrue:[
        self designError: 'Can''t use for loop as expression'.
        ^self].
    initialExpression := aTree child: 1.
    booleanExpression := aTree child: 2.
    incrementExpression :=aTree child: 3.
    body := aTree child: 4.
    self walkTree: initialExpression.
    self pushExpressionContext "For branchIfFalse to work".
        whileStart := self nextInstruction.
        self walkTree: booleanExpression.
    self popContext.
    fixAtEnd := self nextInstruction.
    self emitInstruction: #branchIfFalse with: nil. "to End"
    self walkTree: body.
    self walkTree: incrementExpression.
    self emitBranch: #branch backTo: whileStart.
    end := self nextInstruction.
    self fixupBranch: fixAtEnd with: end.!    ! 
#('February 23, 2021' '03:38:02 PM' 1982344)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFor: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFor: )) !


!StudentCompiler methods !   
emitBranch: opCode backTo: location
    ^self emitInstruction: opCode
        with: (location - self nextInstruction)!    ! 
#('February 23, 2021' '03:39:45 PM' 1969536)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' emitBranch:backTo: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' emitBranch:backTo: )) !


!Transition methods !
printOn: aStream
    aStream cr;<<'      ';<<'for: ';<<self transitionName;<<' goto: ';<<goto stateNumber;<<';'.!  ! 
#('February 23, 2021' '03:41:57 PM' 1918612)!

(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('printing' printOn: )) !

(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('printing' printOn: )) !


"evaluate" 
(CodeFiler organizerFor: 'Transition')  addCategory: 'queryMethods' before: nil!

!Transition methods ! 
isAction
    ^self action ~= nil!  ! 
#('February 23, 2021' '03:42:31 PM' nil)!

(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('queryMethods' isAction )) !


"evaluate"   
Transition removeSelector: #isAction!

"evaluate"   
(CodeFiler organizerFor: Transition) removeCategory: 'queryMethods' ifAbsent: [nil]!

!TransitionName methods ! 
printOn: aStream
    self isAction 
        ifTrue:[aStream<< ' semanticAction: ';<<self action;<<' parameters: ';<< self parameters asArray.^self].
    self hasAttributes
        ifTrue:[aStream<<'#';<< self symbol;<<' properties: ';<<self attributes.^self].
    aStream<<self name;<<' ';<<self state stateNumber.^self!   ! 
#('February 23, 2021' '03:44:01 PM' 1954028)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('printing' printOn: )) !

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('printing' printOn: )) !


"evaluate" 
(CodeFiler organizerFor: FiniteStateMachine class) removeCategory: 'examples' ifAbsent: [nil]!

"evaluate"  
FiniteStateMachine class removeSelector: #concatenateAll:!

"evaluate"  
FiniteStateMachine class removeSelector: #orAll:!

"evaluate"   
(CodeFiler organizerFor: FiniteStateMachine class) rename: 'fsm' to: 'examples'!

!FiniteStateMachine class methods !   
questionMark
    "FiniteStateMachine questionMark"
    |fsm state1 state2 state3 transition1 transition2|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    transition1 := Transition new name: 'a'; goto: state2.
    transition2 := Transition new name: 'a'; goto: state3.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2; add: state3. 
    ^fsm renumber.!    ! 
#('February 23, 2021' '03:48:01 PM' 1962264)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' questionMark )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' questionMark )) !


!FiniteStateMachine class methods !
questionMark
    "FiniteStateMachine questionMark"
    |fsm state1 state2 state3 transition1 transition2|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    transition1 := Transition new transitionName: 'a'; goto: state2.
    transition2 := Transition new transitionName: 'a'; goto: state3.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2; add: state3. 
    ^fsm renumber.!    ! 
#('February 23, 2021' '03:49:47 PM' 1986876)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' questionMark )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' questionMark )) !


"evaluate" 
(CodeFiler organizerFor: 'Transition class')  addCategory: 'get/set' before: nil!


!Transition methods !  
transitionName
    ^transitionName!    !

!Transition methods !
transitionName: aTransitionName
    transitionName := aTransitionName! !

!Transition methods !
goto
    ^goto!    !

!Transition methods !
goto: aState
    goto := aState!   !
(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('get/set' transitionName: goto: transitionName goto )) !

(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('get/set' transitionName: goto: transitionName goto )) !


"evaluate"   
(CodeFiler organizerFor: TransitionName) removeCategory: 'initializing' ifAbsent: [nil]!

!TransitionName methods ! 
name
    ^name!    ! 
#('February 23, 2021' '03:54:03 PM' nil)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' name )) !


!TransitionName methods ! 
symbol
    ^symbol!    ! 
#('February 23, 2021' '03:54:12 PM' 1916136)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' symbol )) !

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' symbol )) !


!TransitionName methods !
symbol
    ^symbol!    ! 
#('February 23, 2021' '03:54:21 PM' 1989708)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' symbol )) !

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' symbol )) !


!TransitionName methods !
name: aString
    name := aString! ! 
#('February 23, 2021' '03:54:29 PM' nil)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' name: )) !


!TransitionName methods !
state: aState
    state := aState! ! 
#('February 23, 2021' '03:54:45 PM' nil)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' state: )) !


!TransitionName methods !   
state
    ^state!  ! 
#('February 23, 2021' '03:54:58 PM' nil)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' state )) !


"evaluate"   
(CodeFiler organizerFor: Transition class) removeCategory: 'get/set' ifAbsent: [nil]!

 
'FiniteStateMachine questionMark'!

"evaluate"  
(CodeFiler organizerFor: Transition class) removeCategory: 'instance creation' ifAbsent: [nil]!

   
'FiniteStateMachine questionMark'!

!FiniteStateMachine class methods ! 
example1
    "FiniteStateMachine example1"
    |fsm state1 state2 state3 transition1 transition2|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    transition1 := Transition new transitionName: 'a'; goto: state2.
    transition2 := Transition new transitionName: 'a'; goto: state3.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2; add: state3. 
    ^fsm renumber.!    ! 
#('February 23, 2021' '03:58:33 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !


"evaluate" 
(CodeFiler setAndInitializeOrganizerFor: FiniteStateMachine class to: (MethodBasedOrganizer fromArray: #(('instance creation' new)
('fsmClassMethods' epsilon forParser: star)
('examples' example1 plus questionMark )))).!

!FiniteStateMachine class methods ! 
example2
    "FiniteStateMachine example2"
    |fsm state1 state2 transition1 transition2|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: false.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    transition1 := Transition new name: 'a'; goto: state2.
    transition2 := Transition new name: 'a'; goto: state2.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2. 
    ^fsm renumber.!    ! 
#('February 23, 2021' '03:59:47 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example2 )) !


"evaluate" 
FiniteStateMachine class removeSelector: #plus!

"evaluate" 
FiniteStateMachine class removeSelector: #questionMark!

!FiniteStateMachine class methods !
forParser: aTransitionName
    "FiniteStateMachine forParser"
    |fsm state1 state2 transition|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: false.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    transition := Transition new name: aTransitionName; goto: state2.
    state1 transitions add: transition.
    fsm states add: state1; add: state2. 
    ^fsm renumber.!  ! 
#('February 23, 2021' '04:00:30 PM' 1952608)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('fsmClassMethods' forParser: )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('fsmClassMethods' forParser: )) !


!FiniteStateMachine class methods !  
forParser: aTransitionName
    |fsm state1 state2 transition|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: false.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    transition := Transition new name: aTransitionName; goto: state2.
    state1 transitions add: transition.
    fsm states add: state1; add: state2. 
    ^fsm renumber.!  ! 
#('February 23, 2021' '04:00:57 PM' 1993140)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('fsmClassMethods' forParser: )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('fsmClassMethods' forParser: )) !


"evaluate"   
FiniteStateMachine class removeSelector: #forParser:!

!FiniteStateMachine class methods !  
star
    "FiniteStateMachine star"
    |fsm state1 transition1|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    transition1 := Transition new name: 'a'; goto: state1.
    state1 transitions add: transition1.
    fsm states add: state1. 
    ^fsm renumber.!   ! 
#('February 23, 2021' '04:03:13 PM' 1965492)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('fsmClassMethods' star )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('fsmClassMethods' star )) !


!FiniteStateMachine class methods !  
star
    "FiniteStateMachine star"
    |fsm state1 transition1|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    transition1 := Transition new transitionName: 'a'; goto: state1.
    state1 transitions add: transition1.
    fsm states add: state1. 
    ^fsm renumber.! ! 
#('February 23, 2021' '04:03:33 PM' 1994728)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('fsmClassMethods' star )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('fsmClassMethods' star )) !


!FiniteStateMachine class methods !  
example2
    "FiniteStateMachine example2"
    |fsm state1 state2 transition1 transition2|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: false.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    transition1 := Transition new transitionName: 'a'; goto: state2.
    transition2 := Transition new transitionName: 'a'; goto: state2.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2. 
    ^fsm renumber.!    ! 
#('February 23, 2021' '04:04:13 PM' 1992264)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example2 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example2 )) !


   
'FiniteStateMachine example2'!

!FiniteStateMachine class methods ! 
example3
    "FiniteStateMachine example1"
    |fsm state1 state2 state3 state4 state5 transition1 transition2 transition3 transition4|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    state4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    transition1 := Transition new transitionName: 'a'; goto: state2.
    transition2 := Transition new transitionName: 'S'; goto: state5.
    transition3 := Transition new transitionName: 'a'; goto: state3.
    transition4 := Transition new transitionName: 'a'; goto: state4.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2; add: state3. 
    ^fsm renumber.! ! 
#('February 23, 2021' '04:08:42 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 )) !


!FiniteStateMachine class methods !
example3
    "FiniteStateMachine example3"
    |fsm state1 state2 state3 state4 state5 transition1 transition2 transition3 transition4|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    state4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    transition1 := Transition new transitionName: 'a'; goto: state2.
    transition2 := Transition new transitionName: 'S'; goto: state5.
    transition3 := Transition new transitionName: 'a'; goto: state3.
    transition4 := Transition new transitionName: 'a'; goto: state4.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2; add: state3. 
    ^fsm renumber.! ! 
#('February 23, 2021' '04:08:49 PM' 1996904)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 )) !


   
'FiniteStateMachine example3'!

!FiniteStateMachine class methods ! 
example3
    "FiniteStateMachine example3"
    |fsm state1 state2 state3 state4 state5 transition1 transition2 transition3 transition4|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    state4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    transition1 := Transition new transitionName: 'a'; goto: state2.
    transition2 := Transition new transitionName: 'S'; goto: state5.
    transition3 := Transition new transitionName: 'a'; goto: state3.
    transition4 := Transition new transitionName: 'a'; goto: state4.
    state1 transitions add: transition1; add: transition2.
    state2 transitions add: transition3.
    state3 transitions add: transition4.
    fsm states add: state1; add: state2; add: state3; add: state4; add: state5.
    ^fsm renumber.!    ! 
#('February 23, 2021' '04:10:32 PM' 1998088)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 )) !


   
'FiniteStateMachine example3'!

!FiniteStateMachine methods !   
printOn: aStream

    aStream << 'FSM'.
    self states do:[ :state | state printOn: aStream ].
    aStream cr;<< 'END'.!   ! 
#('February 23, 2021' '04:11:09 PM' 1922008)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('printing' printOn: )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('printing' printOn: )) !


"evaluate" 
FiniteStateMachine class removeSelector: #star!

   
'FiniteStateMachine example1'!


'FiniteStateMachine example1'!

!FiniteStateMachine class methods ! 
example1
    "FiniteStateMachine example1"
    |fsm state1 state2 state3 transition1 transition2|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    transition1 := Transition new transitionName: '#S properties: "RSN" '; goto: state2.
    transition2 := Transition new transitionName: '#a properties: "RSN" '; goto: state3.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2; add: state3. 
    ^fsm renumber.!    ! 
#('February 23, 2021' '04:13:23 PM' 1991168)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !


   
'FiniteStateMachine example1'!

!FiniteStateMachine class methods ! 
example3
    "FiniteStateMachine example3"
    |fsm state1 state2 state3 state4 state5 transition1 transition2 transition3 transition4|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    state4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    transition1 := Transition new transitionName: '#S properties: "RSN" '; goto: state2.
    transition2 := Transition new transitionName: '#a properties: "RSN" '; goto: state5.
    transition3 := Transition new transitionName: '#a properties: "L" '; goto: state3.
    transition4 := Transition new transitionName: 'semanticAction: #buildTree: parameters: #("list") '; goto: state4.
    state1 transitions add: transition1; add: transition2.
    state2 transitions add: transition3.
    state3 transitions add: transition4.
    fsm states add: state1; add: state2; add: state3; add: state4; add: state5.
    ^fsm renumber.! ! 
#('February 23, 2021' '04:14:16 PM' 1999416)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 )) !


   
'FiniteStateMachine example3'!

!Attribute class methods !  
parserTerminalDefaultAttributes
    "Attribute parserTerminalDefaultAttributes"
    ^Attribute new isRead: true; isKeep: false; isNode: false; isStack: true.!    ! 
#('February 23, 2021' '04:18:31 PM' 1947144)!

(CodeFiler organizerFor: Attribute class) reorganizeFrom: #(
('defaultAttributes' parserTerminalDefaultAttributes )) !

(CodeFiler organizerFor: Attribute class) reorganizeFrom: #(
('defaultAttributes' parserTerminalDefaultAttributes )) !


"evaluate"   
(CodeFiler organizerFor: Attribute class) removeCategory: 'instance creation' ifAbsent: [nil]!


'Attribute parserTerminalDefaultAttributes'!

  
'Attribute parserTerminalDefaultAttributes'!

!FiniteStateMachine class methods !   
example3
    "FiniteStateMachine example3"
    |fsm state1 state2 state3 state4 state5 transition1 transition2 transition3 transition4|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    state4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    transition1 := Transition new transitionName: '#S properties: '; goto: state2.
    transition2 := Transition new transitionName: '#a properties: "RSN" '; goto: state5.
    transition3 := Transition new transitionName: '#a properties: "L" '; goto: state3.
    transition4 := Transition new transitionName: 'semanticAction: #buildTree: parameters: #("list") '; goto: state4.
    state1 transitions add: transition1; add: transition2.
    state2 transitions add: transition3.
    state3 transitions add: transition4.
    fsm states add: state1; add: state2; add: state3; add: state4; add: state5.
    ^fsm renumber.!   ! 
#('February 23, 2021' '04:26:11 PM' 2002416)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 )) !


!FiniteStateMachine class methods !
example1
    "FiniteStateMachine example1"
    |fsm state1 state2 state3 transition1 transition2|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    transition1 := Transition new transitionName isRead: True; goto: state2.
    transition2 := Transition new transitionName: '#a properties: "RSN" '; goto: state3.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2; add: state3. 
    ^fsm renumber.!    ! 
#('February 23, 2021' '04:28:28 PM' 2001376)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !


!FiniteStateMachine class methods !
example1
    "FiniteStateMachine example1"
    |fsm state1 state2 state3 transition1 transition2|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    transition1 := Transition new transitionName: '#a properties: "RSN" '; goto: state2.
    transition2 := Transition new transitionName: '#a properties: "RSN" '; goto: state3.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2; add: state3. 
    ^fsm renumber.!    ! 
#('February 23, 2021' '04:29:38 PM' 2006124)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !


"evaluate" 
TransitionName removeFromSystem!

"evaluate"
CodeFiler removeOrganizerFor: #TransitionName!

"evaluate"  
CodeFiler removeOrganizerFor: #'TransitionName class'!

"define class"  

Object subclass: #TransitionName
  instanceVariableNames: 
    ' symbolOrPair attributes action parameters isRootBuilding '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: TransitionName to: ''!


"evaluate" 

Object subclass: #TransitionName
  instanceVariableNames: 
    ' symbolOrPair attributes action parameters isRootBuilding'
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Grammar Constructor' )
  comment: ''!


!TransitionName methods ! 
symbolOrPair
    ^symbolOrPair!    !

!TransitionName methods !
symbolOrPair: aSymbol
    symbolOrPair := aSymbol! !

!TransitionName methods !
action
    ^action!    !

!TransitionName methods !
action: aSymbol
    action := aSymbol! !

!TransitionName methods !
attributes
    ^attributes!    !

!TransitionName methods !
attributes: aCollection
    attributes := aCollection! !

!TransitionName methods !
parameters
    ^parameters!    !

!TransitionName methods !
parameters: aCollection
    parameters := aCollection! !

!TransitionName methods !
isRootBuilding
    ^isRootBuilding!    !

!TransitionName methods !
isRootBuilding: aBoolean
    isRootBuilding := aBoolean!   !

"evaluate"   
(CodeFiler organizerFor: TransitionName) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' attributes: isRootBuilding parameters action: parameters: symbolOrPair: isRootBuilding: attributes symbolOrPair action )) !

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' attributes: isRootBuilding parameters action: parameters: symbolOrPair: isRootBuilding: attributes symbolOrPair action )) !


"evaluate"   
(CodeFiler organizerFor: 'TransitionName')  addCategory: 'queryMethods' before: nil!

!TransitionName methods ! 
isAction
    ^self action ~= nil!  ! 
#('February 23, 2021' '04:34:08 PM' nil)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('queryMethods' isAction )) !


!TransitionName methods !
hasAttributes
    ^self attributes ~= nil! ! 
#('February 23, 2021' '04:34:22 PM' nil)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('queryMethods' hasAttributes )) !


!TransitionName methods !   
isPair
    ^self name ~= nil!  ! 
#('February 23, 2021' '04:34:31 PM' nil)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('queryMethods' isPair )) !


"evaluate" 
(CodeFiler organizerFor: 'TransitionName')  addCategory: 'printing' before: nil!

!TransitionName methods ! 
printOn: aStream
    self isAction 
        ifTrue:[aStream<< ' semanticAction: ';<<self action;<<' parameters: ';<< self parameters asArray.^self].
    self hasAttributes
        ifTrue:[aStream<<'#';<< self symbol;<<' properties: ';<<self attributes.^self].
    aStream<<self name;<<' ';<<self state stateNumber.^self!   ! 
#('February 23, 2021' '04:37:01 PM' nil)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('printing' printOn: )) !


!TransitionName methods !
printOn: aStream
    self isAction 
        ifTrue:[aStream<< ' semanticAction: ';<<self action;<<' parameters: ';<< self parameters asArray.^self].
    self hasAttributes
        ifTrue:[aStream<<'#';<< self symbolOrPair;<<' properties: ';<<self attributes.^self].!  ! 
#('February 23, 2021' '04:40:18 PM' 2010884)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('printing' printOn: )) !

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('printing' printOn: )) !


!TransitionName methods !  
isPair: aCollection
    ^self ~= nil!  ! 
#('February 23, 2021' '04:51:40 PM' nil)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('queryMethods' isPair: )) !


!TransitionName methods ! 
isSymbol: aSymbol
    ^self ~= nil!    ! 
#('February 23, 2021' '04:52:00 PM' nil)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('queryMethods' isSymbol: )) !


"evaluate"  
TransitionName removeSelector: #isPair!

   
'FiniteStateMachine example1'!

!FiniteStateMachine class methods ! 
example1
    "FiniteStateMachine example1"
    |fsm state1 state2 state3 transition1 transition2 label1|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    (transition1 := Transition new) goto: state2.
    label1 := (Transition new) symbolOrPair: #a
    transition1 TransitionName: label1.
    transition2 := Transition new transitionName: '#a properties: "RSN" '; goto: state3.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2; add: state3. 
    ^fsm renumber.!  ! 
#('February 23, 2021' '04:59:49 PM' 2007112)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !


"evaluate" 
TransitionName removeSelector: #isPair:!

"evaluate"
TransitionName removeSelector: #isSymbol:!

!FiniteStateMachine class methods ! 
example1
    "FiniteStateMachine example1"
    |fsm state1 state2 state3 transition1 transition2 label1|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    transition1 Transition new transitionName: #a; goto: state2.
    transition2 := Transition new transitionName: '#a properties: "RSN" '; goto: state3.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2; add: state3. 
    ^fsm renumber.! ! 
#('February 23, 2021' '05:03:50 PM' 2012448)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !


!FiniteStateMachine class methods !
example1
    "FiniteStateMachine example1"
    |fsm state1 state2 state3 transition1 transition2 label1|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    transition1:= Transition new transitionName: #a; goto: state2.
    transition2 := Transition new transitionName: '#a properties: "RSN" '; goto: state3.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2; add: state3. 
    ^fsm renumber.!   ! 
#('February 23, 2021' '05:03:56 PM' 2013620)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !


!FiniteStateMachine class methods !
example1
    "FiniteStateMachine example1"
    |fsm state1 state2 state3 transition1 transition2|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    transition1:= Transition new transitionName: #a; goto: state2.
    transition2 := Transition new transitionName: '#a properties: "RSN" '; goto: state3.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2; add: state3. 
    ^fsm renumber.!  ! 
#('February 23, 2021' '05:04:02 PM' 2014600)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !


   
'FiniteStateMachine example1'!

!TransitionName methods !   
attributes: aAttribute
    attributes := aAttribute!   ! 
#('February 23, 2021' '05:07:14 PM' 2009132)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' attributes: )) !

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' attributes: )) !


!TransitionName methods !  
attributes: aCollection
    attributes := aCollection! ! 
#('February 23, 2021' '05:12:35 PM' 2016592)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' attributes: )) !

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' attributes: )) !


!FiniteStateMachine class methods !
example1
    "FiniteStateMachine example1"
    |fsm state1 state2 state3 transition1 transition2 label1|
    fsm := FiniteStateMachine new.
    label1 := TransitionName new
        symbolOrPair: #a;
        attributes: [Attribute parserTerminalAttributes].
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    transition1:= Transition new transitionName: #a; goto: state2.
    transition2 := Transition new transitionName: '#a properties: "RSN" '; goto: state3.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2; add: state3. 
    ^fsm renumber.!   ! 
#('February 23, 2021' '05:14:51 PM' 2015584)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !


!FiniteStateMachine class methods !
example1
    "FiniteStateMachine example1"
    |fsm state1 state2 state3 transition1 transition2 label1|
    fsm := FiniteStateMachine new.
    label1 := TransitionName new
        symbolOrPair: #a;
        attributes: [Attribute parserNonterminalDefaultAttributes].
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    transition1:= Transition new transitionName: #a; goto: state2.
    transition2 := Transition new transitionName: '#a properties: "RSN" '; goto: state3.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2; add: state3. 
    ^fsm renumber.! ! 
#('February 23, 2021' '05:15:23 PM' 2017248)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !


!FiniteStateMachine class methods !
example1
    "FiniteStateMachine example1"
    |fsm state1 state2 state3 transition1 transition2 label1|
    fsm := FiniteStateMachine new.
    label1 := TransitionName new
        symbolOrPair: #a;
        attributes: [Attribute parserNonterminalDefaultAttributes].
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    transition1:= Transition new transitionName: label1; goto: state2.
    transition2 := Transition new transitionName: '#a properties: "RSN" '; goto: state3.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2; add: state3. 
    ^fsm renumber.! ! 
#('February 23, 2021' '05:15:55 PM' 2018352)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !


   
'FiniteStateMachine example1'!

!TransitionName methods !   
attributes: aAttribute
    attributes := aAttribute!   ! 
#('February 23, 2021' '05:17:37 PM' 2016916)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' attributes: )) !

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' attributes: )) !


   
'FiniteStateMachine example1'!

!FiniteStateMachine class methods ! 
example1
    "FiniteStateMachine example1"
    |fsm state1 state2 state3 transition1 transition2 label1|
    fsm := FiniteStateMachine new.
    label1 := TransitionName new
        symbolOrPair: #a;
        attributes: Attribute parserNonterminalDefaultAttributes.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    transition1:= Transition new transitionName: label1; goto: state2.
    transition2 := Transition new transitionName: '#a properties: "RSN" '; goto: state3.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2; add: state3. 
    ^fsm renumber.!   ! 
#('February 23, 2021' '05:18:28 PM' 2019464)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !


   
'FiniteStateMachine example1'!

!FiniteStateMachine class methods ! 
example1
    "FiniteStateMachine example1"
    |fsm state1 state2 state3 transition1 transition2 label1 label2|
    fsm := FiniteStateMachine new.
    label1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    label2 := TransitionName new symbolOrPair: #a; attributes: Attribute parserNonterminalDefaultAttributes.    
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    transition1:= Transition new transitionName: label1; goto: state2.
    transition2 := Transition new transitionName: label2; goto: state3.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2; add: state3. 
    ^fsm renumber.! ! 
#('February 23, 2021' '05:20:25 PM' 2020984)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !


!TransitionName methods !  
attributes: aCollection
    attributes := aCollection! ! 
#('February 23, 2021' '05:20:47 PM' 2020612)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' attributes: )) !

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' attributes: )) !


   
'FiniteStateMachine example1'!

!FiniteStateMachine class methods ! 
example1
    "FiniteStateMachine example1"
    |fsm state1 state2 state3 transition1 transition2 label1 label2|
    fsm := FiniteStateMachine new.
    label1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    label2 := TransitionName new symbolOrPair: #a; action: #buildTree.    
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    transition1:= Transition new transitionName: label1; goto: state2.
    transition2 := Transition new transitionName: label2; goto: state3.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2; add: state3. 
    ^fsm renumber.!   ! 
#('February 23, 2021' '05:23:02 PM' 2022140)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !


   
'FiniteStateMachine example1'!

!TransitionName methods !   
printOn: aStream
    self isAction 
        ifTrue:[aStream<< ' semanticAction: ';<<self action;<<' parameters: ';<< self parameters. ^self].
    self hasAttributes
        ifTrue:[aStream<<'#';<< self symbolOrPair;<<' properties: ';<<self attributes.^self].! ! 
#('February 23, 2021' '05:25:02 PM' 2011380)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('printing' printOn: )) !

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('printing' printOn: )) !


   
'FiniteStateMachine example1'!


'FiniteStateMachine example1'!

!TransitionName methods !   
printOn: aStream
    self isAction 
        ifTrue:[aStream<< ' semanticAction: ';<<'#';<< self action;<<' parameters: ';<< self parameters. ^self].
    self hasAttributes
        ifTrue:[aStream<<'#';<< self symbolOrPair;<<' properties: ';<<self attributes.^self].!  ! 
#('February 23, 2021' '05:28:00 PM' 2024900)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('printing' printOn: )) !

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('printing' printOn: )) !


   
'FiniteStateMachine example1'!

!FiniteStateMachine class methods ! 
example1
    "FiniteStateMachine example1"
    |fsm state1 state2 state3 transition1 transition2 label1 label2|
    fsm := FiniteStateMachine new.
    label1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    label2 := TransitionName new symbolOrPair: #a; action: #buildTree; parameters.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    transition1:= Transition new transitionName: label1; goto: state2.
    transition2 := Transition new transitionName: label2; goto: state3.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2; add: state3. 
    ^fsm renumber.!   ! 
#('February 23, 2021' '05:34:13 PM' 2023704)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !


!FiniteStateMachine class methods !
example1
    "FiniteStateMachine example1"
    |fsm state1 state2 state3 transition1 transition2 label1 label2|
    fsm := FiniteStateMachine new.
    label1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    label2 := TransitionName new symbolOrPair: #a; action: #buildTree; parameters: 1.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    transition1:= Transition new transitionName: label1; goto: state2.
    transition2 := Transition new transitionName: label2; goto: state3.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2; add: state3. 
    ^fsm renumber.!    ! 
#('February 23, 2021' '05:34:27 PM' 2026088)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !


!FiniteStateMachine class methods !
example1
    "FiniteStateMachine example1"
    |fsm state1 state2 state3 transition1 transition2 label1 label2|
    fsm := FiniteStateMachine new.
    label1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    label2 := TransitionName new symbolOrPair: #a; action: #buildTree; parameters: 1.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    transition1:= Transition new transitionName: label1; goto: state2.
    transition2 := Transition new transitionName: label2; goto: state3.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2; add: state3. 
    ^fsm renumber.!    ! 
#('February 23, 2021' '05:34:49 PM' 2027260)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !


!FiniteStateMachine class methods !
example1
    "FiniteStateMachine example1"
    |fsm state1 state2 state3 transition1 transition2 label1 label2|
    fsm := FiniteStateMachine new.
    label1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    label2 := TransitionName new symbolOrPair: #a; action: #buildTree; parameters: #(1 2 4 7 9).
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    transition1:= Transition new transitionName: label1; goto: state2.
    transition2 := Transition new transitionName: label2; goto: state3.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2; add: state3. 
    ^fsm renumber.! ! 
#('February 23, 2021' '05:35:49 PM' 2028436)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !


   
'FiniteStateMachine example1'!

!TransitionName methods !   
printOn: aStream
    self isAction 
        ifTrue:[aStream<< ' semanticAction: ';<<'#';<< self action;<<' parameters: ';<<'#';<< self parameters. ^self].
    self hasAttributes
        ifTrue:[aStream<<'#';<< self symbolOrPair;<<' properties: ';<<self attributes.^self].!    ! 
#('February 23, 2021' '05:37:49 PM' 2025504)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('printing' printOn: )) !

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('printing' printOn: )) !


   
'FiniteStateMachine example1'!

!FiniteStateMachine class methods ! 
example4
    "FiniteStateMachine example1"
    |fsm s1 s2 s3 t1 t2 l1 l2|
    fsm := FiniteStateMachine new.
    l1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    l2 := TransitionName new symbolOrPair: #a; action: #buildTree; parameters: #("list").
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    t1:= Transition new transitionName: l1; goto: s2.
    t2 := Transition new transitionName: l2; goto: s3.
    s1 transitions add: t1.
    s2 transitions add: t2.
    fsm states add: s1; add: s2; add: s3. 
    ^fsm renumber.!  ! 
#('February 23, 2021' '05:40:11 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


!FiniteStateMachine class methods !
example4
    "FiniteStateMachine example1"
    |fsm s1 s2 s3 t1 t2 n1 n2|
    fsm := FiniteStateMachine new.
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    n2 := TransitionName new symbolOrPair: #a; action: #buildTree; parameters: #("list").
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    t1:= Transition new transitionName: n1; goto: s2.
    t2 := Transition new transitionName: n2; goto: s3.
    s1 transitions add: t1.
    s2 transitions add: t2.
    fsm states add: s1; add: s2; add: s3. 
    ^fsm renumber.!  ! 
#('February 23, 2021' '05:40:49 PM' 2031420)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


!FiniteStateMachine class methods !
example4
    "FiniteStateMachine example1"
    |fsm s1 s2 s3 t1 t2 n1 n2 n3 n4|
    fsm := FiniteStateMachine new.
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    n2 := TransitionName new symbolOrPair: #a; attributes: Attribute parserNonterminalDefaultAttributes.
    n3 := TransitionName new symbolOrPair: #a; attributes: Attribute .
    n4 := TransitionName new symbolOrPair: #a; action: #buildTree; parameters: #("list").
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    t1:= Transition new transitionName: n1; goto: s2.
    t2 := Transition new transitionName: n2; goto: s3.
    s1 transitions add: t1.
    s2 transitions add: t2.
    fsm states add: s1; add: s2; add: s3. 
    ^fsm renumber.!  ! 
#('February 23, 2021' '05:42:15 PM' 2032368)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


!Attribute class methods ! 
parserTerminalDefaultAttributes
    ^Attribute new isRead: true; isKeep: false; isNode: false; isStack: true.! ! 
#('February 23, 2021' '05:42:50 PM' 2003928)!

(CodeFiler organizerFor: Attribute class) reorganizeFrom: #(
('defaultAttributes' parserTerminalDefaultAttributes )) !

(CodeFiler organizerFor: Attribute class) reorganizeFrom: #(
('defaultAttributes' parserTerminalDefaultAttributes )) !


!Attribute class methods !   
readKeep
    ^Attribute new isRead: true; isKeep: true.!   ! 
#('February 23, 2021' '05:43:37 PM' nil)!

(CodeFiler organizerFor: Attribute class) reorganizeFrom: #(
('defaultAttributes' readKeep )) !


!Attribute class methods ! 
readNoKeep
    ^Attribute new isRead: true; isKeep: false; isNode: false; isStack: false.! ! 
#('February 23, 2021' '05:44:29 PM' nil)!

(CodeFiler organizerFor: Attribute class) reorganizeFrom: #(
('defaultAttributes' readNoKeep )) !


!Attribute class methods !   
readKeep
    ^Attribute new isRead: true; isKeep: true; isNode: false; isStack: false.!    ! 
#('February 23, 2021' '05:44:51 PM' 2035092)!

(CodeFiler organizerFor: Attribute class) reorganizeFrom: #(
('defaultAttributes' readKeep )) !

(CodeFiler organizerFor: Attribute class) reorganizeFrom: #(
('defaultAttributes' readKeep )) !


!Attribute class methods ! 
look
    ^Attribute new isRead: false; isKeep: false; isNode: false; isStack: false.!  ! 
#('February 23, 2021' '05:45:21 PM' nil)!

(CodeFiler organizerFor: Attribute class) reorganizeFrom: #(
('defaultAttributes' look )) !


!FiniteStateMachine class methods !
example4
    "FiniteStateMachine example1"
    |fsm s1 s2 s3 s4 s5 t1 t2 t3 t4 n1 n2 n3 n4|
    fsm := FiniteStateMachine new.
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute readKeep.
    n2 := TransitionName new symbolOrPair: #a; attributes: Attribute readKeep.
    n3 := TransitionName new symbolOrPair: #a; attributes: Attribute readNoKeep.
    n4 := TransitionName new symbolOrPair: #a; action: #buildTree; parameters: #("list").
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    t1:= Transition new transitionName: n1; goto: s2.
    t2 := Transition new transitionName: n2; goto: s5.
    t3 := Transition new transitionName: n3; goto: s3.
    t4 := Transition new transitionName: n4; goto: s4.
    s1 transitions add: t1; t2.
    s2 transitions add: t3.
    s3 transitions add: t4.
    fsm states add: s1; add: s2; add: s3.
    ^fsm renumber.!   ! 
#('February 23, 2021' '05:54:32 PM' 2033420)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


!FiniteStateMachine class methods !
example4
    "FiniteStateMachine example1"
    |fsm s1 s2 s3 s4 s5 t1 t2 t3 t4 n1 n2 n3 n4|
    fsm := FiniteStateMachine new.
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute readKeep.
    n2 := TransitionName new symbolOrPair: #a; attributes: Attribute readKeep.
    n3 := TransitionName new symbolOrPair: #a; attributes: Attribute readNoKeep.
    n4 := TransitionName new symbolOrPair: #a; action: #buildTree; parameters: #("list").
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    t1:= Transition new transitionName: n1; goto: s2.
    t2 := Transition new transitionName: n2; goto: s5.
    t3 := Transition new transitionName: n3; goto: s3.
    t4 := Transition new transitionName: n4; goto: s4.
    s1 transitions add: t1; t2.
    s2 transitions add: t3.
    s3 transitions add: t4.
    fsm states add: s1; add: s2; add: s3; add: s4.
    ^fsm renumber.!  ! 
#('February 23, 2021' '05:54:59 PM' 2036256)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


!FiniteStateMachine class methods !
example4
    "FiniteStateMachine example1"
    |fsm s1 s2 s3 s4 s5 t1 t2 t3 t4 n1 n2 n3 n4|
    fsm := FiniteStateMachine new.
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute readKeep.
    n2 := TransitionName new symbolOrPair: #a; attributes: Attribute readKeep.
    n3 := TransitionName new symbolOrPair: #a; attributes: Attribute readNoKeep.
    n4 := TransitionName new symbolOrPair: #a; action: #buildTree; parameters: #("list").
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    t1:= Transition new transitionName: n1; goto: s2.
    t2 := Transition new transitionName: n2; goto: s5.
    t3 := Transition new transitionName: n3; goto: s3.
    t4 := Transition new transitionName: n4; goto: s4.
    s1 transitions add: t1; t2.
    s2 transitions add: t3.
    s3 transitions add: t4.
    fsm states add: s1; add: s2; add: s3; add: s4; add: s5.
    ^fsm renumber.! ! 
#('February 23, 2021' '05:55:09 PM' 2037752)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


   
'FiniteStateMachine example1'!

!FiniteStateMachine class methods ! 
example4
    "FiniteStateMachine example4"
    |fsm s1 s2 s3 s4 s5 t1 t2 t3 t4 n1 n2 n3 n4|
    fsm := FiniteStateMachine new.
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute readKeep.
    n2 := TransitionName new symbolOrPair: #a; attributes: Attribute readKeep.
    n3 := TransitionName new symbolOrPair: #a; attributes: Attribute readNoKeep.
    n4 := TransitionName new symbolOrPair: #a; action: #buildTree; parameters: #("list").
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    t1:= Transition new transitionName: n1; goto: s2.
    t2 := Transition new transitionName: n2; goto: s5.
    t3 := Transition new transitionName: n3; goto: s3.
    t4 := Transition new transitionName: n4; goto: s4.
    s1 transitions add: t1; t2.
    s2 transitions add: t3.
    s3 transitions add: t4.
    fsm states add: s1; add: s2; add: s3; add: s4; add: s5.
    ^fsm renumber.! ! 
#('February 23, 2021' '05:55:23 PM' 2039256)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


!FiniteStateMachine class methods !
example4
    "FiniteStateMachine example4"
    |fsm s1 s2 s3 s4 s5 t1 t2 t3 t4 n1 n2 n3 n4|
    fsm := FiniteStateMachine new.
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute readKeep.
    n2 := TransitionName new symbolOrPair: #a; attributes: Attribute readKeep.
    n3 := TransitionName new symbolOrPair: #a; attributes: Attribute readNoKeep.
    n4 := TransitionName new symbolOrPair: #a; action: #buildTree; parameters: #("list").
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    t1:= Transition new transitionName: n1; goto: s2.
    t2 := Transition new transitionName: n2; goto: s5.
    t3 := Transition new transitionName: n3; goto: s3.
    t4 := Transition new transitionName: n4; goto: s4.
    s1 transitions add: t1; add: t2.
    s2 transitions add: t3.
    s3 transitions add: t4.
    fsm states add: s1; add: s2; add: s3; add: s4; add: s5.
    ^fsm renumber.!    ! 
#('February 23, 2021' '05:55:43 PM' 2040808)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


   
'FiniteStateMachine example4'!

!FiniteStateMachine class methods ! 
example4
    "FiniteStateMachine example4"
    |fsm s1 s2 s3 s4 s5 t1 t2 t3 t4 n1 n2 n3 n4|
    fsm := FiniteStateMachine new.
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute readKeep.
    n2 := TransitionName new symbolOrPair: #a; attributes: Attribute readKeep.
    n3 := TransitionName new symbolOrPair: #a; attributes: Attribute readNoKeep.
    n4 := TransitionName new symbolOrPair: #a; action: #buildTree; parameters: #(list).
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    t1:= Transition new transitionName: n1; goto: s2.
    t2 := Transition new transitionName: n2; goto: s5.
    t3 := Transition new transitionName: n3; goto: s3.
    t4 := Transition new transitionName: n4; goto: s4.
    s1 transitions add: t1; add: t2.
    s2 transitions add: t3.
    s3 transitions add: t4.
    fsm states add: s1; add: s2; add: s3; add: s4; add: s5.
    ^fsm renumber.!  ! 
#('February 23, 2021' '05:56:39 PM' 2042320)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


   
'FiniteStateMachine example4'!

!FiniteStateMachine class methods ! 
example4
    "FiniteStateMachine example4"
    |fsm s1 s2 s3 s4 s5 t1 t2 t3 t4 n1 n2 n3 n4|
    fsm := FiniteStateMachine new.
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute readKeep.
    n2 := TransitionName new symbolOrPair: #a; attributes: Attribute readKeep.
    n3 := TransitionName new symbolOrPair: #a; attributes: Attribute readNoKeep.
    n4 := TransitionName new symbolOrPair: #a; action: #buildTree; parameters: #(" list ").
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    t1:= Transition new transitionName: n1; goto: s2.
    t2 := Transition new transitionName: n2; goto: s5.
    t3 := Transition new transitionName: n3; goto: s3.
    t4 := Transition new transitionName: n4; goto: s4.
    s1 transitions add: t1; add: t2.
    s2 transitions add: t3.
    s3 transitions add: t4.
    fsm states add: s1; add: s2; add: s3; add: s4; add: s5.
    ^fsm renumber.!  ! 
#('February 23, 2021' '05:56:58 PM' 2043880)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


   
'FiniteStateMachine example4'!

!FiniteStateMachine class methods ! 
example4
    "FiniteStateMachine example4"
    |fsm s1 s2 s3 s4 s5 t1 t2 t3 t4 n1 n2 n3 n4|
    fsm := FiniteStateMachine new.
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute readKeep.
    n2 := TransitionName new symbolOrPair: #a; attributes: Attribute readKeep.
    n3 := TransitionName new symbolOrPair: #a; attributes: Attribute readNoKeep.
    n4 := TransitionName new symbolOrPair: #a; action: #buildTree; parameters: #().
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    t1:= Transition new transitionName: n1; goto: s2.
    t2 := Transition new transitionName: n2; goto: s5.
    t3 := Transition new transitionName: n3; goto: s3.
    t4 := Transition new transitionName: n4; goto: s4.
    s1 transitions add: t1; add: t2.
    s2 transitions add: t3.
    s3 transitions add: t4.
    fsm states add: s1; add: s2; add: s3; add: s4; add: s5.
    ^fsm renumber.!  ! 
#('February 23, 2021' '05:57:36 PM' 2045436)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


   
'FiniteStateMachine example4'!

!FiniteStateMachine class methods ! 
example4
    "FiniteStateMachine example4"
    |fsm s1 s2 s3 s4 s5 t1 t2 t3 t4 n1 n2 n3 n4|
    fsm := FiniteStateMachine new.
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    n2 := TransitionName new symbolOrPair: #a; attributes: Attribute parserNonterminalDefaultAttributes.
    n3 := TransitionName new symbolOrPair: #a; attributes: Attribute readNoKeep.
    n4 := TransitionName new symbolOrPair: #a; action: #buildTree; parameters: #().
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    t1:= Transition new transitionName: n1; goto: s2.
    t2 := Transition new transitionName: n2; goto: s5.
    t3 := Transition new transitionName: n3; goto: s3.
    t4 := Transition new transitionName: n4; goto: s4.
    s1 transitions add: t1; add: t2.
    s2 transitions add: t3.
    s3 transitions add: t4.
    fsm states add: s1; add: s2; add: s3; add: s4; add: s5.
    ^fsm renumber.!  ! 
#('February 23, 2021' '05:59:21 PM' 2046996)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


   
'FiniteStateMachine example4'!

!Attribute class methods !  
readNoKeep
    ^Attribute new isRead: false; isKeep: false; isNode: false; isStack: false.!    ! 
#('February 23, 2021' '05:59:49 PM' 2035332)!

(CodeFiler organizerFor: Attribute class) reorganizeFrom: #(
('defaultAttributes' readNoKeep )) !

(CodeFiler organizerFor: Attribute class) reorganizeFrom: #(
('defaultAttributes' readNoKeep )) !


   
'FiniteStateMachine example4'!

!FiniteStateMachine class methods ! 
example4
    "FiniteStateMachine example4"
    |fsm s1 s2 s3 s4 s5 t1 t2 t3 t4 n1 n2 n3 n4|
    fsm := FiniteStateMachine new.
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    n2 := TransitionName new symbolOrPair: #a; attributes: Attribute parserNonterminalDefaultAttributes.
    n3 := TransitionName new symbolOrPair: #a; attributes: Attribute readNoKeep.
    n4 := TransitionName new symbolOrPair: #a; action: #buildTree; parameters: #('list').
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    t1:= Transition new transitionName: n1; goto: s2.
    t2 := Transition new transitionName: n2; goto: s5.
    t3 := Transition new transitionName: n3; goto: s3.
    t4 := Transition new transitionName: n4; goto: s4.
    s1 transitions add: t1; add: t2.
    s2 transitions add: t3.
    s3 transitions add: t4.
    fsm states add: s1; add: s2; add: s3; add: s4; add: s5.
    ^fsm renumber.!    ! 
#('February 23, 2021' '06:00:49 PM' 2048548)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


   
'FiniteStateMachine example4'!

!FiniteStateMachine class methods ! 
example4
    "FiniteStateMachine example4"
    |fsm s1 s2 s3 s4 s5 t1 t2 t3 t4 n1 n2 n3 n4|
    fsm := FiniteStateMachine new.
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    n2 := TransitionName new symbolOrPair: #a; attributes: Attribute parserNonterminalDefaultAttributes.
    n3 := TransitionName new symbolOrPair: #a; attributes: Attribute readNoKeep.
    n4 := TransitionName new symbolOrPair: #a; action: #buildTree; parameters: #('"list"').
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    t1:= Transition new transitionName: n1; goto: s2.
    t2 := Transition new transitionName: n2; goto: s5.
    t3 := Transition new transitionName: n3; goto: s3.
    t4 := Transition new transitionName: n4; goto: s4.
    s1 transitions add: t1; add: t2.
    s2 transitions add: t3.
    s3 transitions add: t4.
    fsm states add: s1; add: s2; add: s3; add: s4; add: s5.
    ^fsm renumber.!  ! 
#('February 23, 2021' '06:01:08 PM' 2050576)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


   
'FiniteStateMachine example4'!

!FiniteStateMachine class methods ! 
example4
    "FiniteStateMachine example4"
    |fsm s1 s2 s3 s4 s5 t1 t2 t3 t4 n1 n2 n3 n4|
    fsm := FiniteStateMachine new.
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    n2 := TransitionName new symbolOrPair: #a; attributes: Attribute parserNonterminalDefaultAttributes.
    n3 := TransitionName new symbolOrPair: #a; attributes: Attribute readNoKeep.
    n4 := TransitionName new symbolOrPair: #a; action: #buildTree; parameters: #("list").
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    t1:= Transition new transitionName: n1; goto: s2.
    t2 := Transition new transitionName: n2; goto: s5.
    t3 := Transition new transitionName: n3; goto: s3.
    t4 := Transition new transitionName: n4; goto: s4.
    s1 transitions add: t1; add: t2.
    s2 transitions add: t3.
    s3 transitions add: t4.
    fsm states add: s1; add: s2; add: s3; add: s4; add: s5.
    ^fsm renumber.!    ! 
#('February 23, 2021' '06:01:26 PM' 2052188)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


!FiniteStateMachine class methods !
example4
    "FiniteStateMachine example4"
    |fsm s1 s2 s3 s4 s5 t1 t2 t3 t4 n1 n2 n3 n4|
    fsm := FiniteStateMachine new.
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    n2 := TransitionName new symbolOrPair: #a; attributes: Attribute parserNonterminalDefaultAttributes.
    n3 := TransitionName new symbolOrPair: #a; attributes: Attribute readNoKeep.
    n4 := TransitionName new symbolOrPair: #a; action: #buildTree; parameters: #(''list'').
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    t1:= Transition new transitionName: n1; goto: s2.
    t2 := Transition new transitionName: n2; goto: s5.
    t3 := Transition new transitionName: n3; goto: s3.
    t4 := Transition new transitionName: n4; goto: s4.
    s1 transitions add: t1; add: t2.
    s2 transitions add: t3.
    s3 transitions add: t4.
    fsm states add: s1; add: s2; add: s3; add: s4; add: s5.
    ^fsm renumber.!  ! 
#('February 23, 2021' '06:02:14 PM' 2053800)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


   
'FiniteStateMachine example4'!

!FiniteStateMachine class methods ! 
example4
    "FiniteStateMachine example4"
    |fsm s1 s2 s3 s4 s5 t1 t2 t3 t4 n1 n2 n3 n4|
    fsm := FiniteStateMachine new.
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    n2 := TransitionName new symbolOrPair: #a; attributes: Attribute parserNonterminalDefaultAttributes.
    n3 := TransitionName new symbolOrPair: #a; attributes: Attribute readNoKeep.
    n4 := TransitionName new symbolOrPair: #a; action: #buildTree; parameters: #(''list'').
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    t1:= Transition new transitionName: n1; goto: s2.
    t2 := Transition new transitionName: n2; goto: s5.
    t3 := Transition new transitionName: n3; goto: s3.
    t4 := Transition new transitionName: n4; goto: s4.
    s1 transitions add: t1; add: t2.
    s2 transitions add: t3.
    s3 transitions add: t4.
    fsm states add: s1; add: s2; add: s3; add: s4; add: s5.
    Transcript cr; <<fsm.
    ^fsm renumber.!   ! 
#('February 23, 2021' '06:11:44 PM' 2055372)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


   
'FiniteStateMachine example4'!

!FiniteStateMachine class methods ! 
example4
    "FiniteStateMachine example4"
    |fsm s1 s2 s3 s4 s5 t1 t2 t3 t4 n1 n2 n3 n4|
    fsm := FiniteStateMachine new.
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    n2 := TransitionName new symbolOrPair: #a; attributes: Attribute parserNonterminalDefaultAttributes.
    n3 := TransitionName new symbolOrPair: #a; attributes: Attribute readNoKeep.
    n4 := TransitionName new symbolOrPair: #a; action: #buildTree; parameters: #(''list'').
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true; stateNumber: 1.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    t1:= Transition new transitionName: n1; goto: s2.
    t2 := Transition new transitionName: n2; goto: s5.
    t3 := Transition new transitionName: n3; goto: s3.
    t4 := Transition new transitionName: n4; goto: s4.
    s1 transitions add: t1; add: t2.
    s2 transitions add: t3.
    s3 transitions add: t4.
    fsm states add: s1; add: s2; add: s3; add: s4; add: s5.
    Transcript cr; <<fsm.
    ^fsm renumber.!   ! 
#('February 23, 2021' '06:15:25 PM' 2056984)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


   
'FiniteStateMachine example4'!

!FiniteStateMachine class methods ! 
example4
    "FiniteStateMachine example4"
    |fsm s1 s2 s3 s4 s5 t1 t2 t3 t4 n1 n2 n3 n4|
    fsm := FiniteStateMachine new.
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    n2 := TransitionName new symbolOrPair: #a; attributes: Attribute parserNonterminalDefaultAttributes.
    n3 := TransitionName new symbolOrPair: #a; attributes: Attribute readNoKeep.
    n4 := TransitionName new symbolOrPair: #a; action: #buildTree; parameters: #(''list'').
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true; stateNumber: 1.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false; stateNumber: 2.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false; stateNumber: 3.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: true; stateNumber: 4.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: true; stateNumber: 5.
    t1:= Transition new transitionName: n1; goto: s2.
    t2 := Transition new transitionName: n2; goto: s5.
    t3 := Transition new transitionName: n3; goto: s3.
    t4 := Transition new transitionName: n4; goto: s4.
    s1 transitions add: t1; add: t2.
    s2 transitions add: t3.
    s3 transitions add: t4.
    fsm states add: s1; add: s2; add: s3; add: s4; add: s5.
    Transcript cr; <<fsm.
    ^fsm renumber.!   ! 
#('February 23, 2021' '06:16:21 PM' 2058624)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


   
'FiniteStateMachine example4'!

!FiniteStateMachineState methods !  
initialize

    self
        isFinal: false;
        isInitial: false;
        stateNumber: nil;
        transitions: OrderedCollection new!  ! 
#('February 23, 2021' '06:18:15 PM' 1967880)!

(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('initializing' initialize )) !


!FiniteStateMachineState methods !   
stateNumber: aNumber
    stateNumber := aNumber!   ! 
#('February 23, 2021' '06:20:20 PM' 1924556)!

(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('get/set' stateNumber: )) !

(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('get/set' stateNumber: )) !


   
'FiniteStateMachine example4'!

!FiniteStateMachine class methods ! 
example4
    "FiniteStateMachine example4"
    |fsm s1 s2 s3 s4 s5 t1 t2 t3 t4 n1 n2 n3 n4|
    fsm := FiniteStateMachine new.
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    n2 := TransitionName new symbolOrPair: #a; attributes: Attribute parserNonterminalDefaultAttributes.
    n3 := TransitionName new symbolOrPair: #a; attributes: Attribute readNoKeep.
    n4 := TransitionName new symbolOrPair: #a; action: #buildTree; parameters: #(''list'').
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    t1:= Transition new transitionName: n1; goto: s2.
    t2 := Transition new transitionName: n2; goto: s5.
    t3 := Transition new transitionName: n3; goto: s3.
    t4 := Transition new transitionName: n4; goto: s4.
    s1 transitions add: t1; add: t2.
    s2 transitions add: t3.
    s3 transitions add: t4.
    fsm states add: s1; add: s2; add: s3; add: s4; add: s5.
    Transcript cr; <<fsm.
    ^fsm renumber.!   ! 
#('February 23, 2021' '06:23:20 PM' 2060280)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


!FiniteStateMachine class methods !
example4
    "FiniteStateMachine example4"
    |fsm s1 s2 s3 s4 s5 t1 t2 t3 t4 n1 n2 n3 n4|
    fsm := FiniteStateMachine new.
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    n2 := TransitionName new symbolOrPair: #a; attributes: Attribute parserNonterminalDefaultAttributes.
    n3 := TransitionName new symbolOrPair: #a; attributes: Attribute readNoKeep.
    n4 := TransitionName new symbolOrPair: #a; action: #buildTree; parameters: #(''list'').
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    t1:= Transition new transitionName: n1; goto: s2.
    t2 := Transition new transitionName: n2; goto: s5.
    t3 := Transition new transitionName: n3; goto: s3.
    t4 := Transition new transitionName: n4; goto: s4.
    s1 transitions add: t1; add: t2.
    s2 transitions add: t3.
    s3 transitions add: t4.
    fsm states add: s1; add: s2; add: s3; add: s4; add: s5.
    fsm renumber.
    Transcript cr; <<fsm.!    ! 
#('February 23, 2021' '06:24:03 PM' 2062840)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


   
'FiniteStateMachine example4'!


'FiniteStateMachine example4'!

!FiniteStateMachine class methods ! 
example4
    "FiniteStateMachine example4"
    |fsm s1 s2 s3 s4 s5 t1 t2 t3 t4 n1 n2 n3 n4|
    fsm := FiniteStateMachine new.
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    n2 := TransitionName new symbolOrPair: #a; attributes: Attribute parserNonterminalDefaultAttributes.
    n3 := TransitionName new symbolOrPair: #a; attributes: Attribute readNoKeep.
    n4 := TransitionName new symbolOrPair: #a; action: #buildTree; parameters: #(''list'').
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    t1:= Transition new transitionName: n1; goto: s2.
    t2 := Transition new transitionName: n2; goto: s5.
    t3 := Transition new transitionName: n3; goto: s3.
    t4 := Transition new transitionName: n4; goto: s4.
    s1 transitions add: t1; add: t2.
    s2 transitions add: t3.
    s3 transitions add: t4.
    fsm states add: s1; add: s2; add: s3; add: s4; add: s5.
        fsm renumber.
    Transcript cr; <<fsm.!    ! 
#('February 23, 2021' '06:25:10 PM' 2064440)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


!FiniteStateMachine class methods !
example4
    "FiniteStateMachine example4"
    |fsm s1 s2 s3 s4 s5 s6 t1 t2 t3 t4 t5 t6 t7 t8 n1 n2 n3 n4 n5 n6 n7 n8|
    fsm := FiniteStateMachine new.
    s1 := FiniteStateMachineState new isInitial: true; isFinal: false.
        n1 := TransitionName new symbolOrPair: #''; attributes: Attribute look.
        t1:= Transition new transitionName: n1; goto: s2.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
        n2 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute readKeep.
        t2 := Transition new transitionName: n2; goto: s2.
        n3 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
        t3 := Transition new transitionName: n3; goto: s4.
        n4 := TransitionName new symbolOrPair: #''; attributes: Attribute look.
        t4 := Transition new transitionName: n4; goto: s3.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
        n5 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
        t5 := Transition new transitionName: n5; goto: s5.
        n6 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute look.
        t6 := Transition new transitionName: n6; goto: s5.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: false.
        n7 := TransitionName new symbolOrPair: #missingQuote; action: #missingQuote; parameters: #().
        t7 := Transition new transitionName: n4; goto: s4.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: false.
        n8 := TransitionName new symbolOrPair: #emitToken; action: #emitToken; parameters: #String.
        t8 := Transition new transitionName: n4; goto: s4.
    s6 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s1 transitions add: t1.
    s2 transitions add: t2; add: t3; add: t4.
    s3 transitions add: t5; add: t6.
    s4 transitions add: t7.
    s5 transitions add: t8.
    fsm states add: s1; add: s2; add: s3; add: s4; add: s5; add: s6.
        fsm renumber.
    Transcript cr; <<fsm.!    ! 
#('February 23, 2021' '06:43:05 PM' 2066116)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


   
'FiniteStateMachine example3'!


!FiniteStateMachineState methods !
stateNumber
    ^stateNumber!  !

!FiniteStateMachineState methods !   
stateNumber: anInteger
    stateNumber := anInteger!   !
(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('get/set' stateNumber: stateNumber )) !

(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('get/set' stateNumber: stateNumber )) !


!FiniteStateMachineState methods !   
initialize

    self
        isFinal: false;
        isInitial: false;
        stateNumber: 0;
        transitions: OrderedCollection new!    ! 
#('February 23, 2021' '06:49:40 PM' 2062000)!

(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('initializing' initialize )) !


!FiniteStateMachine class methods !  
example4
    "FiniteStateMachine example4"
    |fsm s1 s2 s3 s4 s5 s6 t1 t2 t3 t4 t5 t6 t7 t8 n1 n2 n3 n4 n5 n6 n7 n8|
    fsm := FiniteStateMachine new.
    s1 := FiniteStateMachineState new isInitial: true; isFinal: false.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    n1 := TransitionName new symbolOrPair: #''; attributes: Attribute look.
        t1:= Transition new transitionName: n1; goto: s2.
        n2 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute readKeep.
        t2 := Transition new transitionName: n2; goto: s2.
        n3 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
        t3 := Transition new transitionName: n3; goto: s4.
        n4 := TransitionName new symbolOrPair: #''; attributes: Attribute look.
        t4 := Transition new transitionName: n4; goto: s3.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
        n5 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
        t5 := Transition new transitionName: n5; goto: s5.
        n6 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute look.
        t6 := Transition new transitionName: n6; goto: s5.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: false.
        n7 := TransitionName new symbolOrPair: #missingQuote; action: #missingQuote; parameters: #().
        t7 := Transition new transitionName: n4; goto: s4.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: false.
        n8 := TransitionName new symbolOrPair: #emitToken; action: #emitToken; parameters: #String.
        t8 := Transition new transitionName: n4; goto: s4.
    s6 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s1 transitions add: t1.
    s2 transitions add: t2; add: t3; add: t4.
    s3 transitions add: t5; add: t6.
    s4 transitions add: t7.
    s5 transitions add: t8.
    fsm states add: s1; add: s2; add: s3; add: s4; add: s5; add: s6.
        fsm renumber.
    Transcript cr; <<fsm.!    ! 
#('February 23, 2021' '06:50:35 PM' 2067720)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


!FiniteStateMachine class methods !
example4
    "FiniteStateMachine example4"
    |fsm s1 s2 s3 s4 s5 s6 t1 t2 t3 t4 t5 t6 t7 t8 n1 n2 n3 n4 n5 n6 n7 n8|
    fsm := FiniteStateMachine new.
    s1 := FiniteStateMachineState new isInitial: true; isFinal: false.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s6 := FiniteStateMachineState new isInitial: false; isFinal: true.
    
    n1 := TransitionName new symbolOrPair: #''; attributes: Attribute look.
    t1:= Transition new transitionName: n1; goto: s2.
    n2 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute readKeep.
    t2 := Transition new transitionName: n2; goto: s2.
    n3 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
    t3 := Transition new transitionName: n3; goto: s4.
    n4 := TransitionName new symbolOrPair: #''; attributes: Attribute look.
    t4 := Transition new transitionName: n4; goto: s3.
    n5 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
    t5 := Transition new transitionName: n5; goto: s5.
    n6 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute look.
    t6 := Transition new transitionName: n6; goto: s5.
    n7 := TransitionName new symbolOrPair: #missingQuote; action: #missingQuote; parameters: #().
    t7 := Transition new transitionName: n4; goto: s4.
    n8 := TransitionName new symbolOrPair: #emitToken; action: #emitToken; parameters: #String.
    t8 := Transition new transitionName: n4; goto: s4.

    s1 transitions add: t1.
    s2 transitions add: t2; add: t3; add: t4.
    s3 transitions add: t5; add: t6.
    s4 transitions add: t7.
    s5 transitions add: t8.
    fsm states add: s1; add: s2; add: s3; add: s4; add: s5; add: s6.
        fsm renumber.
    Transcript cr; <<fsm.!    ! 
#('February 23, 2021' '06:52:35 PM' 2070996)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


   
'FiniteStateMachine example4'!

!FiniteStateMachine class methods ! 
example4
    "FiniteStateMachine example4"
    |fsm s1 s2 s3 s4 s5 s6 t1 t2 t3 t4 t5 t6 t7 t8 n1 n2 n3 n4 n5 n6 n7 n8|
    fsm := FiniteStateMachine new.
    s1 := FiniteStateMachineState new isInitial: true; isFinal: false.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s6 := FiniteStateMachineState new isInitial: false; isFinal: true.
    
    n1 := TransitionName new symbolOrPair: #''; attributes: Attribute look.
    t1:= Transition new transitionName: n1; goto: s2.
    n2 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute readKeep.
    t2 := Transition new transitionName: n2; goto: s2.
    n3 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
    t3 := Transition new transitionName: n3; goto: s4.
    n4 := TransitionName new symbolOrPair: #''; attributes: Attribute look.
    t4 := Transition new transitionName: n4; goto: s3.
    n5 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
    t5 := Transition new transitionName: n5; goto: s5.
    n6 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute look.
    t6 := Transition new transitionName: n6; goto: s5.
    n7 := TransitionName new symbolOrPair: #missingQuote; action: #missingQuote; parameters: #().
    t7 := Transition new transitionName: n4; goto: s4.
    n8 := TransitionName new symbolOrPair: #emitToken; action: #emitToken; parameters: #String.
    t8 := Transition new transitionName: n4; goto: s4.

    s1 transitions add: t1.
    s2 transitions add: t2; add: t3; add: t4.
    s3 transitions add: t5; add: t6.
    s4 transitions add: t7.
    s5 transitions add: t8.
    fsm states add: s1; add: s2; add: s3; add: s4; add: s5; add: s6.
        fsm renumber.
    Transcript cr; <<fsm.!    ! 
#('February 23, 2021' '06:54:02 PM' 2073372)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


!FiniteStateMachine class methods !
example4
    "FiniteStateMachine example4"
    |fsm s1 s2 s3 s4 s5 s6 t1 t2 t3 t4 t5 t6 t7 t8 n1 n2 n3 n4 n5 n6 n7 n8|
    fsm := FiniteStateMachine new.
    s1 := FiniteStateMachineState new isInitial: true; isFinal: false.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s6 := FiniteStateMachineState new isInitial: false; isFinal: true.
    
    n1 := TransitionName new symbolOrPair: #'"'; attributes: Attribute look.
    t1:= Transition new transitionName: n1; goto: s2.
    n2 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute readKeep.
    t2 := Transition new transitionName: n2; goto: s2.
    n3 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
    t3 := Transition new transitionName: n3; goto: s4.
    n4 := TransitionName new symbolOrPair: #'"'; attributes: Attribute look.
    t4 := Transition new transitionName: n4; goto: s3.
    n5 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
    t5 := Transition new transitionName: n5; goto: s5.
    n6 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute look.
    t6 := Transition new transitionName: n6; goto: s5.
    n7 := TransitionName new symbolOrPair: #missingQuote; action: #missingQuote; parameters: #().
    t7 := Transition new transitionName: n4; goto: s4.
    n8 := TransitionName new symbolOrPair: #emitToken; action: #emitToken; parameters: #String.
    t8 := Transition new transitionName: n4; goto: s4.

    s1 transitions add: t1.
    s2 transitions add: t2; add: t3; add: t4.
    s3 transitions add: t5; add: t6.
    s4 transitions add: t7.
    s5 transitions add: t8.
    fsm states add: s1; add: s2; add: s3; add: s4; add: s5; add: s6.
        fsm renumber.
    Transcript cr; <<fsm.!  ! 
#('February 23, 2021' '06:55:25 PM' 2075736)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


   
'FiniteStateMachine example4'!

!FiniteStateMachine class methods ! 
example4
    "FiniteStateMachine example4"
    |fsm s1 s2 s3 s4 s5 s6 t1 t2 t3 t4 t5 t6 t7 t8 n1 n2 n3 n4 n5 n6 n7 n8|
    fsm := FiniteStateMachine new.
    s1 := FiniteStateMachineState new isInitial: true; isFinal: false.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s6 := FiniteStateMachineState new isInitial: false; isFinal: true.
    
    n1 := TransitionName new symbolOrPair: #'"'; attributes: Attribute look.
    t1:= Transition new transitionName: n1; goto: s2.
    n2 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute readKeep.
    t2 := Transition new transitionName: n2; goto: s2.
    n3 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
    t3 := Transition new transitionName: n3; goto: s4.
    t4 := Transition new transitionName: n1; goto: s3.
    n5 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
    t5 := Transition new transitionName: n5; goto: s5.
    n6 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute look.
    t6 := Transition new transitionName: n6; goto: s5.
    n7 := TransitionName new symbolOrPair: #missingQuote; action: #missingQuote; parameters: #().
    t7 := Transition new transitionName: n7; goto: s5.
    n8 := TransitionName new symbolOrPair: #emitToken; action: #emitToken; parameters: #String.
    t8 := Transition new transitionName: n8; goto: s6.

    s1 transitions add: t1.
    s2 transitions add: t2; add: t3; add: t4.
    s3 transitions add: t5; add: t6.
    s4 transitions add: t7.
    s5 transitions add: t8.
    fsm states add: s1; add: s2; add: s3; add: s4; add: s5; add: s6.
        fsm renumber.
    Transcript cr; <<fsm.!    ! 
#('February 23, 2021' '06:58:24 PM' 2078060)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


   
'FiniteStateMachine example4'!

!TransitionName methods !   
printOn: aStream
    self isAction 
        ifTrue:[aStream<<'#';<< self symbolOrPair;<< ' semanticAction: ';<<'#';<< self action;<<' parameters: ';<<'#';<< self parameters. ^self].
    self hasAttributes
        ifTrue:[aStream<<'#';<< self symbolOrPair;<<' properties: ';<<self attributes.^self].! ! 
#('February 23, 2021' '06:59:48 PM' 2030828)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('printing' printOn: )) !

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('printing' printOn: )) !


   
'FiniteStateMachine example4'!

!FiniteStateMachine class methods ! 
example3
    "FiniteStateMachine example3"
    |fsm s1 s2 s3 s4 s5 t1 t2 t3 t4 n1 n2 n3 n4|
    fsm := FiniteStateMachine new.
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute look.
    t1:= Transition new transitionName: n1; goto: s2.
    n2 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute readKeep.
    t2 := Transition new transitionName: n2; goto: s2.
    n3 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
    t3 := Transition new transitionName: n3; goto: s4.
    t4 := Transition new transitionName: n1; goto: s3.
    
    s1 transitions add: t1.
    s2 transitions add: t2; add: t3; add: t4.

    fsm states add: s1; add: s2; add: s3; add: s4; add: s5.
        fsm renumber.
    Transcript cr; <<fsm.!  ! 
#('February 23, 2021' '07:03:25 PM' 2004648)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 )) !


!FiniteStateMachine class methods !
example3
    "FiniteStateMachine example3"
    |fsm s1 s2 s3 s4 s5 t1 t2 t3 t4 n1 n2 n3 n4|
    fsm := FiniteStateMachine new.
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    t1:= Transition new transitionName: n1; goto: s2.
    n2 := TransitionName new symbolOrPair: #a; attributes: Attribute parserNonterminalDefaultAttributes.
    t2 := Transition new transitionName: n2; goto: s5.
    n3 := TransitionName new symbolOrPair: #a; attributes: Attribute look.
    t3 := Transition new transitionName: n3; goto: s3.
    n3 := TransitionName new action: #buildTree; parameters: #(""list"").
    t4 := Transition new transitionName: n1; goto: s3.
    
    s1 transitions add: t1.
    s2 transitions add: t2; add: t3; add: t4.

    fsm states add: s1; add: s2; add: s3; add: s4; add: s5.
        fsm renumber.
    Transcript cr; <<fsm.!  ! 
#('February 23, 2021' '07:07:08 PM' 2083320)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 )) !


!FiniteStateMachine class methods !
example3
    "FiniteStateMachine example3"
    |fsm s1 s2 s3 s4 s5 t1 t2 t3 t4 n1 n2 n3 n4|
    fsm := FiniteStateMachine new.
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    t1:= Transition new transitionName: n1; goto: s2.
    n2 := TransitionName new symbolOrPair: #a; attributes: Attribute parserNonterminalDefaultAttributes.
    t2 := Transition new transitionName: n2; goto: s5.
    n3 := TransitionName new symbolOrPair: #a; attributes: Attribute look.
    t3 := Transition new transitionName: n3; goto: s3.
    n3 := TransitionName new action: #buildTree; parameters: #(""list"").
    t4 := Transition new transitionName: n1; goto: s3.
    
    s1 transitions add: t1; add: t2.
    s2 transitions add: t3.
    s3 transitions add: t4.
    fsm states add: s1; add: s2; add: s3; add: s4; add: s5.
        fsm renumber.
    Transcript cr; <<fsm.!    ! 
#('February 23, 2021' '07:07:56 PM' 2084776)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 )) !


   
'FiniteStateMachine example3'!

!FiniteStateMachine class methods ! 
example3
    "FiniteStateMachine example3"
    |fsm s1 s2 s3 s4 s5 t1 t2 t3 t4 n1 n2 n3 n4|
    fsm := FiniteStateMachine new.
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    t1:= Transition new transitionName: n1; goto: s2.
    n2 := TransitionName new symbolOrPair: #a; attributes: Attribute parserNonterminalDefaultAttributes.
    t2 := Transition new transitionName: n2; goto: s5.
    n3 := TransitionName new symbolOrPair: #a; attributes: Attribute look.
    t3 := Transition new transitionName: n3; goto: s3.
    n4 := TransitionName new action: #buildTree; parameters: #(""list"").
    t4 := Transition new transitionName: n4; goto: s3.
    
    s1 transitions add: t1; add: t2.
    s2 transitions add: t3.
    s3 transitions add: t4.
    fsm states add: s1; add: s2; add: s3; add: s4; add: s5.
        fsm renumber.
    Transcript cr; <<fsm.!    ! 
#('February 23, 2021' '07:08:45 PM' 2086348)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 )) !


   
'FiniteStateMachine example3'!
"*** Image started on: February 23, 2021 07:09:08 PM ***"!

"define class"  

Object subclass: #Attribute
  instanceVariableNames: 
    ' isRead isStack isNode isKeep '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"   

Object subclass: #FiniteStateMachine
  instanceVariableNames: 
    ' states '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"

Object subclass: #FiniteStateMachineState
  instanceVariableNames: 
    ' stateNumber isInitial isFinal transitions '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"

Object subclass: #Transition
  instanceVariableNames: 
    ' transitionName goto '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"   

Object subclass: #TransitionName
  instanceVariableNames: 
    ' symbolOrPair attributes action parameters isRootBuilding '
  classVariableNames: ''
  poolDictionaries: ''!


!Attribute class methods !
parserTerminalDefaultAttributes
    ^Attribute new isRead: true; isKeep: false; isNode: false; isStack: true.! !

!Attribute class methods !   
look
    ^Attribute new isRead: false; isKeep: false; isNode: false; isStack: false.!  !

!Attribute class methods !   
readNoKeep
    ^Attribute new isRead: false; isKeep: false; isNode: false; isStack: false.!    !

!Attribute class methods !   
scannerDefaultAttributes
    ^Attribute new isRead: true; isKeep: true; isNode: false; isStack: false.!    !

!Attribute class methods !   
readKeep
    ^Attribute new isRead: true; isKeep: true; isNode: false; isStack: false.!    !

!Attribute class methods !   
parserNonterminalDefaultAttributes
^Attribute new isRead: true; isKeep: false; isNode: true; isStack: true.!   !

"evaluate"   
(CodeFiler organizerFor: Attribute class) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Attribute class) reorganizeFrom: #(
('defaultAttributes' parserTerminalDefaultAttributes look readNoKeep scannerDefaultAttributes readKeep parserNonterminalDefaultAttributes )) !

(CodeFiler organizerFor: Attribute class) reorganizeFrom: #(
('defaultAttributes' parserTerminalDefaultAttributes look readNoKeep scannerDefaultAttributes readKeep parserNonterminalDefaultAttributes )) !



!Attribute methods !
initialize

    self
        isNode: Boolean new;
        isKeep: Boolean new;
        isStack: Boolean new;
        isRead: Boolean new! !

"evaluate"   
(CodeFiler organizerFor: Attribute) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: Attribute) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: Attribute) reorganizeFrom: #(
('initializing' initialize )) !



!Attribute methods !
isStack
    ^isStack!  !

!Attribute methods ! 
isRead
    ^isRead!    !

!Attribute methods ! 
isKeep: aBoolean
    isKeep := aBoolean!   !

!Attribute methods ! 
isRead: aBoolean
    isRead := aBoolean!   !

!Attribute methods ! 
isNode: aBoolean
    isNode := aBoolean!   !

!Attribute methods ! 
isKeep
    ^isKeep!    !

!Attribute methods ! 
isNode
    ^isNode!    !

!Attribute methods ! 
isStack: aBoolean
    isStack := aBoolean! !
(CodeFiler organizerFor: Attribute) reorganizeFrom: #(
('get/set' isStack isRead isKeep: isRead: isNode: isKeep isNode isStack: )) !

(CodeFiler organizerFor: Attribute) reorganizeFrom: #(
('get/set' isStack isRead isKeep: isRead: isNode: isKeep isNode isStack: )) !



!Attribute methods ! 
printOn: aStream
    aStream<<'"'.
    self isRead ifTrue:[aStream<<'R'] ifFalse:[aStream<<'L'].
    self isStack ifTrue:[aStream<<'S']. 
    self isNode ifTrue:[aStream<<'N']. 
    self isKeep ifTrue:[aStream<<'K'].
    aStream<<'"'.!   !
(CodeFiler organizerFor: Attribute) reorganizeFrom: #(
('printing' printOn: )) !

(CodeFiler organizerFor: Attribute) reorganizeFrom: #(
('printing' printOn: )) !
CodeFiler setCommentFor: Attribute to: ''!



!FiniteStateMachine class methods !  
new

    ^super new initialize!   !
(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('instance creation' new )) !



!FiniteStateMachine class methods !
epsilon
    |fsm state1|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    fsm states add: state1.
    ^fsm renumber.!  !
(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('fsmClassMethods' epsilon )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('fsmClassMethods' epsilon )) !



!FiniteStateMachine class methods !
example3
    "FiniteStateMachine example3"
    |fsm state1 state2 state3 state4 state5 transition1 transition2 transition3 transition4|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    state4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    transition1 := Transition new transitionName: '#S properties: '; goto: state2.
    transition2 := Transition new transitionName: '#a properties: "RSN" '; goto: state5.
    transition3 := Transition new transitionName: '#a properties: "L" '; goto: state3.
    transition4 := Transition new transitionName: 'semanticAction: #buildTree: parameters: #("list") '; goto: state4.
    state1 transitions add: transition1; add: transition2.
    state2 transitions add: transition3.
    state3 transitions add: transition4.
    fsm states add: state1; add: state2; add: state3; add: state4; add: state5.
    ^fsm renumber.!   !

!FiniteStateMachine class methods !  
example4
    "FiniteStateMachine example4"
    |fsm s1 s2 s3 s4 s5 s6 t1 t2 t3 t4 t5 t6 t7 t8 n1 n2 n3 n4 n5 n6 n7 n8|
    fsm := FiniteStateMachine new.
    s1 := FiniteStateMachineState new isInitial: true; isFinal: false.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s6 := FiniteStateMachineState new isInitial: false; isFinal: true.
    
    n1 := TransitionName new symbolOrPair: #'"'; attributes: Attribute look.
    t1:= Transition new transitionName: n1; goto: s2.
    n2 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute readKeep.
    t2 := Transition new transitionName: n2; goto: s2.
    n3 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
    t3 := Transition new transitionName: n3; goto: s4.
    t4 := Transition new transitionName: n1; goto: s3.
    n5 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
    t5 := Transition new transitionName: n5; goto: s5.
    n6 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute look.
    t6 := Transition new transitionName: n6; goto: s5.
    n7 := TransitionName new symbolOrPair: #missingQuote; action: #missingQuote; parameters: #().
    t7 := Transition new transitionName: n7; goto: s5.
    n8 := TransitionName new symbolOrPair: #emitToken; action: #emitToken; parameters: #String.
    t8 := Transition new transitionName: n8; goto: s6.

    s1 transitions add: t1.
    s2 transitions add: t2; add: t3; add: t4.
    s3 transitions add: t5; add: t6.
    s4 transitions add: t7.
    s5 transitions add: t8.
    fsm states add: s1; add: s2; add: s3; add: s4; add: s5; add: s6.
        fsm renumber.
    Transcript cr; <<fsm.!    !

!FiniteStateMachine class methods !  
example1
    "FiniteStateMachine example1"
    |fsm state1 state2 state3 transition1 transition2 label1 label2|
    fsm := FiniteStateMachine new.
    label1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    label2 := TransitionName new symbolOrPair: #a; action: #buildTree; parameters: #(1 2 4 7 9).
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    transition1:= Transition new transitionName: label1; goto: state2.
    transition2 := Transition new transitionName: label2; goto: state3.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2; add: state3. 
    ^fsm renumber.! !

!FiniteStateMachine class methods !  
example2
    "FiniteStateMachine example2"
    |fsm state1 state2 transition1 transition2|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: false.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    transition1 := Transition new transitionName: 'a'; goto: state2.
    transition2 := Transition new transitionName: 'a'; goto: state2.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2. 
    ^fsm renumber.!    !
(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 example4 example1 example2 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 example4 example1 example2 )) !



!FiniteStateMachine methods !
initialize

    self
        states: OrderedCollection new!  !
(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('initializing' initialize )) !



!FiniteStateMachine methods !  
states: anOrderedCollection
    states := anOrderedCollection! !

!FiniteStateMachine methods !
states
    ^states!    !
(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('get/set' states: states )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('get/set' states: states )) !



!FiniteStateMachine methods !
printOn: aStream

    aStream << 'FSM'.
    self states do:[ :state | state printOn: aStream ].
    aStream cr;<< 'END'.!   !
(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('printing' printOn: )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('printing' printOn: )) !



!FiniteStateMachine methods !  
questionMark
    ^self or: self FiniteStateMachine epsilon!    !

!FiniteStateMachine methods !
renumber
    self states indexedDo:[ :index :state| state stateNumber: index].!    !

!FiniteStateMachine methods !
or: fsm
    self states addAll: fsm states.
    self renumber.
    ^self!    !
(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' or: questionMark renumber )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' or: questionMark renumber )) !
CodeFiler setCommentFor: FiniteStateMachine to: ''!



!FiniteStateMachineState class methods !
new

    ^super new initialize!   !
(CodeFiler organizerFor: FiniteStateMachineState class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: FiniteStateMachineState class) reorganizeFrom: #(
('instance creation' new )) !



!FiniteStateMachineState methods !   
initialize

    self
        isFinal: false;
        isInitial: false;
        stateNumber: 0;
        transitions: OrderedCollection new!    !
(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('initializing' initialize )) !



!FiniteStateMachineState methods !   
transitions: anOrderedCollection
    transitions := anOrderedCollection!   !

!FiniteStateMachineState methods !   
transitions
    ^transitions!  !

!FiniteStateMachineState methods !   
stateNumber
    ^stateNumber!  !

!FiniteStateMachineState methods !   
isFinal: aBoolean
    isFinal := aBoolean! !

!FiniteStateMachineState methods !   
isFinal
    ^isFinal!  !

!FiniteStateMachineState methods !   
stateNumber: anInteger
    stateNumber := anInteger!   !

!FiniteStateMachineState methods !   
isInitial: aBoolean
    isInitial := aBoolean! !

!FiniteStateMachineState methods !   
isInitial
    ^isInitial!  !
(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('get/set' stateNumber: stateNumber transitions: isFinal: isFinal transitions isInitial: isInitial )) !

(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('get/set' stateNumber: stateNumber transitions: isFinal: isFinal transitions isInitial: isInitial )) !



!FiniteStateMachineState methods !   
printOn: aStream
    aStream cr;<<'   state: ';<<stateNumber;<<' '.
    self isInitial 
        ifTrue: [aStream << 'initial;'].
    self isFinal
        ifTrue: [aStream << 'final;'].
    self transitions do:[:transit | transit printOn: aStream.]!  !
(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('printing' printOn: )) !

(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('printing' printOn: )) !
CodeFiler setCommentFor: FiniteStateMachineState to: ''!



!Transition methods !  
initialize

    self
!   !
(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('initializing' initialize )) !



!Transition methods !  
transitionName: aTransitionName
    transitionName := aTransitionName! !

!Transition methods !
goto: aState
    goto := aState!   !

!Transition methods !
transitionName
    ^transitionName!    !

!Transition methods !
goto
    ^goto!    !
(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('get/set' transitionName: goto: transitionName goto )) !

(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('get/set' transitionName: goto: transitionName goto )) !



!Transition methods !  
printOn: aStream
    aStream cr;<<'      ';<<'for: ';<<self transitionName;<<' goto: ';<<goto stateNumber;<<';'.!  !
(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('printing' printOn: )) !

(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('printing' printOn: )) !
CodeFiler setCommentFor: Transition to: ''!



"evaluate"
(CodeFiler organizerFor: TransitionName class) removeCategory: 'no category methods' ifAbsent: [nil]!


!TransitionName methods !  
action: aSymbol
    action := aSymbol! !

!TransitionName methods !
parameters
    ^parameters!    !

!TransitionName methods !
isRootBuilding
    ^isRootBuilding!    !

!TransitionName methods !
attributes: aCollection
    attributes := aCollection! !

!TransitionName methods !
parameters: aCollection
    parameters := aCollection! !

!TransitionName methods !
symbolOrPair: aSymbol
    symbolOrPair := aSymbol! !

!TransitionName methods !
isRootBuilding: aBoolean
    isRootBuilding := aBoolean!   !

!TransitionName methods !
attributes
    ^attributes!    !

!TransitionName methods !
symbolOrPair
    ^symbolOrPair!    !

!TransitionName methods !
action
    ^action!    !
(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' action: isRootBuilding parameters attributes: parameters: symbolOrPair: isRootBuilding: attributes symbolOrPair action )) !

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' action: isRootBuilding parameters attributes: parameters: symbolOrPair: isRootBuilding: attributes symbolOrPair action )) !



!TransitionName methods !
isAction
    ^self action ~= nil!  !

!TransitionName methods !
hasAttributes
    ^self attributes ~= nil! !
(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('queryMethods' isAction hasAttributes )) !

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('queryMethods' isAction hasAttributes )) !



!TransitionName methods !  
printOn: aStream
    self isAction 
        ifTrue:[aStream<<'#';<< self symbolOrPair;<< ' semanticAction: ';<<'#';<< self action;<<' parameters: ';<<'#';<< self parameters. ^self].
    self hasAttributes
        ifTrue:[aStream<<'#';<< self symbolOrPair;<<' properties: ';<<self attributes.^self].! !
(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('printing' printOn: )) !

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('printing' printOn: )) !
CodeFiler setCommentFor: TransitionName to: ''!


"evaluate"  
Grammar removeFromSystem!

"evaluate"   
CodeFiler removeOrganizerFor: #Grammar!

"evaluate" 
CodeFiler removeOrganizerFor: #'Grammar class'!

"define class" 

Object subclass: #Attribute
  instanceVariableNames: 
    ' isRead isStack isNode isKeep '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"   

Object subclass: #FiniteStateMachine
  instanceVariableNames: 
    ' states '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"

Object subclass: #FiniteStateMachineState
  instanceVariableNames: 
    ' stateNumber isInitial isFinal transitions '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"

Object subclass: #Transition
  instanceVariableNames: 
    ' transitionName goto '
  classVariableNames: ''
  poolDictionaries: ''!

"define class"   

Object subclass: #TransitionName
  instanceVariableNames: 
    ' symbolOrPair attributes action parameters isRootBuilding '
  classVariableNames: ''
  poolDictionaries: ''!


!Attribute class methods !
parserTerminalDefaultAttributes
    ^Attribute new isRead: true; isKeep: false; isNode: false; isStack: true.! !

!Attribute class methods !   
look
    ^Attribute new isRead: false; isKeep: false; isNode: false; isStack: false.!  !

!Attribute class methods !   
readNoKeep
    ^Attribute new isRead: false; isKeep: false; isNode: false; isStack: false.!    !

!Attribute class methods !   
scannerDefaultAttributes
    ^Attribute new isRead: true; isKeep: true; isNode: false; isStack: false.!    !

!Attribute class methods !   
readKeep
    ^Attribute new isRead: true; isKeep: true; isNode: false; isStack: false.!    !

!Attribute class methods !   
parserNonterminalDefaultAttributes
^Attribute new isRead: true; isKeep: false; isNode: true; isStack: true.!   !
(CodeFiler organizerFor: Attribute class) reorganizeFrom: #(
('defaultAttributes' parserTerminalDefaultAttributes look readNoKeep scannerDefaultAttributes readKeep parserNonterminalDefaultAttributes )) !

(CodeFiler organizerFor: Attribute class) reorganizeFrom: #(
('defaultAttributes' parserTerminalDefaultAttributes look readNoKeep scannerDefaultAttributes readKeep parserNonterminalDefaultAttributes )) !



!Attribute methods !   
initialize

    self
        isNode: Boolean new;
        isKeep: Boolean new;
        isStack: Boolean new;
        isRead: Boolean new! !
(CodeFiler organizerFor: Attribute) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: Attribute) reorganizeFrom: #(
('initializing' initialize )) !



!Attribute methods ! 
isStack
    ^isStack!  !

!Attribute methods ! 
isRead
    ^isRead!    !

!Attribute methods ! 
isKeep: aBoolean
    isKeep := aBoolean!   !

!Attribute methods ! 
isRead: aBoolean
    isRead := aBoolean!   !

!Attribute methods ! 
isNode: aBoolean
    isNode := aBoolean!   !

!Attribute methods ! 
isKeep
    ^isKeep!    !

!Attribute methods ! 
isNode
    ^isNode!    !

!Attribute methods ! 
isStack: aBoolean
    isStack := aBoolean! !
(CodeFiler organizerFor: Attribute) reorganizeFrom: #(
('get/set' isStack isRead isKeep: isRead: isNode: isKeep isNode isStack: )) !

(CodeFiler organizerFor: Attribute) reorganizeFrom: #(
('get/set' isStack isRead isKeep: isRead: isNode: isKeep isNode isStack: )) !



!Attribute methods ! 
printOn: aStream
    aStream<<'"'.
    self isRead ifTrue:[aStream<<'R'] ifFalse:[aStream<<'L'].
    self isStack ifTrue:[aStream<<'S']. 
    self isNode ifTrue:[aStream<<'N']. 
    self isKeep ifTrue:[aStream<<'K'].
    aStream<<'"'.!   !
(CodeFiler organizerFor: Attribute) reorganizeFrom: #(
('printing' printOn: )) !

(CodeFiler organizerFor: Attribute) reorganizeFrom: #(
('printing' printOn: )) !
CodeFiler setCommentFor: Attribute to: ''!



!FiniteStateMachine class methods !  
new

    ^super new initialize!   !
(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('instance creation' new )) !



!FiniteStateMachine class methods !
epsilon
    |fsm state1|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    fsm states add: state1.
    ^fsm renumber.!  !
(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('fsmClassMethods' epsilon )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('fsmClassMethods' epsilon )) !



!FiniteStateMachine class methods !
example3
    "FiniteStateMachine example3"
    |fsm state1 state2 state3 state4 state5 transition1 transition2 transition3 transition4|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    state4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    transition1 := Transition new transitionName: '#S properties: '; goto: state2.
    transition2 := Transition new transitionName: '#a properties: "RSN" '; goto: state5.
    transition3 := Transition new transitionName: '#a properties: "L" '; goto: state3.
    transition4 := Transition new transitionName: 'semanticAction: #buildTree: parameters: #("list") '; goto: state4.
    state1 transitions add: transition1; add: transition2.
    state2 transitions add: transition3.
    state3 transitions add: transition4.
    fsm states add: state1; add: state2; add: state3; add: state4; add: state5.
    ^fsm renumber.!   !

!FiniteStateMachine class methods !  
example4
    "FiniteStateMachine example4"
    |fsm s1 s2 s3 s4 s5 s6 t1 t2 t3 t4 t5 t6 t7 t8 n1 n2 n3 n4 n5 n6 n7 n8|
    fsm := FiniteStateMachine new.
    s1 := FiniteStateMachineState new isInitial: true; isFinal: false.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s6 := FiniteStateMachineState new isInitial: false; isFinal: true.
    
    n1 := TransitionName new symbolOrPair: #'"'; attributes: Attribute look.
    t1:= Transition new transitionName: n1; goto: s2.
    n2 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute readKeep.
    t2 := Transition new transitionName: n2; goto: s2.
    n3 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
    t3 := Transition new transitionName: n3; goto: s4.
    t4 := Transition new transitionName: n1; goto: s3.
    n5 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
    t5 := Transition new transitionName: n5; goto: s5.
    n6 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute look.
    t6 := Transition new transitionName: n6; goto: s5.
    n7 := TransitionName new symbolOrPair: #missingQuote; action: #missingQuote; parameters: #().
    t7 := Transition new transitionName: n7; goto: s5.
    n8 := TransitionName new symbolOrPair: #emitToken; action: #emitToken; parameters: #String.
    t8 := Transition new transitionName: n8; goto: s6.

    s1 transitions add: t1.
    s2 transitions add: t2; add: t3; add: t4.
    s3 transitions add: t5; add: t6.
    s4 transitions add: t7.
    s5 transitions add: t8.
    fsm states add: s1; add: s2; add: s3; add: s4; add: s5; add: s6.
        fsm renumber.
    Transcript cr; <<fsm.!    !

!FiniteStateMachine class methods !  
example1
    "FiniteStateMachine example1"
    |fsm state1 state2 state3 transition1 transition2 label1 label2|
    fsm := FiniteStateMachine new.
    label1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    label2 := TransitionName new symbolOrPair: #a; action: #buildTree; parameters: #(1 2 4 7 9).
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    transition1:= Transition new transitionName: label1; goto: state2.
    transition2 := Transition new transitionName: label2; goto: state3.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2; add: state3. 
    ^fsm renumber.! !

!FiniteStateMachine class methods !  
example2
    "FiniteStateMachine example2"
    |fsm state1 state2 transition1 transition2|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: false.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    transition1 := Transition new transitionName: 'a'; goto: state2.
    transition2 := Transition new transitionName: 'a'; goto: state2.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2. 
    ^fsm renumber.!    !
(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 example4 example1 example2 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 example4 example1 example2 )) !



!FiniteStateMachine methods !
initialize

    self
        states: OrderedCollection new!  !
(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('initializing' initialize )) !



!FiniteStateMachine methods !  
states: anOrderedCollection
    states := anOrderedCollection! !

!FiniteStateMachine methods !
states
    ^states!    !
(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('get/set' states: states )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('get/set' states: states )) !



!FiniteStateMachine methods !
printOn: aStream

    aStream << 'FSM'.
    self states do:[ :state | state printOn: aStream ].
    aStream cr;<< 'END'.!   !
(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('printing' printOn: )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('printing' printOn: )) !



!FiniteStateMachine methods !  
questionMark
    ^self or: self FiniteStateMachine epsilon!    !

!FiniteStateMachine methods !
renumber
    self states indexedDo:[ :index :state| state stateNumber: index].!    !

!FiniteStateMachine methods !
or: fsm
    self states addAll: fsm states.
    self renumber.
    ^self!    !
(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' or: questionMark renumber )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' or: questionMark renumber )) !
CodeFiler setCommentFor: FiniteStateMachine to: ''!



!FiniteStateMachineState class methods !
new

    ^super new initialize!   !
(CodeFiler organizerFor: FiniteStateMachineState class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: FiniteStateMachineState class) reorganizeFrom: #(
('instance creation' new )) !



!FiniteStateMachineState methods !   
initialize

    self
        isFinal: false;
        isInitial: false;
        stateNumber: 0;
        transitions: OrderedCollection new!    !
(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('initializing' initialize )) !



!FiniteStateMachineState methods !   
transitions: anOrderedCollection
    transitions := anOrderedCollection!   !

!FiniteStateMachineState methods !   
transitions
    ^transitions!  !

!FiniteStateMachineState methods !   
stateNumber
    ^stateNumber!  !

!FiniteStateMachineState methods !   
isFinal: aBoolean
    isFinal := aBoolean! !

!FiniteStateMachineState methods !   
isFinal
    ^isFinal!  !

!FiniteStateMachineState methods !   
stateNumber: anInteger
    stateNumber := anInteger!   !

!FiniteStateMachineState methods !   
isInitial: aBoolean
    isInitial := aBoolean! !

!FiniteStateMachineState methods !   
isInitial
    ^isInitial!  !
(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('get/set' stateNumber: stateNumber transitions: isFinal: isFinal transitions isInitial: isInitial )) !

(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('get/set' stateNumber: stateNumber transitions: isFinal: isFinal transitions isInitial: isInitial )) !



!FiniteStateMachineState methods !   
printOn: aStream
    aStream cr;<<'   state: ';<<stateNumber;<<' '.
    self isInitial 
        ifTrue: [aStream << 'initial;'].
    self isFinal
        ifTrue: [aStream << 'final;'].
    self transitions do:[:transit | transit printOn: aStream.]!  !
(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('printing' printOn: )) !

(CodeFiler organizerFor: FiniteStateMachineState) reorganizeFrom: #(
('printing' printOn: )) !
CodeFiler setCommentFor: FiniteStateMachineState to: ''!



!Transition methods !  
initialize

    self
!   !
(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('initializing' initialize )) !



!Transition methods !  
transitionName: aTransitionName
    transitionName := aTransitionName! !

!Transition methods !
goto: aState
    goto := aState!   !

!Transition methods !
transitionName
    ^transitionName!    !

!Transition methods !
goto
    ^goto!    !
(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('get/set' transitionName: goto: transitionName goto )) !

(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('get/set' transitionName: goto: transitionName goto )) !



!Transition methods !  
printOn: aStream
    aStream cr;<<'      ';<<'for: ';<<self transitionName;<<' goto: ';<<goto stateNumber;<<';'.!  !
(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('printing' printOn: )) !

(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('printing' printOn: )) !
CodeFiler setCommentFor: Transition to: ''!




!TransitionName methods !   
action: aSymbol
    action := aSymbol! !

!TransitionName methods !
parameters
    ^parameters!    !

!TransitionName methods !
isRootBuilding
    ^isRootBuilding!    !

!TransitionName methods !
attributes: aCollection
    attributes := aCollection! !

!TransitionName methods !
parameters: aCollection
    parameters := aCollection! !

!TransitionName methods !
symbolOrPair: aSymbol
    symbolOrPair := aSymbol! !

!TransitionName methods !
isRootBuilding: aBoolean
    isRootBuilding := aBoolean!   !

!TransitionName methods !
attributes
    ^attributes!    !

!TransitionName methods !
symbolOrPair
    ^symbolOrPair!    !

!TransitionName methods !
action
    ^action!    !
(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' action: isRootBuilding parameters attributes: parameters: symbolOrPair: isRootBuilding: attributes symbolOrPair action )) !

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('get/set' action: isRootBuilding parameters attributes: parameters: symbolOrPair: isRootBuilding: attributes symbolOrPair action )) !



!TransitionName methods !
isAction
    ^self action ~= nil!  !

!TransitionName methods !
hasAttributes
    ^self attributes ~= nil! !
(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('queryMethods' isAction hasAttributes )) !

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('queryMethods' isAction hasAttributes )) !



!TransitionName methods !  
printOn: aStream
    self isAction 
        ifTrue:[aStream<<'#';<< self symbolOrPair;<< ' semanticAction: ';<<'#';<< self action;<<' parameters: ';<<'#';<< self parameters. ^self].
    self hasAttributes
        ifTrue:[aStream<<'#';<< self symbolOrPair;<<' properties: ';<<self attributes.^self].! !
(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('printing' printOn: )) !

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('printing' printOn: )) !
CodeFiler setCommentFor: TransitionName to: ''!


"evaluate"  
FiniteStateMachineState removeSelector: #printOn:tabs:!

"evaluate" 
(CodeFiler organizerFor: FiniteStateMachine) removeCategory: 'ops' ifAbsent: [nil]!

"evaluate" 
(CodeFiler organizerFor: FiniteStateMachine) removeCategory: 'query' ifAbsent: [nil]!

"evaluate"   
FiniteStateMachine removeSelector: #override:!

"evaluate"  
FiniteStateMachine removeSelector: #printOn:tabs:!

"evaluate"  
(CodeFiler setAndInitializeOrganizerFor: FiniteStateMachineState to: (MethodBasedOrganizer fromArray: #(('initializing' initialize)
('get/set' isFinal isFinal: isInitial isInitial: stateNumber stateNumber: transitions transitions:)
('printing' printOn:)))).!

"evaluate"
FiniteStateMachineState removeSelector: #number!

"evaluate"
FiniteStateMachineState removeSelector: #number:!

"evaluate"   
(CodeFiler organizerFor: FiniteStateMachineState) removeCategory: 'no category methods' ifAbsent: [nil]!

"evaluate"
(CodeFiler organizerFor: Transition) removeCategory: 'ops' ifAbsent: [nil]!

"evaluate" 
(CodeFiler organizerFor: Transition) removeCategory: 'initializing' ifAbsent: [nil]!

"evaluate"
TransitionName removeSelector: #=!

"evaluate"  
TransitionName removeSelector: #hasAction!

"evaluate"  
TransitionName removeSelector: #hasParameters!

"evaluate"  
TransitionName removeSelector: #isSemanticAction!

"evaluate"   
TransitionName removeSelector: #name:!

"evaluate"  
TransitionName removeSelector: #name!

"evaluate"   
TransitionName removeSelector: #state!

"evaluate"  
TransitionName removeSelector: #symbol!

"evaluate" 
TransitionName removeSelector: #state:!

"evaluate" 
TransitionName removeSelector: #symbol:!

!TransitionName methods ! 
printOn: aStream
    self isAction 
        ifTrue:[aStream<< self symbolOrPair;<< ' semanticAction: ';<<'#';<< self action;<<' parameters: ';<<'#';<< self parameters. ^self].
    self hasAttributes
        ifTrue:[aStream<<'#';<< self symbolOrPair;<<' properties: ';<<self attributes.^self].!   ! 
#('February 23, 2021' '07:15:18 PM' 2122916)!

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('printing' printOn: )) !

(CodeFiler organizerFor: TransitionName) reorganizeFrom: #(
('printing' printOn: )) !


"evaluate" 
(CodeFiler organizerFor: FiniteStateMachine class) removeCategory: 'ops' ifAbsent: [nil]!

!FiniteStateMachine class methods !  
example4
    "FiniteStateMachine example4"
    |fsm s1 s2 s3 s4 s5 s6 t1 t2 t3 t4 t5 t6 t7 t8 n1 n2 n3 n4 n5 n6 n7 n8|
    fsm := FiniteStateMachine new.
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute look.
    t1:= Transition new transitionName: n1; goto: s2.
    n2 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute readKeep.
    t2 := Transition new transitionName: n2; goto: s2.
    n3 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
    t3 := Transition new transitionName: n3; goto: s4.
    t4 := Transition new transitionName: n1; goto: s3.
    n5 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
    t5 := Transition new transitionName: n5; goto: s5.
    n6 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute look.
    t6 := Transition new transitionName: n6; goto: s5.
    n7 := TransitionName new symbolOrPair: #missingQuote; action: #missingQuote; parameters: #().
    t7 := Transition new transitionName: n7; goto: s5.
    n8 := TransitionName new symbolOrPair: #emitToken; action: #emitToken; parameters: #String.
    t8 := Transition new transitionName: n8; goto: s6.

    s1 transitions add: t1.
    s2 transitions add: t2; add: t3; add: t4.
    s3 transitions add: t5; add: t6.

    fsm states add: s1; add: s2; add: s3; add: s4; add: s5.
        fsm renumber.
    Transcript cr; <<fsm.!  ! 
#('February 23, 2021' '07:17:18 PM' 2112524)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


!FiniteStateMachine class methods !
example4
    "FiniteStateMachine example4"
    |fsm s1 s2 s3 s4 s5 s6 t1 t2 t3 t4 t5 t6 t7 t8 n1 n2 n3 n4 n5 n6 n7 n8|
    fsm := FiniteStateMachine new.
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s6 := FiniteStateMachineState new isInitial: false; isFinal: true.
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute look.
    t1:= Transition new transitionName: n1; goto: s2.
    n2 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute readKeep.
    t2 := Transition new transitionName: n2; goto: s2.
    n3 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
    t3 := Transition new transitionName: n3; goto: s4.
    t4 := Transition new transitionName: n1; goto: s3.
    n5 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
    t5 := Transition new transitionName: n5; goto: s5.
    n6 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute look.
    t6 := Transition new transitionName: n6; goto: s5.
    n7 := TransitionName new symbolOrPair: #missingQuote; action: #missingQuote; parameters: #().
    t7 := Transition new transitionName: n7; goto: s5.
    n8 := TransitionName new symbolOrPair: #emitToken; action: #emitToken; parameters: #String.
    t8 := Transition new transitionName: n8; goto: s6.

    s1 transitions add: t1.
    s2 transitions add: t2; add: t3; add: t4.
    s3 transitions add: t5; add: t6.

    fsm states add: s1; add: s2; add: s3; add: s4; add: s5; add: s6.
        fsm renumber.
    Transcript cr; <<fsm.! ! 
#('February 23, 2021' '07:19:38 PM' 2125872)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


!FiniteStateMachine class methods !
example4
    "FiniteStateMachine example4"
    |fsm s1 s2 s3 s4 s5 s6 t1 t2 t3 t4 t5 t6 t7 t8 n1 n2 n3 n4 n5 n6 n7 n8|
    fsm := FiniteStateMachine new.
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s6 := FiniteStateMachineState new isInitial: false; isFinal: true.
    n1 := TransitionName new symbolOrPair: #'"'; attributes: Attribute look.
    t1:= Transition new transitionName: n1; goto: s2.
    n2 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute readKeep.
    t2 := Transition new transitionName: n2; goto: s2.
    n3 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
    t3 := Transition new transitionName: n3; goto: s4.
    t4 := Transition new transitionName: n1; goto: s3.
    n5 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
    t5 := Transition new transitionName: n5; goto: s5.
    n6 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute look.
    t6 := Transition new transitionName: n6; goto: s5.
    n7 := TransitionName new symbolOrPair: #missingQuote; action: #missingQuote; parameters: #().
    t7 := Transition new transitionName: n7; goto: s5.
    n8 := TransitionName new symbolOrPair: #emitToken; action: #emitToken; parameters: #String.
    t8 := Transition new transitionName: n8; goto: s6.

    s1 transitions add: t1.
    s2 transitions add: t2; add: t3; add: t4.
    s3 transitions add: t5; add: t6.

    fsm states add: s1; add: s2; add: s3; add: s4; add: s5; add: s6.
        fsm renumber.
    Transcript cr; <<fsm.!   ! 
#('February 23, 2021' '07:20:05 PM' 2127976)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


   
'FiniteStateMachine example4'!

!FiniteStateMachine class methods ! 
example4
    "FiniteStateMachine example4"
    |fsm s1 s2 s3 s4 s5 s6 t1 t2 t3 t4 t5 t6 t7 t8 n1 n2 n3 n4 n5 n6 n7 n8|
    fsm := FiniteStateMachine new.
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s6 := FiniteStateMachineState new isInitial: false; isFinal: true.
    n1 := TransitionName new symbolOrPair: #'"'; attributes: Attribute look.
    t1:= Transition new transitionName: n1; goto: s2.
    n2 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute readKeep.
    t2 := Transition new transitionName: n2; goto: s2.
    n3 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
    t3 := Transition new transitionName: n3; goto: s4.
    t4 := Transition new transitionName: n1; goto: s3.
    n5 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
    t5 := Transition new transitionName: n5; goto: s5.
    n6 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute look.
    t6 := Transition new transitionName: n6; goto: s5.
    n7 := TransitionName new symbolOrPair: #missingQuote; action: #missingQuote; parameters: #().
    t7 := Transition new transitionName: n7; goto: s5.
    n8 := TransitionName new symbolOrPair: #emitToken; action: #emitToken; parameters: #String.
    t8 := Transition new transitionName: n8; goto: s6.

    s1 transitions add: t1.
    s2 transitions add: t2; add: t3; add: t4.
    s3 transitions add: t5; add: t6.
    s4 transitions add: t7.
    s5 transitions add: t8.

    fsm states add: s1; add: s2; add: s3; add: s4; add: s5; add: s6.
        fsm renumber.
    Transcript cr; <<fsm.! ! 
#('February 23, 2021' '07:21:15 PM' 2130156)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


   
'FiniteStateMachine example4'!

!FiniteStateMachine class methods ! 
example4
    "FiniteStateMachine example4"
    |fsm s1 s2 s3 s4 s5 s6 t1 t2 t3 t4 t5 t6 t7 t8 n1 n2 n3 n4 n5 n6 n7 n8|
    fsm := FiniteStateMachine new.
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s6 := FiniteStateMachineState new isInitial: false; isFinal: true.
    n1 := TransitionName new symbolOrPair: #'"'; attributes: Attribute look.
    t1:= Transition new transitionName: n1; goto: s2.
    n2 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute readKeep.
    t2 := Transition new transitionName: n2; goto: s2.
    n3 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
    t3 := Transition new transitionName: n3; goto: s4.
    t4 := Transition new transitionName: n1; goto: s3.
    n5 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
    t5 := Transition new transitionName: n5; goto: s5.
    n6 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute look.
    t6 := Transition new transitionName: n6; goto: s5.
    n7 := TransitionName new symbolOrPair: #'#missingQuote'; action: #missingQuote; parameters: #().
    t7 := Transition new transitionName: n7; goto: s5.
    n8 := TransitionName new symbolOrPair: #'#emitToken'; action: #emitToken; parameters: #String.
    t8 := Transition new transitionName: n8; goto: s6.

    s1 transitions add: t1.
    s2 transitions add: t2; add: t3; add: t4.
    s3 transitions add: t5; add: t6.
    s4 transitions add: t7.
    s5 transitions add: t8.

    fsm states add: s1; add: s2; add: s3; add: s4; add: s5; add: s6.
        fsm renumber.
    Transcript cr; <<fsm.!   ! 
#('February 23, 2021' '07:22:06 PM' 2132380)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example4 )) !


   
'FiniteStateMachine example4'!

!FiniteStateMachine class methods ! 
example3
    "FiniteStateMachine example3"
    |fsm s1 s2 s3 s4 s5 t1 t2 t3 t4  n1 n2 n3 n4 |
    fsm := FiniteStateMachine new.
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: false.
    
    n1 := TransitionName new symbolOrPair: #'"'; attributes: Attribute look.
    t1:= Transition new transitionName: n1; goto: s2.
    n2 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute readKeep.
    t2 := Transition new transitionName: n2; goto: s2.
    n3 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
    t3 := Transition new transitionName: n3; goto: s4.
    t4 := Transition new transitionName: n1; goto: s3.

    

    s1 transitions add: t1; add: t2.
    s2 transitions add: t3.
    s3 transitions add: t4.

    fsm states add: s1; add: s2; add: s3; add: s4; add: s5.
        fsm renumber.
    Transcript cr; <<fsm.! ! 
#('February 23, 2021' '07:24:41 PM' 2111296)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 )) !


!FiniteStateMachine class methods !
example3
    "FiniteStateMachine example3"
    |fsm s1 s2 s3 s4 s5 t1 t2 t3 t4  n1 n2 n3 n4 |
    fsm := FiniteStateMachine new.
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    t1:= Transition new transitionName: n1; goto: s2.
    n2 := TransitionName new symbolOrPair: #a; attributes: Attribute parserNonterminalDefaultAttributes.
    t2 := Transition new transitionName: n2; goto: s5.
    n3 := TransitionName new symbolOrPair: #a; attributes: Attribute look.
    t3 := Transition new transitionName: n3; goto: s3.
    n3 := TransitionName new action: #buildTree; parameters: #("'list'").
    t4 := Transition new transitionName: n1; goto: s4.

    s1 transitions add: t1; add: t2.
    s2 transitions add: t3.
    s3 transitions add: t4.

    fsm states add: s1; add: s2; add: s3; add: s4; add: s5.
        fsm renumber.
    Transcript cr; <<fsm.!    ! 
#('February 23, 2021' '07:27:40 PM' 2136948)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 )) !


   
'FiniteStateMachine example3'!

!FiniteStateMachine class methods ! 
example3
    "FiniteStateMachine example3"
    |fsm s1 s2 s3 s4 s5 t1 t2 t3 t4  n1 n2 n3 n4 |
    fsm := FiniteStateMachine new.
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    t1:= Transition new transitionName: n1; goto: s2.
    n2 := TransitionName new symbolOrPair: #a; attributes: Attribute parserNonterminalDefaultAttributes.
    t2 := Transition new transitionName: n2; goto: s5.
    n3 := TransitionName new symbolOrPair: #a; attributes: Attribute look.
    t3 := Transition new transitionName: n3; goto: s3.
    n4 := TransitionName new action: #buildTree; parameters: #("'list'").
    t4 := Transition new transitionName: n4; goto: s4.

    s1 transitions add: t1; add: t2.
    s2 transitions add: t3.
    s3 transitions add: t4.

    fsm states add: s1; add: s2; add: s3; add: s4; add: s5.
        fsm renumber.
    Transcript cr; <<fsm.!    ! 
#('February 23, 2021' '07:28:30 PM' 2138360)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 )) !


!FiniteStateMachine class methods !
example3
    "FiniteStateMachine example3"
    |fsm s1 s2 s3 s4 s5 t1 t2 t3 t4  n1 n2 n3 n4 |
    fsm := FiniteStateMachine new.
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    t1:= Transition new transitionName: n1; goto: s2.
    n2 := TransitionName new symbolOrPair: #a; attributes: Attribute parserNonterminalDefaultAttributes.
    t2 := Transition new transitionName: n2; goto: s5.
    n3 := TransitionName new symbolOrPair: #a; attributes: Attribute look.
    t3 := Transition new transitionName: n3; goto: s3.
    n4 := TransitionName new action: #buildTree; parameters: #("'list'").
    t4 := Transition new transitionName: n4; goto: s4.

    s1 transitions add: t1; add: t2.
    s2 transitions add: t3.
    s3 transitions add: t4.

    fsm states add: s1; add: s2; add: s3; add: s4; add: s5.
        fsm renumber.
    Transcript cr; <<fsm.!    ! 
#('February 23, 2021' '07:28:40 PM' 2139992)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 )) !


   
'FiniteStateMachine example3'!

!FiniteStateMachine class methods ! 
example3
    "FiniteStateMachine example3"
    |fsm s1 s2 s3 s4 s5 t1 t2 t3 t4  n1 n2 n3 n4 |
    fsm := FiniteStateMachine new.
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    t1:= Transition new transitionName: n1; goto: s2.
    n2 := TransitionName new symbolOrPair: #a; attributes: Attribute parserNonterminalDefaultAttributes.
    t2 := Transition new transitionName: n2; goto: s5.
    n3 := TransitionName new symbolOrPair: #a; attributes: Attribute look.
    t3 := Transition new transitionName: n3; goto: s3.
    n4 := TransitionName new symbolOrPair: #''; action: #buildTree; parameters: #("'list'").
    t4 := Transition new transitionName: n4; goto: s4.

    s1 transitions add: t1; add: t2.
    s2 transitions add: t3.
    s3 transitions add: t4.

    fsm states add: s1; add: s2; add: s3; add: s4; add: s5.
        fsm renumber.
    Transcript cr; <<fsm.! ! 
#('February 23, 2021' '07:29:28 PM' 2141584)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example3 )) !


   
'FiniteStateMachine example3'!

!FiniteStateMachine class methods ! 
experimentingExample1
    "FiniteStateMachine experimentingExample1"
    |fsm state1 state2 transition1 transition2|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: false.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    transition1 := Transition new transitionName: 'a'; goto: state2.
    transition2 := Transition new transitionName: 'a'; goto: state2.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2. 
    ^fsm renumber.!  ! 
#('February 23, 2021' '07:30:51 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' experimentingExample1 )) !


!FiniteStateMachine class methods !   
experimentingExample2
    "FiniteStateMachine experimentingExample2"
    |fsm state1 state2 state3 transition1 transition2 label1 label2|
    fsm := FiniteStateMachine new.
    label1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    label2 := TransitionName new symbolOrPair: #a; action: #buildTree; parameters: #(1 2 4 7 9).
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    transition1:= Transition new transitionName: label1; goto: state2.
    transition2 := Transition new transitionName: label2; goto: state3.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2; add: state3. 
    ^fsm renumber.!   ! 
#('February 23, 2021' '07:31:13 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' experimentingExample2 )) !


!FiniteStateMachine class methods !   
example1
    "FiniteStateMachine example1"
    |fsm s1 s2 s3 s4 s5 s6 t1 t2 t3 t4 t5 t6 t7 t8 n1 n2 n3 n4 n5 n6 n7 n8|
    fsm := FiniteStateMachine new.
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s6 := FiniteStateMachineState new isInitial: false; isFinal: true.
    n1 := TransitionName new symbolOrPair: #'"'; attributes: Attribute look.
    t1:= Transition new transitionName: n1; goto: s2.
    n2 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute readKeep.
    t2 := Transition new transitionName: n2; goto: s2.
    n3 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
    t3 := Transition new transitionName: n3; goto: s4.
    t4 := Transition new transitionName: n1; goto: s3.
    n5 := TransitionName new symbolOrPair: #endOfFile; attributes: Attribute look.
    t5 := Transition new transitionName: n5; goto: s5.
    n6 := TransitionName new symbolOrPair: #nonQuote; attributes: Attribute look.
    t6 := Transition new transitionName: n6; goto: s5.
    n7 := TransitionName new symbolOrPair: #'#missingQuote'; action: #missingQuote; parameters: #().
    t7 := Transition new transitionName: n7; goto: s5.
    n8 := TransitionName new symbolOrPair: #'#emitToken'; action: #emitToken; parameters: #String.
    t8 := Transition new transitionName: n8; goto: s6.

    s1 transitions add: t1.
    s2 transitions add: t2; add: t3; add: t4.
    s3 transitions add: t5; add: t6.
    s4 transitions add: t7.
    s5 transitions add: t8.

    fsm states add: s1; add: s2; add: s3; add: s4; add: s5; add: s6.
        fsm renumber.
    Transcript cr; <<fsm.!   ! 
#('February 23, 2021' '07:31:28 PM' 2114524)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example1 )) !


!FiniteStateMachine class methods !
example2
    "FiniteStateMachine example2"
    |fsm s1 s2 s3 s4 s5 t1 t2 t3 t4  n1 n2 n3 n4 |
    fsm := FiniteStateMachine new.
    s1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    s2 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    s4 := FiniteStateMachineState new isInitial: false; isFinal: true.
    s5 := FiniteStateMachineState new isInitial: false; isFinal: true.
    
    n1 := TransitionName new symbolOrPair: #S; attributes: Attribute parserNonterminalDefaultAttributes.
    t1:= Transition new transitionName: n1; goto: s2.
    n2 := TransitionName new symbolOrPair: #a; attributes: Attribute parserNonterminalDefaultAttributes.
    t2 := Transition new transitionName: n2; goto: s5.
    n3 := TransitionName new symbolOrPair: #a; attributes: Attribute look.
    t3 := Transition new transitionName: n3; goto: s3.
    n4 := TransitionName new symbolOrPair: #''; action: #buildTree; parameters: #("'list'").
    t4 := Transition new transitionName: n4; goto: s4.

    s1 transitions add: t1; add: t2.
    s2 transitions add: t3.
    s3 transitions add: t4.

    fsm states add: s1; add: s2; add: s3; add: s4; add: s5.
        fsm renumber.
    Transcript cr; <<fsm.! ! 
#('February 23, 2021' '07:31:40 PM' 2115460)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example2 )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('examples' example2 )) !


"evaluate" 
FiniteStateMachine class removeSelector: #example3!

"evaluate" 
FiniteStateMachine class removeSelector: #example4!

   
'FiniteStateMachine example2'!


'FiniteStateMachine example1'!

"evaluate"  
"*** saved image on: February 23, 2021 07:32:55 PM ***"!  
"*** Image started on: February 23, 2021 07:40:51 PM ***"!
"*** Image started on: February 23, 2021 08:22:02 PM ***"!

"evaluate"  
"*** saved image on: February 23, 2021 08:22:28 PM ***"!  
"*** Image started on: February 23, 2021 08:22:31 PM ***"!

"evaluate"  
"*** saved image on: February 23, 2021 08:22:50 PM ***"!  
"*** Image started on: February 23, 2021 08:22:53 PM ***"!

"evaluate"  
"*** saved image on: February 23, 2021 08:23:02 PM ***"!  
"*** Image started on: February 23, 2021 08:24:07 PM ***"!

"evaluate"  
Transition removeSelector: #printOn:tabs:!

"evaluate"  
Transition removeSelector: #name!

"evaluate"   
Transition removeSelector: #goto:!

"evaluate"  
Transition removeSelector: #attributes!

"evaluate" 
Transition removeSelector: #attributes:!

"evaluate"
Transition removeSelector: #name:!

!Transition methods !   
goto: aState
    goto := aState!   ! 
#('February 23, 2021' '08:27:29 PM' nil)!

(CodeFiler organizerFor: Transition) reorganizeFrom: #(
('get/set' goto: )) !


"evaluate"   
(CodeFiler setAndInitializeOrganizerFor: Transition to: (MethodBasedOrganizer fromArray: #(('get/set' goto goto: transitionName transitionName:)
('printing' printOn:)))).!

"evaluate"
Transition removeSelector: #hasAttributes!

"evaluate"  
(CodeFiler organizerFor: Transition) removeCategory: 'no category methods' ifAbsent: [nil]!

"define class" 

Object subclass: #TransitionName
  instanceVariableNames: 
    ' symbolOrPair attributes action parameters isRootBuilding '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: TransitionName to: ''!


"evaluate" 

Object subclass: #TransitionName
  instanceVariableNames: 
    ' symbolOrPair attributes action parameters isRootBuilding '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Example Parser Users' )
  comment: ''!

"define class"

Object subclass: #Transition
  instanceVariableNames: 
    ' transitionName goto '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: Transition to: ''!


"evaluate"  

Object subclass: #Transition
  instanceVariableNames: 
    ' transitionName goto '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Example Parser Users' )
  comment: ''!

"define class" 

Object subclass: #FiniteStateMachineState
  instanceVariableNames: 
    ' stateNumber isInitial isFinal transitions '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: FiniteStateMachineState to: ''!


"evaluate"  

Object subclass: #FiniteStateMachineState
  instanceVariableNames: 
    ' stateNumber isInitial isFinal transitions '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Example Parser Users' )
  comment: ''!

"define class"  

Object subclass: #FiniteStateMachine
  instanceVariableNames: 
    ' states '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: FiniteStateMachine to: ''!


"evaluate"   

Object subclass: #FiniteStateMachine
  instanceVariableNames: 
    ' states '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Example Parser Users' )
  comment: ''!

"define class"  

Object subclass: #Attribute
  instanceVariableNames: 
    ' isRead isStack isNode isKeep '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: Attribute to: ''!


"evaluate"   

Object subclass: #Attribute
  instanceVariableNames: 
    ' isRead isStack isNode isKeep '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Example Parser Users' )
  comment: ''!

"evaluate" 
(CodeFiler organizerFor: FiniteStateMachine class) removeCategory: 'get/set' ifAbsent: [nil]!

"evaluate"   
FiniteStateMachine class removeSelector: #forE!

"evaluate" 
FiniteStateMachine class removeSelector: #fromParserTransitionSymbol:!

"evaluate"  
FiniteStateMachine class removeSelector: #fromScannerCollection:attributes:!

"evaluate"
FiniteStateMachine class removeSelector: #forIdentifier:attributes:!

"evaluate"
FiniteStateMachine class removeSelector: #epsilon!

"evaluate"  
(CodeFiler organizerFor: FiniteStateMachine class) removeCategory: 'fsmClassMethods' ifAbsent: [nil]!

 
'FiniteStateMachine example1'!


'FiniteStateMachine example2'!

"define class"  

Object subclass: #Attribute
  instanceVariableNames: 
    ' isRead isStack isNode isKeep '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: Attribute to: ''!


"evaluate"   

Object subclass: #Attribute
  instanceVariableNames: 
    ' isRead isStack isNode isKeep '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Grammar Constructor' )
  comment: ''!

"define class"  

Object subclass: #FiniteStateMachineState
  instanceVariableNames: 
    ' stateNumber isInitial isFinal transitions '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: FiniteStateMachineState to: ''!


"evaluate"  

Object subclass: #FiniteStateMachineState
  instanceVariableNames: 
    ' stateNumber isInitial isFinal transitions '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Grammar Constructor' )
  comment: ''!

"define class"   

Object subclass: #Transition
  instanceVariableNames: 
    ' transitionName goto '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: Transition to: ''!


"evaluate"  

Object subclass: #Transition
  instanceVariableNames: 
    ' transitionName goto '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Grammar Constructor' )
  comment: ''!

"define class"  

Object subclass: #TransitionName
  instanceVariableNames: 
    ' symbolOrPair attributes action parameters isRootBuilding '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: TransitionName to: ''!


"evaluate" 

Object subclass: #TransitionName
  instanceVariableNames: 
    ' symbolOrPair attributes action parameters isRootBuilding '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Grammar Constructor' )
  comment: ''!

"define class" 

Object subclass: #FiniteStateMachine
  instanceVariableNames: 
    ' states '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: FiniteStateMachine to: ''!


"evaluate"   

Object subclass: #FiniteStateMachine
  instanceVariableNames: 
    ' states '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Grammar Constructor' )
  comment: ''!

"evaluate"   
(CodeFiler setAndInitializeOrganizerFor: FiniteStateMachine to: (MethodBasedOrganizer fromArray: #(('initializing' initialize)
('get/set' states states:)
('fsmMethods' or: questionMark renumber)
('printing' printOn:)))).!

"evaluate"
FiniteStateMachine removeSelector: #questionMark!

"evaluate"   
FiniteStateMachine removeSelector: #or:!

  
'FiniteStateMachine example2'!


'FiniteStateMachine example1'!

"evaluate"  
(CodeFiler setAndInitializeOrganizerFor: TransitionName to: (MethodBasedOrganizer fromArray: #(('get/set' action action: attributes attributes: isRootBuilding isRootBuilding: parameters parameters: symbolOrPair symbolOrPair:)
('queryMethods' hasAttributes isAction)
('printing' printOn:)))).!

"evaluate"  
"*** saved image on: February 23, 2021 08:37:53 PM ***"!  
"*** Image started on: February 28, 2021 01:12:34 AM ***"!


''!

"define class" 

Object subclass: #FiniteStateMachineBuilder
  instanceVariableNames: 
    ' parser tree map '
  classVariableNames: ''
  poolDictionaries: ''!


!FiniteStateMachineBuilder class methods !  
new

    ^super new initialize!   !

"evaluate"   
(CodeFiler organizerFor: FiniteStateMachineBuilder class) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: FiniteStateMachineBuilder class) reorganizeFrom: #(
('instance creation' new )) !

(CodeFiler organizerFor: FiniteStateMachineBuilder class) reorganizeFrom: #(
('instance creation' new )) !



!FiniteStateMachineBuilder class methods !
rawParserTables
    "FiniteStateMachineBuilder rawParserTables"
    ^
#(
   (keywords stack noStack read look node noNode keep noKeep parser scanner)
   (ReadaheadTable 1 (parser 'RS' 104) (scanner 'RS' 105))
   (ReadaheadTable 2 (walkString: 'RSN' 39) (walkIdentifier: 'RSN' 39) (EndOfFile 'L' 31))
   (ReadaheadTable 3 (#'=' 'RS' 4))
   (ReadaheadTable 4 (walkString: 'RSN' 39) (walkSymbol: 'RSN' 9) (walkInteger: 'RSN' 43) (#'(' 'RS' 10) (walkCharacter: 'RSN' 43) (#'{' 'RS' 11) (walkIdentifier: 'RSN' 39) (#')' 'L' 86) (#'}' 'L' 86) (#'=>' 'L' 86) (#';' 'L' 86))
   (ReadaheadTable 5 (#'[' 'RS' 15) (#'*' 'L' 40) (#'?' 'L' 40) (#'+' 'L' 40) (#'&' 'L' 40) (#'-' 'L' 40) (#'(' 'L' 40) (#'{' 'L' 40) (walkIdentifier: 'L' 40) (walkString: 'L' 40) (walkSymbol: 'L' 40) (walkCharacter: 'L' 40) (walkInteger: 'L' 40) (#'|' 'L' 40) (#')' 'L' 40) (#'}' 'L' 40) (#'=>' 'L' 40) (#';' 'L' 40))
   (ReadaheadTable 6 (#'=>' 'RS' 16) (#';' 'L' 41))
   (ReadaheadTable 7 (#'..' 'RS' 17) (#'[' 'L' 42) (#'*' 'L' 42) (#'?' 'L' 42) (#'+' 'L' 42) (#'&' 'L' 42) (#'-' 'L' 42) (#'(' 'L' 42) (#'{' 'L' 42) (walkIdentifier: 'L' 42) (walkString: 'L' 42) (walkSymbol: 'L' 42) (walkCharacter: 'L' 42) (walkInteger: 'L' 42) (#'|' 'L' 42) (#')' 'L' 42) (#'}' 'L' 42) (#'=>' 'L' 42) (#';' 'L' 42))
   (ReadaheadTable 8 (#';' 'RS' 18))
   (ReadaheadTable 9 (#'[' 'RS' 19) (#'*' 'L' 47) (#'?' 'L' 47) (#'+' 'L' 47) (#'&' 'L' 47) (#'-' 'L' 47) (#'(' 'L' 47) (#'{' 'L' 47) (walkIdentifier: 'L' 47) (walkString: 'L' 47) (walkSymbol: 'L' 47) (walkCharacter: 'L' 47) (walkInteger: 'L' 47) (#';' 'L' 47) (#'|' 'L' 47) (#')' 'L' 47) (#'}' 'L' 47) (#'=>' 'L' 47))
   (ReadaheadTable 10 (walkString: 'RSN' 39) (walkSymbol: 'RSN' 9) (walkInteger: 'RSN' 43) (#'(' 'RS' 10) (walkCharacter: 'RSN' 43) (#'{' 'RS' 11) (walkIdentifier: 'RSN' 39) (#')' 'L' 86) (#'}' 'L' 86) (#'=>' 'L' 86) (#';' 'L' 86))
   (ReadaheadTable 11 (walkString: 'RSN' 39) (walkSymbol: 'RSN' 9) (walkInteger: 'RSN' 43) (#'(' 'RS' 10) (walkCharacter: 'RSN' 43) (#'{' 'RS' 11) (walkIdentifier: 'RSN' 39) (#')' 'L' 86) (#'}' 'L' 86) (#'=>' 'L' 86) (#';' 'L' 86))
   (ReadaheadTable 12 (#'*' 'RS' 52) (#'?' 'RS' 53) (#'+' 'RS' 54) (#'&' 'RS' 22) (#'-' 'RS' 23) (#'(' 'L' 44) (#'{' 'L' 44) (walkIdentifier: 'L' 44) (walkString: 'L' 44) (walkSymbol: 'L' 44) (walkCharacter: 'L' 44) (walkInteger: 'L' 44) (#'|' 'L' 44) (#')' 'L' 44) (#'}' 'L' 44) (#'=>' 'L' 44) (#';' 'L' 44))
   (ReadaheadTable 13 (#'|' 'RS' 24) (#')' 'L' 45) (#'}' 'L' 45) (#'=>' 'L' 45) (#';' 'L' 45))
   (ReadaheadTable 14 (walkString: 'RSN' 39) (walkSymbol: 'RSN' 9) (walkInteger: 'RSN' 43) (#'(' 'RS' 10) (walkCharacter: 'RSN' 43) (#'{' 'RS' 11) (walkIdentifier: 'RSN' 39) (#'|' 'L' 46) (#')' 'L' 46) (#'}' 'L' 46) (#'=>' 'L' 46) (#';' 'L' 46))
   (ReadaheadTable 15 (keep 'RSN' 49) (noNode 'RSN' 49) (noStack 'RSN' 49) (#']' 'RS' 56) (read 'RSN' 49) (look 'RSN' 49) (stack 'RSN' 49) (node 'RSN' 49) (noKeep 'RSN' 49))
   (ReadaheadTable 16 (walkString: 'RSN' 39) (#'-' 'RS' 27) (walkSymbol: 'RSN' 9) (walkIdentifier: 'RSN' 39) (#'+' 'RS' 28) (walkInteger: 'RSN' 59))
   (ReadaheadTable 17 (walkInteger: 'RSN' 43) (walkCharacter: 'RSN' 43))
   (ReadaheadTable 18 (walkString: 'RSN' 39) (walkIdentifier: 'RSN' 39) (EndOfFile 'L' 31))
   (ReadaheadTable 19 (walkString: 'RSN' 39) (walkSymbol: 'RSN' 50) (walkIdentifier: 'RSN' 39) (walkCharacter: 'RSN' 43) (#']' 'RS' 62) (walkInteger: 'RSN' 43))
   (ReadaheadTable 20 (#')' 'RS' 51))
   (ReadaheadTable 21 (#'}' 'RS' 63))
   (ReadaheadTable 22 (walkSymbol: 'RSN' 9) (walkString: 'RSN' 39) (walkIdentifier: 'RSN' 39) (#'{' 'RS' 11) (walkCharacter: 'RSN' 43) (walkInteger: 'RSN' 43) (#'(' 'RS' 10))
   (ReadaheadTable 23 (walkSymbol: 'RSN' 9) (walkString: 'RSN' 39) (walkIdentifier: 'RSN' 39) (#'{' 'RS' 11) (walkCharacter: 'RSN' 43) (walkInteger: 'RSN' 43) (#'(' 'RS' 10))
   (ReadaheadTable 24 (walkString: 'RSN' 39) (walkSymbol: 'RSN' 9) (walkInteger: 'RSN' 43) (#'(' 'RS' 10) (walkCharacter: 'RSN' 43) (#'{' 'RS' 11) (walkIdentifier: 'RSN' 39))
   (ReadaheadTable 25 (walkString: 'RSN' 39) (walkSymbol: 'RSN' 9) (walkInteger: 'RSN' 43) (#'(' 'RS' 10) (walkCharacter: 'RSN' 43) (#'{' 'RS' 11) (walkIdentifier: 'RSN' 39) (#'|' 'L' 55) (#')' 'L' 55) (#'}' 'L' 55) (#'=>' 'L' 55) (#';' 'L' 55))
   (ReadaheadTable 26 (keep 'RSN' 49) (noNode 'RSN' 49) (noStack 'RSN' 49) (#']' 'RS' 56) (read 'RSN' 49) (look 'RSN' 49) (stack 'RSN' 49) (node 'RSN' 49) (noKeep 'RSN' 49))
   (ReadaheadTable 27 (walkInteger: 'RSN' 67))
   (ReadaheadTable 28 (walkInteger: 'RSN' 59))
   (ReadaheadTable 29 (walkString: 'RSN' 39) (walkSymbol: 'RSN' 50) (#']' 'RS' 62) (walkIdentifier: 'RSN' 39) (walkCharacter: 'RSN' 43) (walkInteger: 'RSN' 43))
   (ReadaheadTable 30 (#'|' 'RS' 24) (#')' 'L' 66) (#'}' 'L' 66) (#'=>' 'L' 66) (#';' 'L' 66))
   (ReadbackTable 31 ((GrammarType 2) 'RSN' 85) ((#';' 18) 'RS' 68))
   (ReadbackTable 32 ((RepetitionOption 25) 'RSN' 32) ((RepetitionOption 14) 'RSN' 92))
   (ReadbackTable 33 ((#'[' 15) 'RS' 70) ((Attribute 26) 'RSN' 33))
   (ReadbackTable 34 ((#'+' 28) 'RS' 96) ((#'=>' 16) 'L' 96))
   (ReadbackTable 35 ((#'[' 19) 'RS' 47) ((SemanticActionParameter 29) 'RSN' 35))
   (ReadbackTable 36 ((Concatenation 30) 'RSN' 69) ((Concatenation 13) 'RSN' 102))
   (ReadbackTable 37 ((GrammarType 2) 'RSN' 85) ((#';' 18) 'RS' 68))
   (ShiftbackTable 38 1 79)
   (ShiftbackTable 39 1 75)
   (ShiftbackTable 40 1 71)
   (ShiftbackTable 41 1 83)
   (ShiftbackTable 42 1 80)
   (ShiftbackTable 43 1 82)
   (ShiftbackTable 44 1 74)
   (ShiftbackTable 45 1 81)
   (ShiftbackTable 46 1 72)
   (ShiftbackTable 47 1 87)
   (ShiftbackTable 48 1 88)
   (ShiftbackTable 49 1 77)
   (ShiftbackTable 50 1 76)
   (ShiftbackTable 51 3 80)
   (ShiftbackTable 52 2 89)
   (ShiftbackTable 53 2 90)
   (ShiftbackTable 54 2 91)
   (ShiftbackTable 55 1 32)
   (ShiftbackTable 56 1 33)
   (ShiftbackTable 57 1 94)
   (ShiftbackTable 58 3 95)
   (ShiftbackTable 59 1 34)
   (ShiftbackTable 60 1 97)
   (ShiftbackTable 61 3 98)
   (ShiftbackTable 62 1 35)
   (ShiftbackTable 63 3 99)
   (ShiftbackTable 64 3 100)
   (ShiftbackTable 65 3 101)
   (ShiftbackTable 66 2 36)
   (ShiftbackTable 67 2 103)
   (ShiftbackTable 68 3 37)
   (ShiftbackTable 69 1 36)
   (ShiftbackTable 70 1 93)
   (ReduceTable 71 Expression (4 'RSN' 12)(10 'RSN' 12)(11 'RSN' 12)(14 'RSN' 12)(22 'RSN' 64)(23 'RSN' 65)(24 'RSN' 12)(25 'RSN' 12))
   (ReduceTable 72 Concatenation (4 'RSN' 13)(10 'RSN' 13)(11 'RSN' 13)(24 'RSN' 30))
   (ReduceTable 73 ListOfFiniteStateMachines (1 'RSN' 106))
   (ReduceTable 74 RepetitionOption (4 'RSN' 14)(10 'RSN' 14)(11 'RSN' 14)(14 'RSN' 25)(24 'RSN' 14)(25 'RSN' 25))
   (ReduceTable 75 Name (2 'RSN' 3)(4 'RSN' 42)(10 'RSN' 42)(11 'RSN' 42)(14 'RSN' 42)(16 'RSN' 57)(18 'RSN' 3)(19 'RSN' 50)(22 'RSN' 42)(23 'RSN' 42)(24 'RSN' 42)(25 'RSN' 42)(29 'RSN' 50))
   (ReduceTable 76 SemanticActionParameter (19 'RSN' 29)(29 'RSN' 29))
   (ReduceTable 77 Attribute (15 'RSN' 26)(26 'RSN' 26))
   (ReduceTable 78 TreeBuildingOptions (16 'RSN' 58))
   (ReduceTable 79 GrammarType (1 'RSN' 2))
   (ReduceTable 80 Primary (4 'RSN' 5)(10 'RSN' 5)(11 'RSN' 5)(14 'RSN' 5)(22 'RSN' 5)(23 'RSN' 5)(24 'RSN' 5)(25 'RSN' 5))
   (ReduceTable 81 Alternation (4 'RSN' 6)(10 'RSN' 20)(11 'RSN' 21))
   (ReduceTable 82 Byte (4 'RSN' 7)(10 'RSN' 7)(11 'RSN' 7)(14 'RSN' 7)(17 'RSN' 61)(19 'RSN' 50)(22 'RSN' 7)(23 'RSN' 7)(24 'RSN' 7)(25 'RSN' 7)(29 'RSN' 50))
   (ReduceTable 83 FiniteStateMachine (4 'RSN' 8))
   (ReduceTable 84 SemanticAction (4 'RSN' 48)(10 'RSN' 48)(11 'RSN' 48)(14 'RSN' 48)(16 'RSN' 60)(22 'RSN' 48)(23 'RSN' 48)(24 'RSN' 48)(25 'RSN' 48))
   (SemanticTable 85 buildTree: walkList: 73)
   (SemanticTable 86 buildTree: walkEpsilon: 81)
   (SemanticTable 87 buildTree: walkSemanticAction: 84)
   (SemanticTable 88 buildTree: walkNonTreeBuildingSemanticAction: 71)
   (SemanticTable 89 buildTree: walkStar: 74)
   (SemanticTable 90 buildTree: walkQuestionMark: 74)
   (SemanticTable 91 buildTree: walkPlus: 74)
   (SemanticTable 92 buildTree: walkConcatenation: 72)
   (SemanticTable 93 buildTree: walkAttributes: 71)
   (SemanticTable 94 buildTree: walkBuildTreeOrTokenFromName: 78)
   (SemanticTable 95 buildTree: walkConcatenation: 83)
   (SemanticTable 96 buildTree: walkBuildTreeFromLeftIndex: 78)
   (SemanticTable 97 buildTree: walkTreeBuildingSemanticAction: 78)
   (SemanticTable 98 buildTree: walkDotDot: 80)
   (SemanticTable 99 buildTree: walkLook: 80)
   (SemanticTable 100 buildTree: walkAnd: 74)
   (SemanticTable 101 buildTree: walkMinus: 74)
   (SemanticTable 102 buildTree: walkOr: 81)
   (SemanticTable 103 buildTree: walkBuildTreeFromRightIndex: 78)
   (SemanticTable 104 processTypeNow: parser 38)
   (SemanticTable 105 processTypeNow: scanner 38)
   (AcceptTable 106))! !

!FiniteStateMachineBuilder class methods !   
rawScannerTables
    "FiniteStateMachineBuilder rawScannerTables"
    ^
#(
   (ScannerReadaheadTable 1 ('''' 'R' 9) (']' 'RK' 36) ('/' 'R' 10) ('{' 'RK' 37) ('}' 'RK' 38) ('"' 'R' 11) ('$' 'R' 12) ((256) 'L' 21) ('?' 'RK' 32) ('ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz' 'RK' 6) ('(' 'RK' 23) (')' 'RK' 24) ('*' 'RK' 25) ('+' 'RK' 26) ('-' 'RK' 2) ('&' 'RK' 22) ('.' 'RK' 3) ((9 10 12 13) 'R' 7) (' ' 'R' 7) ('0123456789' 'RK' 4) (';' 'RK' 30) ('=' 'RK' 5) ('[' 'RK' 34) ('#' 'R' 8) ('|' 'RK' 35))
   (ScannerReadaheadTable 2 ((9 10 12 13 96 147 148 256) 'L' 27) ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_0123456789!!,+-/\*~=@%&?|<[]{}()^;#:.$''" ' 'L' 27) ('>' 'RK' 39))
   (ScannerReadaheadTable 3 ((9 10 12 13 96 147 148 256) 'L' 28) ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_0123456789!!,+-/\*~=@%&?|<>[]{}()^;#:$''" ' 'L' 28) ('.' 'RK' 40))
   (ScannerReadaheadTable 4 ((9 10 12 13 96 147 148 256) 'L' 29) ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_!!,+-/\*~=@%&?|<>[]{}()^;#:.$''" ' 'L' 29) ('0123456789' 'RK' 4))
   (ScannerReadaheadTable 5 ((9 10 12 13 96 147 148 256) 'L' 31) ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_0123456789!!,+-/\*~=@%&?|<[]{}()^;#:.$''" ' 'L' 31) ('>' 'RK' 41))
   (ScannerReadaheadTable 6 ((9 10 12 13 96 147 148 256) 'L' 33) ('!!,+-/\*~=@%&?|<>[]{}()^;#.$''" ' 'L' 33) ('0123456789:ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz' 'RK' 6))
   (ScannerReadaheadTable 7 ((96 147 148 256) 'L' 1) ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_0123456789!!,+-/\*~=@%&?|<>[]{}()^;#:.$''"' 'L' 1) ((9 10 12 13) 'R' 7) (' ' 'R' 7))
   (ScannerReadaheadTable 8 ('"' 'R' 14) ('''' 'R' 15) ('ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz' 'RK' 13))
   (ScannerReadaheadTable 9 ((256) 'LK' 43) ('''' 'R' 16) ((9 10 12 13 96 147 148) 'RK' 9) (' !!"#$%&()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_abcdefghijklmnopqrstuvwxyz{|}~' 'RK' 9))
   (ScannerReadaheadTable 10 ((9 10 12 13) 'L' 45) (' ' 'L' 45) ((96 147 148 256) 'LK' 45) ('=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_\abcdefghijklmnopqrstuvwxyz{|}~!!"#$%&''()*+,-.0123456789:;<' 'LK' 45) ('/' 'R' 17))
   (ScannerReadaheadTable 11 ((256) 'LK' 46) ('"' 'R' 18) ((9 10 12 13 96 147 148) 'RK' 11) (' !!#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_abcdefghijklmnopqrstuvwxyz{|}~' 'RK' 11))
   (ScannerReadaheadTable 12 ((9 10 12 13 96 147 148) 'RK' 47) (' !!"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_abcdefghijklmnopqrstuvwxyz{|}~' 'RK' 47))
   (ScannerReadaheadTable 13 ((9 10 12 13 96 147 148 256) 'L' 42) ('!!,+-/\*~=@%&?|<>[]{}()^;#.$''" ' 'L' 42) ('0123456789:ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz' 'RK' 13))
   (ScannerReadaheadTable 14 ((256) 'LK' 48) ('"' 'R' 19) ((9 10 12 13 96 147 148) 'RK' 14) (' !!#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_abcdefghijklmnopqrstuvwxyz{|}~' 'RK' 14))
   (ScannerReadaheadTable 15 ((256) 'LK' 49) ('''' 'R' 20) ((9 10 12 13 96 147 148) 'RK' 15) (' !!"#$%&()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_abcdefghijklmnopqrstuvwxyz{|}~' 'RK' 15))
   (ScannerReadaheadTable 16 ((9 10 12 13 96 147 148 256) 'L' 44) ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_0123456789!!,+-/\*~=@%&?|<>[]{}()^;#:.$" ' 'L' 44) ('''' 'RK' 9))
   (ScannerReadaheadTable 17 ((9 96 147 148) 'R' 17) ('=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_abcdefghijklmnopqrstuvwxyz{|}~ !!"#$%&''()*+,-./0123456789:;<' 'R' 17) ((256) 'LK' 1) ((10 12 13) 'R' 1))
   (ScannerReadaheadTable 18 ((9 10 12 13 96 147 148 256) 'L' 44) ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_0123456789!!,+-/\*~=@%&?|<>[]{}()^;#:.$'' ' 'L' 44) ('"' 'RK' 11))
   (ScannerReadaheadTable 19 ((9 10 12 13 96 147 148 256) 'L' 42) ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_0123456789!!,+-/\*~=@%&?|<>[]{}()^;#:.$'' ' 'L' 42) ('"' 'RK' 14))
   (ScannerReadaheadTable 20 ((9 10 12 13 96 147 148 256) 'L' 42) ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_0123456789!!,+-/\*~=@%&?|<>[]{}()^;#:.$" ' 'L' 42) ('''' 'RK' 15))
   (SemanticTable 21 buildToken: EndOfFile 1)
   (SemanticTable 22 buildToken: '&' 1)
   (SemanticTable 23 buildToken: '(' 1)
   (SemanticTable 24 buildToken: ')' 1)
   (SemanticTable 25 buildToken: '*' 1)
   (SemanticTable 26 buildToken: '+' 1)
   (SemanticTable 27 buildToken: '-' 1)
   (SemanticTable 28 buildToken: '.' 1)
   (SemanticTable 29 buildToken: walkInteger: 1)
   (SemanticTable 30 buildToken: ';' 1)
   (SemanticTable 31 buildToken: '=' 1)
   (SemanticTable 32 buildToken: '?' 1)
   (SemanticTable 33 buildToken: walkIdentifier: 1)
   (SemanticTable 34 buildToken: '[' 1)
   (SemanticTable 35 buildToken: '|' 1)
   (SemanticTable 36 buildToken: ']' 1)
   (SemanticTable 37 buildToken: '{' 1)
   (SemanticTable 38 buildToken: '}' 1)
   (SemanticTable 39 buildToken: '->' 1)
   (SemanticTable 40 buildToken: '..' 1)
   (SemanticTable 41 buildToken: '=>' 1)
   (SemanticTable 42 buildToken: walkSymbol: 1)
   (SemanticTable 43 syntaxError: 'missing end quote for single quoted string' 44)
   (SemanticTable 44 buildToken: walkString: 1)
   (SemanticTable 45 syntaxError: '// is a comment, / alone is not valid' 1)
   (SemanticTable 46 syntaxError: 'missing end quote for double quoted string' 44)
   (SemanticTable 47 buildToken: walkCharacter: 1)
   (SemanticTable 48 syntaxError: 'missing end quote for double quoted string' 42)
   (SemanticTable 49 syntaxError: 'missing end quote for single quoted string' 42))!  !
(CodeFiler organizerFor: FiniteStateMachineBuilder class) reorganizeFrom: #(
('raw tables' rawParserTables rawScannerTables )) !

(CodeFiler organizerFor: FiniteStateMachineBuilder class) reorganizeFrom: #(
('raw tables' rawParserTables rawScannerTables )) !



!FiniteStateMachineBuilder class methods !   
promptForFiniteStateMachines
    "FiniteStateMachineBuilder promptForFiniteStateMachines"
    | fileName file |
    fileName :=  FileDialog promptTitle: 'File of finite state machines'.
    fileName isNil ifTrue: [^self]. "User cancelled"
    Transcript cr; cr; << 'Building finite state machines for file '; << fileName printString.
    file := File pathNameReadOnly: fileName.
    ^FiniteStateMachineBuilder new process: file contents!    !
(CodeFiler organizerFor: FiniteStateMachineBuilder class) reorganizeFrom: #(
('examples' promptForFiniteStateMachines )) !

(CodeFiler organizerFor: FiniteStateMachineBuilder class) reorganizeFrom: #(
('examples' promptForFiniteStateMachines )) !



!FiniteStateMachineBuilder methods ! 
initialize
    parser := Parser
        for: self
        parserTables: self class rawParserTables
        scannerTables: self class rawScannerTables.
    map := Dictionary new.! !

"evaluate"   
(CodeFiler organizerFor: FiniteStateMachineBuilder) removeCategory: 'no category methods' ifAbsent: [nil]!
(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('initializing' initialize )) !



!FiniteStateMachineBuilder methods !
process: text
    tree := parser parse: text.
    self walkTree: tree!    !

!FiniteStateMachineBuilder methods ! 
walkTree: aTree
    ^self perform: aTree label with: aTree!    !
(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('processing' process: walkTree: )) !

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('processing' process: walkTree: )) !



!FiniteStateMachineBuilder methods ! 
walkList: aTree
    "Note: Since none of the walk routines are there (except this one), running will stop as soon
    as a new one that you must implement is reached."
    
    | name fsm outputIndex |
    "If there is too much output, just change the index. If it's 10, you start outputting at fsm 10."
    outputIndex := 1. self halt: 'Task 4: Take a look at the tree...'.
    
    1 to: aTree children size by: 2 do: [:index |
        "Child index must be a walkIdentifier: token and child index+1 must be a finite state machine tree."
        name := (aTree child: index) symbol.
        fsm := self walkTree: (aTree child: index+1).
        (index+1)/2  >= outputIndex ifTrue: [
            Transcript cr; << 'FSM for '; << name; << ' = '; cr; << fsm].
        map at: name put: fsm].!    !
(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkList: )) !

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkList: )) !



!FiniteStateMachineBuilder methods !   
processTypeNow: parserOrScanner    
    self halt: 'Look at the parameter? It tells you if you are processing a parser or a scanner'!  !
(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('semantic actions' processTypeNow: )) !

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('semantic actions' processTypeNow: )) !
CodeFiler setCommentFor: FiniteStateMachineBuilder to: ''!


"define class"   

Object subclass: #FiniteStateMachineBuilder
  instanceVariableNames: 
    ' parser tree map '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: FiniteStateMachineBuilder to: ''!


"evaluate"

Object subclass: #FiniteStateMachineBuilder
  instanceVariableNames: 
    ' parser tree map '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Grammar Constructor' )
  comment: ''!

!FiniteStateMachineBuilder methods ! 
walkEpsilon: aTree
    ^FiniteStateMachine epsilon!    ! 
#('February 28, 2021' '01:21:03 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkEpsilon: )) !


!FiniteStateMachineBuilder methods !  
walkQuestionMark: aTree
    |fsm|
    fsm := self walkTree: (aTree child:1).
    ^fsm questionMark!  ! 
#('February 28, 2021' '01:21:12 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkQuestionMark: )) !


!FiniteStateMachineBuilder methods ! 
walkPlus: aTree
    |fsm|
    fsm := self walkTree: (aTree child:1).
    ^fsm plus.! ! 
#('February 28, 2021' '01:22:09 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkPlus: )) !


"evaluate"   
(CodeFiler organizerFor: 'FiniteStateMachine class')  addCategory: 'classMethods' before: 'examples'!

!FiniteStateMachine class methods !  
forParser: aTransitionName
    |fsm state1 state2 transition|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: false.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    transition := Transition new name: aTransitionName; goto: state2.
    state1 transitions add: transition.
    fsm states add: state1; add: state2. 
    ^fsm renumber.!  ! 
#('February 28, 2021' '01:25:00 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('classMethods' forParser: )) !


!FiniteStateMachine class methods !  
starMark
    |fsm state1 transition1|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    transition1 := Transition new name: 'a'; goto: state1.
    state1 transitions add: transition1.
    fsm states add: state1. 
    ^fsm renumber.!  ! 
#('February 28, 2021' '01:25:10 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('classMethods' starMark )) !


!FiniteStateMachine class methods !
epsilon
    |fsm state1|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    fsm states add: state1.
    ^fsm renumber.!  ! 
#('February 28, 2021' '01:25:19 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('classMethods' epsilon )) !


!FiniteStateMachine class methods ! 
star
    |fsm state1 transition1|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    transition1 := Transition new name: 'a'; goto: state1.
    state1 transitions add: transition1.
    fsm states add: state1. 
    ^fsm renumber.!  ! 
#('February 28, 2021' '01:25:26 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('classMethods' star )) !


"evaluate" 
FiniteStateMachine class removeSelector: #starMark!

!FiniteStateMachine class methods !
plus
    |fsm state1 state2 transition1 transition2|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: false.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    transition1 := Transition new name: 'a'; goto: state2.
    transition2 := Transition new name: 'a'; goto: state2.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2. 
    ^fsm renumber.!   ! 
#('February 28, 2021' '01:25:56 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('classMethods' plus )) !


!FiniteStateMachine class methods !
question
    |fsm state1 state2 state3 transition1 transition2|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    transition1 := Transition new name: 'a'; goto: state2.
    transition2 := Transition new name: 'a'; goto: state3.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2; add: state3. 
    ^fsm renumber.!   ! 
#('February 28, 2021' '01:26:12 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('classMethods' question )) !


!FiniteStateMachineBuilder methods !   
walkConcatenation: aTree
    | fsms |
    fsms := aTree children collect: [:child | self walkTree: child].
    ^ FiniteStateMachine concatenate: fsms.!  ! 
#('February 28, 2021' '02:09:27 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkConcatenation: )) !


!FiniteStateMachineBuilder methods !
walkStar: aTree
    |fsm|
    fsm := self walkTree: (aTree child:1).
    ^fsm star.! ! 
#('February 28, 2021' '02:24:27 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkStar: )) !


!FiniteStateMachineBuilder methods ! 
walkAttributes: aTree
    | fsm |
    fsm := self walkTree: (aTree children first).
    ^fsm override: (aTree children rest collect: [:token | token symbol ]).! ! 
#('February 28, 2021' '02:25:25 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkAttributes: )) !


!FiniteStateMachineBuilder methods !   
walkConcatenation: aTree
    | fsm |
    fsm := aTree children collect: [:child | self walkTree: child].
    ^ FiniteStateMachine concat: fsm.!  ! 
#('February 28, 2021' '02:28:32 AM' 2182152)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkConcatenation: )) !

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkConcatenation: )) !


!FiniteStateMachineBuilder methods ! 
walkOr: aTree
    ^ FiniteStateMachine or: (aTree children collect: [:child | self walkTree: child]).! ! 
#('February 28, 2021' '02:29:25 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkOr: )) !


!FiniteStateMachineBuilder methods !   
walkBuildTreeFromRightIndex: aTree
    | parameters aTransitionName |
    parameters := aTree children collect: [:x | (self convert: x) negated]. 
    
    aTransitionName := TransitionName new
        action: ( [#buildTreeFromIndex] ifFalse: [#buildToken]);
        isRootBuilding: true;
        parameters: parameters;
        symbol: aTree label.
    ^FiniteStateMachine fromParserTransitionSymbol: aTransitionName.!    ! 
#('February 28, 2021' '02:32:17 AM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkBuildTreeFromRightIndex: )) !


"evaluate"
"*** saved image on: February 28, 2021 02:33:07 AM ***"!  
"*** Image started on: March 2, 2021 04:18:22 PM ***"!

"define class"  

Object subclass: #FiniteStateMachineBuilder
  instanceVariableNames: 
    ' parser tree map isParser '
  classVariableNames: ''
  poolDictionaries: ''!CodeFiler setCommentFor: FiniteStateMachineBuilder to: ''!


"evaluate"   

Object subclass: #FiniteStateMachineBuilder
  instanceVariableNames: 
    ' parser tree map isParser'
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Grammar Constructor' )
  comment: ''!

!FiniteStateMachineBuilder methods ! 
processTypeNow: parserOrScanner    
    isParser := parserOrScanner = #parser.!    ! 
#('March 2, 2021' '04:29:28 PM' 2176696)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('semantic actions' processTypeNow: )) !

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('semantic actions' processTypeNow: )) !


!FiniteStateMachineBuilder methods !   
walkIdentifier: aTree
    |name transit|
    name := aTree symbol.
    transit := TransitionName new 
        symbol: name; 
        attributes: (isParser ifTrue: [Attribute parserTerminalDefaultAttributes] ifFalse: [Attribute scannerDefaultAttributes]).
    ^FiniteStateMachine forParser: transit.!   ! 
#('March 2, 2021' '04:31:55 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkIdentifier: )) !


"evaluate" 
FiniteStateMachineBuilder removeSelector: #walkOr:!

"evaluate" 
FiniteStateMachineBuilder removeSelector: #walkConcatenation:!

"evaluate"  
FiniteStateMachineBuilder removeSelector: #walkBuildTreeFromRightIndex:!

"evaluate"
FiniteStateMachineBuilder removeSelector: #walkAttributes:!

!FiniteStateMachineBuilder methods !   
walkQuestionMark: aTree
    |fsm|
    fsm := self walkTree: (aTree child:1).
    ^fsm question.! ! 
#('March 2, 2021' '04:36:06 PM' 2177876)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkQuestionMark: )) !

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkQuestionMark: )) !


!FiniteStateMachine class methods !
questionMark
    |fsm state1 state2 state3 transition1 transition2|
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true.
    state2 := FiniteStateMachineState new isInitial: false; isFinal: true.
    state3 := FiniteStateMachineState new isInitial: false; isFinal: false.
    transition1 := Transition new name: 'a'; goto: state2.
    transition2 := Transition new name: 'a'; goto: state3.
    state1 transitions add: transition1.
    state2 transitions add: transition2.
    fsm states add: state1; add: state2; add: state3. 
    ^fsm renumber.!   ! 
#('March 2, 2021' '04:38:54 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('classMethods' questionMark )) !


"evaluate" 
FiniteStateMachine class removeSelector: #question!

!FiniteStateMachine class methods !
or: fsm
    self states addAll: fsm states.
    self renumber.
    ^self!    ! 
#('March 2, 2021' '04:39:22 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('classMethods' or: )) !


!FiniteStateMachine methods !   
or: fsm
    self states addAll: fsm states.
    self renumber.
    ^self!    ! 
#('March 2, 2021' '04:40:34 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' or: )) !


!FiniteStateMachine methods !   
questionMark
    ^self or: FiniteStateMachine epsilon! ! 
#('March 2, 2021' '04:40:51 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' questionMark )) !


"evaluate" 
FiniteStateMachine class removeSelector: #or:!

!FiniteStateMachineBuilder methods !
walkQuestionMark: aTree
    |fsm|
    fsm := self walkTree: (aTree child:1).
    ^fsm questionMark.! ! 
#('March 2, 2021' '04:42:26 PM' 2186412)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkQuestionMark: )) !

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkQuestionMark: )) !


!FiniteStateMachineBuilder methods !   
walkConcatenate: aTree
    |fsm|
    fsm := self walkTree: (aTree child:1).
    ^fsm concat.!    ! 
#('March 2, 2021' '04:43:09 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkConcatenate: )) !


!FiniteStateMachineBuilder methods !  
walkTreeBuildingSemanticAction: aTree
    ^ (self walkTree: aTree children first) override: #treeBuilding.!    ! 
#('March 2, 2021' '05:06:41 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkTreeBuildingSemanticAction: )) !


!FiniteStateMachineBuilder methods !   
walkSemanticAction: aTree
    | action parameters aTransitionName |
    action := self convert: (aTree children first).
    
    parameters := aTree children rest collect: [:x | self convert: x ]. 
    
    aTransitionName := TransitionName new
        action: action;
        isRootBuilding: false;
        parameters: parameters;
        symbol: aTree label.
    ^FiniteStateMachine fromParserTransitionSymbol: aTransitionName.!   ! 
#('March 2, 2021' '05:07:22 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkSemanticAction: )) !


!FiniteStateMachineBuilder methods !   
walkOr: aTree
    | fsms |

    fsms := aTree children collect: [:child |
        self walkTree: child
    ].
    
    ^ FiniteStateMachine or: fsms!    ! 
#('March 2, 2021' '05:08:04 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkOr: )) !


!FiniteStateMachineBuilder methods !   
walkOr: aTree
    | fsms |
    fsms := aTree children collect: [:child |
        self walkTree: child].
    ^ FiniteStateMachine or: fsms!  ! 
#('March 2, 2021' '05:08:16 PM' 2190220)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkOr: )) !

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkOr: )) !


!FiniteStateMachineBuilder methods !   
walkNonTreeBuildingSemanticAction: aTree
    ^ (self walkTree: aTree children first) override: #notTreeBuilding.!  ! 
#('March 2, 2021' '05:08:27 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkNonTreeBuildingSemanticAction: )) !


!FiniteStateMachineBuilder methods !
lookForToken: aTree

    ((aTree child: 1) class) = Token ifTrue: [
        ^ (aTree child: 1) symbol
    ].
    
    ^ self lookForToken: (aTree child: 1)!  ! 
#('March 2, 2021' '05:09:28 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' lookForToken: )) !


"evaluate"   
(CodeFiler organizerFor: 'FiniteStateMachineBuilder class')  addCategory: 'fsmbuildMethods' before: nil!

!FiniteStateMachineBuilder class methods !
or: fsms
    | fsm |
    fsm := fsms first.
    fsms rest do: [:x | 
        fsm := fsm or: x.].
    ^ fsm renumber!   ! 
#('March 2, 2021' '05:10:38 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder class) reorganizeFrom: #(
('fsmbuildMethods' or: )) !


!FiniteStateMachineBuilder methods !  
walkAttributes: aTree
    | fsm |
    fsm := self walkTree: (aTree children first).
    ^fsm override: (aTree children rest collect: [:token | token symbol ]).! ! 
#('March 2, 2021' '05:13:34 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkAttributes: )) !


!FiniteStateMachineBuilder methods !   
walkAttributes: aTree
    | expression attributeTokens attributeSymbols fsm | 
    
    expression := aTree child: 1. 
    attributeTokens := aTree children rest.
    attributeSymbols := attributeTokens collect: [:token | token symbol].
    fsm := self walkTree: expression.

    ^ fsm override: attributeSymbols!   ! 
#('March 2, 2021' '05:15:39 PM' 2192156)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkAttributes: )) !

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkAttributes: )) !


!FiniteStateMachine class methods !
concat: fsms
    | fsm |
    fsm := fsms first.
    fsms rest do: [:cfsm | 
        fsm concat: cfsm.].
    ^ fsm renumber.!   ! 
#('March 2, 2021' '05:16:49 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('classMethods' concat: )) !


!FiniteStateMachineBuilder methods !
walkConcatenate: aTree
    |fsm|
    fsm := aTree children collect: [:child | self walkTree: child].
    ^ FiniteStateMachine concat: fsm.!  ! 
#('March 2, 2021' '05:18:08 PM' 2188944)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkConcatenate: )) !

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkConcatenate: )) !


!FiniteStateMachineBuilder methods ! 
walkAttributes: aTree
    | expression attributeTokens attributeSymbols fsm | 
    
    expression := aTree child: 1. 
    attributeTokens := aTree children rest.
    attributeSymbols := attributeTokens collect: [:token | token symbol].
    fsm := self walkTree: expression.

    ^ fsm attributes!   ! 
#('March 2, 2021' '05:20:58 PM' 2192520)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkAttributes: )) !

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkAttributes: )) !


!FiniteStateMachineBuilder methods !   
walkAttributes: aTree
    | expression attributeTokens attributeSymbols fsm | 
    
    expression := aTree child: 1. 
    attributeTokens := aTree children rest.
    attributeSymbols := attributeTokens collect: [:token | token symbol].
    fsm := self walkTree: expression.

    ^ fsm override: attributeSymbols!   ! 
#('March 2, 2021' '05:22:01 PM' 2193936)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkAttributes: )) !

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkAttributes: )) !


"evaluate" 
FiniteStateMachineBuilder removeSelector: #lookForToken:!

!FiniteStateMachineBuilder methods ! 
walkAttributes: aTree!  ! 
#('March 2, 2021' '05:22:53 PM' 2194560)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkAttributes: )) !

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkAttributes: )) !


!FiniteStateMachineBuilder methods !   
walkNonTreeBuildingSemanticAction: aTree!   ! 
#('March 2, 2021' '05:23:22 PM' 2191016)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkNonTreeBuildingSemanticAction: )) !

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkNonTreeBuildingSemanticAction: )) !


!FiniteStateMachineBuilder methods ! 
walkOr: aTree
    | fsm |
    fsm := aTree children collect: [:child |
        self walkTree: child].
    ^ FiniteStateMachine or: fsm! ! 
#('March 2, 2021' '05:23:38 PM' 2190572)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkOr: )) !

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkOr: )) !


!FiniteStateMachineBuilder methods !   
walkTreeBuildingSemanticAction: aTree!  ! 
#('March 2, 2021' '05:24:12 PM' 2189244)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkTreeBuildingSemanticAction: )) !

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkTreeBuildingSemanticAction: )) !


"evaluate" 
FiniteStateMachineBuilder removeSelector: #walkTreeBuildingSemanticAction:!

"evaluate" 
FiniteStateMachineBuilder removeSelector: #walkNonTreeBuildingSemanticAction:!

"evaluate"  
(CodeFiler organizerFor: FiniteStateMachineBuilder class) removeCategory: 'fsmbuildMethods' ifAbsent: [nil]!

"evaluate"
FiniteStateMachineBuilder removeSelector: #walkAttributes:!

!FiniteStateMachine methods !  
override: attributes

attributes do: [:symbol | 
    self states do: [:state | 
        state transitions do: [:transition |
            transition override: symbol.
        ].
    ].
].
^ self.!    ! 
#('March 2, 2021' '09:50:00 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' override: )) !


!FiniteStateMachine methods ! 
override: attributes

attributes do: [:symbol | 
    self states do: [:state | 
        state transitions do: [:transition |
            transition override: symbol.].].].
^ self.!  ! 
#('March 2, 2021' '09:50:24 PM' 2197216)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' override: )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' override: )) !


!FiniteStateMachine methods !
recognizesE
    states do: [:state | (state isInitial and: [state isFinal]) ifTrue: [^true]].
    ^false.!    ! 
#('March 2, 2021' '09:50:43 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' recognizesE )) !


!FiniteStateMachine methods !   
concat: fsm2
    | fsm1RecE fsm2RecE fsm1Final fsm2Initial |
    fsm1Final := self allFinal.
    fsm2Initial := fsm2 allInitial.
    fsm1RecE := self recognizesE.
    fsm2RecE := fsm2 recognizesE.
    
    fsm1Final do: [:state | 
        state transitions addAllIfAbsent: (fsm2 initialTransitions).
    ].
    
    fsm2RecE ifFalse: [ fsm1Final do: [:state | state isFinal: false] ].
    fsm1RecE ifFalse: [ fsm2Initial do: [:state | state isInitial: false] ].

    self states addAll: fsm2 states.

    ^ self reduce.!    ! 
#('March 2, 2021' '09:51:10 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' concat: )) !


!FiniteStateMachine methods !   
copy
    | fsm stateMap |
    fsm := FiniteStateMachine new.
    stateMap := Dictionary new.
    "TODO: make states first, then copy the transitions
    deepCopy
    "    
    states do: [:state | 
    
        fsm states add: (FiniteStateMachineState new 
            isInitial: state isInitial;
            isFinal: state isFinal
        ).
        
        stateMap at: state put: fsm states last.    
    ].
    
    states do: [:state |
        state transitions do: [:trans | 
            (stateMap at: state) transitions add: (Transition new name: trans name deepCopy; goto: (stateMap at: trans goto)).
        ].
    ].
    
    ^ fsm renumber.!    ! 
#('March 2, 2021' '09:51:33 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' copy )) !


"evaluate" 
FiniteStateMachine removeSelector: #copy!

!FiniteStateMachine methods !
star
    ^ (FiniteStateMachine forE or: self plus) renumber.!  ! 
#('March 2, 2021' '09:52:49 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' star )) !


"evaluate" 
FiniteStateMachine class removeSelector: #plus!

"evaluate" 
FiniteStateMachine class removeSelector: #star!

"evaluate" 
FiniteStateMachine class removeSelector: #questionMark!

"evaluate" 
FiniteStateMachine class removeSelector: #forParser:!

!FiniteStateMachine class methods !  
forE
    | fsm state1 |
    fsm := FiniteStateMachine new.
    state1 := FiniteStateMachineState new isInitial: true; isFinal: true; number: 1.
    fsm states add: state1.
    ^fsm.! ! 
#('March 2, 2021' '09:54:07 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('classMethods' forE )) !


!FiniteStateMachine class methods !
forIdentifier: aSymbol attributes: attributes
    | fsm transitions state1 state2 transition1 |
    fsm := FiniteStateMachine new.
    
    state1 := FiniteStateMachineState new isInitial: true; number: 1.
    state2 := FiniteStateMachineState new isFinal: true; number: 2.
    
    state1 transitions add: (Transition new goto: state2; name: (TransitionName new symbol: aSymbol; attributes: attributes )).
    
    fsm states add: state1; add: state2.
    ^fsm.!   ! 
#('March 2, 2021' '09:54:28 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('classMethods' forIdentifier:attributes: )) !


!FiniteStateMachine class methods !   
fromScannerCollection: aCollection attributes: attributes
    | fsm s1 s2 transition |
    fsm := FiniteStateMachine new.
    
    s1 := FiniteStateMachineState new.
    s1 isInitial: true.
    
    s2 := FiniteStateMachineState new.
    s2 isFinal: true.
    
    aCollection do: [:x | 
        transition := Transition new.
        transition goto: s2.
        transition name: (TransitionName new symbol: x; attributes: attributes).
        s1 transitions add: transition.
    ].
    fsm states add: s1.
    fsm states add: s2.

    ^ fsm renumber.! ! 
#('March 2, 2021' '09:54:45 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('classMethods' fromScannerCollection:attributes: )) !


!FiniteStateMachine class methods !   
fromParserTransitionSymbol: symbol
    | fsm s1 s2 transition |
    fsm := FiniteStateMachine new.
    
    s1 := FiniteStateMachineState new.
    s1 isInitial: true.
    
    s2 := FiniteStateMachineState new.
    s2 isFinal: true.
    
    transition := Transition new.
    transition goto: s2.
    transition name: symbol.
    s1 transitions add: transition.
    
    fsm states add: s1.
    fsm states add: s2.
    
    ^ fsm renumber.!  ! 
#('March 2, 2021' '09:54:59 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('classMethods' fromParserTransitionSymbol: )) !


!FiniteStateMachine class methods ! 
or: fsms
    | fsm |
    fsm := fsms first.
    fsms rest do: [:cfsm | 
        fsm or: cfsm.
    ].
    ^ fsm renumber.! ! 
#('March 2, 2021' '09:55:31 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('classMethods' or: )) !


"evaluate"  
FiniteStateMachine class removeSelector: #forE!

!FiniteStateMachine methods !  
isEpsilon
    states do: [:state | (state isInitial and: [state isFinal]) ifTrue: [^true]].
    ^false.!  ! 
#('March 2, 2021' '09:58:26 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' isEpsilon )) !


"evaluate"
FiniteStateMachine removeSelector: #recognizesE!

!FiniteStateMachine methods ! 
star
    ^ (FiniteStateMachine epsilon or: self plus) renumber.!   ! 
#('March 2, 2021' '09:58:45 PM' 2199980)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' star )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' star )) !


!FiniteStateMachine methods !  
concat: fsm2
    | fsm1E fsm2E fsm1Final fsm2Initial |
    fsm1Final := self allFinal.
    fsm2Initial := fsm2 allInitial.
    fsm1E := self isEpsilon.
    fsm2E := fsm2 isEpsilon.
    
    fsm1Final do: [:state | 
        state transitions addAllIfAbsent: (fsm2 initialTransitions).
    ].
    
    fsm2E ifFalse: [ fsm1Final do: [:state | state isFinal: false] ].
    fsm1E ifFalse: [ fsm2Initial do: [:state | state isInitial: false] ].

    self states addAll: fsm2 states.

    ^ self reduce.!  ! 
#('March 2, 2021' '10:00:12 PM' 2198356)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' concat: )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' concat: )) !


!FiniteStateMachine methods !
reduce
    | cameFromInitial canReachFinal changed |
    self renumber.
    
    cameFromInitial := IdentityDictionary new.
    canReachFinal := IdentityDictionary new.
    
    self states do: [:state |
        cameFromInitial at: state put: state isInitial.
        canReachFinal at: state put: state isFinal.
    ].
    
    changed := true.
    [ changed ] whileTrue: [
        changed := false.
        self states do: [:state |
            state transitions do: [:transition |
                (cameFromInitial at: state) ifTrue: [
                    (cameFromInitial at: transition goto) ifFalse: [
                        changed := true.
                    ].
                    cameFromInitial at: transition goto put: true.
                ].
                
                (canReachFinal at: transition goto) ifTrue: [
                    (canReachFinal at: state) ifFalse: [
                        changed := true.
                    ].
                    canReachFinal at: state put: true.
                ].
            ].
        ].
    ].
    
    self states: (self states select: [:state |
        (cameFromInitial at: state) and: [canReachFinal at: state].
    ]).
    self states do: [:state |
        state transitions: (state transitions select: [:transition |
            states includesIdentical: transition goto.
        ]).
    ].
    
    
    ^self renumber!  ! 
#('March 2, 2021' '10:00:54 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' reduce )) !


!FiniteStateMachine methods !
or: fsm
    states addAll: fsm states.
    ^self reduce.! ! 
#('March 2, 2021' '10:01:41 PM' 2187964)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' or: )) !

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' or: )) !


!FiniteStateMachine methods !
allInitial
    ^states select: [:x | x isInitial].!    ! 
#('March 2, 2021' '10:02:26 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' allInitial )) !


!FiniteStateMachine methods !
allFinal
    ^states select: [:x | x isFinal].!    ! 
#('March 2, 2021' '10:02:34 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' allFinal )) !


!FiniteStateMachine methods !  
initialTransitions
    ^ (states collect: [:x | x transitions] when: [:x | x isInitial]) flattened.!   ! 
#('March 2, 2021' '10:02:46 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' initialTransitions )) !


!FiniteStateMachine methods !
convert: x
    self halt: 'doesnt match character 0'.
    ^x isDigit ifTrue: [x digitValue] ifFalse: [x asCharacter]! ! 
#('March 2, 2021' '10:03:26 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachine) reorganizeFrom: #(
('fsmMethods' convert: )) !


"evaluate" 
(CodeFiler organizerFor: 'FiniteStateMachineBuilder')  addCategory: 'defaults' before: 'semantic actions'!

!FiniteStateMachineBuilder methods !
parserDefaults
    ^ 'RS'.!    ! 
#('March 2, 2021' '10:05:00 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('defaults' parserDefaults )) !


!FiniteStateMachineBuilder methods !
scannerDefaults
    ^ 'RK'.!   ! 
#('March 2, 2021' '10:05:10 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('defaults' scannerDefaults )) !


!FiniteStateMachineBuilder methods !   
walkAttributes: aTree
    | fsm |
    fsm := self walkTree: (aTree children first).
    ^fsm override: (aTree children rest collect: [:token | token symbol ]).! ! 
#('March 2, 2021' '10:05:25 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkAttributes: )) !


!FiniteStateMachineBuilder methods !   
walkBuildTreeFromRightIndex: aTree
    | parameters aTransitionName |
    parameters := aTree children collect: [:x | (self convert: x) negated]. 
    
    aTransitionName := TransitionName new
        action: (isParser ifTrue: [#buildTreeFromIndex] ifFalse: [#buildToken]);
        isRootBuilding: true;
        parameters: parameters;
        symbol: aTree label.
    ^FiniteStateMachine fromParserTransitionSymbol: aTransitionName.!    ! 
#('March 2, 2021' '10:05:50 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkBuildTreeFromRightIndex: )) !


!FiniteStateMachineBuilder methods !  
walkBuildTreeOrTokenFromName: aTree
    | parameters aTransitionName |
    parameters := aTree children collect: [:x | self convert: x].
    
    aTransitionName := TransitionName new
        action: (isParser ifTrue: [#buildTree] ifFalse: [#buildToken]);
        isRootBuilding: isParser;
        parameters: parameters;
        symbol: aTree label.
    ^FiniteStateMachine fromParserTransitionSymbol: aTransitionName.!   ! 
#('March 2, 2021' '10:05:59 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkBuildTreeOrTokenFromName: )) !


!FiniteStateMachineBuilder methods ! 
walkCharacter: aTree
    ^ FiniteStateMachine fromScannerCollection: aTree symbol attributes: self scannerDefaults.!   ! 
#('March 2, 2021' '10:06:17 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkCharacter: )) !


!FiniteStateMachineBuilder methods !
walkIdentifier: aTree
    | fsm |
    fsm := map at: aTree symbol ifAbsent: [ nil ].
    fsm isNil ifFalse: [^fsm copy].
    fsm := FiniteStateMachine forIdentifier: aTree symbol attributes: (isParser ifTrue: [self parserDefaults] ifFalse: ['RK']).
    ^ fsm.!   ! 
#('March 2, 2021' '10:07:00 PM' 2185592)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkIdentifier: )) !

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkIdentifier: )) !


!FiniteStateMachineBuilder methods !   
walkInteger: aTree
    | fsm |
    fsm := OrderedCollection new.
    fsm add: aTree symbol asInteger asCharacter.
    
    ^ FiniteStateMachine fromScannerCollection: fsm attributes: self scannerDefaults.!  ! 
#('March 2, 2021' '10:08:11 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkInteger: )) !


!FiniteStateMachineBuilder methods !  
walkLook: aTree
    ^(self walkTree: (aTree child: 1)) override: #(#look).!    ! 
#('March 2, 2021' '10:09:31 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkLook: )) !


!FiniteStateMachineBuilder methods ! 
walkSemanticAction: aTree
    | action parameters aTransitionName |
    action := self convert: (aTree children first).
    
    parameters := aTree children rest collect: [:x | self convert: x ]. 
    
    aTransitionName := TransitionName new
        action: action;
        isRootBuilding: false;
        parameters: parameters;
        symbol: aTree label.
    ^FiniteStateMachine fromParserTransitionSymbol: aTransitionName.!   ! 
#('March 2, 2021' '10:10:14 PM' 2189572)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkSemanticAction: )) !

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkSemanticAction: )) !


!FiniteStateMachineBuilder methods !   
walkNonTreeBuildingSemanticAction: aTree
    ^ (self walkTree: aTree children first) override: #notTreeBuilding.!  ! 
#('March 2, 2021' '10:10:45 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkNonTreeBuildingSemanticAction: )) !


!FiniteStateMachineBuilder methods !
walkConcatenation: aTree
    |fsm|
    fsm := aTree children collect: [:child | self walkTree: child].
    ^ FiniteStateMachine concat: fsm.!    ! 
#('March 2, 2021' '10:11:42 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkConcatenation: )) !


"evaluate"  
FiniteStateMachineBuilder removeSelector: #walkConcatenate:!

!FiniteStateMachineBuilder methods !  
walkBuildTreeFromLeftIndex: aTree
    | parameters aTransitionName |
    parameters := aTree children collect: [:x | self convert: x ]. 
    
    aTransitionName := TransitionName new
        action: (isParser ifTrue: [#buildTreeFromIndex] ifFalse: [#buildToken]);
        isRootBuilding: true;
        parameters: parameters;
        symbol: aTree label.
    ^FiniteStateMachine fromParserTransitionSymbol: aTransitionName.!  ! 
#('March 2, 2021' '10:12:29 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkBuildTreeFromLeftIndex: )) !


!FiniteStateMachineBuilder methods !   
walkTreeBuildingSemanticAction: aTree
    ^ (self walkTree: aTree children first) override: #treeBuilding.!    ! 
#('March 2, 2021' '10:13:08 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkTreeBuildingSemanticAction: )) !


!FiniteStateMachineBuilder methods !   
walkDotDot: aTree
    | startVal endVal parameters fsm |
    
    parameters := OrderedCollection new.
    startVal := aTree children first symbol first asciiValue.
    endVal := aTree children second symbol first asciiValue.
    
    startVal to: endVal do: [:val | 
        parameters add: val asCharacter.
    ].
    
    fsm := FiniteStateMachine fromScannerCollection: parameters attributes: self scannerDefaults.
    ^ fsm.!  ! 
#('March 2, 2021' '10:16:20 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkDotDot: )) !


!FiniteStateMachineBuilder methods !   
walkDotDot: aTree
    | startVal endVal parameters fsm |
    
    parameters := OrderedCollection new.
    startVal := aTree children first symbol first asciiValue.
    endVal := aTree children second symbol first asciiValue.
    
    startVal to: endVal do: [:value | 
        parameters add: value asCharacter.
    ].
    
    fsm := FiniteStateMachine fromScannerCollection: parameters attributes: self scannerDefaults.
    ^ fsm.!  ! 
#('March 2, 2021' '10:16:31 PM' 2214160)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkDotDot: )) !

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkDotDot: )) !


!FiniteStateMachineBuilder methods !   
convert: aTree
    | type |
    type := aTree label.
    
    type = #walkCharacter: ifTrue: [
        ^aTree symbol first
    ].
    type = #walkString: ifTrue: [
        ^aTree symbol asString
    ].
    type = #walkInteger: ifTrue: [
        ^aTree symbol asInteger
    ].
    type = #walkSymbol: ifTrue: [
        ^aTree symbol asSymbol
    ].
    type = #walkIdentifier: ifTrue: [
        ^aTree symbol asSymbol
    ].!  ! 
#('March 2, 2021' '10:17:52 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('defaults' convert: )) !


"evaluate"
(CodeFiler setAndInitializeOrganizerFor: FiniteStateMachineBuilder to: (MethodBasedOrganizer fromArray: #(('initializing' initialize)
('processing' process: walkTree:)
('tree walking' walkAttributes: walkBuildTreeFromLeftIndex: walkBuildTreeFromRightIndex: walkBuildTreeOrTokenFromName: walkCharacter: walkConcatenation: walkDotDot: walkEpsilon: walkIdentifier: walkInteger: walkList: walkLook: walkNonTreeBuildingSemanticAction: walkOr:
        walkPlus: walkQuestionMark: walkSemanticAction: walkStar: walkTreeBuildingSemanticAction:)
('otherMethods' convert: parserDefaults scannerDefaults)
('semantic actions' processTypeNow:)))).!

!FiniteStateMachineBuilder methods !  
walkString: aTree
    | string name |
    string := aTree symbol.
    ^ isParser
        ifTrue: [
            name := TransitionName new symbol: string; attributes: self parserDefaults.
            ^ FiniteStateMachine fromParserTransitionSymbol: name.
        ]
        ifFalse: [
            ^ FiniteStateMachine fromScannerCollection: string attributes: self scannerDefaults
        ].!    ! 
#('March 2, 2021' '10:22:29 PM' nil)!

(CodeFiler organizerFor: FiniteStateMachineBuilder) reorganizeFrom: #(
('tree walking' walkString: )) !


"evaluate" 
"*** saved image on: March 2, 2021 10:24:21 PM ***"!  
"*** Image started on: March 20, 2021 09:51:13 PM ***"!   
"*** Image started on: March 20, 2021 09:58:27 PM ***"!   
"*** Image started on: March 20, 2021 09:58:55 PM ***"!   
"*** Image started on: March 23, 2021 02:37:44 PM ***"!   
"*** Image started on: March 23, 2021 04:47:57 PM ***"!

!FiniteStateMachine class methods !
concat: fsms
    | fsm |
    fsm := fsms first.
    fsms rest do: [:cfsm | 
        fsm concat: cfsm.
    ].
    ^ fsm renumber.! ! 
#('March 23, 2021' '05:27:26 PM' 2193156)!

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('classMethods' concat: )) !

(CodeFiler organizerFor: FiniteStateMachine class) reorganizeFrom: #(
('classMethods' concat: )) !

"*** Image started on: March 23, 2021 07:09:24 PM ***"!   
"*** Image started on: March 23, 2021 07:10:31 PM ***"!   
"*** Image started on: March 23, 2021 07:11:49 PM ***"!   
"*** Image started on: March 23, 2021 07:13:15 PM ***"!

!StudentCompiler methods ! 
walkIf: aTree
    |exp then else fixToElse elseStart fixToEnd endStart|
    exp := aTree child: 1.
    then := aTree child: 2.
    else := aTree children size < 3
        ifTrue: [nil]
        ifFalse: [aTree child: 3].
    (else isNil and: [self isExpressionContext]) ifTrue:[
        self error: 'Missing else for if expression'.
        else := then "Make the compiler work"].
        
        
    self pushExpressionContext.
        self walkTree: exp.
    self popContext.
    fixToElse := self emitInstruction: #branchIfFalse with: nil. 
    self walkTree: then.
    else isNil
        ifTrue:[
            elseStart := self nextInstruction.
            self fixupBranch: fixToElse with: elseStart]
        ifFalse:[
            fixToEnd := self emitInstruction: #branch with: nil. 
            elseStart := self nextInstruction. 
            self walkTree: else.
            endStart := self nextInstruction.
            self fixupBranch: fixToElse with: elseStart.
            self fixupBranch: fixToEnd with: endStart].!  ! 
#('March 23, 2021' '07:14:23 PM' 1859740)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIf: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIf: )) !


!StudentCompiler methods !
walkFor: aTree
    |initialExpression booleanExpression incrementExpression body end whileStart fixAtEnd|
    self isExpressionContext ifTrue:[
        self designError: 'Can''t use for loop as expression'.
        ^self].
    initialExpression := aTree child: 1.
    booleanExpression := aTree child: 2.
    incrementExpression :=aTree child: 3.
    body := aTree child: 4.
    self walkTree: initialExpression.
    self pushExpressionContext "For branchIfFalse to work".
        whileStart := self nextInstruction.
        self walkTree: booleanExpression.
    self popContext.
    fixAtEnd := self nextInstruction.
    self emitInstruction: #branchIfFalse with: nil. "to End"
    self walkTree: body.
    self walkTree: incrementExpression.
    self emitBranch: #branch backTo: whileStart.
    end := self nextInstruction.
    self fixupBranch: fixAtEnd with: end.!    ! 
#('March 23, 2021' '07:14:41 PM' 1867872)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFor: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFor: )) !


!StudentCompiler methods !  
walkMinus: aTree
    self isStatementContext ifTrue: [^self].
    self walkTree: (aTree child: 1).
    self walkTree: (aTree child: 2).
    self emitInstruction: 'MINUS'.! ! 
#('March 23, 2021' '07:14:50 PM' 1824652)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkMinus: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkMinus: )) !


!StudentCompiler methods !  
walkLess: aTree
    self isStatementContext ifTrue: [^self].
    self walkTree: (aTree child: 1).
    self walkTree: (aTree child: 2).
    self emitInstruction: 'Less'.!   ! 
#('March 23, 2021' '07:15:26 PM' 1824904)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkLess: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkLess: )) !


!StudentCompiler methods !
walkPlus: aTree
    self isStatementContext ifTrue: [^self].
    self walkTree: (aTree child: 1).
    self walkTree: (aTree child: 2).
    self emitInstruction: 'ADD'.!    ! 
#('March 23, 2021' '07:15:33 PM' 1825156)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkPlus: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkPlus: )) !


!StudentCompiler methods !
walkInteger: token
    self isStatementContext ifTrue: [^self].
    self emitInstruction: 'PUSH' with: token symbol asInteger!  ! 
#('March 23, 2021' '07:15:41 PM' 1848628)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkInteger: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkInteger: )) !


"evaluate"  
(CodeFiler organizerFor: 'StudentCompiler')  addCategory: 'emit details' before: 'walk details'!

!StudentCompiler methods !
emitIf: aTree
    |exp then else|
    exp := aTree child: 1.
    then := aTree child: 2.
    else := aTree children size < 3
        ifTrue: [nil]
        ifFalse: [aTree child: 3].
    else isNil and: [self isExpressionContext] ifTrue:[
        self error: 'Missing else for if expression'.
        else := then "Make the compiler work"]! ! 
#('March 23, 2021' '07:16:28 PM' nil)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('emit details' emitIf: )) !


!StudentCompiler methods !  
emitFor: aTree
    |initialExpression booleanExpression incrementExpression body|
    self isExpressionContext ifTrue:[
        self designError:'Can''t use for loop as expression'.
        ^self].
    initialExpression := aTree child: 1.
    booleanExpression := aTree child: 2.
    incrementExpression := aTree child:3.
    body := aTree child: 4.!  ! 
#('March 23, 2021' '07:16:35 PM' nil)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('emit details' emitFor: )) !


!StudentCompiler methods ! 
emitBranch: opcode backTo: location
    ^self emitInstruction: opcode
        with: (location - self nextInstruction)!  ! 
#('March 23, 2021' '07:16:43 PM' nil)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('emit details' emitBranch:backTo: )) !


!StudentCompiler methods !   
emitInstruction: opCode with: operand
    code add:opCode; add: operand.
    ^code size-1!  ! 
#('March 23, 2021' '07:16:51 PM' nil)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('emit details' emitInstruction:with: )) !


!StudentCompiler methods !
emitInstruction: opCode
    code add:opCode.
    ^code size!    ! 
#('March 23, 2021' '07:17:01 PM' nil)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('emit details' emitInstruction: )) !


!StudentCompiler methods ! 
nextInstruction
    ^code size+1!   ! 
#('March 23, 2021' '07:17:08 PM' 1820572)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' nextInstruction )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' nextInstruction )) !


!StudentCompiler methods !
fixupAllBranches: initUnknown with: a
    |nextUnknown unknown|
    unknown := initUnknown.
    [unknown notNil] whileTrue:[
        nextUnknown := code at: unknown + 1
        self fixupBranch unknown with: a.
        unknown := nextUnknown]! ! 
#('March 23, 2021' '07:17:19 PM' 1845356)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' fixupAllBranches:with: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' fixupAllBranches:with: )) !


!StudentCompiler methods !  
emitList: aTree
    aTree children isEmpty ifTrue:[
        self iExpressionContext ifTrue:[
            self emitInstruction: #push with: nil.
        ^self]]
    self pushStatementContext.
        aTree children allButLast do: [:child |
            self emit: child].
        self popContext.
        self emit:(aTree child: aTree children size).!   ! 
#('March 23, 2021' '07:17:30 PM' nil)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('emit details' emitList: )) !


!StudentCompiler methods !
fixupBranch: where with: nextInstruction
    |newOffset|
    newOffset :=nextInstruction - where.
    code at: where + 1 put: newOffset!    ! 
#('March 23, 2021' '07:17:43 PM' 1861916)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' fixupBranch:with: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' fixupBranch:with: )) !


  
'Smalltalk'!

!StudentCompiler methods !
walkTree: aTree
    self perform: (aTree label asSymbol) with: aTree!   ! 
#('March 23, 2021' '07:18:40 PM' 1863900)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('compiling/evaluating/walk' walkTree: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('compiling/evaluating/walk' walkTree: )) !


!StudentCompiler methods !  
compile: text
    tree := parser parse: text.
    self walkTree: tree.
    ^code!   ! 
#('March 23, 2021' '07:18:50 PM' 1861524)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('compiling/evaluating/walk' compile: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('compiling/evaluating/walk' compile: )) !


!StudentCompiler methods !
initialize
    parser := Parser
        for: self
        parserTables: self class rawParserTables
        scannerTables: self class rawScannerTables.
        
    code := OrderedCollection new.
    contextStack := OrderedCollection new.
    self pushStatementContext!    ! 
#('March 23, 2021' '07:19:15 PM' 1864272)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('initializing' initialize )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('initializing' initialize )) !


"define class"  

Object subclass: #StudentCompiler
  instanceVariableNames: 
    ' code parser tree contextStack '
  classVariableNames: ''
  poolDictionaries: ''!

"evaluate"
Object subclass: #StudentCompiler
  instanceVariableNames: 
    ' code parser tree contextStack '
  classVariableNames: ''
  poolDictionaries: ''
  categories: #( 'Example Parser Users' )
!

!StudentCompiler methods !   
walkMultiply: aTree
    self isStatementContext ifTrue: [^self].
    self walkTree: (aTree child: 1).
    self walkTree: (aTree child: 2).
    self emitInstruction: 'MULTIPLY'.!   ! 
#('March 23, 2021' '07:20:30 PM' 1821132)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkMultiply: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkMultiply: )) !


!StudentCompiler methods !
walkIdentifier: token
    self isStatementContext ifTrue: [^self].
    self emitInstruction: 'PUSH' with: token symbol! ! 
#('March 23, 2021' '07:20:37 PM' 1854668)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIdentifier: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkIdentifier: )) !


!StudentCompiler methods !
walkFunctionCall: aTree
    aTree children rest do: [:child | self walkTree: child].
    self emitInstruction: 'FUNCTION_CALL' with: (aTree child: 1) symbol!   ! 
#('March 23, 2021' '07:20:45 PM' nil)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkFunctionCall: )) !


!StudentCompiler methods !
walkDivide: aTree
    self isStatementContext ifTrue: [^self].
    self walkTree: (aTree child: 1).
    self walkTree: (aTree child: 2).
    self emitInstruction: 'DIVIDE'.!   ! 
#('March 23, 2021' '07:20:56 PM' 1821832)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkDivide: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkDivide: )) !


!StudentCompiler methods !
walkGreater: aTree
    self isStatementContext ifTrue: [^self].
    self walkTree: (aTree child: 1).
    self walkTree: (aTree child: 2).
    self emitInstruction: 'GREATER'.! ! 
#('March 23, 2021' '07:21:05 PM' 1822088)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkGreater: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkGreater: )) !


!StudentCompiler methods !  
walkAssign: aTree
    |name expression|
    name := (aTree child: 1) symbol.
    expression := aTree child: 2.
    self pushExpressionContext.
        self walkTree: expression.
    self popContext.
    self isExpressionContext ifTrue: [
        self emitInstruction: #Duplicate].
    self emitInstruction: #Pop with: name! ! 
#('March 23, 2021' '07:21:14 PM' 1838500)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkAssign: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkAssign: )) !


!StudentCompiler methods !
walkList: aTree
    aTree children isEmpty ifTrue:[
        self isExpressionContext ifTrue:[
            self emitInstruction: #push with: nil.
        ^self]].
    self pushStatementContext.
        aTree children allButLast do: [:child |
            self walkTree: child].
    self popContext.
    self walkTree:(aTree child: aTree children size).! ! 
#('March 23, 2021' '07:21:27 PM' 1822936)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkList: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk details' walkList: )) !


!StudentCompiler methods !
generate: instruction with: operand
    code cr; << instruction; << ' '; << operand!    ! 
#('March 23, 2021' '07:22:05 PM' 1846192)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' generate:with: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' generate:with: )) !


!StudentCompiler methods !  
generate: instruction
    code cr; << instruction!  ! 
#('March 23, 2021' '07:22:15 PM' 1846448)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' generate: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('walk support' generate: )) !


  
'StudentCompiler walkExample2'!

!StudentCompiler class methods !   
promptForCompilation
    "SampleTranslator promptForCompilation"
    ^SampleTranslator new
        compile: (Prompter prompt: 'Expression to compile' default: '1+2*3')!    ! 
#('March 23, 2021' '07:23:54 PM' nil)!

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' promptForCompilation )) !


!StudentCompiler class methods ! 
walkExample2
    "StudentCompiler walkExample2"
    ^StudentCompiler new compile: 'if (a > b) {a = b; c = d;} else {e = f;}'!   ! 
#('March 23, 2021' '07:24:25 PM' 1816792)!

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample2 )) !

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample2 )) !


!StudentCompiler class methods !
walkExample1
    "StudentCompiler walkExample1"
    ^StudentCompiler new compile: 'a = b = 1+ 2*3;'!    ! 
#('March 23, 2021' '07:25:11 PM' 1863120)!

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample1 )) !

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample1 )) !



'StudentCompiler walkExample2'!

   
'StudentCompiler walkExample2'!

!StudentCompiler class methods !   
walkExample3
    "StudentCompiler walkExample3"
    ^StudentCompiler new compile: 'for(i=0; i<3; i=i+1){a=i;}'! ! 
#('March 23, 2021' '07:26:22 PM' nil)!

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample3 )) !


!StudentCompiler class methods ! 
walkExample3
    "StudentCompiler walkExample3"
    ^StudentCompiler new generate: 'for(i=0; i<3; i=i+1){a=i;}'!    ! 
#('March 23, 2021' '07:26:56 PM' 2233476)!

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample3 )) !

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample3 )) !


!StudentCompiler class methods !
walkExample3
    "StudentCompiler walkExample3"
    ^StudentCompiler new compile: 'for(i=0; i<3; i=i+1){a=i;}'! ! 
#('March 23, 2021' '07:27:24 PM' 2233772)!

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample3 )) !

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample3 )) !


!StudentCompiler class methods !
walkExample3
    "StudentCompiler walkExample3"
    StudentCompiler new compile: 'for(i=0; i<3; i=i+1){a=i;}'
    Transcript cr; << 'Compiling '; << text.
    ^code indexedDo: [:index :object | Transcript cr; << index; << ': '; << object].! ! 
#('March 23, 2021' '07:30:21 PM' 2234176)!

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample3 )) !

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample3 )) !


!StudentCompiler class methods !
walkExample3
    "StudentCompiler walkExample3"
    StudentCompiler new compile: 'for(i=0; i<3; i=i+1){a=i;}'.
    Transcript cr; << 'Compiling '; << text.
    ^code indexedDo: [:index :object | Transcript cr; << index; << ': '; << object].!    ! 
#('March 23, 2021' '07:30:41 PM' 2234576)!

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample3 )) !


!StudentCompiler class methods ! 
walkExample3
    "StudentCompiler walkExample3"
    ^StudentCompiler new compile: 'for(i=0; i<3; i=i+1){a=i;}'!    ! 
#('March 23, 2021' '07:31:04 PM' 2235108)!

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample3 )) !

(CodeFiler organizerFor: StudentCompiler class) reorganizeFrom: #(
('examples' walkExample3 )) !



'StudentCompiler walkExample3'!

   
'StudentCompiler walkExample3'!

   
'StudentCompiler walkExample2'!

!StudentCompiler methods ! 
compile: text
    tree := parser parse: text.
    self walkTree: tree.
    Transcript cr; << 'Compiling '; << text.
    code indexedDo: [:index :object | Transcript cr; << index; << ': '; << object].
    ^code!    ! 
#('March 23, 2021' '07:34:59 PM' 2226836)!

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('compiling/evaluating/walk' compile: )) !

(CodeFiler organizerFor: StudentCompiler) reorganizeFrom: #(
('compiling/evaluating/walk' compile: )) !


  
'StudentCompiler walkExample2'!

   
'StudentCompiler walkExample3'!

"evaluate" 
"*** saved image on: March 23, 2021 07:37:19 PM ***"! 
"*** Image started on: April 1, 2021 05:07:24 PM ***"!

"evaluate"  
"*** saved image on: April 1, 2021 05:07:48 PM ***"!